var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
  get: (a7, b5) => (typeof require !== "undefined" ? require : a7)[b5]
}) : x4)(function(x4) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x4 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key3 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key3) && key3 !== except)
        __defProp(to, key3, { get: () => from[key3], enumerable: !(desc = __getOwnPropDesc(from, key3)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .svelte-kit/output/server/chunks/prod-ssr.js
var DEV;
var init_prod_ssr = __esm({
  ".svelte-kit/output/server/chunks/prod-ssr.js"() {
    DEV = false;
  }
});

// .svelte-kit/output/server/chunks/utils.js
function is_promise(value) {
  return typeof value?.then === "function";
}
function run_all(arr2) {
  for (var i9 = 0; i9 < arr2.length; i9++) {
    arr2[i9]();
  }
}
function run(fn) {
  return fn();
}
function subscribe_to_store(store, run2, invalidate) {
  if (store == null) {
    run2(void 0);
    if (invalidate)
      invalidate(void 0);
    return noop;
  }
  const unsub = store.subscribe(
    run2,
    // @ts-expect-error
    invalidate
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var noop;
var init_utils = __esm({
  ".svelte-kit/output/server/chunks/utils.js"() {
    noop = () => {
    };
  }
});

// .svelte-kit/output/server/chunks/index3.js
function create_root_block(intro) {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // intro
    i: intro,
    // parent
    p: null,
    // transition
    r: null,
    // type
    t: ROOT_BLOCK
  };
}
function is_runes(context) {
  const component_context = context || current_component_context;
  return component_context !== null && component_context.r;
}
function default_equals(a7, b5) {
  return a7 === b5;
}
function create_source_signal(flags, value) {
  return {
    // consumers
    c: null,
    // equals
    e: default_equals,
    // flags
    f: flags,
    // value
    v: value
  };
}
function create_computation_signal(flags, value, block2) {
  return {
    // block
    b: block2,
    // consumers
    c: null,
    // destroy
    d: null,
    // equals
    e: null,
    // flags
    f: flags,
    // level
    l: 0,
    // init
    i: null,
    // references
    r: null,
    // value
    v: value,
    // context: We can remove this if we get rid of beforeUpdate/afterUpdate
    x: null,
    // destroy
    y: null
  };
}
function push_reference(target_signal, ref_signal) {
  const references = target_signal.r;
  if (references === null) {
    target_signal.r = [ref_signal];
  } else {
    references.push(ref_signal);
  }
}
function is_signal_dirty(signal) {
  const flags = signal.f;
  if ((flags & DIRTY) !== 0 || signal.v === UNINITIALIZED) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    const dependencies = (
      /** @type {import('./types.js').ComputationSignal<V>} **/
      signal.d
    );
    if (dependencies !== null) {
      const length = dependencies.length;
      let i9;
      for (i9 = 0; i9 < length; i9++) {
        const dependency = dependencies[i9];
        if ((dependency.f & MAYBE_DIRTY) !== 0 && !is_signal_dirty(dependency)) {
          set_signal_status(dependency, CLEAN);
          continue;
        }
        if ((dependency.f & DIRTY) !== 0) {
          if ((dependency.f & DERIVED) !== 0) {
            update_derived(
              /** @type {import('./types.js').ComputationSignal<V>} **/
              dependency,
              true
            );
            if ((signal.f & DIRTY) !== 0) {
              return true;
            }
          } else {
            return true;
          }
        }
      }
    }
  }
  return false;
}
function execute_signal_fn(signal) {
  const init3 = signal.i;
  const flags = signal.f;
  const previous_dependencies = current_dependencies;
  const previous_dependencies_index = current_dependencies_index;
  const previous_untracked_writes = current_untracked_writes;
  const previous_consumer = current_consumer;
  const previous_block = current_block;
  const previous_component_context = current_component_context;
  const previous_skip_consumer = current_skip_consumer;
  const is_render_effect = (flags & RENDER_EFFECT) !== 0;
  const previous_untracking = current_untracking;
  current_dependencies = /** @type {null | import('./types.js').Signal[]} */
  null;
  current_dependencies_index = 0;
  current_untracked_writes = null;
  current_consumer = signal;
  current_block = signal.b;
  current_component_context = signal.x;
  current_skip_consumer = !is_flushing_effect && (flags & UNOWNED) !== 0;
  current_untracking = false;
  try {
    let res;
    if (is_render_effect) {
      res = /** @type {(block: import('./types.js').Block, signal: import('./types.js').Signal) => V} */
      init3(
        /** @type {import('./types.js').Block} */
        signal.b,
        /** @type {import('./types.js').Signal} */
        signal
      );
    } else {
      res = /** @type {() => V} */
      init3();
    }
    let dependencies = (
      /** @type {import('./types.js').Signal<unknown>[]} **/
      signal.d
    );
    if (current_dependencies !== null) {
      let i9;
      if (dependencies !== null) {
        const deps_length = dependencies.length;
        const full_current_dependencies = current_dependencies_index === 0 ? current_dependencies : dependencies.slice(0, current_dependencies_index).concat(current_dependencies);
        const current_dep_length = full_current_dependencies.length;
        const full_current_dependencies_set = current_dep_length > 16 && deps_length - current_dependencies_index > 1 ? new Set(full_current_dependencies) : null;
        for (i9 = current_dependencies_index; i9 < deps_length; i9++) {
          const dependency = dependencies[i9];
          if (full_current_dependencies_set !== null ? !full_current_dependencies_set.has(dependency) : !full_current_dependencies.includes(dependency)) {
            remove_consumer(signal, dependency);
          }
        }
      }
      if (dependencies !== null && current_dependencies_index > 0) {
        dependencies.length = current_dependencies_index + current_dependencies.length;
        for (i9 = 0; i9 < current_dependencies.length; i9++) {
          dependencies[current_dependencies_index + i9] = current_dependencies[i9];
        }
      } else {
        signal.d = /** @type {import('./types.js').Signal<V>[]} **/
        dependencies = current_dependencies;
      }
      if (!current_skip_consumer) {
        for (i9 = current_dependencies_index; i9 < dependencies.length; i9++) {
          const dependency = dependencies[i9];
          const consumers = dependency.c;
          if (consumers === null) {
            dependency.c = [signal];
          } else if (consumers[consumers.length - 1] !== signal) {
            consumers.push(signal);
          }
        }
      }
    } else if (dependencies !== null && current_dependencies_index < dependencies.length) {
      remove_consumers(signal, current_dependencies_index);
      dependencies.length = current_dependencies_index;
    }
    return res;
  } finally {
    current_dependencies = previous_dependencies;
    current_dependencies_index = previous_dependencies_index;
    current_untracked_writes = previous_untracked_writes;
    current_consumer = previous_consumer;
    current_block = previous_block;
    current_component_context = previous_component_context;
    current_skip_consumer = previous_skip_consumer;
    current_untracking = previous_untracking;
  }
}
function remove_consumer(signal, dependency) {
  const consumers = dependency.c;
  let consumers_length = 0;
  if (consumers !== null) {
    consumers_length = consumers.length - 1;
    const index7 = consumers.indexOf(signal);
    if (index7 !== -1) {
      if (consumers_length === 0) {
        dependency.c = null;
      } else {
        consumers[index7] = consumers[consumers_length];
        consumers.pop();
      }
    }
  }
  if (consumers_length === 0 && (dependency.f & UNOWNED) !== 0) {
    set_signal_status(dependency, DIRTY);
    remove_consumers(
      /** @type {import('./types.js').ComputationSignal<V>} **/
      dependency,
      0
    );
  }
}
function remove_consumers(signal, start_index) {
  const dependencies = signal.d;
  if (dependencies !== null) {
    const active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);
    let i9;
    for (i9 = start_index; i9 < dependencies.length; i9++) {
      const dependency = dependencies[i9];
      if (active_dependencies === null || !active_dependencies.includes(dependency)) {
        remove_consumer(signal, dependency);
      }
    }
  }
}
function destroy_references(signal) {
  const references = signal.r;
  signal.r = null;
  if (references !== null) {
    let i9;
    for (i9 = 0; i9 < references.length; i9++) {
      destroy_signal(references[i9]);
    }
  }
}
function report_error(block2, error2) {
  let current_block2 = block2;
  if (current_block2 !== null) {
    throw error2;
  }
}
function execute_effect(signal) {
  if ((signal.f & DESTROYED) !== 0) {
    return;
  }
  const teardown = signal.v;
  const previous_effect = current_effect;
  current_effect = signal;
  try {
    destroy_references(signal);
    if (teardown !== null) {
      teardown();
    }
    const possible_teardown = execute_signal_fn(signal);
    if (typeof possible_teardown === "function") {
      signal.v = possible_teardown;
    }
  } catch (error2) {
    const block2 = signal.b;
    if (block2 !== null) {
      report_error(block2, error2);
    } else {
      throw error2;
    }
  } finally {
    current_effect = previous_effect;
  }
  const component_context = signal.x;
  if (is_runes(component_context) && // Don't rerun pre effects more than once to accomodate for "$: only runs once" behavior
  (signal.f & PRE_EFFECT) !== 0 && current_queued_pre_and_render_effects.length > 0) {
    flush_local_pre_effects(component_context);
  }
}
function infinite_loop_guard() {
  if (flush_count > 100) {
    throw new Error(
      "ERR_SVELTE_TOO_MANY_UPDATES"
    );
  }
  flush_count++;
}
function flush_queued_effects(effects) {
  const length = effects.length;
  if (length > 0) {
    infinite_loop_guard();
    const previously_flushing_effect = is_flushing_effect;
    is_flushing_effect = true;
    try {
      let i9;
      for (i9 = 0; i9 < length; i9++) {
        const signal = effects[i9];
        const flags = signal.f;
        if ((flags & (DESTROYED | INERT)) === 0) {
          if (is_signal_dirty(signal)) {
            set_signal_status(signal, CLEAN);
            execute_effect(signal);
          } else if ((flags & MAYBE_DIRTY) !== 0) {
            set_signal_status(signal, CLEAN);
          }
        }
      }
    } finally {
      is_flushing_effect = previously_flushing_effect;
    }
    effects.length = 0;
  }
}
function process_microtask() {
  is_micro_task_queued = false;
  if (flush_count > 101) {
    return;
  }
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  current_queued_pre_and_render_effects = [];
  current_queued_effects = [];
  flush_queued_effects(previous_queued_pre_and_render_effects);
  flush_queued_effects(previous_queued_effects);
  if (!is_micro_task_queued) {
    flush_count = 0;
  }
}
function schedule_effect(signal, sync) {
  const flags = signal.f;
  if (sync) {
    const previously_flushing_effect = is_flushing_effect;
    try {
      is_flushing_effect = true;
      execute_effect(signal);
      set_signal_status(signal, CLEAN);
    } finally {
      is_flushing_effect = previously_flushing_effect;
    }
  } else {
    if (current_scheduler_mode === FLUSH_MICROTASK) {
      if (!is_micro_task_queued) {
        is_micro_task_queued = true;
        queueMicrotask(process_microtask);
      }
    }
    if ((flags & EFFECT) !== 0) {
      current_queued_effects.push(signal);
      if ((flags & MANAGED) === 0) {
        mark_subtree_children_inert(signal, true);
      }
    } else {
      const length = current_queued_pre_and_render_effects.length;
      let should_append = length === 0;
      if (!should_append) {
        const target_level = signal.l;
        const target_block = signal.b;
        const is_pre_effect = (flags & PRE_EFFECT) !== 0;
        let target_signal;
        let is_target_pre_effect;
        let i9 = length;
        while (true) {
          target_signal = current_queued_pre_and_render_effects[--i9];
          if (target_signal.l <= target_level) {
            if (i9 + 1 === length) {
              should_append = true;
            } else {
              is_target_pre_effect = (target_signal.f & PRE_EFFECT) !== 0;
              if (target_signal.b !== target_block || is_target_pre_effect && !is_pre_effect) {
                i9++;
              }
              current_queued_pre_and_render_effects.splice(i9, 0, signal);
            }
            break;
          }
          if (i9 === 0) {
            current_queued_pre_and_render_effects.unshift(signal);
            break;
          }
        }
      }
      if (should_append) {
        current_queued_pre_and_render_effects.push(signal);
      }
    }
  }
}
function process_task() {
  is_task_queued = false;
  const tasks = current_queued_tasks.slice();
  current_queued_tasks = [];
  run_all(tasks);
}
function process_raf_task() {
  is_raf_queued = false;
  const tasks = current_raf_tasks.slice();
  current_raf_tasks = [];
  run_all(tasks);
}
function flush_local_pre_effects(context) {
  const effects = [];
  for (let i9 = 0; i9 < current_queued_pre_and_render_effects.length; i9++) {
    const effect2 = current_queued_pre_and_render_effects[i9];
    if ((effect2.f & PRE_EFFECT) !== 0 && effect2.x === context) {
      effects.push(effect2);
      current_queued_pre_and_render_effects.splice(i9, 1);
      i9--;
    }
  }
  flush_queued_effects(effects);
}
function flushSync(fn) {
  const previous_scheduler_mode = current_scheduler_mode;
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  try {
    infinite_loop_guard();
    const pre_and_render_effects = [];
    const effects = [];
    current_scheduler_mode = FLUSH_SYNC;
    current_queued_pre_and_render_effects = pre_and_render_effects;
    current_queued_effects = effects;
    flush_queued_effects(previous_queued_pre_and_render_effects);
    flush_queued_effects(previous_queued_effects);
    if (fn !== void 0) {
      fn();
    }
    if (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {
      flushSync();
    }
    if (is_raf_queued) {
      process_raf_task();
    }
    if (is_task_queued) {
      process_task();
    }
    flush_count = 0;
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
    current_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;
    current_queued_effects = previous_queued_effects;
  }
}
async function tick() {
  await Promise.resolve();
  flushSync();
}
function update_derived(signal, force_schedule) {
  const previous_updating_derived = updating_derived;
  updating_derived = true;
  destroy_references(signal);
  const value = execute_signal_fn(signal);
  updating_derived = previous_updating_derived;
  const status = current_skip_consumer || (signal.f & UNOWNED) !== 0 ? DIRTY : CLEAN;
  set_signal_status(signal, status);
  const equals = (
    /** @type {import('./types.js').EqualsFunctions} */
    signal.e
  );
  if (!equals(value, signal.v)) {
    signal.v = value;
    mark_signal_consumers(signal, DIRTY, force_schedule);
  }
}
function get(signal) {
  const flags = signal.f;
  if ((flags & DESTROYED) !== 0) {
    return signal.v;
  }
  if (current_consumer !== null && (current_consumer.f & MANAGED) === 0 && !current_untracking) {
    const unowned = (current_consumer.f & UNOWNED) !== 0;
    const dependencies = current_consumer.d;
    if (current_dependencies === null && dependencies !== null && dependencies[current_dependencies_index] === signal && !(unowned && current_effect !== null)) {
      current_dependencies_index++;
    } else if (dependencies === null || current_dependencies_index === 0 || dependencies[current_dependencies_index - 1] !== signal) {
      if (current_dependencies === null) {
        current_dependencies = [signal];
      } else {
        current_dependencies.push(signal);
      }
    }
    if (current_untracked_writes !== null && current_effect !== null && (current_effect.f & CLEAN) !== 0 && current_untracked_writes.includes(signal)) {
      set_signal_status(current_effect, DIRTY);
      schedule_effect(current_effect, false);
    }
  }
  if ((flags & DERIVED) !== 0 && is_signal_dirty(signal)) {
    {
      update_derived(
        /** @type {import('./types.js').ComputationSignal<V>} **/
        signal,
        false
      );
    }
  }
  return signal.v;
}
function set(signal, value) {
  set_signal_value(signal, value);
  return value;
}
function mark_subtree_children_inert(signal, inert, visited_blocks) {
  const references = signal.r;
  if (references !== null) {
    let i9;
    for (i9 = 0; i9 < references.length; i9++) {
      const reference = references[i9];
      if ((reference.f & IS_EFFECT) !== 0) {
        mark_subtree_inert(reference, inert, visited_blocks);
      }
    }
  }
}
function mark_subtree_inert(signal, inert, visited_blocks = /* @__PURE__ */ new Set()) {
  const flags = signal.f;
  const is_already_inert = (flags & INERT) !== 0;
  if (is_already_inert !== inert) {
    signal.f ^= INERT;
    if (!inert && (flags & IS_EFFECT) !== 0 && (flags & CLEAN) === 0) {
      schedule_effect(
        /** @type {import('./types.js').EffectSignal} */
        signal,
        false
      );
    }
    const block2 = signal.b;
    if (block2 !== null && !visited_blocks.has(block2)) {
      visited_blocks.add(block2);
      const type = block2.t;
      if (type === IF_BLOCK) {
        const condition_effect = block2.e;
        if (condition_effect !== null && block2 !== current_block) {
          mark_subtree_inert(condition_effect, inert);
        }
        const consequent_effect = block2.ce;
        if (consequent_effect !== null && block2.v) {
          mark_subtree_inert(consequent_effect, inert, visited_blocks);
        }
        const alternate_effect = block2.ae;
        if (alternate_effect !== null && !block2.v) {
          mark_subtree_inert(alternate_effect, inert, visited_blocks);
        }
      } else if (type === EACH_BLOCK) {
        const items = block2.v;
        for (let { e: each_item_effect } of items) {
          if (each_item_effect !== null) {
            mark_subtree_inert(each_item_effect, inert, visited_blocks);
          }
        }
      }
    }
  }
  mark_subtree_children_inert(signal, inert, visited_blocks);
}
function mark_signal_consumers(signal, to_status, force_schedule) {
  const runes = is_runes(null);
  const consumers = signal.c;
  if (consumers !== null) {
    const length = consumers.length;
    let i9;
    for (i9 = 0; i9 < length; i9++) {
      const consumer = consumers[i9];
      const flags = consumer.f;
      const unowned = (flags & UNOWNED) !== 0;
      const dirty = (flags & DIRTY) !== 0;
      if (dirty && !unowned || (!force_schedule || !runes) && consumer === current_effect) {
        continue;
      }
      set_signal_status(consumer, to_status);
      if ((flags & CLEAN) !== 0 || dirty && unowned) {
        if ((consumer.f & IS_EFFECT) !== 0) {
          schedule_effect(
            /** @type {import('./types.js').EffectSignal} */
            consumer,
            false
          );
        } else {
          mark_signal_consumers(consumer, MAYBE_DIRTY, force_schedule);
        }
      }
    }
  }
}
function set_signal_value(signal, value) {
  if (!current_untracking && !ignore_mutation_validation && current_consumer !== null && is_runes(null) && (current_consumer.f & DERIVED) !== 0) {
    throw new Error(
      "ERR_SVELTE_UNSAFE_MUTATION"
    );
  }
  if ((signal.f & SOURCE) !== 0 && !/** @type {import('./types.js').EqualsFunctions} */
  signal.e(value, signal.v)) {
    signal.v = value;
    if (is_runes(null) && current_effect !== null && current_effect.c === null && (current_effect.f & CLEAN) !== 0) {
      if (current_dependencies !== null && current_dependencies.includes(signal)) {
        set_signal_status(current_effect, DIRTY);
        schedule_effect(current_effect, false);
      } else {
        if (current_untracked_writes === null) {
          current_untracked_writes = [signal];
        } else {
          current_untracked_writes.push(signal);
        }
      }
    }
    mark_signal_consumers(signal, DIRTY, true);
  }
}
function destroy_signal(signal) {
  const teardown = (
    /** @type {null | (() => void)} */
    signal.v
  );
  const destroy = signal.y;
  const flags = signal.f;
  destroy_references(signal);
  remove_consumers(signal, 0);
  signal.i = signal.r = signal.y = signal.x = signal.b = signal.d = signal.c = null;
  set_signal_status(signal, DESTROYED);
  if (destroy !== null) {
    if (is_array(destroy)) {
      run_all(destroy);
    } else {
      destroy();
    }
  }
  if (teardown !== null && (flags & IS_EFFECT) !== 0) {
    teardown();
  }
}
// @__NO_SIDE_EFFECTS__
function source(initial_value) {
  const source2 = create_source_signal(SOURCE | CLEAN, initial_value);
  bind_signal_to_component_context(source2);
  return source2;
}
function bind_signal_to_component_context(signal) {
  if (current_component_context === null || !current_component_context.r)
    return;
  const signals = current_component_context.d;
  if (signals) {
    signals.push(signal);
  } else {
    current_component_context.d = [signal];
  }
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value) {
  const s9 = /* @__PURE__ */ source(initial_value);
  s9.e = safe_equal;
  return s9;
}
function internal_create_effect(type, init3, sync, block2, schedule) {
  const signal = create_computation_signal(type | DIRTY, null, block2);
  signal.i = init3;
  signal.x = current_component_context;
  if (current_effect !== null) {
    signal.l = current_effect.l + 1;
    if ((type & MANAGED) === 0) {
      push_reference(current_effect, signal);
    }
  }
  if (schedule) {
    schedule_effect(signal, sync);
  }
  return signal;
}
function effect_active() {
  return current_effect ? (current_effect.f & MANAGED) === 0 : false;
}
function render_effect(init3, block2 = current_block, managed = false, sync = true) {
  let flags = RENDER_EFFECT;
  if (managed) {
    flags |= MANAGED;
  }
  return internal_create_effect(
    flags,
    /** @type {any} */
    init3,
    sync,
    block2,
    true
  );
}
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function safe_not_equal(a7, b5) {
  return a7 != a7 ? (
    // eslint-disable-next-line eqeqeq
    b5 == b5
  ) : a7 !== b5 || a7 !== null && typeof a7 === "object" || typeof a7 === "function";
}
function safe_equal(a7, b5) {
  return !safe_not_equal(a7, b5);
}
function get_or_init_context_map() {
  const component_context = current_component_context;
  if (component_context === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_CONTEXT"
    );
  }
  return component_context.c ??= new Map(get_parent_context(component_context) || void 0);
}
function get_parent_context(component_context) {
  let parent = component_context.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
function update(signal, d6 = 1) {
  const value = get(signal);
  set_signal_value(signal, value + d6);
  return value;
}
function push$1(props, runes = false) {
  current_component_context = {
    // accessors
    a: null,
    // context
    c: null,
    // effects
    e: null,
    // mounted
    m: false,
    // parent
    p: current_component_context,
    // signals
    d: null,
    // props
    s: props,
    // runes
    r: runes,
    // update_callbacks
    u: null
  };
}
function pop$1(accessors) {
  const context_stack_item = current_component_context;
  if (context_stack_item !== null) {
    if (accessors !== void 0) {
      context_stack_item.a = accessors;
    }
    const effects = context_stack_item.e;
    if (effects !== null) {
      context_stack_item.e = null;
      for (let i9 = 0; i9 < effects.length; i9++) {
        schedule_effect(effects[i9], false);
      }
    }
    current_component_context = context_stack_item.p;
    context_stack_item.m = true;
  }
}
function create_payload() {
  return { out: "", head: { title: "", out: "", anchor: 0 }, anchor: 0 };
}
function copy_payload(to_copy) {
  return {
    ...to_copy,
    head: { ...to_copy.head }
  };
}
function assign_payload(p1, p22) {
  p1.out = p22.out;
  p1.head = p22.head;
  p1.anchor = p22.anchor;
}
function render(component7, options3) {
  const payload = create_payload();
  const root_anchor = create_anchor(payload);
  const root_head_anchor = create_anchor(payload.head);
  const prev_on_destroy = on_destroy;
  on_destroy = [];
  payload.out += root_anchor;
  if (options3.context) {
    push$1({});
    current_component_context.c = options3.context;
  }
  component7(payload, options3.props, {}, {});
  if (options3.context) {
    pop$1();
  }
  payload.out += root_anchor;
  for (const cleanup of on_destroy)
    cleanup();
  on_destroy = prev_on_destroy;
  return {
    head: payload.head.out || payload.head.title ? payload.head.title + root_head_anchor + payload.head.out + root_head_anchor : "",
    html: payload.out
  };
}
function push(runes) {
  push$1({}, runes);
}
function pop() {
  pop$1();
}
function escape2(value, is_attr = false) {
  const str2 = String(value ?? "");
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last2 = 0;
  while (pattern2.test(str2)) {
    const i9 = pattern2.lastIndex - 1;
    const ch = str2[i9];
    escaped2 += str2.substring(last2, i9) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last2 = i9 + 1;
  }
  return escaped2 + str2.substring(last2);
}
function head(payload, fn) {
  const head_payload = payload.head;
  fn(head_payload);
}
function attr(name2, value, boolean) {
  if (value == null || !value && boolean || value === "" && name2 === "class")
    return "";
  const assignment = boolean ? "" : `="${escape2(value, true)}"`;
  return ` ${name2}${assignment}`;
}
function spread_attributes(attrs, lowercase_attributes, is_svg, class_hash, additional) {
  const merged_attrs = {};
  let key3;
  for (let i9 = 0; i9 < attrs.length; i9++) {
    const obj = attrs[i9];
    for (key3 in obj) {
      if (typeof obj[key3] !== "function") {
        merged_attrs[key3] = obj[key3];
      }
    }
  }
  const styles = additional?.styles;
  if (styles) {
    if ("style" in merged_attrs) {
      merged_attrs.style = style_object_to_string(
        merge_styles(
          /** @type {string} */
          merged_attrs.style,
          styles
        )
      );
    } else {
      merged_attrs.style = style_object_to_string(styles);
    }
  }
  if (class_hash) {
    if ("class" in merged_attrs) {
      merged_attrs.class += ` ${class_hash}`;
    } else {
      merged_attrs.class = class_hash;
    }
  }
  const classes = additional?.classes;
  if (classes) {
    if ("class" in merged_attrs) {
      merged_attrs.class += ` ${classes}`;
    } else {
      merged_attrs.class = classes;
    }
  }
  let attr_str = "";
  let name2;
  for (name2 in merged_attrs) {
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name2))
      continue;
    if (lowercase_attributes) {
      name2 = name2.toLowerCase();
    }
    const is_boolean = !is_svg && DOMBooleanAttributes.includes(name2);
    attr_str += attr(name2, merged_attrs[name2], is_boolean);
  }
  return attr_str;
}
function spread_props(props) {
  const merged_props = {};
  let key3;
  for (let i9 = 0; i9 < props.length; i9++) {
    const obj = props[i9];
    for (key3 in obj) {
      merged_props[key3] = obj[key3];
    }
  }
  return merged_props;
}
function stringify(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter(
    /** @param {any} key */
    (key3) => style_object[key3]
  ).map(
    /** @param {any} key */
    (key3) => `${key3}: ${escape2(style_object[key3], true)};`
  ).join(" ");
}
function merge_styles(style_attribute, style_directive) {
  const style_object = {};
  for (const individual_style of style_attribute.split(";")) {
    const colon_index = individual_style.indexOf(":");
    const name2 = individual_style.slice(0, colon_index).trim();
    const value = individual_style.slice(colon_index + 1).trim();
    if (!name2)
      continue;
    style_object[name2] = value;
  }
  for (const name2 in style_directive) {
    const value = style_directive[name2];
    if (value) {
      style_object[name2] = value;
    } else {
      delete style_object[name2];
    }
  }
  return style_object;
}
function store_get(store_values, store_name, store) {
  if (store_name in store_values && store_values[store_name][0] === store) {
    return store_values[store_name][2];
  }
  store_values[store_name]?.[1]();
  store_values[store_name] = [store, null, void 0];
  const unsub = subscribe_to_store(
    store,
    /** @param {any} v */
    (v5) => store_values[store_name][2] = v5
  );
  store_values[store_name][1] = unsub;
  return store_values[store_name][2];
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function unsubscribe_stores(store_values) {
  for (const store_name in store_values) {
    store_values[store_name][1]();
  }
}
function value_or_fallback(value, fallback) {
  return value === void 0 ? fallback : value;
}
function slot(payload, slot_fn, slot_props, fallback_fn) {
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn();
    }
  } else {
    slot_fn(payload, slot_props);
  }
}
function rest_props(props, rest) {
  const rest_props2 = {};
  let key3;
  for (key3 in props) {
    if (!rest.includes(key3)) {
      rest_props2[key3] = props[key3];
    }
  }
  return rest_props2;
}
function sanitize_props(props) {
  const { children, $$slots, ...sanitized } = props;
  return sanitized;
}
function bind_props(props_parent, props_now) {
  for (const key3 in props_now) {
    const initial_value = props_parent[key3];
    const value = props_now[key3];
    if (initial_value === void 0 && value !== void 0 && Object.getOwnPropertyDescriptor(props_parent, key3)?.set) {
      props_parent[key3] = value;
    }
  }
}
function await_block(promise, pending_fn, then_fn) {
  if (is_promise(promise)) {
    promise.then(null, noop);
    if (pending_fn !== null) {
      pending_fn();
    }
  } else if (then_fn !== null) {
    then_fn(promise);
  }
}
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function create_anchor(payload) {
  const depth = payload.anchor++;
  return `<!--ssr:${depth}-->`;
}
var is_array, array_from, object_keys, object_assign, is_frozen, define_property, get_descriptor, object_prototype, array_prototype, get_prototype_of, PassiveDelegatedEvents, DOMBooleanAttributes, ROOT_BLOCK, IF_BLOCK, EACH_BLOCK, SOURCE, DERIVED, EFFECT, PRE_EFFECT, RENDER_EFFECT, MANAGED, UNOWNED, CLEAN, DIRTY, MAYBE_DIRTY, INERT, DESTROYED, IS_EFFECT, FLUSH_MICROTASK, FLUSH_SYNC, UNINITIALIZED, current_scheduler_mode, is_micro_task_queued, is_task_queued, is_raf_queued, is_flushing_effect, current_queued_pre_and_render_effects, current_queued_effects, current_queued_tasks, current_raf_tasks, flush_count, current_consumer, current_effect, current_dependencies, current_dependencies_index, current_untracked_writes, current_untracking, ignore_mutation_validation, current_skip_consumer, current_block, current_component_context, updating_derived, STATUS_MASK, ATTR_REGEX, CONTENT_REGEX, INVALID_ATTR_NAME_CHAR_REGEX, VoidElements, on_destroy;
var init_index3 = __esm({
  ".svelte-kit/output/server/chunks/index3.js"() {
    init_utils();
    is_array = Array.isArray;
    array_from = Array.from;
    object_keys = Object.keys;
    object_assign = Object.assign;
    is_frozen = Object.isFrozen;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    PassiveDelegatedEvents = ["touchstart", "touchmove", "touchend"];
    DOMBooleanAttributes = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "hidden",
      "indeterminate",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected"
    ];
    ROOT_BLOCK = 0;
    IF_BLOCK = 1;
    EACH_BLOCK = 2;
    SOURCE = 1;
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    PRE_EFFECT = 1 << 3;
    RENDER_EFFECT = 1 << 4;
    MANAGED = 1 << 6;
    UNOWNED = 1 << 7;
    CLEAN = 1 << 8;
    DIRTY = 1 << 9;
    MAYBE_DIRTY = 1 << 10;
    INERT = 1 << 11;
    DESTROYED = 1 << 12;
    IS_EFFECT = EFFECT | PRE_EFFECT | RENDER_EFFECT;
    FLUSH_MICROTASK = 0;
    FLUSH_SYNC = 1;
    UNINITIALIZED = Symbol();
    current_scheduler_mode = FLUSH_MICROTASK;
    is_micro_task_queued = false;
    is_task_queued = false;
    is_raf_queued = false;
    is_flushing_effect = false;
    current_queued_pre_and_render_effects = [];
    current_queued_effects = [];
    current_queued_tasks = [];
    current_raf_tasks = [];
    flush_count = 0;
    current_consumer = null;
    current_effect = null;
    current_dependencies = null;
    current_dependencies_index = 0;
    current_untracked_writes = null;
    current_untracking = false;
    ignore_mutation_validation = false;
    current_skip_consumer = false;
    current_block = null;
    current_component_context = null;
    updating_derived = false;
    STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
    ATTR_REGEX = /[&"]/g;
    CONTENT_REGEX = /[&<]/g;
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    VoidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    on_destroy = [];
  }
});

// .svelte-kit/output/server/chunks/main-client.js
function getContext(key3) {
  const context_map = get_or_init_context_map();
  return (
    /** @type {T} */
    context_map.get(key3)
  );
}
function setContext(key3, context) {
  const context_map = get_or_init_context_map();
  context_map.set(key3, context);
  return context;
}
function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function createEventDispatcher() {
  const component_context = current_component_context;
  if (component_context === null) {
    throw new Error("createEventDispatcher can only be used during component initialisation.");
  }
  return (type, detail, options3) => {
    const events = (
      /** @type {Record<string, Function | Function[]>} */
      component_context.s.$$events?.[
        /** @type {any} */
        type
      ]
    );
    if (events) {
      const callbacks = is_array(events) ? events.slice() : [events];
      const event = create_custom_event(
        /** @type {string} */
        type,
        detail,
        options3
      );
      for (const fn of callbacks) {
        fn.call(component_context.a, event);
      }
      return !event.defaultPrevented;
    }
    return true;
  };
}
var init_main_client = __esm({
  ".svelte-kit/output/server/chunks/main-client.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/chunks/shared-server.js
function set_private_env(environment) {
  private_env = environment;
}
function set_public_env(environment) {
  public_env = environment;
}
function set_safe_public_env(environment) {
  safe_public_env = environment;
}
var private_env, public_env, safe_public_env;
var init_shared_server = __esm({
  ".svelte-kit/output/server/chunks/shared-server.js"() {
    private_env = {};
    public_env = {};
    safe_public_env = {};
  }
});

// .svelte-kit/output/server/chunks/hooks.server.js
var hooks_server_exports = {};
__export(hooks_server_exports, {
  ssr: () => ssr
});
var ssr;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    ssr = false;
  }
});

// .svelte-kit/output/server/chunks/index.js
function error(status, body2) {
  if (isNaN(status) || status < 400 || status > 599) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body2);
}
function json(data, init3) {
  const body2 = JSON.stringify(data);
  const headers2 = new Headers(init3?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init3,
    headers: headers2
  });
}
function text(body2, init3) {
  const headers2 = new Headers(init3?.headers);
  if (!headers2.has("content-length")) {
    const encoded = encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init3,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init3,
    headers: headers2
  });
}
var HttpError, Redirect, SvelteKitError, ActionFailure, encoder;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    SvelteKitError = class extends Error {
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message2) {
        super(message2);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
    encoder = new TextEncoder();
  }
});

// .svelte-kit/output/server/chunks/exports.js
function resolve(base2, path2) {
  if (path2[0] === "/" && path2[1] === "/")
    return path2;
  let url = new URL(base2, internal);
  url = new URL(path2, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
function normalize_path(path2, trailing_slash) {
  if (path2 === "/" || trailing_slash === "ignore")
    return path2;
  if (trailing_slash === "never") {
    return path2.endsWith("/") ? path2.slice(0, -1) : path2;
  } else if (trailing_slash === "always" && !path2.endsWith("/")) {
    return path2 + "/";
  }
  return path2;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key3 in params) {
    params[key3] = decodeURIComponent(params[key3]);
  }
  return params;
}
function make_trackable(url, callback, search_params_callback) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key3) {
        if (key3 === "get" || key3 === "getAll" || key3 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key3](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key3);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
  }
  {
    disable_hash(tracked);
  }
  return tracked;
}
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
function has_data_suffix(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
function add_data_suffix(pathname) {
  if (pathname.endsWith(".html"))
    return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function strip_data_suffix(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
function validator(expected) {
  function validate(module2, file) {
    if (!module2)
      return;
    for (const key3 in module2) {
      if (key3[0] === "_" || expected.has(key3))
        continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key3, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key3}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  return validate;
}
function hint_for_supported_files(key3, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key3)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key3)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key3)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key3)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key3)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key3}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var internal, tracked_url_properties, DATA_SUFFIX, HTML_DATA_SUFFIX, valid_layout_exports, valid_page_exports, valid_layout_server_exports, valid_page_server_exports, valid_server_exports, validate_layout_exports, validate_page_exports, validate_layout_server_exports, validate_page_server_exports, validate_server_exports;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    internal = new URL("sveltekit-internal://");
    tracked_url_properties = /** @type {const} */
    [
      "href",
      "pathname",
      "search",
      "toString",
      "toJSON"
    ];
    DATA_SUFFIX = "/__data.json";
    HTML_DATA_SUFFIX = ".html__data.json";
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});

// node_modules/devalue/src/utils.js
function is_primitive(thing) {
  return Object(thing) !== thing;
}
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str2) {
  let result = "";
  let last_pos = 0;
  const len = str2.length;
  for (let i9 = 0; i9 < len; i9 += 1) {
    const char = str2[i9];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str2.slice(last_pos, i9) + replacement;
      last_pos = i9 + 1;
    }
  }
  return `"${last_pos === 0 ? str2 : result + str2.slice(last_pos)}"`;
}
var escaped, DevalueError, object_proto_names;
var init_utils2 = __esm({
  "node_modules/devalue/src/utils.js"() {
    escaped = {
      "<": "\\u003C",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    DevalueError = class extends Error {
      /**
       * @param {string} message
       * @param {string[]} keys
       */
      constructor(message2, keys) {
        super(message2);
        this.name = "DevalueError";
        this.path = keys.join("");
      }
    };
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
  }
});

// node_modules/devalue/src/uneval.js
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str3 = replacer(thing);
        if (typeof str3 === "string") {
          custom.set(thing, str3);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach((value2, i9) => {
            keys.push(`[${i9}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key3, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key3) ? stringify_primitive(key3) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key3 in thing) {
            keys.push(`.${key3}`);
            walk(thing[key3]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a7, b5) => b5[1] - a7[1]).forEach((entry, i9) => {
    names.set(entry[0], get_name(i9));
  });
  function stringify3(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom.has(thing)) {
      return custom.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify3(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v5, i9) => i9 in thing ? stringify3(v5) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify3).join(",")}])`;
      default:
        const obj = `{${Object.keys(thing).map((key3) => `${safe_key(key3)}:${stringify3(thing[key3])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  const str2 = stringify3(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name2, thing) => {
      params.push(name2);
      if (custom.has(thing)) {
        values.push(
          /** @type {string} */
          custom.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify3(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v5, i9) => {
            statements.push(`${name2}[${i9}]=${stringify3(v5)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name2}.${Array.from(thing).map((v5) => `add(${stringify3(v5)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name2}.${Array.from(thing).map(([k4, v5]) => `set(${stringify3(k4)}, ${stringify3(v5)})`).join(".")}`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key3) => {
            statements.push(
              `${name2}${safe_prop(key3)}=${stringify3(thing[key3])}`
            );
          });
      }
    });
    statements.push(`return ${str2}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str2;
  }
}
function get_name(num) {
  let name2 = "";
  do {
    name2 = chars[num % chars.length] + name2;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name2) ? `${name2}0` : name2;
}
function escape_unsafe_char(c8) {
  return escaped[c8] || c8;
}
function escape_unsafe_chars(str2) {
  return str2.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key3) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key3) ? key3 : escape_unsafe_chars(JSON.stringify(key3));
}
function safe_prop(key3) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key3) ? `.${key3}` : `[${escape_unsafe_chars(JSON.stringify(key3))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string")
    return stringify_string(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  const str2 = String(thing);
  if (typeof thing === "number")
    return str2.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint")
    return thing + "n";
  return str2;
}
var chars, unsafe_chars, reserved;
var init_uneval = __esm({
  "node_modules/devalue/src/uneval.js"() {
    init_utils2();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
  }
});

// node_modules/devalue/src/constants.js
var UNDEFINED, HOLE, NAN, POSITIVE_INFINITY, NEGATIVE_INFINITY, NEGATIVE_ZERO;
var init_constants = __esm({
  "node_modules/devalue/src/constants.js"() {
    UNDEFINED = -1;
    HOLE = -2;
    NAN = -3;
    POSITIVE_INFINITY = -4;
    NEGATIVE_INFINITY = -5;
    NEGATIVE_ZERO = -6;
  }
});

// node_modules/devalue/src/parse.js
var init_parse = __esm({
  "node_modules/devalue/src/parse.js"() {
    init_constants();
  }
});

// node_modules/devalue/src/stringify.js
function stringify2(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom = [];
  for (const key3 in reducers) {
    custom.push({ key: key3, fn: reducers[key3] });
  }
  const keys = [];
  let p5 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (indexes.has(thing))
      return indexes.get(thing);
    if (thing === void 0)
      return UNDEFINED;
    if (Number.isNaN(thing))
      return NAN;
    if (thing === Infinity)
      return POSITIVE_INFINITY;
    if (thing === -Infinity)
      return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0)
      return NEGATIVE_ZERO;
    const index8 = p5++;
    indexes.set(thing, index8);
    for (const { key: key3, fn } of custom) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index8] = `["${key3}",${flatten(value2)}]`;
        return index8;
      }
    }
    let str2 = "";
    if (is_primitive(thing)) {
      str2 = stringify_primitive2(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str2 = `["Object",${stringify_primitive2(thing)}]`;
          break;
        case "BigInt":
          str2 = `["BigInt",${thing}]`;
          break;
        case "Date":
          str2 = `["Date","${thing.toISOString()}"]`;
          break;
        case "RegExp":
          const { source: source2, flags } = thing;
          str2 = flags ? `["RegExp",${stringify_string(source2)},"${flags}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str2 = "[";
          for (let i9 = 0; i9 < thing.length; i9 += 1) {
            if (i9 > 0)
              str2 += ",";
            if (i9 in thing) {
              keys.push(`[${i9}]`);
              str2 += flatten(thing[i9]);
              keys.pop();
            } else {
              str2 += HOLE;
            }
          }
          str2 += "]";
          break;
        case "Set":
          str2 = '["Set"';
          for (const value2 of thing) {
            str2 += `,${flatten(value2)}`;
          }
          str2 += "]";
          break;
        case "Map":
          str2 = '["Map"';
          for (const [key3, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key3) ? stringify_primitive2(key3) : "..."})`
            );
            str2 += `,${flatten(key3)},${flatten(value2)}`;
          }
          str2 += "]";
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str2 = '["null"';
            for (const key3 in thing) {
              keys.push(`.${key3}`);
              str2 += `,${stringify_string(key3)},${flatten(thing[key3])}`;
              keys.pop();
            }
            str2 += "]";
          } else {
            str2 = "{";
            let started = false;
            for (const key3 in thing) {
              if (started)
                str2 += ",";
              started = true;
              keys.push(`.${key3}`);
              str2 += `${stringify_string(key3)}:${flatten(thing[key3])}`;
              keys.pop();
            }
            str2 += "}";
          }
      }
    }
    stringified[index8] = str2;
    return index8;
  }
  const index7 = flatten(value);
  if (index7 < 0)
    return `${index7}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive2(thing) {
  const type = typeof thing;
  if (type === "string")
    return stringify_string(thing);
  if (thing instanceof String)
    return stringify_string(thing.toString());
  if (thing === void 0)
    return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0)
    return NEGATIVE_ZERO.toString();
  if (type === "bigint")
    return `["BigInt","${thing}"]`;
  return String(thing);
}
var init_stringify = __esm({
  "node_modules/devalue/src/stringify.js"() {
    init_utils2();
    init_constants();
  }
});

// node_modules/devalue/index.js
var init_devalue = __esm({
  "node_modules/devalue/index.js"() {
    init_uneval();
    init_parse();
    init_stringify();
  }
});

// .svelte-kit/output/server/chunks/index4.js
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function safe_not_equal2(a7, b5) {
  return a7 != a7 ? (
    // eslint-disable-next-line eqeqeq
    b5 == b5
  ) : a7 !== b5 || a7 && typeof a7 === "object" || typeof a7 === "function";
}
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i9 = 0; i9 < subscriber_queue.length; i9 += 2) {
            subscriber_queue[i9][0](subscriber_queue[i9 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update2) || noop;
    }
    run2(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe };
}
function run_all2(fns) {
  fns.forEach(run);
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto2 = fn.length < 2;
  return readable(initial_value, (set2, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update2);
      if (auto2) {
        set2(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i9) => subscribe_to_store(
        store,
        (value) => {
          values[i9] = value;
          pending &= ~(1 << i9);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i9;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all2(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function readonly(store) {
  return {
    // @ts-expect-error TODO i suspect the bind is unnecessary
    subscribe: store.subscribe.bind(store)
  };
}
function get_store_value(store) {
  let value;
  subscribe_to_store(store, (_4) => value = _4)();
  return value;
}
var subscriber_queue;
var init_index4 = __esm({
  ".svelte-kit/output/server/chunks/index4.js"() {
    init_utils();
    subscriber_queue = [];
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse5;
    exports.serialize = serialize2;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp2 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse5(str2, options3) {
      if (typeof str2 !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options3 || {};
      var dec = opt.decode || decode3;
      var index7 = 0;
      while (index7 < str2.length) {
        var eqIdx = str2.indexOf("=", index7);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str2.indexOf(";", index7);
        if (endIdx === -1) {
          endIdx = str2.length;
        } else if (endIdx < eqIdx) {
          index7 = str2.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key3 = str2.slice(index7, eqIdx).trim();
        if (void 0 === obj[key3]) {
          var val = str2.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key3] = tryDecode(val, dec);
        }
        index7 = endIdx + 1;
      }
      return obj;
    }
    function serialize2(name2, val, options3) {
      var opt = options3 || {};
      var enc = opt.encode || encode4;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp2.test(name2)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp2.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str2 = name2 + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str2 += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp2.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str2 += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp2.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str2 += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str2 += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str2 += "; HttpOnly";
      }
      if (opt.secure) {
        str2 += "; Secure";
      }
      if (opt.partitioned) {
        str2 += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str2 += "; Priority=Low";
            break;
          case "medium":
            str2 += "; Priority=Medium";
            break;
          case "high":
            str2 += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str2 += "; SameSite=Strict";
            break;
          case "lax":
            str2 += "; SameSite=Lax";
            break;
          case "strict":
            str2 += "; SameSite=Strict";
            break;
          case "none":
            str2 += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str2;
    }
    function decode3(str2) {
      return str2.indexOf("%") !== -1 ? decodeURIComponent(str2) : str2;
    }
    function encode4(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str2, decode4) {
      try {
        return decode4(str2);
      } catch (e5) {
        return str2;
      }
    }
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str2) {
      return typeof str2 === "string" && !!str2.trim();
    }
    function parseString2(setCookieValue, options3) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name2 = parsed.name;
      var value = parsed.value;
      options3 = options3 ? Object.assign({}, defaultParseOptions, options3) : defaultParseOptions;
      try {
        value = options3.decodeValues ? decodeURIComponent(value) : value;
      } catch (e5) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e5
        );
      }
      var cookie2 = {
        name: name2,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key3 = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key3 === "expires") {
          cookie2.expires = new Date(value2);
        } else if (key3 === "max-age") {
          cookie2.maxAge = parseInt(value2, 10);
        } else if (key3 === "secure") {
          cookie2.secure = true;
        } else if (key3 === "httponly") {
          cookie2.httpOnly = true;
        } else if (key3 === "samesite") {
          cookie2.sameSite = value2;
        } else {
          cookie2[key3] = value2;
        }
      });
      return cookie2;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name2 = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name2 = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name: name2, value };
    }
    function parse5(input, options3) {
      options3 = options3 ? Object.assign({}, defaultParseOptions, options3) : defaultParseOptions;
      if (!input) {
        if (!options3.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key3) {
            return key3.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options3.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options3 = options3 ? Object.assign({}, defaultParseOptions, options3) : defaultParseOptions;
      if (!options3.map) {
        return input.filter(isNonEmptyString).map(function(str2) {
          return parseString2(str2, options3);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str2) {
          var cookie2 = parseString2(str2, options3);
          cookies2[cookie2.name] = cookie2;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module2.exports = parse5;
    module2.exports.parse = parse5;
    module2.exports.parseString = parseString2;
    module2.exports.splitCookiesString = splitCookiesString2;
  }
});

// .svelte-kit/output/server/entries/fallbacks/layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => Layout
});
function Layout($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}`;
  pop();
}
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/layout.svelte.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  stylesheets: () => stylesheets
});
var index, component_cache, component, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    index = 0;
    component = async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default;
    imports = ["_app/immutable/nodes/0.CveWEt7o.js", "_app/immutable/chunks/disclose-version.BDr9Qe-U.js", "_app/immutable/chunks/runtime.PSreMutw.js", "_app/immutable/chunks/render.CzD__4ML.js"];
    stylesheets = [];
    fonts = [];
  }
});

// .svelte-kit/output/server/chunks/client.js
function get2(key3, parse5 = JSON.parse) {
  try {
    return parse5(sessionStorage[key3]);
  } catch {
  }
}
var SNAPSHOT_KEY, SCROLL_KEY;
var init_client = __esm({
  ".svelte-kit/output/server/chunks/client.js"() {
    init_exports();
    init_devalue();
    SNAPSHOT_KEY = "sveltekit:snapshot";
    SCROLL_KEY = "sveltekit:scroll";
    get2(SCROLL_KEY) ?? {};
    get2(SNAPSHOT_KEY) ?? {};
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error$1
});
function Error$1($$payload, $$props) {
  push(false);
  const $$store_subs = {};
  $$payload.out += `<h1>${escape2(store_get($$store_subs, "$page", page).status)}</h1> <p>${escape2(store_get($$store_subs, "$page", page).error?.message)}</p>`;
  unsubscribe_stores($$store_subs);
  pop();
}
var getStores, page;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_index3();
    init_main_client();
    init_client();
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        /** @type {typeof page} */
        page: {
          subscribe: stores.page.subscribe
        },
        /** @type {typeof navigating} */
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        /** @type {typeof updated} */
        updated: stores.updated
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default;
    imports2 = ["_app/immutable/nodes/1.xm2y3qbI.js", "_app/immutable/chunks/disclose-version.BDr9Qe-U.js", "_app/immutable/chunks/runtime.PSreMutw.js", "_app/immutable/chunks/render.CzD__4ML.js", "_app/immutable/chunks/entry.DT7XnUlp.js", "_app/immutable/chunks/index.ChcU8woL.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js
function i(e5, o7) {
  e5.forEach(function(r8) {
    Array.isArray(r8) ? i(r8, o7) : o7.push(r8);
  });
}
function y(e5) {
  let o7 = [];
  return i(e5, o7), o7;
}
var l, u, x, a, p, g;
var init_chunk_JXBJZR5A = __esm({
  "node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js"() {
    l = (e5) => typeof e5 == "boolean" ? `${e5}` : e5 === 0 ? "0" : e5;
    u = (e5) => !e5 || typeof e5 != "object" || Object.keys(e5).length === 0;
    x = (e5, o7) => JSON.stringify(e5) === JSON.stringify(o7);
    a = (...e5) => y(e5).filter(Boolean);
    p = (e5, o7) => {
      let r8 = {}, c8 = Object.keys(e5), f5 = Object.keys(o7);
      for (let t8 of c8)
        if (f5.includes(t8)) {
          let s9 = e5[t8], n7 = o7[t8];
          typeof s9 == "object" && typeof n7 == "object" ? r8[t8] = p(s9, n7) : Array.isArray(s9) || Array.isArray(n7) ? r8[t8] = a(n7, s9) : r8[t8] = n7 + " " + s9;
        } else
          r8[t8] = e5[t8];
      for (let t8 of f5)
        c8.includes(t8) || (r8[t8] = o7[t8]);
      return r8;
    };
    g = (e5) => !e5 || typeof e5 != "string" ? e5 : e5.replace(/\s+/g, " ").trim();
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/tw-join.mjs
function twJoin() {
  var index7 = 0;
  var argument;
  var resolvedValue;
  var string = "";
  while (index7 < arguments.length) {
    if (argument = arguments[index7++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  var resolvedValue;
  var string = "";
  for (var k4 = 0; k4 < mix.length; k4++) {
    if (mix[k4]) {
      if (resolvedValue = toValue(mix[k4])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var init_tw_join = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/tw-join.mjs"() {
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/class-utils.mjs
function createClassUtils(config) {
  var classMap = createClassMap(config);
  var conflictingClassGroups = config.conflictingClassGroups, _config$conflictingCl = config.conflictingClassGroupModifiers, conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
  function getClassGroupId(className) {
    var classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    var conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  var currentClassPart = classParts[0];
  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  var classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(function(_ref) {
    var validator2 = _ref.validator;
    return validator2(classRest);
  })?.classGroupId;
}
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    var property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  var theme = config.theme, prefix = config.prefix;
  var classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(function(_ref2) {
    var classGroupId = _ref2[0], classGroup = _ref2[1];
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach(function(classDefinition) {
    if (typeof classDefinition === "string") {
      var classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(function(_ref3) {
      var key3 = _ref3[0], classGroup2 = _ref3[1];
      processClassesRecursively(classGroup2, getPart(classPartObject, key3), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path2) {
  var currentClassPartObject = classPartObject;
  path2.split(CLASS_PART_SEPARATOR).forEach(function(pathPart) {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(function(_ref4) {
    var classGroupId = _ref4[0], classGroup = _ref4[1];
    var prefixedClassGroup = classGroup.map(function(classDefinition) {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(function(_ref5) {
          var key3 = _ref5[0], value = _ref5[1];
          return [prefix + key3, value];
        }));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
var CLASS_PART_SEPARATOR, arbitraryPropertyRegex;
var init_class_utils = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/class-utils.mjs"() {
    CLASS_PART_SEPARATOR = "-";
    arbitraryPropertyRegex = /^\[(.+)\]$/;
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/lru-cache.mjs
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: function get4() {
        return void 0;
      },
      set: function set2() {
      }
    };
  }
  var cacheSize = 0;
  var cache = /* @__PURE__ */ new Map();
  var previousCache = /* @__PURE__ */ new Map();
  function update2(key3, value) {
    cache.set(key3, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get: function get4(key3) {
      var value = cache.get(key3);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key3)) !== void 0) {
        update2(key3, value);
        return value;
      }
    },
    set: function set2(key3, value) {
      if (cache.has(key3)) {
        cache.set(key3, value);
      } else {
        update2(key3, value);
      }
    }
  };
}
var init_lru_cache = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/lru-cache.mjs"() {
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/modifier-utils.mjs
function createSplitModifiers(config) {
  var separator = config.separator || ":";
  var isSeparatorSingleCharacter = separator.length === 1;
  var firstSeparatorCharacter = separator[0];
  var separatorLength = separator.length;
  return function splitModifiers(className) {
    var modifiers = [];
    var bracketDepth = 0;
    var modifierStart = 0;
    var postfixModifierPosition;
    for (var index7 = 0; index7 < className.length; index7++) {
      var currentCharacter = className[index7];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index7, index7 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index7));
          modifierStart = index7 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index7;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  var sortedModifiers = [];
  var unsortedModifiers = [];
  modifiers.forEach(function(modifier) {
    var isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
  return sortedModifiers;
}
var IMPORTANT_MODIFIER;
var init_modifier_utils = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/modifier-utils.mjs"() {
    IMPORTANT_MODIFIER = "!";
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/config-utils.mjs
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
var init_config_utils = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/config-utils.mjs"() {
    init_class_utils();
    init_lru_cache();
    init_modifier_utils();
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/merge-classlist.mjs
function mergeClassList(classList, configUtils) {
  var splitModifiers = configUtils.splitModifiers, getClassGroupId = configUtils.getClassGroupId, getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
  var classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function(originalClassName) {
    var _splitModifiers = splitModifiers(originalClassName), modifiers = _splitModifiers.modifiers, hasImportantModifier = _splitModifiers.hasImportantModifier, baseClassName = _splitModifiers.baseClassName, maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
    var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    var variantModifier = sortModifiers(modifiers).join(":");
    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter(function(parsed) {
    if (!parsed.isTailwindClass) {
      return true;
    }
    var modifierId = parsed.modifierId, classGroupId = parsed.classGroupId, hasPostfixModifier = parsed.hasPostfixModifier;
    var classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function(group) {
      return classGroupsInConflict.add(modifierId + group);
    });
    return true;
  }).reverse().map(function(parsed) {
    return parsed.originalClassName;
  }).join(" ");
}
var SPLIT_CLASSES_REGEX;
var init_merge_classlist = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/merge-classlist.mjs"() {
    init_modifier_utils();
    SPLIT_CLASSES_REGEX = /\s+/;
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/create-tailwind-merge.mjs
function createTailwindMerge() {
  for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
    createConfig[_key] = arguments[_key];
  }
  var configUtils;
  var cacheGet;
  var cacheSet;
  var functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    var firstCreateConfig = createConfig[0], restCreateConfig = createConfig.slice(1);
    var config = restCreateConfig.reduce(function(previousConfig, createConfigCurrent) {
      return createConfigCurrent(previousConfig);
    }, firstCreateConfig());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    var cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    var result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var init_create_tailwind_merge = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/create-tailwind-merge.mjs"() {
    init_config_utils();
    init_merge_classlist();
    init_tw_join();
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/from-theme.mjs
function fromTheme(key3) {
  var themeGetter = function themeGetter2(theme) {
    return theme[key3] || [];
  };
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
var init_from_theme = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/from-theme.mjs"() {
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/validators.mjs
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, "size", isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryUrl(value) {
  return getIsArbitraryValue(value, "url", isUrl);
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isNumber(value) {
  return !Number.isNaN(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isInteger(value) {
  return isIntegerOnly(value) || getIsArbitraryValue(value, "number", isIntegerOnly);
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isAny() {
  return true;
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function getIsArbitraryValue(value, label, testValue) {
  var result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return result[1] === label;
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value);
}
function isNever() {
  return false;
}
function isUrl(value) {
  return value.startsWith("url(");
}
function isIntegerOnly(value) {
  return Number.isInteger(Number(value));
}
function isShadow(value) {
  return shadowRegex.test(value);
}
var arbitraryValueRegex, fractionRegex, stringLengths, tshirtUnitRegex, lengthUnitRegex, shadowRegex;
var init_validators = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/validators.mjs"() {
    arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    fractionRegex = /^\d+\/\d+$/;
    stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/default-config.mjs
function getDefaultConfig() {
  var colors = fromTheme("colors");
  var spacing = fromTheme("spacing");
  var blur = fromTheme("blur");
  var brightness = fromTheme("brightness");
  var borderColor = fromTheme("borderColor");
  var borderRadius = fromTheme("borderRadius");
  var borderSpacing = fromTheme("borderSpacing");
  var borderWidth = fromTheme("borderWidth");
  var contrast = fromTheme("contrast");
  var grayscale = fromTheme("grayscale");
  var hueRotate = fromTheme("hueRotate");
  var invert = fromTheme("invert");
  var gap = fromTheme("gap");
  var gradientColorStops = fromTheme("gradientColorStops");
  var gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  var inset = fromTheme("inset");
  var margin = fromTheme("margin");
  var opacity = fromTheme("opacity");
  var padding = fromTheme("padding");
  var saturate = fromTheme("saturate");
  var scale = fromTheme("scale");
  var sepia = fromTheme("sepia");
  var skew = fromTheme("skew");
  var space = fromTheme("space");
  var translate = fromTheme("translate");
  var getOverscroll = function getOverscroll2() {
    return ["auto", "contain", "none"];
  };
  var getOverflow = function getOverflow2() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  };
  var getSpacingWithAutoAndArbitrary = function getSpacingWithAutoAndArbitrary2() {
    return ["auto", isArbitraryValue, spacing];
  };
  var getSpacingWithArbitrary = function getSpacingWithArbitrary2() {
    return [isArbitraryValue, spacing];
  };
  var getLengthWithEmpty = function getLengthWithEmpty2() {
    return ["", isLength];
  };
  var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary2() {
    return ["auto", isNumber, isArbitraryValue];
  };
  var getPositions = function getPositions2() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  };
  var getLineStyles = function getLineStyles2() {
    return ["solid", "dashed", "dotted", "double", "none"];
  };
  var getBlendModes = function getBlendModes2() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  };
  var getAlign = function getAlign2() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  };
  var getZeroAndEmpty = function getZeroAndEmpty2() {
    return ["", "0", isArbitraryValue];
  };
  var getBreaks = function getBreaks2() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  };
  var getNumber = function getNumber2() {
    return [isNumber, isArbitraryNumber];
  };
  var getNumberAndArbitrary = function getNumberAndArbitrary2() {
    return [isNumber, isArbitraryValue];
  };
  return {
    cacheSize: 500,
    theme: {
      colors: [isAny],
      spacing: [isLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmpty(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      "float": [{
        "float": ["right", "left", "none"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [].concat(getPositions(), [isArbitraryValue])
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal"].concat(getAlign())
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal"].concat(getAlign(), ["baseline"])
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [].concat(getAlign(), ["baseline"])
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize, isArbitraryValue]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isArbitraryValue, isLength]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [].concat(getLineStyles(), ["wavy"])
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isArbitraryValue, isLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      "break": [{
        "break": ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [].concat(getPositions(), [isArbitraryPosition])
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryUrl]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [].concat(getLineStyles(), ["hidden"])
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [""].concat(getLineStyles())
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isArbitraryValue, isLength]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmpty()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: ["appearance-none"],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "pinch-zoom", "manipulation", {
          pan: ["x", "left", "right", "y", "up", "down"]
        }]
      }],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
var init_default_config = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/default-config.mjs"() {
    init_from_theme();
    init_validators();
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/merge-configs.mjs
function mergeConfigs(baseConfig, configExtension) {
  for (var key3 in configExtension) {
    mergePropertyRecursively(baseConfig, key3, configExtension[key3]);
  }
  return baseConfig;
}
function mergePropertyRecursively(baseObject, mergeKey, mergeValue) {
  if (!hasOwnProperty.call(baseObject, mergeKey) || overrideTypes.has(typeof mergeValue) || mergeValue === null) {
    baseObject[mergeKey] = mergeValue;
    return;
  }
  if (Array.isArray(mergeValue) && Array.isArray(baseObject[mergeKey])) {
    baseObject[mergeKey] = baseObject[mergeKey].concat(mergeValue);
    return;
  }
  if (typeof mergeValue === "object" && typeof baseObject[mergeKey] === "object") {
    if (baseObject[mergeKey] === null) {
      baseObject[mergeKey] = mergeValue;
      return;
    }
    for (var nextKey in mergeValue) {
      mergePropertyRecursively(baseObject[mergeKey], nextKey, mergeValue[nextKey]);
    }
  }
}
var hasOwnProperty, overrideTypes;
var init_merge_configs = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/merge-configs.mjs"() {
    hasOwnProperty = Object.prototype.hasOwnProperty;
    overrideTypes = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/extend-tailwind-merge.mjs
function extendTailwindMerge(configExtension) {
  for (var _len = arguments.length, createConfig = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    createConfig[_key - 1] = arguments[_key];
  }
  return typeof configExtension === "function" ? createTailwindMerge.apply(void 0, [getDefaultConfig, configExtension].concat(createConfig)) : createTailwindMerge.apply(void 0, [function() {
    return mergeConfigs(getDefaultConfig(), configExtension);
  }].concat(createConfig));
}
var init_extend_tailwind_merge = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/extend-tailwind-merge.mjs"() {
    init_create_tailwind_merge();
    init_default_config();
    init_merge_configs();
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/tw-merge.mjs
var twMerge;
var init_tw_merge = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/lib/tw-merge.mjs"() {
    init_create_tailwind_merge();
    init_default_config();
    twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  }
});

// node_modules/tailwind-variants/node_modules/tailwind-merge/dist/tailwind-merge.mjs
var init_tailwind_merge = __esm({
  "node_modules/tailwind-variants/node_modules/tailwind-merge/dist/tailwind-merge.mjs"() {
    init_extend_tailwind_merge();
    init_tw_merge();
  }
});

// node_modules/tailwind-variants/dist/index.js
var se, _, N, q, M, F, w, Z, ie;
var init_dist = __esm({
  "node_modules/tailwind-variants/dist/index.js"() {
    init_chunk_JXBJZR5A();
    init_tailwind_merge();
    se = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
    _ = (s9) => s9 || void 0;
    N = (...s9) => _(y(s9).filter(Boolean).join(" "));
    q = null;
    M = {};
    F = false;
    w = (...s9) => (b$1) => b$1.twMerge ? ((!q || F) && (F = false, q = u(M) ? twMerge : extendTailwindMerge(M)), _(q(N(s9)))) : N(s9);
    Z = (s9, b5) => {
      for (let e5 in b5)
        s9.hasOwnProperty(e5) ? s9[e5] = N(s9[e5], b5[e5]) : s9[e5] = b5[e5];
      return s9;
    };
    ie = (s9, b$1) => {
      let { extend: e5 = null, slots: j4 = {}, variants: U4 = {}, compoundVariants: C5 = [], compoundSlots: V3 = [], defaultVariants: W4 = {} } = s9, m5 = { ...se, ...b$1 }, S5 = e5 != null && e5.base ? N(e5.base, s9 == null ? void 0 : s9.base) : s9 == null ? void 0 : s9.base, g$1 = e5 != null && e5.variants && !u(e5.variants) ? p(U4, e5.variants) : U4, A5 = e5 != null && e5.defaultVariants && !u(e5.defaultVariants) ? { ...e5.defaultVariants, ...W4 } : W4;
      !u(m5.twMergeConfig) && !x(m5.twMergeConfig, M) && (F = true, M = m5.twMergeConfig);
      let O3 = u(e5 == null ? void 0 : e5.slots), $3 = u(j4) ? {} : { base: N(s9 == null ? void 0 : s9.base, O3 && (e5 == null ? void 0 : e5.base)), ...j4 }, h$1 = O3 ? $3 : Z({ ...e5 == null ? void 0 : e5.slots }, u($3) ? { base: s9 == null ? void 0 : s9.base } : $3), v5 = (l7) => {
        if (u(g$1) && u(j4) && O3)
          return w(S5, l7 == null ? void 0 : l7.class, l7 == null ? void 0 : l7.className)(m5);
        if (C5 && !Array.isArray(C5))
          throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof C5}`);
        if (V3 && !Array.isArray(V3))
          throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof V3}`);
        let K3 = (t8, n7, a7 = [], i9) => {
          let r8 = a7;
          if (typeof n7 == "string")
            r8 = r8.concat(g(n7).split(" ").map((c8) => `${t8}:${c8}`));
          else if (Array.isArray(n7))
            r8 = r8.concat(n7.reduce((c8, f5) => c8.concat(`${t8}:${f5}`), []));
          else if (typeof n7 == "object" && typeof i9 == "string") {
            for (let c8 in n7)
              if (n7.hasOwnProperty(c8) && c8 === i9) {
                let f5 = n7[c8];
                if (f5 && typeof f5 == "string") {
                  let o7 = g(f5);
                  r8[i9] ? r8[i9] = r8[i9].concat(o7.split(" ").map((u6) => `${t8}:${u6}`)) : r8[i9] = o7.split(" ").map((u6) => `${t8}:${u6}`);
                } else
                  Array.isArray(f5) && f5.length > 0 && (r8[i9] = f5.reduce((o7, u6) => o7.concat(`${t8}:${u6}`), []));
              }
          }
          return r8;
        }, z3 = (t8, n7 = g$1, a$1 = null, i9 = null) => {
          var J3;
          let r8 = n7[t8];
          if (!r8 || u(r8))
            return null;
          let c8 = (J3 = i9 == null ? void 0 : i9[t8]) != null ? J3 : l7 == null ? void 0 : l7[t8];
          if (c8 === null)
            return null;
          let f5 = l(c8), o7 = Array.isArray(m5.responsiveVariants) && m5.responsiveVariants.length > 0 || m5.responsiveVariants === true, u6 = A5 == null ? void 0 : A5[t8], d6 = [];
          if (typeof f5 == "object" && o7)
            for (let [k4, L5] of Object.entries(f5)) {
              let ae3 = r8[L5];
              if (k4 === "initial") {
                u6 = L5;
                continue;
              }
              Array.isArray(m5.responsiveVariants) && !m5.responsiveVariants.includes(k4) || (d6 = K3(k4, ae3, d6, a$1));
            }
          let T2 = r8[f5] || r8[l(u6)];
          return typeof d6 == "object" && typeof a$1 == "string" && d6[a$1] ? Z(d6, T2) : d6.length > 0 ? (d6.push(T2), d6) : T2;
        }, P4 = () => g$1 ? Object.keys(g$1).map((t8) => z3(t8, g$1)) : null, p5 = (t8, n7) => {
          if (!g$1 || typeof g$1 != "object")
            return null;
          let a7 = new Array();
          for (let i9 in g$1) {
            let r8 = z3(i9, g$1, t8, n7), c8 = t8 === "base" && typeof r8 == "string" ? r8 : r8 && r8[t8];
            c8 && (a7[a7.length] = c8);
          }
          return a7;
        }, D4 = {};
        for (let t8 in l7)
          l7[t8] !== void 0 && (D4[t8] = l7[t8]);
        let G3 = (t8, n7) => {
          var i9;
          let a7 = typeof (l7 == null ? void 0 : l7[t8]) == "object" ? { [t8]: (i9 = l7[t8]) == null ? void 0 : i9.initial } : {};
          return { ...A5, ...D4, ...a7, ...n7 };
        }, H3 = (t8 = [], n7) => {
          let a7 = [];
          for (let { class: i9, className: r8, ...c8 } of t8) {
            let f5 = true;
            for (let [o7, u6] of Object.entries(c8)) {
              let d6 = G3(o7, n7);
              if (Array.isArray(u6)) {
                if (!u6.includes(d6[o7])) {
                  f5 = false;
                  break;
                }
              } else if (d6[o7] !== u6) {
                f5 = false;
                break;
              }
            }
            f5 && (i9 && a7.push(i9), r8 && a7.push(r8));
          }
          return a7;
        }, I4 = (t8) => {
          let n7 = H3(C5, t8), a7 = H3(e5 == null ? void 0 : e5.compoundVariants, t8);
          return a(a7, n7);
        }, ee3 = (t8) => {
          let n7 = I4(t8);
          if (!Array.isArray(n7))
            return n7;
          let a7 = {};
          for (let i9 of n7)
            if (typeof i9 == "string" && (a7.base = w(a7.base, i9)(m5)), typeof i9 == "object")
              for (let [r8, c8] of Object.entries(i9))
                a7[r8] = w(a7[r8], c8)(m5);
          return a7;
        }, te3 = (t8) => {
          if (V3.length < 1)
            return null;
          let n7 = {};
          for (let { slots: a7 = [], class: i9, className: r8, ...c8 } of V3) {
            if (!u(c8)) {
              let f5 = true;
              for (let o7 of Object.keys(c8)) {
                let u6 = G3(o7, t8)[o7];
                if (u6 === void 0 || (Array.isArray(c8[o7]) ? !c8[o7].includes(u6) : c8[o7] !== u6)) {
                  f5 = false;
                  break;
                }
              }
              if (!f5)
                continue;
            }
            for (let f5 of a7)
              n7[f5] = n7[f5] || [], n7[f5].push([i9, r8]);
          }
          return n7;
        };
        if (!u(j4) || !O3) {
          let t8 = {};
          if (typeof h$1 == "object" && !u(h$1))
            for (let n7 of Object.keys(h$1))
              t8[n7] = (a7) => {
                var i9, r8;
                return w(h$1[n7], p5(n7, a7), ((i9 = ee3(a7)) != null ? i9 : [])[n7], ((r8 = te3(a7)) != null ? r8 : [])[n7], a7 == null ? void 0 : a7.class, a7 == null ? void 0 : a7.className)(m5);
              };
          return t8;
        }
        return w(S5, P4(), I4(), l7 == null ? void 0 : l7.class, l7 == null ? void 0 : l7.className)(m5);
      }, x4 = () => {
        if (!(!g$1 || typeof g$1 != "object"))
          return Object.keys(g$1);
      };
      return v5.variantKeys = x4(), v5.extend = e5, v5.base = S5, v5.slots = h$1, v5.variants = g$1, v5.defaultVariants = A5, v5.compoundSlots = V3, v5.compoundVariants = C5, v5;
    };
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e5) {
  var t8, f5, n7 = "";
  if ("string" == typeof e5 || "number" == typeof e5)
    n7 += e5;
  else if ("object" == typeof e5)
    if (Array.isArray(e5)) {
      var o7 = e5.length;
      for (t8 = 0; t8 < o7; t8++)
        e5[t8] && (f5 = r(e5[t8])) && (n7 && (n7 += " "), n7 += f5);
    } else
      for (f5 in e5)
        e5[f5] && (n7 && (n7 += " "), n7 += f5);
  return n7;
}
function clsx() {
  for (var e5, t8, f5 = 0, n7 = "", o7 = arguments.length; f5 < o7; f5++)
    (e5 = arguments[f5]) && (t8 = r(e5)) && (n7 && (n7 += " "), n7 += t8);
  return n7;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});

// node_modules/dequal/dist/index.mjs
var init_dist2 = __esm({
  "node_modules/dequal/dist/index.mjs"() {
  }
});

// .svelte-kit/output/server/chunks/github-markdown.js
function onDestroy(fn) {
  on_destroy.push(fn);
}
function styleToString(style) {
  return Object.keys(style).reduce((str2, key3) => {
    if (style[key3] === void 0)
      return str2;
    return str2 + `${key3}:${style[key3]};`;
  }, "");
}
function isElement(element) {
  return element instanceof Element;
}
function isHTMLElement(element) {
  return element instanceof HTMLElement;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isReadable(value) {
  return isObject(value) && "subscribe" in value;
}
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function noop2() {
}
function addEventListener(target, event, handler, options3) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options3));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options3));
  };
}
function addMeltEventListener(target, event, handler, options3) {
  const events = Array.isArray(event) ? event : [event];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options3));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options3));
    };
  }
  return () => noop2();
}
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
function withMelt(handler) {
  return (event) => {
    const customEvent = dispatchMeltEvent(event);
    if (customEvent?.defaultPrevented)
      return;
    return handler(event);
  };
}
function withGet(store) {
  return {
    ...store,
    get: () => get_store_value(store)
  };
}
function effect(stores, fn) {
  let cb = void 0;
  const destroy = derived(stores, (stores2) => {
    cb?.();
    cb = fn(stores2);
  }).subscribe(noop2);
  const unsub = () => {
    destroy();
    cb?.();
  };
  safeOnDestroy(unsub);
  return unsub;
}
var badgeVariants, isBrowser, isFunction, kbd, safeOnDestroy, documentEscapeKeyStore, useEscapeKeydown, buttonVariants;
var init_github_markdown = __esm({
  ".svelte-kit/output/server/chunks/github-markdown.js"() {
    init_dist();
    init_clsx();
    init_dist2();
    init_index4();
    init_index3();
    badgeVariants = ie({
      base: "inline-flex items-center border rounded-full px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none select-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
      variants: {
        variant: {
          default: "bg-primary hover:bg-primary/80 border-transparent text-primary-foreground",
          secondary: "bg-secondary hover:bg-secondary/80 border-transparent text-secondary-foreground",
          destructive: "bg-destructive hover:bg-destructive/80 border-transparent text-destructive-foreground",
          outline: "text-foreground"
        }
      },
      defaultVariants: {
        variant: "default"
      }
    });
    ({
      type: "hidden",
      "aria-hidden": true,
      hidden: true,
      tabIndex: -1,
      style: styleToString({
        position: "absolute",
        opacity: 0,
        "pointer-events": "none",
        margin: 0,
        transform: "translateX(-100%)"
      })
    });
    isBrowser = typeof document !== "undefined";
    isFunction = (v5) => typeof v5 === "function";
    withGet.writable = function(initial) {
      const internal2 = writable(initial);
      let value = initial;
      return {
        subscribe: internal2.subscribe,
        set(newValue) {
          internal2.set(newValue);
          value = newValue;
        },
        update(updater) {
          const newValue = updater(value);
          internal2.set(newValue);
          value = newValue;
        },
        get() {
          return value;
        }
      };
    };
    withGet.derived = function(stores, fn) {
      const subscribers = /* @__PURE__ */ new Map();
      const get4 = () => {
        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();
        return fn(values);
      };
      const subscribe = (subscriber) => {
        const unsubscribers = [];
        const storesArr = Array.isArray(stores) ? stores : [stores];
        storesArr.forEach((store) => {
          unsubscribers.push(store.subscribe(() => {
            subscriber(get4());
          }));
        });
        subscriber(get4());
        subscribers.set(subscriber, unsubscribers);
        return () => {
          const unsubscribers2 = subscribers.get(subscriber);
          if (unsubscribers2) {
            for (const unsubscribe of unsubscribers2) {
              unsubscribe();
            }
          }
          subscribers.delete(subscriber);
        };
      };
      return {
        get: get4,
        subscribe
      };
    };
    kbd = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*",
      A: "a",
      P: "p"
    };
    safeOnDestroy = (fn) => {
      try {
        onDestroy(fn);
      } catch {
        return fn;
      }
    };
    readable(void 0, (set2) => {
      function clicked(event) {
        set2(event);
        set2(void 0);
      }
      const unsubscribe = addEventListener(document, "pointerup", clicked, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    documentEscapeKeyStore = readable(void 0, (set2) => {
      function keydown(event) {
        if (event && event.key === kbd.ESCAPE) {
          set2(event);
        }
        set2(void 0);
      }
      const unsubscribe = addEventListener(document, "keydown", keydown, {
        passive: false
      });
      return unsubscribe;
    });
    useEscapeKeydown = (node, config = {}) => {
      let unsub = noop2;
      function update2(config2 = {}) {
        unsub();
        const options3 = { enabled: true, ...config2 };
        const enabled = isReadable(options3.enabled) ? options3.enabled : readable(options3.enabled);
        unsub = executeCallbacks(
          // Handle escape keydowns
          documentEscapeKeyStore.subscribe((e5) => {
            if (!e5 || !get_store_value(enabled))
              return;
            const target = e5.target;
            if (!isHTMLElement(target) || target.closest("[data-escapee]") !== node) {
              return;
            }
            e5.preventDefault();
            if (options3.ignore) {
              if (isFunction(options3.ignore)) {
                if (options3.ignore(e5))
                  return;
              } else if (Array.isArray(options3.ignore)) {
                if (options3.ignore.length > 0 && options3.ignore.some((ignoreEl) => {
                  return ignoreEl && target === ignoreEl;
                }))
                  return;
              }
            }
            options3.handler?.(e5);
          }),
          effect(enabled, ($enabled) => {
            if ($enabled) {
              node.dataset.escapee = "";
            } else {
              delete node.dataset.escapee;
            }
          })
        );
      }
      update2(config);
      return {
        update: update2,
        destroy() {
          node.removeAttribute("data-escapee");
          unsub();
        }
      };
    };
    buttonVariants = ie({
      base: "inline-flex items-center justify-center rounded-md text-sm font-medium whitespace-nowrap ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    });
  }
});

// node_modules/tailwind-merge/dist/bundle-mjs.mjs
function createClassUtils2(config) {
  const classMap = createClassMap2(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR2);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive2(classParts, classMap) || getGroupIdForArbitraryProperty2(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive2(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive2(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR2);
  return classPartObject.validators.find(({
    validator: validator2
  }) => validator2(classRest))?.classGroupId;
}
function getGroupIdForArbitraryProperty2(className) {
  if (arbitraryPropertyRegex2.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex2.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap2(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries2(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively2(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively2(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart2(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter2(classDefinition)) {
        processClassesRecursively2(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key3, classGroup2]) => {
      processClassesRecursively2(classGroup2, getPart2(classPartObject, key3), classGroupId, theme);
    });
  });
}
function getPart2(classPartObject, path2) {
  let currentClassPartObject = classPartObject;
  path2.split(CLASS_PART_SEPARATOR2).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter2(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries2(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key3, value]) => [prefix + key3, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache2(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  function update2(key3, value) {
    cache.set(key3, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get(key3) {
      let value = cache.get(key3);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key3)) !== void 0) {
        update2(key3, value);
        return value;
      }
    },
    set(key3, value) {
      if (cache.has(key3)) {
        cache.set(key3, value);
      } else {
        update2(key3, value);
      }
    }
  };
}
function createSplitModifiers2(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index7 = 0; index7 < className.length; index7++) {
      let currentCharacter = className[index7];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index7, index7 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index7));
          modifierStart = index7 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index7;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER2);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers2(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils2(config) {
  return {
    cache: createLruCache2(config.cacheSize),
    splitModifiers: createSplitModifiers2(config),
    ...createClassUtils2(config)
  };
}
function mergeClassList2(classList, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX2).map((originalClassName) => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers2(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER2 : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter((parsed) => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map((parsed) => parsed.originalClassName).join(" ");
}
function twJoin2() {
  let index7 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index7 < arguments.length) {
    if (argument = arguments[index7++]) {
      if (resolvedValue = toValue2(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue2(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k4 = 0; k4 < mix.length; k4++) {
    if (mix[k4]) {
      if (resolvedValue = toValue2(mix[k4])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function createTailwindMerge2(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils2(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList2(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin2.apply(null, arguments));
  };
}
function fromTheme2(key3) {
  const themeGetter = (theme) => theme[key3] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
function isLength2(value) {
  return isNumber2(value) || stringLengths2.has(value) || fractionRegex2.test(value);
}
function isArbitraryLength2(value) {
  return getIsArbitraryValue2(value, "length", isLengthOnly2);
}
function isNumber2(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber2(value) {
  return getIsArbitraryValue2(value, "number", isNumber2);
}
function isInteger2(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent2(value) {
  return value.endsWith("%") && isNumber2(value.slice(0, -1));
}
function isArbitraryValue2(value) {
  return arbitraryValueRegex2.test(value);
}
function isTshirtSize2(value) {
  return tshirtUnitRegex2.test(value);
}
function isArbitrarySize2(value) {
  return getIsArbitraryValue2(value, sizeLabels, isNever2);
}
function isArbitraryPosition2(value) {
  return getIsArbitraryValue2(value, "position", isNever2);
}
function isArbitraryImage(value) {
  return getIsArbitraryValue2(value, imageLabels, isImage);
}
function isArbitraryShadow2(value) {
  return getIsArbitraryValue2(value, "", isShadow2);
}
function isAny2() {
  return true;
}
function getIsArbitraryValue2(value, label, testValue) {
  const result = arbitraryValueRegex2.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly2(value) {
  return lengthUnitRegex2.test(value) && !colorFunctionRegex.test(value);
}
function isNever2() {
  return false;
}
function isShadow2(value) {
  return shadowRegex2.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
function getDefaultConfig2() {
  const colors = fromTheme2("colors");
  const spacing = fromTheme2("spacing");
  const blur = fromTheme2("blur");
  const brightness = fromTheme2("brightness");
  const borderColor = fromTheme2("borderColor");
  const borderRadius = fromTheme2("borderRadius");
  const borderSpacing = fromTheme2("borderSpacing");
  const borderWidth = fromTheme2("borderWidth");
  const contrast = fromTheme2("contrast");
  const grayscale = fromTheme2("grayscale");
  const hueRotate = fromTheme2("hueRotate");
  const invert = fromTheme2("invert");
  const gap = fromTheme2("gap");
  const gradientColorStops = fromTheme2("gradientColorStops");
  const gradientColorStopPositions = fromTheme2("gradientColorStopPositions");
  const inset = fromTheme2("inset");
  const margin = fromTheme2("margin");
  const opacity = fromTheme2("opacity");
  const padding = fromTheme2("padding");
  const saturate = fromTheme2("saturate");
  const scale = fromTheme2("scale");
  const sepia = fromTheme2("sepia");
  const skew = fromTheme2("skew");
  const space = fromTheme2("space");
  const translate = fromTheme2("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue2, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue2, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength2, isArbitraryLength2];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber2, isArbitraryValue2];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue2];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumber = () => [isNumber2, isArbitraryNumber2];
  const getNumberAndArbitrary = () => [isNumber2, isArbitraryValue2];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny2],
      spacing: [isLength2, isArbitraryLength2],
      blur: ["none", "", isTshirtSize2, isArbitraryValue2],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize2, isArbitraryValue2],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent2, isArbitraryLength2],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue2]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize2]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue2]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger2, isArbitraryValue2]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue2]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger2, isArbitraryValue2]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny2]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger2, isArbitraryValue2]
        }, isArbitraryValue2]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny2]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger2, isArbitraryValue2]
        }, isArbitraryValue2]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue2]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue2]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue2, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue2, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue2, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize2]
        }, isTshirtSize2]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue2, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue2, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue2, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue2, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize2, isArbitraryLength2]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber2]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny2]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue2]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber2, isArbitraryNumber2]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength2, isArbitraryValue2]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue2]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue2]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength2, isArbitraryLength2]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength2, isArbitraryValue2]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue2]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue2]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition2]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize2]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength2, isArbitraryValue2]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength2, isArbitraryLength2]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength2, isArbitraryLength2]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize2, isArbitraryShadow2]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny2]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize2, isArbitraryValue2]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue2]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue2]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue2]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger2, isArbitraryValue2]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue2]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue2]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue2]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength2, isArbitraryLength2, isArbitraryNumber2]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
var CLASS_PART_SEPARATOR2, arbitraryPropertyRegex2, IMPORTANT_MODIFIER2, SPLIT_CLASSES_REGEX2, arbitraryValueRegex2, fractionRegex2, stringLengths2, tshirtUnitRegex2, lengthUnitRegex2, colorFunctionRegex, shadowRegex2, imageRegex, sizeLabels, imageLabels, twMerge2;
var init_bundle_mjs = __esm({
  "node_modules/tailwind-merge/dist/bundle-mjs.mjs"() {
    CLASS_PART_SEPARATOR2 = "-";
    arbitraryPropertyRegex2 = /^\[(.+)\]$/;
    IMPORTANT_MODIFIER2 = "!";
    SPLIT_CLASSES_REGEX2 = /\s+/;
    arbitraryValueRegex2 = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    fractionRegex2 = /^\d+\/\d+$/;
    stringLengths2 = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    tshirtUnitRegex2 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    lengthUnitRegex2 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
    shadowRegex2 = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
    imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
    imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
    twMerge2 = /* @__PURE__ */ createTailwindMerge2(getDefaultConfig2);
  }
});

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
function escape3(html, encode4) {
  if (encode4) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
function unescape2(html) {
  return html.replace(unescapeTest, (_4, n7) => {
    n7 = n7.toLowerCase();
    if (n7 === "colon")
      return ":";
    if (n7.charAt(0) === "#") {
      return n7.charAt(1) === "x" ? String.fromCharCode(parseInt(n7.substring(2), 16)) : String.fromCharCode(+n7.substring(1));
    }
    return "";
  });
}
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
function cleanUrl(sanitize, base2, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e5) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base2 && !originIndependentUrl.test(href)) {
    href = resolveUrl(base2, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e5) {
    return null;
  }
  return href;
}
function resolveUrl(base2, href) {
  if (!baseUrls[" " + base2]) {
    if (justDomain.test(base2)) {
      baseUrls[" " + base2] = base2 + "/";
    } else {
      baseUrls[" " + base2] = rtrim(base2, "/", true);
    }
  }
  base2 = baseUrls[" " + base2];
  const relativeBase = base2.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base2.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base2.replace(domain, "$1") + href;
  } else {
    return base2 + href;
  }
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str2) => {
    let escaped2 = false, curr = offset;
    while (--curr >= 0 && str2[curr] === "\\")
      escaped2 = !escaped2;
    if (escaped2) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i9 = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i9 < cells.length; i9++) {
    cells[i9] = cells[i9].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str2, c8, invert) {
  const l7 = str2.length;
  if (l7 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l7) {
    const currChar = str2.charAt(l7 - suffLen - 1);
    if (currChar === c8 && !invert) {
      suffLen++;
    } else if (currChar !== c8 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str2.slice(0, l7 - suffLen);
}
function findClosingBracket(str2, b5) {
  if (str2.indexOf(b5[1]) === -1) {
    return -1;
  }
  const l7 = str2.length;
  let level = 0, i9 = 0;
  for (; i9 < l7; i9++) {
    if (str2[i9] === "\\") {
      i9++;
    } else if (str2[i9] === b5[0]) {
      level++;
    } else if (str2[i9] === b5[1]) {
      level--;
      if (level < 0) {
        return i9;
      }
    }
  }
  return -1;
}
function checkDeprecations(opt, callback) {
  if (!opt || opt.silent) {
    return;
  }
  if (callback) {
    console.warn("marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async");
  }
  if (opt.sanitize || opt.sanitizer) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
  if (opt.highlight || opt.langPrefix !== "language-") {
    console.warn("marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.");
  }
  if (opt.mangle) {
    console.warn("marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.");
  }
  if (opt.baseUrl) {
    console.warn("marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.");
  }
  if (opt.smartypants) {
    console.warn("marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.");
  }
  if (opt.xhtml) {
    console.warn("marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.");
  }
  if (opt.headerIds || opt.headerPrefix) {
    console.warn("marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.");
  }
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape3(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer2.inlineTokens(text2)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape3(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
function smartypants(text2) {
  return text2.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text2) {
  let out = "", i9, ch;
  const l7 = text2.length;
  for (i9 = 0; i9 < l7; i9++) {
    ch = text2.charCodeAt(i9);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
function marked(src, opt, callback) {
  return markedInstance.parse(src, opt, callback);
}
var defaults, escapeTest, escapeReplace, escapeTestNoEncode, escapeReplaceNoEncode, escapeReplacements, getEscapeReplacement, unescapeTest, caret, nonWordAndColonTest, originIndependentUrl, baseUrls, justDomain, protocol, domain, noopTest, Tokenizer, block, inline, Lexer, Renderer, TextRenderer, Slugger, Parser, Hooks, Marked, markedInstance, options2, setOptions, use, walkTokens, parseInline, parser, lexer;
var init_marked_esm = __esm({
  "node_modules/marked/lib/marked.esm.js"() {
    defaults = getDefaults();
    escapeTest = /[&<>"']/;
    escapeReplace = new RegExp(escapeTest.source, "g");
    escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    getEscapeReplacement = (ch) => escapeReplacements[ch];
    unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    caret = /(^|[^\[])\^/g;
    nonWordAndColonTest = /[^\w:]/g;
    originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    baseUrls = {};
    justDomain = /^[^:]+:\/*[^/]*$/;
    protocol = /^([^:]+:)[\s\S]*$/;
    domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    noopTest = { exec: function noopTest2() {
    } };
    Tokenizer = class {
      constructor(options3) {
        this.options = options3 || defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text2 = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text2, "\n") : text2
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text2 = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
            text: text2
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text2 = cap[2].trim();
          if (/#$/.test(text2)) {
            const trimmed = rtrim(text2, "#");
            if (this.options.pedantic) {
              text2 = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text2 = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text: text2,
            tokens: this.lexer.inline(text2)
          };
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          const tokens = this.lexer.blockTokens(text2);
          this.lexer.state.top = top;
          return {
            type: "blockquote",
            raw: cap[0],
            tokens,
            text: text2
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw, istask, ischecked, indent, i9, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t8) => " ".repeat(3 * t8.length));
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
              const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
              const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
              const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
              while (src) {
                rawLine = src.split("\n", 1)[0];
                nextLine = rawLine;
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                  itemContents += "\n" + nextLine.slice(indent);
                } else {
                  if (blankLine) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= 4) {
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }
                  itemContents += "\n" + nextLine;
                }
                if (!blankLine && !nextLine.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }
            if (!list.loose) {
              if (endsWithBlankLine) {
                list.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list.raw += raw;
          }
          list.items[list.items.length - 1].raw = raw.trimRight();
          list.items[list.items.length - 1].text = itemContents.trimRight();
          list.raw = list.raw.trimRight();
          const l7 = list.items.length;
          for (i9 = 0; i9 < l7; i9++) {
            this.lexer.state.top = false;
            list.items[i9].tokens = this.lexer.blockTokens(list.items[i9].text, []);
            if (!list.loose) {
              const spacers = list.items[i9].tokens.filter((t8) => t8.type === "space");
              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t8) => /\n.*\n/.test(t8.raw));
              list.loose = hasMultipleLineBreaks;
            }
          }
          if (list.loose) {
            for (i9 = 0; i9 < l7; i9++) {
              list.items[i9].loose = true;
            }
          }
          return list;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            block: true,
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]);
            token.type = "paragraph";
            token.text = text2;
            token.tokens = this.lexer.inline(text2);
          }
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
          return {
            type: "def",
            tag,
            raw: cap[0],
            href,
            title
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1]).map((c8) => {
              return { text: c8 };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l7 = item.align.length;
            let i9, j4, k4, row;
            for (i9 = 0; i9 < l7; i9++) {
              if (/^ *-+: *$/.test(item.align[i9])) {
                item.align[i9] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i9])) {
                item.align[i9] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i9])) {
                item.align[i9] = "left";
              } else {
                item.align[i9] = null;
              }
            }
            l7 = item.rows.length;
            for (i9 = 0; i9 < l7; i9++) {
              item.rows[i9] = splitCells(item.rows[i9], item.header.length).map((c8) => {
                return { text: c8 };
              });
            }
            l7 = item.header.length;
            for (j4 = 0; j4 < l7; j4++) {
              item.header[j4].tokens = this.lexer.inline(item.header[j4].text);
            }
            l7 = item.rows.length;
            for (j4 = 0; j4 < l7; j4++) {
              row = item.rows[j4];
              for (k4 = 0; k4 < row.length; k4++) {
                row[k4].tokens = this.lexer.inline(row[k4].text);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text: text2,
            tokens: this.lexer.inline(text2)
          };
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape3(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: false,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link) {
            const text2 = cap[0].charAt(0);
            return {
              type: "text",
              raw: text2,
              text: text2
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            const raw = src.slice(0, lLength + match.index + rLength + 1);
            if (Math.min(lLength, rLength) % 2) {
              const text3 = raw.slice(1, -1);
              return {
                type: "em",
                raw,
                text: text3,
                tokens: this.lexer.inlineTokens(text3)
              };
            }
            const text2 = raw.slice(2, -2);
            return {
              type: "strong",
              raw,
              text: text2,
              tokens: this.lexer.inlineTokens(text2)
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text2 = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text2);
          const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text2 = text2.substring(1, text2.length - 1);
          }
          text2 = escape3(text2, true);
          return {
            type: "codespan",
            raw: cap[0],
            text: text2
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      }
      autolink(src, mangle2) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text2, href;
          if (cap[2] === "@") {
            text2 = escape3(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text2;
          } else {
            text2 = escape3(cap[1]);
            href = text2;
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [
              {
                type: "text",
                raw: text2,
                text: text2
              }
            ]
          };
        }
      }
      url(src, mangle2) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text2, href;
          if (cap[2] === "@") {
            text2 = escape3(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text2;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text2 = escape3(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [
              {
                type: "text",
                raw: text2,
                text: text2
              }
            ]
          };
        }
      }
      inlineText(src, smartypants2) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text2;
          if (this.lexer.state.inRawBlock) {
            text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]) : cap[0];
          } else {
            text2 = escape3(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text: text2
          };
        }
      }
    };
    block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^((?:(?!^bull ).|\n(?!\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = { ...block };
    block.gfm = {
      ...block.normal,
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    };
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = {
      ...block.normal,
      html: edit(
        `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
      ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    };
    inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
        rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^((?![*_])[\spunctuation])/
    };
    inline._punctuation = "\\p{P}$+<=>`^|~";
    inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
    inline.anyPunctuation = /\\[punct]/g;
    inline._escapes = /\\([punct])/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = { ...inline };
    inline.pedantic = {
      ...inline.normal,
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    };
    inline.gfm = {
      ...inline.normal,
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    };
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = {
      ...inline.gfm,
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    };
    Lexer = class _Lexer {
      constructor(options3) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options3 || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules2 = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules2.block = block.pedantic;
          rules2.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules2.block = block.gfm;
          if (this.options.breaks) {
            rules2.inline = inline.breaks;
          } else {
            rules2.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules2;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block,
          inline
        };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options3) {
        const lexer2 = new _Lexer(options3);
        return lexer2.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options3) {
        const lexer2 = new _Lexer(options3);
        return lexer2.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        let next2;
        while (next2 = this.inlineQueue.shift()) {
          this.inlineTokens(next2.src, next2.tokens);
        }
        return this.tokens;
      }
      /**
       * Lexing
       */
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, (_4, leading, tabs) => {
            return leading + "    ".repeat(tabs.length);
          });
        }
        let token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
    Renderer = class {
      constructor(options3) {
        this.options = options3 || defaults;
      }
      code(code, infostring, escaped2) {
        const lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped2 = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped2 ? code : escape3(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape3(lang) + '">' + (escaped2 ? code : escape3(code, true)) + "</code></pre>\n";
      }
      /**
       * @param {string} quote
       */
      blockquote(quote) {
        return `<blockquote>
${quote}</blockquote>
`;
      }
      html(html, block2) {
        return html;
      }
      /**
       * @param {string} text
       * @param {string} level
       * @param {string} raw
       * @param {any} slugger
       */
      heading(text2, level, raw, slugger) {
        if (this.options.headerIds) {
          const id = this.options.headerPrefix + slugger.slug(raw);
          return `<h${level} id="${id}">${text2}</h${level}>
`;
        }
        return `<h${level}>${text2}</h${level}>
`;
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body2, ordered, start) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body2 + "</" + type + ">\n";
      }
      /**
       * @param {string} text
       */
      listitem(text2) {
        return `<li>${text2}</li>
`;
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      /**
       * @param {string} text
       */
      paragraph(text2) {
        return `<p>${text2}</p>
`;
      }
      /**
       * @param {string} header
       * @param {string} body
       */
      table(header, body2) {
        if (body2)
          body2 = `<tbody>${body2}</tbody>`;
        return "<table>\n<thead>\n" + header + "</thead>\n" + body2 + "</table>\n";
      }
      /**
       * @param {string} content
       */
      tablerow(content) {
        return `<tr>
${content}</tr>
`;
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
        return tag + content + `</${type}>
`;
      }
      /**
       * span level renderer
       * @param {string} text
       */
      strong(text2) {
        return `<strong>${text2}</strong>`;
      }
      /**
       * @param {string} text
       */
      em(text2) {
        return `<em>${text2}</em>`;
      }
      /**
       * @param {string} text
       */
      codespan(text2) {
        return `<code>${text2}</code>`;
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      /**
       * @param {string} text
       */
      del(text2) {
        return `<del>${text2}</del>`;
      }
      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      link(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text2 + "</a>";
        return out;
      }
      /**
       * @param {string} href
       * @param {string} title
       * @param {string} text
       */
      image(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        let out = `<img src="${href}" alt="${text2}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text2) {
        return text2;
      }
    };
    TextRenderer = class {
      // no need for block level renderers
      strong(text2) {
        return text2;
      }
      em(text2) {
        return text2;
      }
      codespan(text2) {
        return text2;
      }
      del(text2) {
        return text2;
      }
      html(text2) {
        return text2;
      }
      text(text2) {
        return text2;
      }
      link(href, title, text2) {
        return "" + text2;
      }
      image(href, title, text2) {
        return "" + text2;
      }
      br() {
        return "";
      }
    };
    Slugger = class {
      constructor() {
        this.seen = {};
      }
      /**
       * @param {string} value
       */
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      /**
       * Finds the next safe (unique) slug to use
       * @param {string} originalSlug
       * @param {boolean} isDryRun
       */
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      /**
       * Convert string to unique id
       * @param {object} [options]
       * @param {boolean} [options.dryrun] Generates the next unique slug without
       * updating the internal accumulator.
       */
      slug(value, options3 = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options3.dryrun);
      }
    };
    Parser = class _Parser {
      constructor(options3) {
        this.options = options3 || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options3) {
        const parser2 = new _Parser(options3);
        return parser2.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options3) {
        const parser2 = new _Parser(options3);
        return parser2.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = "", i9, j4, k4, l22, l32, row, cell, header, body2, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        const l7 = tokens.length;
        for (i9 = 0; i9 < l7; i9++) {
          token = tokens[i9];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape2(this.parseInline(token.tokens, this.textRenderer)),
                this.slugger
              );
              continue;
            }
            case "code": {
              out += this.renderer.code(
                token.text,
                token.lang,
                token.escaped
              );
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l22 = token.header.length;
              for (j4 = 0; j4 < l22; j4++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.header[j4].tokens),
                  { header: true, align: token.align[j4] }
                );
              }
              header += this.renderer.tablerow(cell);
              body2 = "";
              l22 = token.rows.length;
              for (j4 = 0; j4 < l22; j4++) {
                row = token.rows[j4];
                cell = "";
                l32 = row.length;
                for (k4 = 0; k4 < l32; k4++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[k4].tokens),
                    { header: false, align: token.align[k4] }
                  );
                }
                body2 += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body2);
              continue;
            }
            case "blockquote": {
              body2 = this.parse(token.tokens);
              out += this.renderer.blockquote(body2);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l22 = token.items.length;
              body2 = "";
              for (j4 = 0; j4 < l22; j4++) {
                item = token.items[j4];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body2 += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body2, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text, token.block);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body2 = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i9 + 1 < l7 && tokens[i9 + 1].type === "text") {
                token = tokens[++i9];
                body2 += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body2) : body2;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i9, token, ret;
        const l7 = tokens.length;
        for (i9 = 0; i9 < l7; i9++) {
          token = tokens[i9];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
    Hooks = class {
      constructor(options3) {
        this.options = options3 || defaults;
      }
      static passThroughHooks = /* @__PURE__ */ new Set([
        "preprocess",
        "postprocess"
      ]);
      /**
       * Process markdown before marked
       */
      preprocess(markdown) {
        return markdown;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(html) {
        return html;
      }
    };
    Marked = class {
      defaults = getDefaults();
      options = this.setOptions;
      parse = this.#parseMarkdown(Lexer.lex, Parser.parse);
      parseInline = this.#parseMarkdown(Lexer.lexInline, Parser.parseInline);
      Parser = Parser;
      parser = Parser.parse;
      Renderer = Renderer;
      TextRenderer = TextRenderer;
      Lexer = Lexer;
      lexer = Lexer.lex;
      Tokenizer = Tokenizer;
      Slugger = Slugger;
      Hooks = Hooks;
      constructor(...args) {
        this.use(...args);
      }
      walkTokens(tokens, callback) {
        let values = [];
        for (const token of tokens) {
          values = values.concat(callback.call(this, token));
          switch (token.type) {
            case "table": {
              for (const cell of token.header) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
              for (const row of token.rows) {
                for (const cell of row) {
                  values = values.concat(this.walkTokens(cell.tokens, callback));
                }
              }
              break;
            }
            case "list": {
              values = values.concat(this.walkTokens(token.items, callback));
              break;
            }
            default: {
              if (this.defaults.extensions && this.defaults.extensions.childTokens && this.defaults.extensions.childTokens[token.type]) {
                this.defaults.extensions.childTokens[token.type].forEach((childTokens) => {
                  values = values.concat(this.walkTokens(token[childTokens], callback));
                });
              } else if (token.tokens) {
                values = values.concat(this.walkTokens(token.tokens, callback));
              }
            }
          }
        }
        return values;
      }
      use(...args) {
        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
        args.forEach((pack) => {
          const opts = { ...pack };
          opts.async = this.defaults.async || opts.async || false;
          if (pack.extensions) {
            pack.extensions.forEach((ext) => {
              if (!ext.name) {
                throw new Error("extension name required");
              }
              if (ext.renderer) {
                const prevRenderer = extensions.renderers[ext.name];
                if (prevRenderer) {
                  extensions.renderers[ext.name] = function(...args2) {
                    let ret = ext.renderer.apply(this, args2);
                    if (ret === false) {
                      ret = prevRenderer.apply(this, args2);
                    }
                    return ret;
                  };
                } else {
                  extensions.renderers[ext.name] = ext.renderer;
                }
              }
              if (ext.tokenizer) {
                if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                  throw new Error("extension level must be 'block' or 'inline'");
                }
                if (extensions[ext.level]) {
                  extensions[ext.level].unshift(ext.tokenizer);
                } else {
                  extensions[ext.level] = [ext.tokenizer];
                }
                if (ext.start) {
                  if (ext.level === "block") {
                    if (extensions.startBlock) {
                      extensions.startBlock.push(ext.start);
                    } else {
                      extensions.startBlock = [ext.start];
                    }
                  } else if (ext.level === "inline") {
                    if (extensions.startInline) {
                      extensions.startInline.push(ext.start);
                    } else {
                      extensions.startInline = [ext.start];
                    }
                  }
                }
              }
              if (ext.childTokens) {
                extensions.childTokens[ext.name] = ext.childTokens;
              }
            });
            opts.extensions = extensions;
          }
          if (pack.renderer) {
            const renderer = this.defaults.renderer || new Renderer(this.defaults);
            for (const prop in pack.renderer) {
              const prevRenderer = renderer[prop];
              renderer[prop] = (...args2) => {
                let ret = pack.renderer[prop].apply(renderer, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args2);
                }
                return ret;
              };
            }
            opts.renderer = renderer;
          }
          if (pack.tokenizer) {
            const tokenizer = this.defaults.tokenizer || new Tokenizer(this.defaults);
            for (const prop in pack.tokenizer) {
              const prevTokenizer = tokenizer[prop];
              tokenizer[prop] = (...args2) => {
                let ret = pack.tokenizer[prop].apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            }
            opts.tokenizer = tokenizer;
          }
          if (pack.hooks) {
            const hooks = this.defaults.hooks || new Hooks();
            for (const prop in pack.hooks) {
              const prevHook = hooks[prop];
              if (Hooks.passThroughHooks.has(prop)) {
                hooks[prop] = (arg) => {
                  if (this.defaults.async) {
                    return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                      return prevHook.call(hooks, ret2);
                    });
                  }
                  const ret = pack.hooks[prop].call(hooks, arg);
                  return prevHook.call(hooks, ret);
                };
              } else {
                hooks[prop] = (...args2) => {
                  let ret = pack.hooks[prop].apply(hooks, args2);
                  if (ret === false) {
                    ret = prevHook.apply(hooks, args2);
                  }
                  return ret;
                };
              }
            }
            opts.hooks = hooks;
          }
          if (pack.walkTokens) {
            const walkTokens2 = this.defaults.walkTokens;
            opts.walkTokens = function(token) {
              let values = [];
              values.push(pack.walkTokens.call(this, token));
              if (walkTokens2) {
                values = values.concat(walkTokens2.call(this, token));
              }
              return values;
            };
          }
          this.defaults = { ...this.defaults, ...opts };
        });
        return this;
      }
      setOptions(opt) {
        this.defaults = { ...this.defaults, ...opt };
        return this;
      }
      #parseMarkdown(lexer2, parser2) {
        return (src, opt, callback) => {
          if (typeof opt === "function") {
            callback = opt;
            opt = null;
          }
          const origOpt = { ...opt };
          opt = { ...this.defaults, ...origOpt };
          const throwError = this.#onError(opt.silent, opt.async, callback);
          if (typeof src === "undefined" || src === null) {
            return throwError(new Error("marked(): input parameter is undefined or null"));
          }
          if (typeof src !== "string") {
            return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
          }
          checkDeprecations(opt, callback);
          if (opt.hooks) {
            opt.hooks.options = opt;
          }
          if (callback) {
            const highlight = opt.highlight;
            let tokens;
            try {
              if (opt.hooks) {
                src = opt.hooks.preprocess(src);
              }
              tokens = lexer2(src, opt);
            } catch (e5) {
              return throwError(e5);
            }
            const done = (err) => {
              let out;
              if (!err) {
                try {
                  if (opt.walkTokens) {
                    this.walkTokens(tokens, opt.walkTokens);
                  }
                  out = parser2(tokens, opt);
                  if (opt.hooks) {
                    out = opt.hooks.postprocess(out);
                  }
                } catch (e5) {
                  err = e5;
                }
              }
              opt.highlight = highlight;
              return err ? throwError(err) : callback(null, out);
            };
            if (!highlight || highlight.length < 3) {
              return done();
            }
            delete opt.highlight;
            if (!tokens.length)
              return done();
            let pending = 0;
            this.walkTokens(tokens, (token) => {
              if (token.type === "code") {
                pending++;
                setTimeout(() => {
                  highlight(token.text, token.lang, (err, code) => {
                    if (err) {
                      return done(err);
                    }
                    if (code != null && code !== token.text) {
                      token.text = code;
                      token.escaped = true;
                    }
                    pending--;
                    if (pending === 0) {
                      done();
                    }
                  });
                }, 0);
              }
            });
            if (pending === 0) {
              done();
            }
            return;
          }
          if (opt.async) {
            return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
          }
          try {
            if (opt.hooks) {
              src = opt.hooks.preprocess(src);
            }
            const tokens = lexer2(src, opt);
            if (opt.walkTokens) {
              this.walkTokens(tokens, opt.walkTokens);
            }
            let html = parser2(tokens, opt);
            if (opt.hooks) {
              html = opt.hooks.postprocess(html);
            }
            return html;
          } catch (e5) {
            return throwError(e5);
          }
        };
      }
      #onError(silent, async, callback) {
        return (e5) => {
          e5.message += "\nPlease report this to https://github.com/markedjs/marked.";
          if (silent) {
            const msg = "<p>An error occurred:</p><pre>" + escape3(e5.message + "", true) + "</pre>";
            if (async) {
              return Promise.resolve(msg);
            }
            if (callback) {
              callback(null, msg);
              return;
            }
            return msg;
          }
          if (async) {
            return Promise.reject(e5);
          }
          if (callback) {
            callback(e5);
            return;
          }
          throw e5;
        };
      }
    };
    markedInstance = new Marked(defaults);
    marked.options = marked.setOptions = function(opt) {
      markedInstance.setOptions(opt);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = getDefaults;
    marked.defaults = defaults;
    marked.use = function(...args) {
      markedInstance.use(...args);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.walkTokens = function(tokens, callback) {
      return markedInstance.walkTokens(tokens, callback);
    };
    marked.parseInline = markedInstance.parseInline;
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.Hooks = Hooks;
    marked.parse = marked;
    options2 = marked.options;
    setOptions = marked.setOptions;
    use = marked.use;
    walkTokens = marked.walkTokens;
    parseInline = marked.parseInline;
    parser = Parser.parse;
    lexer = Lexer.lex;
  }
});

// .svelte-kit/output/server/chunks/SvelteMarkdown.js
function cubicOut(t8) {
  const f5 = t8 - 1;
  return f5 * f5 * f5 + 1;
}
function cn(...inputs) {
  return twMerge2(clsx(inputs));
}
function Badge($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "href", "variant", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  let href = value_or_fallback($$props["href"], void 0);
  let variant = value_or_fallback($$props["variant"], "default");
  const $$tag = href ? "a" : "span";
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if ($$tag) {
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `<${$$tag}${spread_attributes(
      [
        { "href": href },
        {
          "class": cn(badgeVariants({ variant, className }))
        },
        $$restProps
      ],
      true,
      false,
      ""
    )}>`;
    if (!VoidElements.has($$tag)) {
      $$payload.out += `${anchor_1}`;
      const anchor_2 = create_anchor($$payload);
      $$payload.out += `${anchor_2}`;
      slot($$payload, $$props.children, {}, null);
      $$payload.out += `${anchor_2}`;
      $$payload.out += `${anchor_1}</${$$tag}>`;
    }
  }
  $$payload.out += `${anchor}`;
  bind_props($$props, { class: className, href, variant });
  pop();
}
function Icon($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode",
    "$$props"
  ]);
  push(false);
  let name2 = $$props["name"];
  let color = value_or_fallback($$props["color"], "currentColor");
  let size = value_or_fallback($$props["size"], 24);
  let strokeWidth = value_or_fallback($$props["strokeWidth"], 2);
  let absoluteStrokeWidth = value_or_fallback($$props["absoluteStrokeWidth"], false);
  let iconNode = $$props["iconNode"];
  const anchor = create_anchor($$payload);
  const each_array = ensure_array_like(iconNode);
  const anchor_4 = create_anchor($$payload);
  $$payload.out += `<svg${spread_attributes(
    [
      defaultAttributes$1,
      $$restProps,
      { "width": size },
      { "height": size },
      { "stroke": color },
      {
        "stroke-width": absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth
      },
      {
        "class": `lucide-icon lucide lucide-${name2} ${$$sanitized_props.class ?? ""}`
      }
    ],
    false,
    true,
    ""
  )}>${anchor}`;
  for (let $$index = 0; $$index < each_array.length; $$index++) {
    const $$item = each_array[$$index];
    const [tag, attrs] = $$item;
    const anchor_1 = create_anchor($$payload);
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `${anchor_1}${anchor_2}`;
    if (tag) {
      const anchor_3 = create_anchor($$payload);
      $$payload.out += `<${tag}${spread_attributes([attrs], false, true, "")}>`;
      if (!VoidElements.has(tag)) {
        $$payload.out += `${anchor_3}`;
        $$payload.out += `${anchor_3}</${tag}>`;
      }
    }
    $$payload.out += `${anchor_2}${anchor_1}`;
  }
  $$payload.out += `${anchor}${anchor_4}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor_4}</svg>`;
  bind_props($$props, {
    name: name2,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode
  });
  pop();
}
function Star($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    [
      "polygon",
      {
        "points": "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"
      }
    ]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "star" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function getAttrs(builders) {
  const attrs = {};
  builders.forEach((builder2) => {
    Object.keys(builder2).forEach((key22) => {
      if (key22 !== "action") {
        attrs[key22] = builder2[key22];
      }
    });
  });
  return attrs;
}
function Button$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "href",
    "type",
    "builders",
    "el",
    "$$props"
  ]);
  push(false);
  let href = value_or_fallback($$props["href"], void 0);
  let type = value_or_fallback($$props["type"], void 0);
  let builders = value_or_fallback($$props["builders"], []);
  let el = value_or_fallback($$props["el"], void 0);
  const attrs = { "data-button-root": "" };
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (builders && builders.length) {
    $$payload.out += "<!--ssr:if:true-->";
    const $$tag = href ? "a" : "button";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    if ($$tag) {
      const anchor_2 = create_anchor($$payload);
      $$payload.out += `<${$$tag}${spread_attributes(
        [
          { "type": href ? void 0 : type },
          { "href": href },
          { "tabindex": "0" },
          getAttrs(builders),
          $$restProps,
          attrs
        ],
        true,
        false,
        ""
      )}>`;
      if (!VoidElements.has($$tag)) {
        $$payload.out += `${anchor_2}`;
        const anchor_3 = create_anchor($$payload);
        $$payload.out += `${anchor_3}`;
        slot($$payload, $$props.children, {}, null);
        $$payload.out += `${anchor_3}`;
        $$payload.out += `${anchor_2}</${$$tag}>`;
      }
    }
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const $$tag_1 = href ? "a" : "button";
    const anchor_4 = create_anchor($$payload);
    $$payload.out += `${anchor_4}`;
    if ($$tag_1) {
      const anchor_5 = create_anchor($$payload);
      $$payload.out += `<${$$tag_1}${spread_attributes(
        [
          { "type": href ? void 0 : type },
          { "href": href },
          { "tabindex": "0" },
          $$restProps,
          attrs
        ],
        true,
        false,
        ""
      )}>`;
      if (!VoidElements.has($$tag_1)) {
        $$payload.out += `${anchor_5}`;
        const anchor_6 = create_anchor($$payload);
        $$payload.out += `${anchor_6}`;
        slot($$payload, $$props.children, {}, null);
        $$payload.out += `${anchor_6}`;
        $$payload.out += `${anchor_5}</${$$tag_1}>`;
      }
    }
    $$payload.out += `${anchor_4}`;
  }
  $$payload.out += `${anchor}`;
  bind_props($$props, { href, type, builders, el });
  pop();
}
function Button($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "class",
    "variant",
    "size",
    "builders",
    "$$props"
  ]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  let variant = value_or_fallback($$props["variant"], "default");
  let size = value_or_fallback($$props["size"], "default");
  let builders = value_or_fallback($$props["builders"], []);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Button$1($$payload, spread_props([
    {
      builders,
      class: cn(buttonVariants({ variant, size, className })),
      type: "button"
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  bind_props($$props, { class: className, variant, size, builders });
  pop();
}
function supressWarnings() {
  const origWarn = console.warn;
  console.warn = (message2) => {
    if (message2.includes("unknown prop"))
      return;
    if (message2.includes("unexpected slot"))
      return;
    origWarn(message2);
  };
}
function Parser2($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "type",
    "tokens",
    "header",
    "rows",
    "ordered",
    "renderers",
    "$$props"
  ]);
  push(false);
  let type = value_or_fallback($$props["type"], void 0);
  let tokens = value_or_fallback($$props["tokens"], void 0);
  let header = value_or_fallback($$props["header"], void 0);
  let rows = value_or_fallback($$props["rows"], void 0);
  let ordered = value_or_fallback($$props["ordered"], false);
  let renderers = $$props["renderers"];
  supressWarnings();
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (!type) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    const each_array = ensure_array_like(tokens);
    $$payload.out += `${anchor_1}`;
    for (let $$index = 0; $$index < each_array.length; $$index++) {
      const token = each_array[$$index];
      const anchor_2 = create_anchor($$payload);
      const anchor_3 = create_anchor($$payload);
      $$payload.out += `${anchor_2}${anchor_3}`;
      Parser2($$payload, spread_props([token, { renderers }]));
      $$payload.out += `${anchor_3}${anchor_2}`;
    }
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_4 = create_anchor($$payload);
    $$payload.out += `${anchor_4}`;
    if (renderers[type]) {
      $$payload.out += "<!--ssr:if:true-->";
      const anchor_5 = create_anchor($$payload);
      $$payload.out += `${anchor_5}`;
      if (type === "table") {
        $$payload.out += "<!--ssr:if:true-->";
        const anchor_6 = create_anchor($$payload);
        $$payload.out += `${anchor_6}`;
        renderers.table?.($$payload, {
          children: ($$payload2, $$slotProps) => {
            const anchor_7 = create_anchor($$payload2);
            const anchor_13 = create_anchor($$payload2);
            $$payload2.out += `${anchor_7}`;
            renderers.tablehead?.($$payload2, {
              children: ($$payload3, $$slotProps2) => {
                const anchor_8 = create_anchor($$payload3);
                $$payload3.out += `${anchor_8}`;
                renderers.tablerow?.($$payload3, {
                  children: ($$payload4, $$slotProps3) => {
                    const anchor_9 = create_anchor($$payload4);
                    const each_array_1 = ensure_array_like(header);
                    $$payload4.out += `${anchor_9}`;
                    for (let i9 = 0; i9 < each_array_1.length; i9++) {
                      const headerItem = each_array_1[i9];
                      const anchor_10 = create_anchor($$payload4);
                      const anchor_11 = create_anchor($$payload4);
                      $$payload4.out += `${anchor_10}${anchor_11}`;
                      renderers.tablecell?.($$payload4, {
                        header: true,
                        align: $$restProps.align[i9] || "center",
                        children: ($$payload5, $$slotProps4) => {
                          const anchor_12 = create_anchor($$payload5);
                          $$payload5.out += `${anchor_12}`;
                          Parser2($$payload5, { tokens: headerItem.tokens, renderers });
                          $$payload5.out += `${anchor_12}`;
                        }
                      });
                      $$payload4.out += `${anchor_11}${anchor_10}`;
                    }
                    $$payload4.out += `${anchor_9}`;
                  }
                });
                $$payload3.out += `${anchor_8}`;
              }
            });
            $$payload2.out += `${anchor_7} ${anchor_13}`;
            renderers.tablebody?.($$payload2, {
              children: ($$payload3, $$slotProps2) => {
                const anchor_14 = create_anchor($$payload3);
                const each_array_2 = ensure_array_like(rows);
                $$payload3.out += `${anchor_14}`;
                for (let $$index_3 = 0; $$index_3 < each_array_2.length; $$index_3++) {
                  const row = each_array_2[$$index_3];
                  const anchor_15 = create_anchor($$payload3);
                  const anchor_16 = create_anchor($$payload3);
                  $$payload3.out += `${anchor_15}${anchor_16}`;
                  renderers.tablerow?.($$payload3, {
                    children: ($$payload4, $$slotProps3) => {
                      const anchor_17 = create_anchor($$payload4);
                      const each_array_3 = ensure_array_like(row);
                      $$payload4.out += `${anchor_17}`;
                      for (let i9 = 0; i9 < each_array_3.length; i9++) {
                        const cells = each_array_3[i9];
                        const anchor_18 = create_anchor($$payload4);
                        const anchor_19 = create_anchor($$payload4);
                        $$payload4.out += `${anchor_18}${anchor_19}`;
                        renderers.tablecell?.($$payload4, {
                          header: false,
                          align: $$restProps.align[i9] || "center",
                          children: ($$payload5, $$slotProps4) => {
                            const anchor_20 = create_anchor($$payload5);
                            $$payload5.out += `${anchor_20}`;
                            Parser2($$payload5, { tokens: cells.tokens, renderers });
                            $$payload5.out += `${anchor_20}`;
                          }
                        });
                        $$payload4.out += `${anchor_19}${anchor_18}`;
                      }
                      $$payload4.out += `${anchor_17}`;
                    }
                  });
                  $$payload3.out += `${anchor_16}${anchor_15}`;
                }
                $$payload3.out += `${anchor_14}`;
              }
            });
            $$payload2.out += `${anchor_13}`;
          }
        });
        $$payload.out += `${anchor_6}`;
      } else {
        $$payload.out += "<!--ssr:if:false-->";
        const anchor_21 = create_anchor($$payload);
        $$payload.out += `${anchor_21}`;
        if (type === "list") {
          $$payload.out += "<!--ssr:if:true-->";
          const anchor_22 = create_anchor($$payload);
          $$payload.out += `${anchor_22}`;
          if (ordered) {
            $$payload.out += "<!--ssr:if:true-->";
            const anchor_23 = create_anchor($$payload);
            $$payload.out += `${anchor_23}`;
            renderers.list?.($$payload, spread_props([
              { ordered },
              $$restProps,
              {
                children: ($$payload2, $$slotProps) => {
                  const anchor_24 = create_anchor($$payload2);
                  const each_array_4 = ensure_array_like($$restProps.items);
                  $$payload2.out += `${anchor_24}`;
                  for (let $$index_4 = 0; $$index_4 < each_array_4.length; $$index_4++) {
                    const item = each_array_4[$$index_4];
                    const anchor_25 = create_anchor($$payload2);
                    const anchor_26 = create_anchor($$payload2);
                    $$payload2.out += `${anchor_25}${anchor_26}`;
                    (renderers.orderedlistitem || renderers.listitem)?.($$payload2, spread_props([
                      item,
                      {
                        children: ($$payload3, $$slotProps2) => {
                          const anchor_27 = create_anchor($$payload3);
                          $$payload3.out += `${anchor_27}`;
                          Parser2($$payload3, { tokens: item.tokens, renderers });
                          $$payload3.out += `${anchor_27}`;
                        }
                      }
                    ]));
                    $$payload2.out += `${anchor_26}${anchor_25}`;
                  }
                  $$payload2.out += `${anchor_24}`;
                }
              }
            ]));
            $$payload.out += `${anchor_23}`;
          } else {
            $$payload.out += "<!--ssr:if:false-->";
            const anchor_28 = create_anchor($$payload);
            $$payload.out += `${anchor_28}`;
            renderers.list?.($$payload, spread_props([
              { ordered },
              $$restProps,
              {
                children: ($$payload2, $$slotProps) => {
                  const anchor_29 = create_anchor($$payload2);
                  const each_array_5 = ensure_array_like($$restProps.items);
                  $$payload2.out += `${anchor_29}`;
                  for (let $$index_5 = 0; $$index_5 < each_array_5.length; $$index_5++) {
                    const item = each_array_5[$$index_5];
                    const anchor_30 = create_anchor($$payload2);
                    const anchor_31 = create_anchor($$payload2);
                    $$payload2.out += `${anchor_30}${anchor_31}`;
                    (renderers.unorderedlistitem || renderers.listitem)?.($$payload2, spread_props([
                      item,
                      {
                        children: ($$payload3, $$slotProps2) => {
                          const anchor_32 = create_anchor($$payload3);
                          $$payload3.out += `${anchor_32}`;
                          Parser2($$payload3, { tokens: item.tokens, renderers });
                          $$payload3.out += `${anchor_32}`;
                        }
                      }
                    ]));
                    $$payload2.out += `${anchor_31}${anchor_30}`;
                  }
                  $$payload2.out += `${anchor_29}`;
                }
              }
            ]));
            $$payload.out += `${anchor_28}`;
          }
          $$payload.out += `${anchor_22}`;
        } else {
          $$payload.out += "<!--ssr:if:false-->";
          const anchor_33 = create_anchor($$payload);
          $$payload.out += `${anchor_33}`;
          renderers[type]?.($$payload, spread_props([
            $$restProps,
            {
              children: ($$payload2, $$slotProps) => {
                const anchor_34 = create_anchor($$payload2);
                $$payload2.out += `${anchor_34}`;
                if (tokens) {
                  $$payload2.out += "<!--ssr:if:true-->";
                  const anchor_35 = create_anchor($$payload2);
                  $$payload2.out += `${anchor_35}`;
                  Parser2($$payload2, { tokens, renderers });
                  $$payload2.out += `${anchor_35}`;
                } else {
                  $$payload2.out += "<!--ssr:if:false-->";
                  $$payload2.out += `${escape2($$restProps.raw)}`;
                }
                $$payload2.out += `${anchor_34}`;
              }
            }
          ]));
          $$payload.out += `${anchor_33}`;
        }
        $$payload.out += `${anchor_21}`;
      }
      $$payload.out += `${anchor_5}`;
    } else {
      $$payload.out += "<!--ssr:if:false-->";
    }
    $$payload.out += `${anchor_4}`;
  }
  $$payload.out += `${anchor}`;
  bind_props($$props, {
    type,
    tokens,
    header,
    rows,
    ordered,
    renderers
  });
  pop();
}
function Heading($$payload, $$props) {
  push(false);
  let id;
  let depth = $$props["depth"];
  let raw = $$props["raw"];
  let text2 = $$props["text"];
  const { slug, getOptions } = getContext(key2);
  const options3 = getOptions();
  id = options3.headerIds ? options3.headerPrefix + slug(text2) : void 0;
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (depth === 1) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `<h1${attr("id", id, false)}>${anchor_1}`;
    slot($$payload, $$props.children, {}, null);
    $$payload.out += `${anchor_1}</h1>`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `${anchor_2}`;
    if (depth === 2) {
      $$payload.out += "<!--ssr:if:true-->";
      const anchor_3 = create_anchor($$payload);
      $$payload.out += `<h2${attr("id", id, false)}>${anchor_3}`;
      slot($$payload, $$props.children, {}, null);
      $$payload.out += `${anchor_3}</h2>`;
    } else {
      $$payload.out += "<!--ssr:if:false-->";
      const anchor_4 = create_anchor($$payload);
      $$payload.out += `${anchor_4}`;
      if (depth === 3) {
        $$payload.out += "<!--ssr:if:true-->";
        const anchor_5 = create_anchor($$payload);
        $$payload.out += `<h3${attr("id", id, false)}>${anchor_5}`;
        slot($$payload, $$props.children, {}, null);
        $$payload.out += `${anchor_5}</h3>`;
      } else {
        $$payload.out += "<!--ssr:if:false-->";
        const anchor_6 = create_anchor($$payload);
        $$payload.out += `${anchor_6}`;
        if (depth === 4) {
          $$payload.out += "<!--ssr:if:true-->";
          const anchor_7 = create_anchor($$payload);
          $$payload.out += `<h4${attr("id", id, false)}>${anchor_7}`;
          slot($$payload, $$props.children, {}, null);
          $$payload.out += `${anchor_7}</h4>`;
        } else {
          $$payload.out += "<!--ssr:if:false-->";
          const anchor_8 = create_anchor($$payload);
          $$payload.out += `${anchor_8}`;
          if (depth === 5) {
            $$payload.out += "<!--ssr:if:true-->";
            const anchor_9 = create_anchor($$payload);
            $$payload.out += `<h5${attr("id", id, false)}>${anchor_9}`;
            slot($$payload, $$props.children, {}, null);
            $$payload.out += `${anchor_9}</h5>`;
          } else {
            $$payload.out += "<!--ssr:if:false-->";
            const anchor_10 = create_anchor($$payload);
            $$payload.out += `${anchor_10}`;
            if (depth === 6) {
              $$payload.out += "<!--ssr:if:true-->";
              const anchor_11 = create_anchor($$payload);
              $$payload.out += `<h6${attr("id", id, false)}>${anchor_11}`;
              slot($$payload, $$props.children, {}, null);
              $$payload.out += `${anchor_11}</h6>`;
            } else {
              $$payload.out += "<!--ssr:if:false-->";
              $$payload.out += `${escape2(raw)}`;
            }
            $$payload.out += `${anchor_10}`;
          }
          $$payload.out += `${anchor_8}`;
        }
        $$payload.out += `${anchor_6}`;
      }
      $$payload.out += `${anchor_4}`;
    }
    $$payload.out += `${anchor_2}`;
  }
  $$payload.out += `${anchor}`;
  bind_props($$props, { depth, raw, text: text2 });
  pop();
}
function Paragraph($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<p>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</p>`;
  pop();
}
function Text2($$payload, $$props) {
  push(false);
  let text2 = $$props["text"];
  let raw = $$props["raw"];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}`;
  bind_props($$props, { text: text2, raw });
  pop();
}
function Image($$payload, $$props) {
  push(false);
  let href = value_or_fallback($$props["href"], "");
  let title = value_or_fallback($$props["title"], void 0);
  let text2 = value_or_fallback($$props["text"], "");
  $$payload.out += `<img${attr("src", href, false)}${attr("title", title, false)}${attr("alt", text2, false)}>`;
  bind_props($$props, { href, title, text: text2 });
  pop();
}
function Link($$payload, $$props) {
  push(false);
  let href = value_or_fallback($$props["href"], "");
  let title = value_or_fallback($$props["title"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<a${attr("href", href, false)}${attr("title", title, false)}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</a>`;
  bind_props($$props, { href, title });
  pop();
}
function Em($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<em>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</em>`;
  pop();
}
function Del($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<del>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</del>`;
  pop();
}
function Codespan($$payload, $$props) {
  push(false);
  let raw = $$props["raw"];
  $$payload.out += `<code>${escape2(raw.replace(/`/g, ""))}</code>`;
  bind_props($$props, { raw });
  pop();
}
function Strong($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<strong>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</strong>`;
  pop();
}
function Table($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<table>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</table>`;
  pop();
}
function TableHead($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<thead>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</thead>`;
  pop();
}
function TableBody($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<tbody>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</tbody>`;
  pop();
}
function TableRow($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<tr>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</tr>`;
  pop();
}
function TableCell($$payload, $$props) {
  push(false);
  let header = $$props["header"];
  let align = $$props["align"];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (header) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `<th${attr("align", align, false)}>${anchor_1}`;
    slot($$payload, $$props.children, {}, null);
    $$payload.out += `${anchor_1}</th>`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `<td${attr("align", align, false)}>${anchor_2}`;
    slot($$payload, $$props.children, {}, null);
    $$payload.out += `${anchor_2}</td>`;
  }
  $$payload.out += `${anchor}`;
  bind_props($$props, { header, align });
  pop();
}
function List($$payload, $$props) {
  push(false);
  let ordered = $$props["ordered"];
  let start = $$props["start"];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (ordered) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `<ol${attr("start", start, false)}>${anchor_1}`;
    slot($$payload, $$props.children, {}, null);
    $$payload.out += `${anchor_1}</ol>`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `<ul>${anchor_2}`;
    slot($$payload, $$props.children, {}, null);
    $$payload.out += `${anchor_2}</ul>`;
  }
  $$payload.out += `${anchor}`;
  bind_props($$props, { ordered, start });
  pop();
}
function ListItem($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<li>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</li>`;
  pop();
}
function Hr($$payload, $$props) {
  push(false);
  $$payload.out += `<hr>`;
  pop();
}
function Html($$payload, $$props) {
  push(false);
  let text2 = $$props["text"];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}${text2}${anchor}`;
  bind_props($$props, { text: text2 });
  pop();
}
function Blockquote($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<blockquote>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</blockquote>`;
  pop();
}
function Code($$payload, $$props) {
  push(false);
  let lang = $$props["lang"];
  let text2 = $$props["text"];
  $$payload.out += `<pre${attr("class", lang, false)}><code>${escape2(text2)}</code></pre>`;
  bind_props($$props, { lang, text: text2 });
  pop();
}
function Br($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<br>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}`;
  pop();
}
function SvelteMarkdown($$payload, $$props) {
  push(false);
  let preprocessed, slugger, combinedOptions, combinedRenderers;
  let source2 = value_or_fallback($$props["source"], []);
  let renderers = value_or_fallback($$props["renderers"], {});
  let options3 = value_or_fallback($$props["options"], {});
  let isInline = value_or_fallback($$props["isInline"], false);
  const dispatch = createEventDispatcher();
  let tokens;
  let lexer2;
  setContext(key2, {
    slug: (val) => slugger ? slugger.slug(val) : "",
    getOptions: () => combinedOptions
  });
  preprocessed = Array.isArray(source2);
  slugger = source2 ? new Slugger() : void 0;
  combinedOptions = { ...defaultOptions, ...options3 };
  if (preprocessed) {
    tokens = source2;
  } else {
    lexer2 = new Lexer(combinedOptions);
    tokens = isInline ? lexer2.inlineTokens(source2) : lexer2.lex(source2);
    dispatch("parsed", { tokens });
  }
  combinedRenderers = { ...defaultRenderers, ...renderers };
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Parser2($$payload, { tokens, renderers: combinedRenderers });
  $$payload.out += `${anchor}`;
  bind_props($$props, { source: source2, renderers, options: options3, isInline });
  pop();
}
var flyAndScale, defaultAttributes, defaultAttributes$1, key2, defaultRenderers, defaultOptions;
var init_SvelteMarkdown = __esm({
  ".svelte-kit/output/server/chunks/SvelteMarkdown.js"() {
    init_index3();
    init_github_markdown();
    init_dist2();
    init_clsx();
    init_bundle_mjs();
    init_main_client();
    init_marked_esm();
    flyAndScale = (node, params = { y: -8, x: 0, start: 0.95, duration: 150 }) => {
      const style = getComputedStyle(node);
      const transform = style.transform === "none" ? "" : style.transform;
      const scaleConversion = (valueA, scaleA, scaleB) => {
        const [minA, maxA] = scaleA;
        const [minB, maxB] = scaleB;
        const percentage = (valueA - minA) / (maxA - minA);
        const valueB = percentage * (maxB - minB) + minB;
        return valueB;
      };
      const styleToString3 = (style2) => {
        return Object.keys(style2).reduce((str2, key22) => {
          if (style2[key22] === void 0)
            return str2;
          return str2 + `${key22}:${style2[key22]};`;
        }, "");
      };
      return {
        duration: params.duration ?? 200,
        delay: 0,
        css: (t8) => {
          const y7 = scaleConversion(t8, [0, 1], [params.y ?? 5, 0]);
          const x4 = scaleConversion(t8, [0, 1], [params.x ?? 0, 0]);
          const scale = scaleConversion(t8, [0, 1], [params.start ?? 0.95, 1]);
          return styleToString3({
            transform: `${transform} translate3d(${x4}px, ${y7}px, 0) scale(${scale})`,
            opacity: t8
          });
        },
        easing: cubicOut
      };
    };
    defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    };
    defaultAttributes$1 = defaultAttributes;
    key2 = {};
    defaultRenderers = {
      heading: Heading,
      paragraph: Paragraph,
      text: Text2,
      image: Image,
      link: Link,
      em: Em,
      strong: Strong,
      codespan: Codespan,
      del: Del,
      table: Table,
      tablehead: TableHead,
      tablebody: TableBody,
      tablerow: TableRow,
      tablecell: TableCell,
      list: List,
      orderedlistitem: null,
      unorderedlistitem: null,
      listitem: ListItem,
      hr: Hr,
      html: Html,
      blockquote: Blockquote,
      code: Code,
      br: Br
    };
    defaultOptions = {
      baseUrl: null,
      breaks: false,
      gfm: true,
      headerIds: true,
      headerPrefix: "",
      highlight: null,
      langPrefix: "language-",
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      xhtml: false
    };
  }
});

// node_modules/fauna/dist/browser/index.js
async function* Xe(t8, e5, r8) {
  let s9 = e5;
  for (s9 instanceof O && (yield s9.data); s9.after; ) {
    let n7 = qe`Set.paginate(${s9.after})`;
    s9 = (await t8.query(n7, r8)).data, yield s9.data;
  }
}
async function* wt(t8, e5, r8) {
  let s9 = await e5();
  if (s9 instanceof O || s9 instanceof q2) {
    for await (let n7 of Xe(t8, s9, r8))
      yield n7;
    return;
  }
  yield [s9];
}
async function* xt(t8) {
  for await (let e5 of t8)
    for (let r8 of e5)
      yield r8;
}
function qe(t8, ...e5) {
  return new X(t8, ...e5);
}
var Ce, Pe, i2, c, f, Ne, l2, ke, C, d, F2, P, N2, ne, M2, W, se2, k, v, j, $, w2, A, x2, _2, oe, L, J, ie2, ae, ce, I, y2, pe, ve, K, me, fe, je, ye, $e, U, G, Ae, Ie, mt, pt, ft, yt, Le, ue, gt, De, Tt, ht, Ue, Ge, Be, E, Q, D, Z2, B, ee, V, te, O, q2, R, Ve, H, Je, Ke, Ye, ze, g2, ge, X, Ze, Te, rt, et, tt, St, _t, nt, st, He, be, S, Y, h, re, de, Fe, le, Me, we, ot, xe, it, Se, at, _e, ct, Ee, ut, Qe, dt, We, he, Et;
var init_browser = __esm({
  "node_modules/fauna/dist/browser/index.js"() {
    Ce = ((t8) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(t8, { get: (e5, r8) => (typeof __require < "u" ? __require : e5)[r8] }) : t8)(function(t8) {
      if (typeof __require < "u")
        return __require.apply(this, arguments);
      throw new Error('Dynamic require of "' + t8 + '" is not supported');
    });
    Pe = (t8, e5, r8) => {
      if (!e5.has(t8))
        throw TypeError("Cannot " + r8);
    };
    i2 = (t8, e5, r8) => (Pe(t8, e5, "read from private field"), r8 ? r8.call(t8) : e5.get(t8));
    c = (t8, e5, r8) => {
      if (e5.has(t8))
        throw TypeError("Cannot add the same private member more than once");
      e5 instanceof WeakSet ? e5.add(t8) : e5.set(t8, r8);
    };
    f = (t8, e5, r8, s9) => (Pe(t8, e5, "write to private field"), s9 ? s9.call(t8, r8) : e5.set(t8, r8), r8);
    Ne = (t8, e5, r8, s9) => ({ set _(n7) {
      f(t8, e5, n7, r8);
    }, get _() {
      return i2(t8, e5, s9);
    } });
    l2 = (t8, e5, r8) => (Pe(t8, e5, "access private method"), r8);
    ke = { default: new URL("https://db.fauna.com"), local: new URL("http://localhost:8443"), localhost: new URL("http://localhost:8443") };
    C = class extends Error {
      constructor(...e5) {
        super(...e5);
      }
    };
    d = class extends C {
      httpStatus;
      code;
      queryInfo;
      constraint_failures;
      constructor(e5, r8) {
        super(e5.error.message), Error.captureStackTrace && Error.captureStackTrace(this, d), this.name = "ServiceError", this.code = e5.error.code, this.httpStatus = r8;
        let s9 = { txn_ts: e5.txn_ts, summary: e5.summary, query_tags: e5.query_tags, stats: e5.stats };
        this.queryInfo = s9, this.constraint_failures = e5.error.constraint_failures;
      }
    };
    F2 = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, F2), this.name = "QueryRuntimeError";
      }
    };
    P = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, P), this.name = "QueryCheckError";
      }
    };
    N2 = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, N2), this.name = "InvalidRequestError";
      }
    };
    ne = class extends d {
      abort;
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, P), this.name = "AbortError", this.abort = e5.error.abort;
      }
    };
    M2 = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, M2), this.name = "AuthenticationError";
      }
    };
    W = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, W), this.name = "AuthorizationError";
      }
    };
    se2 = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, N2), this.name = "ContendedTransactionError";
      }
    };
    k = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, k), this.name = "ThrottlingError";
      }
    };
    v = class extends d {
      stats;
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, v), this.name = "QueryTimeoutError", this.stats = e5.stats;
      }
    };
    j = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, j), this.name = "ServiceInternalError";
      }
    };
    $ = class extends d {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, $), this.name = "ServiceTimeoutError";
      }
    };
    w2 = class extends C {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, w2), this.name = "ClientError";
      }
    };
    A = class extends C {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, A), this.name = "ClientClosedError";
      }
    };
    x2 = class extends C {
      constructor(e5, r8) {
        super(e5, r8), Error.captureStackTrace && Error.captureStackTrace(this, x2), this.name = "NetworkError";
      }
    };
    _2 = class extends C {
      httpStatus;
      constructor(e5) {
        super(e5.message), Error.captureStackTrace && Error.captureStackTrace(this, _2), this.name = "ProtocolError", this.httpStatus = e5.httpStatus;
      }
    };
    oe = class {
      #e;
      #t;
      constructor({ url: e5, fetch_keepalive: r8 }) {
        this.#e = new URL("/query/1", e5).toString(), this.#t = r8;
      }
      async request({ data: e5, headers: r8, method: s9, client_timeout_ms: n7 }) {
        let o7 = AbortSignal.timeout === void 0 ? (() => {
          let T2 = new AbortController(), m5 = T2.signal;
          return setTimeout(() => T2.abort(), n7), m5;
        })() : AbortSignal.timeout(n7), a7 = await fetch(this.#e, { method: s9, headers: { ...r8, "Content-Type": "application/json" }, body: JSON.stringify(e5), signal: o7, keepalive: this.#t }).catch((T2) => {
          throw new x2("The network connection encountered a problem.", { cause: T2 });
        }), u6 = a7.status, p5 = {};
        a7.headers.forEach((T2, m5) => p5[m5] = T2);
        let b5 = await a7.text();
        return { status: u6, body: b5, headers: p5 };
      }
      close() {
      }
    };
    try {
      L = Ce("node:http2");
    } catch {
      L = void 0;
    }
    U = class {
      constructor({ http2_session_idle_ms: e5, url: r8, http2_max_streams: s9 }) {
        c(this, K);
        c(this, fe);
        c(this, ye);
        c(this, ie2, void 0);
        c(this, ae, void 0);
        c(this, ce, void 0);
        c(this, I, 0);
        c(this, y2, void 0);
        if (L === void 0)
          throw new Error("Your platform does not support Node's http2 library");
        f(this, ie2, e5), f(this, ae, s9), f(this, ce, r8), f(this, y2, null);
      }
      static getClient(e5) {
        var n7;
        let r8 = l2(n7 = U, pe, ve).call(n7, e5);
        i2(U, J).has(r8) || i2(U, J).set(r8, new U(e5));
        let s9 = i2(U, J).get(r8);
        return Ne(s9, I)._++, s9;
      }
      async request(e5) {
        let r8 = 0, s9;
        do
          try {
            return await l2(this, ye, $e).call(this, e5);
          } catch (n7) {
            if (n7?.code !== "ERR_HTTP2_GOAWAY_SESSION")
              throw new x2("The network connection encountered a problem.", { cause: n7 });
            s9 = n7, r8++;
          }
        while (r8 < 3);
        throw new x2("The network connection encountered a problem.", { cause: s9 });
      }
      close() {
        this.isClosed() || (Ne(this, I)._--, i2(this, I) === 0 && i2(this, y2) && !i2(this, y2).closed && i2(this, y2).close());
      }
      isClosed() {
        return i2(this, I) === 0;
      }
    };
    G = U;
    J = /* @__PURE__ */ new WeakMap(), ie2 = /* @__PURE__ */ new WeakMap(), ae = /* @__PURE__ */ new WeakMap(), ce = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap(), y2 = /* @__PURE__ */ new WeakMap(), pe = /* @__PURE__ */ new WeakSet(), ve = function({ http2_session_idle_ms: e5, url: r8 }) {
      return `${r8}|${e5}`;
    }, K = /* @__PURE__ */ new WeakSet(), me = function() {
      f(this, I, 0), i2(this, y2) && !i2(this, y2).closed && i2(this, y2).close();
    }, fe = /* @__PURE__ */ new WeakSet(), je = function() {
      if (!i2(this, y2) || i2(this, y2).closed || i2(this, y2).destroyed) {
        let e5 = L.connect(i2(this, ce), { peerMaxConcurrentStreams: i2(this, ae) }).once("error", () => l2(this, K, me).call(this)).once("goaway", () => l2(this, K, me).call(this));
        e5.setTimeout(i2(this, ie2), () => {
          l2(this, K, me).call(this);
        }), f(this, y2, e5);
      }
      return i2(this, y2);
    }, ye = /* @__PURE__ */ new WeakSet(), $e = function({ client_timeout_ms: e5, data: r8, headers: s9, method: n7 }) {
      return new Promise((o7, a7) => {
        let u6, p5 = (b5) => {
          let T2 = Number(b5[L.constants.HTTP2_HEADER_STATUS]), m5 = "";
          u6.on("data", (z3) => {
            m5 += z3;
          }), u6.on("end", () => {
            o7({ status: T2, body: m5, headers: b5 });
          });
        };
        try {
          let b5 = { ...s9, [L.constants.HTTP2_HEADER_PATH]: "/query/1", [L.constants.HTTP2_HEADER_METHOD]: n7 };
          u6 = l2(this, fe, je).call(this).request(b5).setEncoding("utf8").on("error", (m5) => {
            a7(m5);
          }).on("response", p5), u6.write(JSON.stringify(r8), "utf8"), u6.setTimeout(e5, () => {
            u6.destroy(new Error("Client timeout"));
          }), u6.end();
        } catch (b5) {
          a7(b5);
        }
      });
    }, c(G, pe), c(G, J, /* @__PURE__ */ new Map());
    Ae = (t8) => mt() ? G.getClient(t8) : new oe(t8);
    Ie = (t8) => t8 instanceof Object && "body" in t8 && "headers" in t8 && "status" in t8;
    mt = () => {
      if (typeof process < "u" && process && process.release?.name === "node")
        try {
          return Ce("node:http2"), true;
        } catch {
          return false;
        }
      return false;
    };
    pt = /(?:\d{4}|[\u2212-]\d{4,}|\+\d{5,})/;
    ft = /(?:0[1-9]|1[0-2])/;
    yt = /(?:0[1-9]|[12]\d|3[01])/;
    Le = /(?:[01][0-9]|2[0-3])/;
    ue = /(?:[0-5][0-9])/;
    gt = /(?:\.\d+)/;
    De = new RegExp(`(${pt.source}-(${ft.source})-(${yt.source}))`);
    Tt = new RegExp(`(${Le.source}:${ue.source}:${ue.source}${gt.source}?)`);
    ht = new RegExp(`([zZ]|[+\u2212-]${Le.source}(?::?${ue.source}|:${ue.source}:${ue.source}))`);
    Ue = new RegExp(`^${De.source}$`);
    Ge = new RegExp(`^${De.source}`);
    Be = new RegExp(`^${De.source}T${Tt.source}${ht.source}$`);
    E = class {
      isoString;
      constructor(e5) {
        this.isoString = e5;
      }
      static from(e5) {
        if (typeof e5 != "string")
          throw new TypeError(`Expected string but received ${typeof e5}: ${e5}`);
        if (Be.exec(e5) === null)
          throw new RangeError(`(regex) Expected an ISO date string but received '${e5}'`);
        return new E(e5);
      }
      static fromDate(e5) {
        return new E(e5.toISOString());
      }
      toDate() {
        let e5 = new Date(this.isoString);
        if (e5.toString() === "Invalid Date")
          throw new RangeError("Fauna Date could not be converted to Javascript Date");
        return e5;
      }
      toString() {
        return `TimeStub("${this.isoString}")`;
      }
    };
    Q = class {
      dateString;
      constructor(e5) {
        this.dateString = e5;
      }
      static from(e5) {
        if (typeof e5 != "string")
          throw new TypeError(`Expected string but received ${typeof e5}: ${e5}`);
        let r8 = Ue.exec(e5);
        if (r8 === null)
          throw new RangeError(`Expected a plain date string but received '${e5}'`);
        return new Q(r8[0]);
      }
      static fromDate(e5) {
        let r8 = e5.toISOString(), s9 = Ge.exec(r8);
        if (s9 === null)
          throw new w2(`Failed to parse date '${e5}'`);
        return new Q(s9[0]);
      }
      toDate() {
        let e5 = /* @__PURE__ */ new Date(this.dateString + "T00:00:00Z");
        if (e5.toString() === "Invalid Date")
          throw new RangeError("Fauna Date could not be converted to Javascript Date");
        return e5;
      }
      toString() {
        return `DateStub("${this.dateString}")`;
      }
    };
    D = class {
      coll;
      id;
      constructor({ coll: e5, id: r8 }) {
        this.id = r8, typeof e5 == "string" ? this.coll = new V(e5) : this.coll = e5;
      }
    };
    Z2 = class extends D {
      ts;
      constructor(e5) {
        let { coll: r8, id: s9, ts: n7, ...o7 } = e5;
        super({ coll: r8, id: s9 }), this.ts = n7, Object.assign(this, o7);
      }
      toObject() {
        return { ...this };
      }
    };
    B = class {
      coll;
      name;
      constructor({ coll: e5, name: r8 }) {
        this.name = r8, typeof e5 == "string" ? this.coll = new V(e5) : this.coll = e5;
      }
    };
    ee = class extends B {
      ts;
      data;
      constructor(e5) {
        let { coll: r8, name: s9, ts: n7, data: o7, ...a7 } = e5;
        super({ coll: r8, name: s9 }), this.ts = n7, this.data = o7 || {}, Object.assign(this, a7);
      }
      toObject() {
        return { ...this };
      }
    };
    V = class {
      name;
      constructor(e5) {
        this.name = e5;
      }
    };
    te = class {
      ref;
      cause;
      constructor(e5, r8) {
        this.ref = e5, this.cause = r8;
      }
    };
    O = class {
      data;
      after;
      constructor({ data: e5, after: r8 }) {
        this.data = e5, this.after = r8;
      }
    };
    q2 = class {
      after;
      constructor(e5) {
        this.after = e5;
      }
    };
    R = class {
      #e;
      constructor(e5, r8, s9) {
        if (s9 = s9 ?? {}, r8 instanceof Function)
          this.#e = wt(e5, r8, s9);
        else if (r8 instanceof O || r8 instanceof q2)
          this.#e = Xe(e5, r8, s9);
        else
          throw new TypeError(`Expected 'Page<T> | EmbeddedSet | (() => Promise<T | Page<T> | EmbeddedSet>)', but received ${JSON.stringify(r8)}`);
      }
      static fromQuery(e5, r8, s9) {
        return new R(e5, async () => (await e5.query(r8, s9)).data, s9);
      }
      static fromPageable(e5, r8, s9) {
        return new R(e5, r8, s9);
      }
      flatten() {
        return new Ve(this);
      }
      async next() {
        return this.#e.next();
      }
      async return() {
        return this.#e.return();
      }
      async throw(e5) {
        return this.#e.throw(e5);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
    };
    Ve = class {
      #e;
      constructor(e5) {
        this.#e = xt(e5);
      }
      async next() {
        return this.#e.next();
      }
      async return() {
        return this.#e.return();
      }
      async throw(e5) {
        return this.#e.throw(e5);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
    };
    H = class {
      static encode(e5) {
        return ge(e5);
      }
      static decode(e5, r8) {
        return JSON.parse(e5, (s9, n7) => {
          if (n7 == null)
            return null;
          if (n7["@mod"])
            return new V(n7["@mod"]);
          if (n7["@doc"]) {
            if (typeof n7["@doc"] == "string") {
              let [a7, u6] = n7["@doc"].split(":");
              return new D({ coll: a7, id: u6 });
            }
            let o7 = n7["@doc"];
            return o7.id ? new Z2(o7) : new ee(o7);
          } else if (n7["@ref"]) {
            let o7 = n7["@ref"], a7;
            return o7.id ? a7 = new D(o7) : a7 = new B(o7), "exists" in o7 && o7.exists === false ? new te(a7, o7.cause) : a7;
          } else {
            if (n7["@set"])
              return typeof n7["@set"] == "string" ? new q2(n7["@set"]) : new O(n7["@set"]);
            if (n7["@int"])
              return Number(n7["@int"]);
            if (n7["@long"]) {
              let o7 = BigInt(n7["@long"]);
              return r8.long_type === "number" ? ((o7 > Number.MAX_SAFE_INTEGER || o7 < Number.MIN_SAFE_INTEGER) && console.warn("Value is too large to be represented as a number. Returning as Number with loss of precision. Use long_type 'bigint' instead."), Number(o7)) : o7;
            } else {
              if (n7["@double"])
                return Number(n7["@double"]);
              if (n7["@date"])
                return Q.from(n7["@date"]);
              if (n7["@time"])
                return E.from(n7["@time"]);
              if (n7["@object"])
                return n7["@object"];
            }
          }
          return n7;
        });
      }
    };
    Je = BigInt("-9223372036854775808");
    Ke = BigInt("9223372036854775807");
    Ye = -(2 ** 31);
    ze = 2 ** 31 - 1;
    g2 = { bigint: (t8) => {
      if (t8 < Je || t8 > Ke)
        throw new RangeError("BigInt value exceeds max magnitude for a 64-bit Fauna long. Use a 'number' to represent doubles beyond that limit.");
      return t8 >= Ye && t8 <= ze ? { "@int": t8.toString() } : { "@long": t8.toString() };
    }, number: (t8) => {
      if (t8 === Number.POSITIVE_INFINITY || t8 === Number.NEGATIVE_INFINITY)
        throw new RangeError(`Cannot convert ${t8} to a Fauna type.`);
      return Number.isInteger(t8) ? t8 >= Ye && t8 <= ze ? { "@int": t8.toString() } : Number.isSafeInteger(t8) ? { "@long": t8.toString() } : { "@double": t8.toString() } : { "@double": t8.toString() };
    }, string: (t8) => t8, object: (t8) => {
      let e5 = false, r8 = {};
      for (let s9 in t8)
        s9.startsWith("@") && (e5 = true), t8[s9] !== void 0 && (r8[s9] = ge(t8[s9]));
      return e5 ? { "@object": r8 } : r8;
    }, array: (t8) => {
      let e5 = [];
      for (let r8 in t8)
        e5.push(ge(t8[r8]));
      return e5;
    }, date: (t8) => ({ "@time": t8.toISOString() }), faunadate: (t8) => ({ "@date": t8.dateString }), faunatime: (t8) => ({ "@time": t8.isoString }), module: (t8) => ({ "@mod": t8.name }), documentReference: (t8) => ({ "@ref": { id: t8.id, coll: { "@mod": t8.coll.name } } }), document: (t8) => ({ "@ref": { id: t8.id, coll: { "@mod": t8.coll.name } } }), namedDocumentReference: (t8) => ({ "@ref": { name: t8.name, coll: { "@mod": t8.coll.name } } }), namedDocument: (t8) => ({ "@ref": { name: t8.name, coll: { "@mod": t8.coll.name } } }), set: (t8) => {
      throw new w2("Page could not be encoded. Fauna does not accept encoded Set values, yet. Use Page.data and Page.after as arguments, instead.");
    } };
    ge = (t8) => {
      if (t8 === void 0)
        throw new TypeError("Passing undefined as a QueryValue is not supported");
      switch (typeof t8) {
        case "bigint":
          return g2.bigint(t8);
        case "string":
          return g2.string(t8);
        case "number":
          return g2.number(t8);
        case "boolean":
          return t8;
        case "object":
          return t8 == null ? null : Array.isArray(t8) ? g2.array(t8) : t8 instanceof Date ? g2.date(t8) : t8 instanceof Q ? g2.faunadate(t8) : t8 instanceof E ? g2.faunatime(t8) : t8 instanceof V ? g2.module(t8) : t8 instanceof Z2 ? g2.document(t8) : t8 instanceof D ? g2.documentReference(t8) : t8 instanceof ee ? g2.namedDocument(t8) : t8 instanceof B ? g2.namedDocumentReference(t8) : t8 instanceof te ? ge(t8.ref) : t8 instanceof O || t8 instanceof q2 ? g2.set(t8) : g2.object(t8);
      }
    };
    X = class {
      #e;
      #t;
      constructor(e5, ...r8) {
        if (e5.length === 0 || e5.length !== r8.length + 1)
          throw new Error("invalid query constructed");
        this.#e = e5, this.#t = r8;
      }
      toQuery(e5 = {}) {
        return { ...this.#r(e5), ...e5 };
      }
      #r(e5) {
        if (this.#e.length === 1)
          return { query: { fql: [this.#e[0]] }, arguments: {} };
        let r8 = {};
        return { query: { fql: this.#e.flatMap((n7, o7) => {
          if (o7 === this.#e.length - 1)
            return n7 === "" ? [] : [n7];
          let a7 = this.#t[o7], u6;
          if (a7 instanceof X) {
            let p5 = a7.toQuery(e5);
            u6 = p5.query, r8 = { ...r8, ...p5.arguments };
          } else
            u6 = { value: H.encode(a7) };
          return [n7, u6].filter((p5) => p5 !== "");
        }) }, arguments: r8 };
      }
    };
    Ze = "1.3.1";
    try {
      Te = Ce("node:os");
    } catch {
      Te = void 0;
    }
    rt = () => {
      let t8 = { driver: ["javascript", Ze].join("-"), env: "unknown", os: "unknown", runtime: "unknown" };
      try {
        let e5 = typeof window > "u" && typeof process < "u" && process.versions != null && process.versions.node != null, r8 = typeof window < "u" && typeof window.document < "u", s9 = typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
        e5 ? (t8.runtime = ["nodejs", process.version].join("-"), t8.env = _t(), t8.os = [Te.platform(), Te.release()].join("-")) : s9 ? (t8.runtime = et(navigator), t8.env = "Service Worker", t8.os = tt(navigator)) : r8 ? (t8.runtime = et(navigator), t8.env = "browser", t8.os = tt(navigator)) : typeof EdgeRuntime != "string" && (t8.runtime = "Vercel Edge Runtime", t8.env = "edge");
      } catch {
      }
      return Object.entries(t8).filter(([e5, r8]) => r8 !== "unknown").map((e5) => e5.join("=")).join("; ");
    };
    et = (t8) => {
      let e5 = t8.appName, r8 = "" + parseFloat(t8.appVersion), s9, n7, o7;
      return (n7 = t8.userAgent.indexOf("Opera")) != -1 ? (e5 = "Opera", r8 = t8.userAgent.substring(n7 + 6), (n7 = t8.userAgent.indexOf("Version")) != -1 && (r8 = t8.userAgent.substring(n7 + 8))) : (n7 = t8.userAgent.indexOf("MSIE")) != -1 ? (e5 = "Microsoft Internet Explorer", r8 = t8.userAgent.substring(n7 + 5)) : e5 == "Netscape" && t8.userAgent.indexOf("Trident/") != -1 ? (e5 = "Microsoft Internet Explorer", r8 = t8.userAgent.substring(n7 + 5), (n7 = t8.userAgent.indexOf("rv:")) != -1 && (r8 = t8.userAgent.substring(n7 + 3))) : (n7 = t8.userAgent.indexOf("Chrome")) != -1 ? (e5 = "Chrome", r8 = t8.userAgent.substring(n7 + 7)) : (n7 = t8.userAgent.indexOf("Safari")) != -1 ? (e5 = "Safari", r8 = t8.userAgent.substring(n7 + 7), (n7 = t8.userAgent.indexOf("Version")) != -1 && (r8 = t8.userAgent.substring(n7 + 8)), t8.userAgent.indexOf("CriOS") != -1 && (e5 = "Chrome")) : (n7 = t8.userAgent.indexOf("Firefox")) != -1 ? (e5 = "Firefox", r8 = t8.userAgent.substring(n7 + 8)) : (s9 = t8.userAgent.lastIndexOf(" ") + 1) < (n7 = t8.userAgent.lastIndexOf("/")) && (e5 = t8.userAgent.substring(s9, n7), r8 = t8.userAgent.substring(n7 + 1), e5.toLowerCase() == e5.toUpperCase() && (e5 = t8.appName)), (o7 = r8.indexOf(";")) != -1 && (r8 = r8.substring(0, o7)), (o7 = r8.indexOf(" ")) != -1 && (r8 = r8.substring(0, o7)), (o7 = r8.indexOf(")")) != -1 && (r8 = r8.substring(0, o7)), [e5, r8].join("-");
    };
    tt = (t8) => {
      let e5 = "unknown", r8 = [{ s: "Windows 10", r: /(Windows 10.0|Windows NT 10.0)/ }, { s: "Windows 8.1", r: /(Windows 8.1|Windows NT 6.3)/ }, { s: "Windows 8", r: /(Windows 8|Windows NT 6.2)/ }, { s: "Windows 7", r: /(Windows 7|Windows NT 6.1)/ }, { s: "Windows Vista", r: /Windows NT 6.0/ }, { s: "Windows Server 2003", r: /Windows NT 5.2/ }, { s: "Windows XP", r: /(Windows NT 5.1|Windows XP)/ }, { s: "Windows 2000", r: /(Windows NT 5.0|Windows 2000)/ }, { s: "Windows ME", r: /(Win 9x 4.90|Windows ME)/ }, { s: "Windows 98", r: /(Windows 98|Win98)/ }, { s: "Windows 95", r: /(Windows 95|Win95|Windows_95)/ }, { s: "Windows NT 4.0", r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ }, { s: "Windows CE", r: /Windows CE/ }, { s: "Windows 3.11", r: /Win16/ }, { s: "Android", r: /Android/ }, { s: "Open BSD", r: /OpenBSD/ }, { s: "Sun OS", r: /SunOS/ }, { s: "Chrome OS", r: /CrOS/ }, { s: "Linux", r: /(Linux|X11(?!.*CrOS))/ }, { s: "iOS", r: /(iPhone|iPad|iPod)/ }, { s: "Mac OS X", r: /Mac OS X/ }, { s: "Mac OS", r: /(Mac OS|MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ }, { s: "QNX", r: /QNX/ }, { s: "UNIX", r: /UNIX/ }, { s: "BeOS", r: /BeOS/ }, { s: "OS/2", r: /OS\/2/ }, { s: "Search Bot", r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/ }];
      for (let n7 in r8) {
        let o7 = r8[n7];
        if (o7.r.test(t8.userAgent)) {
          e5 = o7.s;
          break;
        }
      }
      let s9 = "unknown";
      if (/Windows/.test(e5)) {
        let n7 = /Windows (.*)/.exec(e5);
        n7 && (s9 = n7[1]), e5 = "Windows";
      }
      switch (e5) {
        case "Mac OS":
        case "Mac OS X":
        case "Android": {
          let n7 = /(?:Android|Mac OS|Mac OS X|MacPPC|MacIntel|Mac_PowerPC|Macintosh) ([._\d]+)/.exec(t8.userAgent);
          n7 && (s9 = n7[1]);
          break;
        }
        case "iOS": {
          let n7 = /OS (\d+)_(\d+)_?(\d+)?/.exec(t8.appVersion);
          n7 && (s9 = n7[1] + "." + n7[2] + "." + (n7[3] ?? 0));
          break;
        }
      }
      return [e5, s9].join("-");
    };
    St = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : self;
    _t = () => {
      if (!(typeof process < "u" && process && process.env && typeof process.env == "object"))
        return "unknown";
      let e5 = [{ name: "Netlify", check: function() {
        return !!process.env.NETLIFY_IMAGES_CDN_DOMAIN;
      } }, { name: "Vercel", check: function() {
        return !!process.env.VERCEL;
      } }, { name: "Heroku", check: function() {
        return !!process.env.PATH && process.env.PATH.indexOf(".heroku") !== -1;
      } }, { name: "AWS Lambda", check: function() {
        return !!process.env.AWS_LAMBDA_FUNCTION_VERSION;
      } }, { name: "GCP Cloud Functions", check: function() {
        return !!process.env._ && process.env._.indexOf("google") !== -1;
      } }, { name: "GCP Compute Instances", check: function() {
        return !!process.env.GOOGLE_CLOUD_PROJECT;
      } }, { name: "Azure Cloud Functions", check: function() {
        return !!process.env.WEBSITE_FUNCTIONS_AZUREMONITOR_CATEGORIES;
      } }, { name: "Azure Compute", check: function() {
        return !!process.env.ORYX_ENV_TYPE && !!process.env.WEBSITE_INSTANCE_ID && process.env.ORYX_ENV_TYPE === "AppService";
      } }, { name: "Mongo Stitch", check: function() {
        return typeof St?.StitchError == "function";
      } }, { name: "Render", check: function() {
        return !!process.env.RENDER_SERVICE_ID;
      } }, { name: "Begin", check: function() {
        return !!process.env.BEGIN_DATA_SCOPE_ID;
      } }].find((r8) => r8.check());
      return e5 ? e5.name : "unknown";
    };
    nt = (t8) => t8 instanceof Object && "data" in t8;
    st = (t8) => t8 instanceof Object && "error" in t8 && t8.error instanceof Object && "code" in t8.error && "message" in t8.error;
    He = { client_timeout_buffer_ms: 5e3, format: "tagged", http2_session_idle_ms: 5e3, http2_max_streams: 100, long_type: "number", fetch_keepalive: false, query_timeout_ms: 5e3, max_attempts: 3, max_backoff: 20 };
    We = class {
      constructor(e5, r8) {
        c(this, de);
        c(this, le);
        c(this, we);
        c(this, xe);
        c(this, Se);
        c(this, _e);
        c(this, Ee);
        c(this, Qe);
        c(this, S, void 0);
        c(this, Y, void 0);
        c(this, h, void 0);
        c(this, re, false);
        f(this, S, { ...He, ...e5, secret: l2(this, we, ot).call(this, e5), endpoint: l2(this, xe, it).call(this, e5) }), l2(this, Qe, dt).call(this), r8 ? f(this, Y, r8) : f(this, Y, Ae({ url: i2(this, S).endpoint.toString(), http2_session_idle_ms: i2(this, S).http2_session_idle_ms, http2_max_streams: i2(this, S).http2_max_streams, fetch_keepalive: i2(this, S).fetch_keepalive }));
      }
      get lastTxnTs() {
        return i2(this, h);
      }
      set lastTxnTs(e5) {
        e5 !== void 0 && f(this, h, i2(this, h) ? Math.max(e5, i2(this, h)) : e5);
      }
      get clientConfiguration() {
        let { ...e5 } = i2(this, S);
        return e5;
      }
      close() {
        if (i2(this, re))
          throw new A("Your client is closed. You cannot close it again.");
        i2(this, Y).close(), f(this, re, true);
      }
      paginate(e5, r8) {
        return e5 instanceof X ? R.fromQuery(this, e5, r8) : R.fromPageable(this, e5, r8);
      }
      async query(e5, r8) {
        if (i2(this, re))
          throw new A("Your client is closed. No further requests can be issued.");
        let s9 = e5.toQuery(r8).query;
        return l2(this, de, Fe).call(this, s9, r8);
      }
    };
    he = We;
    be = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), h = /* @__PURE__ */ new WeakMap(), re = /* @__PURE__ */ new WeakMap(), de = /* @__PURE__ */ new WeakSet(), Fe = async function(e5, r8, s9 = 0) {
      let n7 = this.clientConfiguration.max_backoff ?? He.max_backoff, o7 = this.clientConfiguration.max_attempts ?? He.max_attempts, a7 = Math.min(Math.random() * 2 ** s9, n7) * 1e3, u6 = (p5) => new Promise((b5) => setTimeout(b5, p5));
      return s9 += 1, l2(this, _e, ct).call(this, e5, r8, s9).catch((p5) => {
        if (p5 instanceof k && s9 < o7)
          return u6(a7).then(() => l2(this, de, Fe).call(this, e5, r8, s9));
        throw p5;
      });
    }, le = /* @__PURE__ */ new WeakSet(), Me = function(e5) {
      if (e5 instanceof w2 || e5 instanceof x2 || e5 instanceof _2 || e5 instanceof d)
        return e5;
      if (Ie(e5)) {
        if (st(e5.body)) {
          let r8 = e5.body, s9 = e5.status;
          return l2(this, Se, at).call(this, r8, s9);
        }
        return new _2({ message: `Response is in an unkown format: ${e5.body}`, httpStatus: e5.status });
      }
      return new w2("A client level error occurred. Fauna was not called.", { cause: e5 });
    }, we = /* @__PURE__ */ new WeakSet(), ot = function(e5) {
      let r8;
      typeof process < "u" && process && typeof process == "object" && process.env && typeof process.env == "object" && (r8 = process.env.FAUNA_SECRET);
      let s9 = e5?.secret ?? r8;
      if (s9 === void 0)
        throw new TypeError("You must provide a secret to the driver. Set it in an environmental variable named FAUNA_SECRET or pass it to the Client constructor.");
      return s9;
    }, xe = /* @__PURE__ */ new WeakSet(), it = function(e5) {
      if (e5 && "endpoint" in e5 && e5.endpoint === void 0)
        throw new TypeError("ClientConfiguration option endpoint must be defined.");
      let r8;
      return typeof process < "u" && process && typeof process == "object" && process.env && typeof process.env == "object" && (r8 = process.env.FAUNA_ENDPOINT ? new URL(process.env.FAUNA_ENDPOINT) : void 0), e5?.endpoint ?? r8 ?? ke.default;
    }, Se = /* @__PURE__ */ new WeakSet(), at = function(e5, r8) {
      switch (r8) {
        case 400:
          return Et.includes(e5.error.code) ? new P(e5, r8) : e5.error.code === "invalid_request" ? new N2(e5, r8) : e5.error.code === "abort" && e5.error.abort !== void 0 ? new ne(e5, r8) : new F2(e5, r8);
        case 401:
          return new M2(e5, r8);
        case 403:
          return new W(e5, r8);
        case 409:
          return new se2(e5, r8);
        case 429:
          return new k(e5, r8);
        case 440:
          return new v(e5, r8);
        case 500:
          return new j(e5, r8);
        case 503:
          return new $(e5, r8);
        default:
          return new d(e5, r8);
      }
    }, _e = /* @__PURE__ */ new WeakSet(), ct = async function(e5, r8, s9 = 0) {
      try {
        let n7 = { ...i2(this, S), ...r8 }, o7 = { Authorization: `Bearer ${n7.secret}` };
        l2(this, Ee, ut).call(this, n7, o7);
        let a7 = n7.format === "tagged", u6 = n7.arguments ? a7 ? H.encode(n7.arguments) : n7.arguments : void 0, p5 = { query: e5, arguments: u6 }, b5 = n7.query_timeout_ms + i2(this, S).client_timeout_buffer_ms, T2 = await i2(this, Y).request({ client_timeout_ms: b5, data: p5, headers: o7, method: "POST" }), m5;
        try {
          if (m5 = { ...T2, body: a7 ? H.decode(T2.body, { long_type: n7.long_type }) : JSON.parse(T2.body) }, m5.body.query_tags) {
            let Re = m5.body.query_tags.split(",").map((lt) => lt.split("="));
            m5.body.query_tags = Object.fromEntries(Re);
          }
        } catch (Re) {
          throw new _2({ message: `Error parsing response as JSON: ${Re}`, httpStatus: T2.status });
        }
        if (!nt(m5.body))
          throw l2(this, le, Me).call(this, m5);
        let z3 = m5.body.txn_ts;
        (i2(this, h) === void 0 && z3 !== void 0 || z3 !== void 0 && i2(this, h) !== void 0 && i2(this, h) < z3) && f(this, h, z3);
        let Oe2 = m5.body;
        return Oe2.stats && (Oe2.stats.attempts = s9), Oe2;
      } catch (n7) {
        throw l2(this, le, Me).call(this, n7);
      }
    }, Ee = /* @__PURE__ */ new WeakSet(), ut = function(e5, r8) {
      for (let s9 of Object.entries(e5))
        if (["format", "query_timeout_ms", "linearized", "max_contention_retries", "traceparent", "typecheck", "query_tags"].includes(s9[0])) {
          let n7, o7 = `x-${s9[0].replaceAll("_", "-")}`;
          s9[0] === "query_tags" ? n7 = Object.entries(s9[1]).map((a7) => a7.join("=")).join(",") : typeof s9[1] == "string" ? n7 = s9[1] : n7 = String(s9[1]), s9[0] === "traceparent" && (o7 = s9[0]), r8[o7] = n7;
        }
      r8["x-last-txn-ts"] === void 0 && i2(this, h) !== void 0 && (r8["x-last-txn-ts"] = i2(this, h)), r8["x-driver-env"] = i2(We, be);
    }, Qe = /* @__PURE__ */ new WeakSet(), dt = function() {
      let e5 = i2(this, S);
      if (["client_timeout_buffer_ms", "endpoint", "format", "http2_session_idle_ms", "long_type", "query_timeout_ms", "fetch_keepalive", "http2_max_streams"].forEach((s9) => {
        if (e5[s9] === void 0)
          throw new TypeError(`ClientConfiguration option '${s9}' must be defined.`);
      }), e5.http2_max_streams <= 0)
        throw new RangeError("'http2_max_streams' must be greater than zero.");
      if (e5.client_timeout_buffer_ms <= 0)
        throw new RangeError("'client_timeout_buffer_ms' must be greater than zero.");
      if (e5.query_timeout_ms <= 0)
        throw new RangeError("'query_timeout_ms' must be greater than zero.");
    }, c(he, be, rt());
    Et = ["invalid_function_definition", "invalid_identifier", "invalid_query", "invalid_syntax", "invalid_type"];
  }
});

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    webcrypto_default = crypto;
    isCryptoKey = (key3) => key3 instanceof CryptoKey;
  }
});

// node_modules/jose/dist/browser/runtime/digest.js
var init_digest = __esm({
  "node_modules/jose/dist/browser/runtime/digest.js"() {
    init_webcrypto();
  }
});

// node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i9 = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i9);
    i9 += buffer.length;
  }
  return buf;
}
var encoder3, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_digest();
    encoder3 = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// node_modules/jose/dist/browser/runtime/base64url.js
var decodeBase64, decode;
var init_base64url = __esm({
  "node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_buffer_utils();
    decodeBase64 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i9 = 0; i9 < binary.length; i9++) {
        bytes[i9] = binary.charCodeAt(i9);
      }
      return bytes;
    };
    decode = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});

// node_modules/jose/dist/browser/util/errors.js
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWSInvalid, JWTInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWSSignatureVerificationFailed;
var init_errors = __esm({
  "node_modules/jose/dist/browser/util/errors.js"() {
    JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message2) {
        super(message2);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/random.js
var random_default;
var init_random = __esm({
  "node_modules/jose/dist/browser/runtime/random.js"() {
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});

// node_modules/jose/dist/browser/lib/iv.js
var init_iv = __esm({
  "node_modules/jose/dist/browser/lib/iv.js"() {
    init_errors();
    init_random();
  }
});

// node_modules/jose/dist/browser/lib/check_iv_length.js
var init_check_iv_length = __esm({
  "node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_errors();
    init_iv();
  }
});

// node_modules/jose/dist/browser/runtime/check_cek_length.js
var init_check_cek_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/timing_safe_equal.js
var init_timing_safe_equal = __esm({
  "node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
  }
});

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name2, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name2}`);
}
function isAlgorithm(algorithm, name2) {
  return algorithm.name === name2;
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key3, usages) {
  if (usages.length && !usages.some((expected) => key3.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last2 = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last2}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key3, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key3.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key3.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key3.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key3.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key3.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key3.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key3.algorithm.name !== "Ed25519" && key3.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key3.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key3.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key3, usages);
}
var init_crypto_key = __esm({
  "node_modules/jose/dist/browser/lib/crypto_key.js"() {
  }
});

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last2 = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last2}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default = (actual, ...types2) => {
      return message("Key must be ", actual, ...types2);
    };
  }
});

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types;
var init_is_key_like = __esm({
  "node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_webcrypto();
    is_key_like_default = (key3) => {
      return isCryptoKey(key3);
    };
    types = ["CryptoKey"];
  }
});

// node_modules/jose/dist/browser/runtime/decrypt.js
var init_decrypt = __esm({
  "node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    isDisjoint = (...headers2) => {
      const sources = headers2.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "node_modules/jose/dist/browser/lib/is_object.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/bogus.js
var init_bogus = __esm({
  "node_modules/jose/dist/browser/runtime/bogus.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/aeskw.js
var init_aeskw = __esm({
  "node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/runtime/ecdhes.js
var init_ecdhes = __esm({
  "node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/lib/check_p2s.js
var init_check_p2s = __esm({
  "node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/pbes2kw.js
var init_pbes2kw = __esm({
  "node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/runtime/subtle_rsaes.js
var init_subtle_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    check_key_length_default = (alg, key3) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key3.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/rsaes.js
var init_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/lib/cek.js
var init_cek = __esm({
  "node_modules/jose/dist/browser/lib/cek.js"() {
    init_errors();
    init_random();
  }
});

// node_modules/jose/dist/browser/lib/format_pem.js
var init_format_pem = __esm({
  "node_modules/jose/dist/browser/lib/format_pem.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/asn1.js
var init_asn1 = __esm({
  "node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse3, jwk_to_key_default;
var init_jwk_to_key = __esm({
  "node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_webcrypto();
    init_errors();
    parse3 = async (jwk) => {
      if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        jwk.ext ?? false,
        jwk.key_ops ?? keyUsages
      ];
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    };
    jwk_to_key_default = parse3;
  }
});

// node_modules/jose/dist/browser/key/import.js
async function importJWK(jwk, alg) {
  if (!isObject2(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm({
  "node_modules/jose/dist/browser/key/import.js"() {
    init_base64url();
    init_asn1();
    init_jwk_to_key();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck, asymmetricTypeCheck, checkKeyType, check_key_type_default;
var init_check_key_type = __esm({
  "node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = (alg, key3) => {
      if (key3 instanceof Uint8Array)
        return;
      if (!is_key_like_default(key3)) {
        throw new TypeError(withAlg(alg, key3, ...types, "Uint8Array"));
      }
      if (key3.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key3, usage) => {
      if (!is_key_like_default(key3)) {
        throw new TypeError(withAlg(alg, key3, ...types));
      }
      if (key3.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key3.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key3.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key3.algorithm && usage === "verify" && key3.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key3.algorithm && usage === "encrypt" && key3.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    checkKeyType = (alg, key3, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key3);
      } else {
        asymmetricTypeCheck(alg, key3, usage);
      }
    };
    check_key_type_default = checkKeyType;
  }
});

// node_modules/jose/dist/browser/runtime/encrypt.js
var init_encrypt = __esm({
  "node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_errors();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/lib/aesgcmkw.js
var init_aesgcmkw = __esm({
  "node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_encrypt();
    init_decrypt();
    init_iv();
    init_base64url();
  }
});

// node_modules/jose/dist/browser/lib/decrypt_key_management.js
var init_decrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
  }
});

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_errors();
    validate_crit_default = validateCrit;
  }
});

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms, validate_algorithms_default;
var init_validate_algorithms = __esm({
  "node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s9) => typeof s9 !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    validate_algorithms_default = validateAlgorithms;
  }
});

// node_modules/jose/dist/browser/jwe/flattened/decrypt.js
var init_decrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_base64url();
    init_decrypt();
    init_errors();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jwe/compact/decrypt.js
var init_decrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jwe/general/decrypt.js
var init_decrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/runtime/key_to_jwk.js
var init_key_to_jwk = __esm({
  "node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/key/export.js
var init_export = __esm({
  "node_modules/jose/dist/browser/key/export.js"() {
    init_asn1();
    init_asn1();
    init_key_to_jwk();
  }
});

// node_modules/jose/dist/browser/lib/encrypt_key_management.js
var init_encrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
  }
});

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected;
var init_encrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_base64url();
    init_encrypt();
    init_iv();
    init_encrypt_key_management();
    init_errors();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
  }
});

// node_modules/jose/dist/browser/jwe/general/encrypt.js
var init_encrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_encrypt2();
    init_errors();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
  }
});

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key3, usage) {
  if (isCryptoKey(key3)) {
    checkSigCryptoKey(key3, alg, usage);
    return key3;
  }
  if (key3 instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key3, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key3, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key3, ...types, "Uint8Array"));
}
var init_get_sign_verify_key = __esm({
  "node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/runtime/verify.js
var verify, verify_default;
var init_verify = __esm({
  "node_modules/jose/dist/browser/runtime/verify.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify = async (alg, key3, signature, data) => {
      const cryptoKey = await getCryptoKey(alg, key3, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch {
        return false;
      }
    };
    verify_default = verify;
  }
});

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key3, options3) {
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options3?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options3 && validate_algorithms_default("algorithms", options3.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key3 === "function") {
    key3 = await key3(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key3, "verify");
  const data = concat(encoder3.encode(jws.protected ?? ""), encoder3.encode("."), typeof jws.payload === "string" ? encoder3.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key3, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder3.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key: key3 };
  }
  return result;
}
var init_verify2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key3, options3) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key3, options3);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key3 === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_verify2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jws/general/verify.js
var init_verify4 = __esm({
  "node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_verify2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "node_modules/jose/dist/browser/lib/epoch.js"() {
    epoch_default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "node_modules/jose/dist/browser/lib/secs.js"() {
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
    secs_default = (str2) => {
      const matched = REGEX.exec(str2);
      if (!matched || matched[4] && matched[1]) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[2]);
      const unit = matched[3].toLowerCase();
      let numericDate;
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          numericDate = Math.round(value);
          break;
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          numericDate = Math.round(value * minute);
          break;
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          numericDate = Math.round(value * hour);
          break;
        case "day":
        case "days":
        case "d":
          numericDate = Math.round(value * day);
          break;
        case "week":
        case "weeks":
        case "w":
          numericDate = Math.round(value * week);
          break;
        default:
          numericDate = Math.round(value * year);
          break;
      }
      if (matched[1] === "-" || matched[4] === "ago") {
        return -numericDate;
      }
      return numericDate;
    };
  }
});

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp, checkAudiencePresence, jwt_claims_set_default;
var init_jwt_claims_set = __esm({
  "node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_errors();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    jwt_claims_set_default = (protectedHeader, encodedPayload, options3 = {}) => {
      const { typ } = options3;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder.decode(encodedPayload));
      } catch {
      }
      if (!isObject2(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options3;
      const presenceCheck = [...requiredClaims];
      if (maxTokenAge !== void 0)
        presenceCheck.push("iat");
      if (audience !== void 0)
        presenceCheck.push("aud");
      if (subject !== void 0)
        presenceCheck.push("sub");
      if (issuer !== void 0)
        presenceCheck.push("iss");
      for (const claim of new Set(presenceCheck.reverse())) {
        if (!(claim in payload)) {
          throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
        }
      }
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options3.clockTolerance) {
        case "string":
          tolerance = secs_default(options3.clockTolerance);
          break;
        case "number":
          tolerance = options3.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options3;
      const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key3, options3) {
  const verified = await compactVerify(jwt, key3, options3);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options3);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key3 === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify5 = __esm({
  "node_modules/jose/dist/browser/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwt/decrypt.js
var init_decrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_decrypt3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwe/compact/encrypt.js
var init_encrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_encrypt2();
  }
});

// node_modules/jose/dist/browser/runtime/sign.js
var init_sign = __esm({
  "node_modules/jose/dist/browser/runtime/sign.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
  }
});

// node_modules/jose/dist/browser/jws/flattened/sign.js
var init_sign2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
  }
});

// node_modules/jose/dist/browser/jws/compact/sign.js
var init_sign3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_sign2();
  }
});

// node_modules/jose/dist/browser/jws/general/sign.js
var init_sign4 = __esm({
  "node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_sign2();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwt/produce.js
var init_produce = __esm({
  "node_modules/jose/dist/browser/jwt/produce.js"() {
    init_epoch();
    init_is_object();
    init_secs();
  }
});

// node_modules/jose/dist/browser/jwt/sign.js
var init_sign5 = __esm({
  "node_modules/jose/dist/browser/jwt/sign.js"() {
    init_sign3();
    init_errors();
    init_buffer_utils();
    init_produce();
  }
});

// node_modules/jose/dist/browser/jwt/encrypt.js
var init_encrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_encrypt4();
    init_buffer_utils();
    init_produce();
  }
});

// node_modules/jose/dist/browser/jwk/thumbprint.js
var init_thumbprint = __esm({
  "node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_digest();
    init_base64url();
    init_errors();
    init_buffer_utils();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/jwk/embedded.js
var init_embedded = __esm({
  "node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_import();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key3) {
  return isObject2(key3);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key3 = await importJWK({ ...jwk, ext: true }, alg);
    if (key3 instanceof Uint8Array || key3.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key3;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set2 = new LocalJWKSet(jwks);
  return async (protectedHeader, token) => set2.getKey(protectedHeader, token);
}
var LocalJWKSet;
var init_local = __esm({
  "node_modules/jose/dist/browser/jwks/local.js"() {
    init_import();
    init_errors();
    init_is_object();
    LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token?.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        }
        if (length !== 1) {
          const error2 = new JWKSMultipleMatchingKeys();
          const { _cached } = this;
          error2[Symbol.asyncIterator] = async function* () {
            for (const jwk2 of candidates) {
              try {
                yield await importWithAlgCache(_cached, jwk2, alg);
              } catch {
              }
            }
          };
          throw error2;
        }
        return importWithAlgCache(this._cached, jwk, alg);
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/fetch_jwks.js
var init_fetch_jwks = __esm({
  "node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwks/remote.js
var USER_AGENT;
var init_remote = __esm({
  "node_modules/jose/dist/browser/jwks/remote.js"() {
    init_fetch_jwks();
    init_errors();
    init_local();
    if (typeof navigator === "undefined" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) {
      const NAME2 = "jose";
      const VERSION2 = "v5.2.1";
      USER_AGENT = `${NAME2}/${VERSION2}`;
    }
  }
});

// node_modules/jose/dist/browser/jwt/unsecured.js
var init_unsecured = __esm({
  "node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_base64url();
    init_buffer_utils();
    init_errors();
    init_jwt_claims_set();
    init_produce();
  }
});

// node_modules/jose/dist/browser/util/base64url.js
var init_base64url2 = __esm({
  "node_modules/jose/dist/browser/util/base64url.js"() {
    init_base64url();
  }
});

// node_modules/jose/dist/browser/util/decode_protected_header.js
var init_decode_protected_header = __esm({
  "node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/util/decode_jwt.js
var init_decode_jwt = __esm({
  "node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/generate.js
var init_generate = __esm({
  "node_modules/jose/dist/browser/runtime/generate.js"() {
    init_webcrypto();
    init_errors();
    init_random();
  }
});

// node_modules/jose/dist/browser/key/generate_key_pair.js
var init_generate_key_pair = __esm({
  "node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/key/generate_secret.js
var init_generate_secret = __esm({
  "node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/runtime/runtime.js
var init_runtime = __esm({
  "node_modules/jose/dist/browser/runtime/runtime.js"() {
  }
});

// node_modules/jose/dist/browser/util/runtime.js
var init_runtime2 = __esm({
  "node_modules/jose/dist/browser/util/runtime.js"() {
    init_runtime();
  }
});

// node_modules/jose/dist/browser/index.js
var init_browser2 = __esm({
  "node_modules/jose/dist/browser/index.js"() {
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
    init_runtime2();
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn2(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error2(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn2("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a7) {
          return isArrayImpl(a7);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x4) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty2.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty2.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key3, ref, self2, source2, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key: key3,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source2
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement5(type, config, children) {
          var propName;
          var props = {};
          var key3 = null;
          var ref = null;
          var self2 = null;
          var source2 = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key3 = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source2 = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i9 = 0; i9 < childrenLength; i9++) {
              childArray[i9] = arguments[i9 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key3 || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key3) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key3, ref, self2, source2, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement2(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key3 = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source2 = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key3 = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i9 = 0; i9 < childrenLength; i9++) {
              childArray[i9] = arguments[i9 + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key3, ref, self2, source2, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape5(key3) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key3.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text2) {
          return text2.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index7) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape5("" + element.key);
          }
          return index7.toString(36);
        }
        function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c8) {
                return c8;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array2.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i9 = 0; i9 < children.length; i9++) {
              child = children[i9];
              nextName = nextNamePrefix + getElementKey(child, i9);
              subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n7 = 0;
          mapChildren(children, function() {
            n7++;
          });
          return n7;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext4(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error3) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error3;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef2(render2) {
          {
            if (render2 != null && render2.$$typeof === REACT_MEMO_TYPE) {
              error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render2 !== "function") {
              error2("forwardRef requires a render function but was given %s.", render2 === null ? "null" : typeof render2);
            } else {
              if (render2.length !== 0 && render2.length !== 2) {
                error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render2.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render2 != null) {
              if (render2.defaultProps != null || render2.propTypes != null) {
                error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render2
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!render2.name && !render2.displayName) {
                  render2.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo3(type, compare) {
          {
            if (!isValidElementType(type)) {
              error2("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!type.name && !type.displayName) {
                  type.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext6(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState4(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init3) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init3);
        }
        function useRef4(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect4(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create4, deps);
        }
        function useInsertionEffect(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create4, deps);
        }
        function useLayoutEffect(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create4, deps);
        }
        function useCallback3(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo3(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create4, deps);
        }
        function useImperativeHandle(ref, create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create4, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source2, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x4) {
                var match = x4.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x4) {
                  control = x4;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x4) {
                  control = x4;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x4) {
                control = x4;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s9 = sampleLines.length - 1;
              var c8 = controlLines.length - 1;
              while (s9 >= 1 && c8 >= 0 && sampleLines[s9] !== controlLines[c8]) {
                c8--;
              }
              for (; s9 >= 1 && c8 >= 0; s9--, c8--) {
                if (sampleLines[s9] !== controlLines[c8]) {
                  if (s9 !== 1 || c8 !== 1) {
                    do {
                      s9--;
                      c8--;
                      if (c8 < 0 || sampleLines[s9] !== controlLines[c8]) {
                        var _frame = "\n" + sampleLines[s9].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s9 >= 1 && c8 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source2, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source2, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source2, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source2, ownerFn);
                } catch (x4) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source2) {
          if (source2 !== void 0) {
            var fileName = source2.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source2.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i9 = 0; i9 < node.length; i9++) {
              var child = node[i9];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i9 = 0; i9 < keys.length; i9++) {
              var key3 = keys[i9];
              if (key3 !== "children" && key3 !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key3);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error2("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement5.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i9 = 2; i9 < arguments.length; i9++) {
              validateChildKeys(arguments[i9], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn2("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement2.apply(this, arguments);
          for (var i9 = 2; i9 < arguments.length; i9++) {
            validateChildKeys(arguments[i9], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options3) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error3) {
              popActScope(prevActScopeDepth);
              throw error3;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve2, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve2, reject);
                    } else {
                      resolve2(returnValue2);
                    }
                  }, function(error3) {
                    popActScope(prevActScopeDepth);
                    reject(error3);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve2, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                    } else {
                      resolve2(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve2, reject) {
                    resolve2(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve2, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve2(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                  }
                });
              } catch (error3) {
                reject(error3);
              }
            } else {
              resolve2(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i9 = 0;
              try {
                for (; i9 < queue.length; i9++) {
                  var callback = queue[i9];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error3) {
                queue = queue.slice(i9 + 1);
                throw error3;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext4;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef2;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo3;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback3;
        exports.useContext = useContext6;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect4;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo3;
        exports.useReducer = useReducer;
        exports.useRef = useRef4;
        exports.useState = useState4;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push2(heap2, node) {
          var index7 = heap2.length;
          heap2.push(node);
          siftUp(heap2, node, index7);
        }
        function peek(heap2) {
          return heap2.length === 0 ? null : heap2[0];
        }
        function pop2(heap2) {
          if (heap2.length === 0) {
            return null;
          }
          var first = heap2[0];
          var last2 = heap2.pop();
          if (last2 !== first) {
            heap2[0] = last2;
            siftDown(heap2, last2, 0);
          }
          return first;
        }
        function siftUp(heap2, node, i9) {
          var index7 = i9;
          while (index7 > 0) {
            var parentIndex = index7 - 1 >>> 1;
            var parent = heap2[parentIndex];
            if (compare(parent, node) > 0) {
              heap2[parentIndex] = node;
              heap2[index7] = parent;
              index7 = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap2, node, i9) {
          var index7 = i9;
          var length = heap2.length;
          var halfLength = length >>> 1;
          while (index7 < halfLength) {
            var leftIndex = (index7 + 1) * 2 - 1;
            var left = heap2[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap2[rightIndex];
            if (compare(left, node) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap2[index7] = right;
                heap2[rightIndex] = node;
                index7 = rightIndex;
              } else {
                heap2[index7] = left;
                heap2[leftIndex] = node;
                index7 = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node) < 0) {
              heap2[index7] = right;
              heap2[rightIndex] = node;
              index7 = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a7, b5) {
          var diff = a7.sortIndex - b5.sortIndex;
          return diff !== 0 ? diff : a7.id - b5.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop2(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop2(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push2(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error2) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error2;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop2(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop2(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options3) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options3 === "object" && options3 !== null) {
            var delay3 = options3.delay;
            if (typeof delay3 === "number" && delay3 > 0) {
              startTime2 = currentTime + delay3;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push2(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push2(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React2 = require_react();
        var Scheduler = require_scheduler();
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
          {
            suppressWarning = newSuppressWarning;
          }
        }
        function warn2(format) {
          {
            if (!suppressWarning) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error2(format) {
          {
            if (!suppressWarning) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = false;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = /* @__PURE__ */ new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i9 = 0; i9 < dependencies.length; i9++) {
            allNativeEvents.add(dependencies[i9]);
          }
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkPropStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkFormFieldValueStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name2.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name2) {
          return properties.hasOwnProperty(name2) ? properties[name2] : null;
        }
        function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name2;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            RESERVED,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name2 = _ref[0], attributeName = _ref[1];
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            true,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            NUMERIC,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize2 = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize2);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize2);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize2);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        function getValueForProperty(node, name2, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node[propertyName];
            } else {
              {
                checkAttributeStringCoercion(expected, name2);
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                  var value = node.getAttribute(attributeName);
                  if (value === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                    return value;
                  }
                  if (value === "" + expected) {
                    return expected;
                  }
                  return value;
                }
              } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return node.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node, name2, expected, isCustomComponentTag) {
          {
            if (!isAttributeNameSafe(name2)) {
              return;
            }
            if (!node.hasAttribute(name2)) {
              return expected === void 0 ? void 0 : null;
            }
            var value = node.getAttribute(name2);
            {
              checkAttributeStringCoercion(expected, name2);
            }
            if (value === "" + expected) {
              return expected;
            }
            return value;
          }
        }
        function setValueForProperty(node, name2, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name2);
          if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag)) {
            value = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name2)) {
              var _attributeName = name2;
              if (value === null) {
                node.removeAttribute(_attributeName);
              } else {
                {
                  checkAttributeStringCoercion(value, name2);
                }
                node.setAttribute(_attributeName, "" + value);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type = propertyInfo.type;
              node[propertyName] = type === BOOLEAN ? false : "";
            } else {
              node[propertyName] = value;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null) {
            node.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
              attributeValue = "";
            } else {
              {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                attributeValue = "" + value;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source2, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x4) {
                var match = x4.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x4) {
                  control = x4;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x4) {
                  control = x4;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x4) {
                control = x4;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s9 = sampleLines.length - 1;
              var c8 = controlLines.length - 1;
              while (s9 >= 1 && c8 >= 0 && sampleLines[s9] !== controlLines[c8]) {
                c8--;
              }
              for (; s9 >= 1 && c8 >= 0; s9--, c8--) {
                if (sampleLines[s9] !== controlLines[c8]) {
                  if (s9 !== 1 || c8 !== 1) {
                    do {
                      s9--;
                      c8--;
                      if (c8 < 0 || sampleLines[s9] !== controlLines[c8]) {
                        var _frame = "\n" + sampleLines[s9].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s9 >= 1 && c8 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source2, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source2, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source2, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source2, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source2, ownerFn);
                } catch (x4) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source2 = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
              return describeFunctionComponentFrame(fiber.type.render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node = workInProgress2;
            do {
              info += describeFiber(node);
              node = node.return;
            } while (node);
            return info;
          } catch (x4) {
            return "\nError generating stack: " + x4.message + "\n" + x4.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x4) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromFiber(fiber) {
          var tag = fiber.tag, type = fiber.type;
          switch (tag) {
            case CacheComponent:
              return "Cache";
            case ContextConsumer:
              var context = type;
              return getContextName$1(context) + ".Consumer";
            case ContextProvider:
              var provider = type;
              return getContextName$1(provider._context) + ".Provider";
            case DehydratedFragment:
              return "DehydratedFragment";
            case ForwardRef:
              return getWrappedName$1(type, type.render, "ForwardRef");
            case Fragment:
              return "Fragment";
            case HostComponent:
              return type;
            case HostPortal:
              return "Portal";
            case HostRoot:
              return "Root";
            case HostText:
              return "Text";
            case LazyComponent:
              return getComponentNameFromType(type);
            case Mode:
              if (type === REACT_STRICT_MODE_TYPE) {
                return "StrictMode";
              }
              return "Mode";
            case OffscreenComponent:
              return "Offscreen";
            case Profiler:
              return "Profiler";
            case ScopeComponent:
              return "Scope";
            case SuspenseComponent:
              return "Suspense";
            case SuspenseListComponent:
              return "SuspenseList";
            case TracingMarkerComponent:
              return "TracingMarker";
            case ClassComponent:
            case FunctionComponent:
            case IncompleteClassComponent:
            case IndeterminateComponent:
            case MemoComponent:
            case SimpleMemoComponent:
              if (typeof type === "function") {
                return type.displayName || type.name || null;
              }
              if (typeof type === "string") {
                return type;
              }
              break;
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current === null) {
              return null;
            }
            var owner = current._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentNameFromFiber(owner);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
            current = fiber;
            isRendering = false;
          }
        }
        function getCurrentFiber() {
          {
            return current;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function toString2(value) {
          return "" + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              {
                checkFormFieldValueStringCoercion(value);
              }
              return value;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
        }
        function getTracker(node) {
          return node._valueTracker;
        }
        function detachTracker(node) {
          node._valueTracker = null;
        }
        function getValueFromNode(node) {
          var value = "";
          if (!node) {
            return value;
          }
          if (isCheckable(node)) {
            value = node.checked ? "true" : "false";
          } else {
            value = node.value;
          }
          return value;
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
          {
            checkFormFieldValueStringCoercion(node[valueField]);
          }
          var currentValue = "" + node[valueField];
          if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get5 = descriptor.get, set3 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get5.call(this);
            },
            set: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
              set3.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node);
              delete node[valueField];
            }
          };
          return tracker;
        }
        function track(node) {
          if (getTracker(node)) {
            return;
          }
          node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
          if (!node) {
            return false;
          }
          var tracker = getTracker(node);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement(doc) {
          doc = doc || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc === "undefined") {
            return null;
          }
          try {
            return doc.activeElement || doc.body;
          } catch (e5) {
            return doc.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props) {
          var usesChecked = props.type === "checkbox" || props.type === "radio";
          return usesChecked ? props.checked != null : props.value != null;
        }
        function getHostProps(element, props) {
          var node = element;
          var checked = props.checked;
          var hostProps = assign({}, props, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked != null ? checked : node._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element, props) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node = element;
          var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
          node._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
            controlled: isControlled(props)
          };
        }
        function updateChecked(element, props) {
          var node = element;
          var checked = props.checked;
          if (checked != null) {
            setValueForProperty(node, "checked", checked, false);
          }
        }
        function updateWrapper(element, props) {
          var node = element;
          {
            var controlled = isControlled(props);
            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element, props);
          var value = getToStringValue(props.value);
          var type = props.type;
          if (value != null) {
            if (type === "number") {
              if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
              // eslint-disable-next-line
              node.value != value) {
                node.value = toString2(value);
              }
            } else if (node.value !== toString2(value)) {
              node.value = toString2(value);
            }
          } else if (type === "submit" || type === "reset") {
            node.removeAttribute("value");
            return;
          }
          {
            if (props.hasOwnProperty("value")) {
              setDefaultValue(node, props.type, value);
            } else if (props.hasOwnProperty("defaultValue")) {
              setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
            }
          }
          {
            if (props.checked == null && props.defaultChecked != null) {
              node.defaultChecked = !!props.defaultChecked;
            }
          }
        }
        function postMountWrapper(element, props, isHydrating2) {
          var node = element;
          if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
            var type = props.type;
            var isButton = type === "submit" || type === "reset";
            if (isButton && (props.value === void 0 || props.value === null)) {
              return;
            }
            var initialValue = toString2(node._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node.value) {
                  node.value = initialValue;
                }
              }
            }
            {
              node.defaultValue = initialValue;
            }
          }
          var name2 = node.name;
          if (name2 !== "") {
            node.name = "";
          }
          {
            node.defaultChecked = !node.defaultChecked;
            node.defaultChecked = !!node._wrapperState.initialChecked;
          }
          if (name2 !== "") {
            node.name = name2;
          }
        }
        function restoreControlledState(element, props) {
          var node = element;
          updateWrapper(node, props);
          updateNamedCousins(node, props);
        }
        function updateNamedCousins(rootNode, props) {
          var name2 = props.name;
          if (props.type === "radio" && name2 != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            {
              checkAttributeStringCoercion(name2, "name");
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
            for (var i9 = 0; i9 < group.length; i9++) {
              var otherNode = group[i9];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node, type, value) {
          if (
            // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
            type !== "number" || getActiveElement(node.ownerDocument) !== node
          ) {
            if (value == null) {
              node.defaultValue = toString2(node._wrapperState.initialValue);
            } else if (node.defaultValue !== toString2(value)) {
              node.defaultValue = toString2(value);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element, props) {
          {
            if (props.value == null) {
              if (typeof props.children === "object" && props.children !== null) {
                React2.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                  }
                });
              } else if (props.dangerouslySetInnerHTML != null) {
                if (!didWarnInvalidInnerHTML) {
                  didWarnInvalidInnerHTML = true;
                  error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            if (props.selected != null && !didWarnSelectedSetOnOption) {
              error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element, props) {
          if (props.value != null) {
            element.setAttribute("value", toString2(getToStringValue(props.value)));
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a7) {
          return isArrayImpl(a7);
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props) {
          {
            checkControlledValueProps("select", props);
            for (var i9 = 0; i9 < valuePropNames.length; i9++) {
              var propName = valuePropNames[i9];
              if (props[propName] == null) {
                continue;
              }
              var propNameIsArray = isArray(props[propName]);
              if (props.multiple && !propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props.multiple && propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          var options4 = node.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i9 = 0; i9 < selectedValues.length; i9++) {
              selectedValue["$" + selectedValues[i9]] = true;
            }
            for (var _i = 0; _i < options4.length; _i++) {
              var selected = selectedValue.hasOwnProperty("$" + options4[_i].value);
              if (options4[_i].selected !== selected) {
                options4[_i].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options4[_i].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString2(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i2 = 0; _i2 < options4.length; _i2++) {
              if (options4[_i2].value === _selectedValue) {
                options4[_i2].selected = true;
                if (setDefaultSelected) {
                  options4[_i2].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options4[_i2].disabled) {
                defaultSelected = options4[_i2];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$1(element, props) {
          return assign({}, props, {
            value: void 0
          });
        }
        function initWrapperState$1(element, props) {
          var node = element;
          {
            checkSelectPropTypes(props);
          }
          node._wrapperState = {
            wasMultiple: !!props.multiple
          };
          {
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element, props) {
          var node = element;
          node.multiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          } else if (props.defaultValue != null) {
            updateOptions(node, !!props.multiple, props.defaultValue, true);
          }
        }
        function postUpdateWrapper(element, props) {
          var node = element;
          var wasMultiple = node._wrapperState.wasMultiple;
          node._wrapperState.wasMultiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          } else if (wasMultiple !== !!props.multiple) {
            if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            } else {
              updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element, props) {
          var node = element;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element, props) {
          var node = element;
          if (props.dangerouslySetInnerHTML != null) {
            throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          }
          var hostProps = assign({}, props, {
            value: void 0,
            defaultValue: void 0,
            children: toString2(node._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element, props) {
          var node = element;
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props.value;
          if (initialValue == null) {
            var children = props.children, defaultValue = props.defaultValue;
            if (children != null) {
              {
                error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (defaultValue != null) {
                  throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                }
                if (isArray(children)) {
                  if (children.length > 1) {
                    throw new Error("<textarea> can only have at most one child.");
                  }
                  children = children[0];
                }
                defaultValue = children;
              }
            }
            if (defaultValue == null) {
              defaultValue = "";
            }
            initialValue = defaultValue;
          }
          node._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element, props) {
          var node = element;
          var value = getToStringValue(props.value);
          var defaultValue = getToStringValue(props.defaultValue);
          if (value != null) {
            var newValue = toString2(value);
            if (newValue !== node.value) {
              node.value = newValue;
            }
            if (props.defaultValue == null && node.defaultValue !== newValue) {
              node.defaultValue = newValue;
            }
          }
          if (defaultValue != null) {
            node.defaultValue = toString2(defaultValue);
          }
        }
        function postMountWrapper$3(element, props) {
          var node = element;
          var textContent = node.textContent;
          if (textContent === node._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element, props) {
          updateWrapper$1(element, props);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
          if (node.namespaceURI === SVG_NAMESPACE) {
            if (!("innerHTML" in node)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node.firstChild) {
                node.removeChild(node.firstChild);
              }
              while (svgNode.firstChild) {
                node.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node.innerHTML = html;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node, text2) {
          if (text2) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text2;
              return;
            }
          }
          node.textContent = text2;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key3) {
          return prefix2 + key3.charAt(0).toUpperCase() + key3.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name2, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
            return value + "px";
          }
          {
            checkCSSPropertyStringCoercion(value, name2);
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name2) {
          return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_4, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error2(
              "Unsupported style property %s. Did you mean %s?",
              name2,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name2.replace(msPattern$1, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name2, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name2, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name2);
          };
          var warnStyleValueIsInfinity = function(name2, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name2);
          };
          warnValidStyle = function(name2, value) {
            if (name2.indexOf("-") > -1) {
              warnHyphenatedStyleName(name2);
            } else if (badVendoredStyleNamePattern.test(name2)) {
              warnBadVendoredStyleName(name2);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name2, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name2, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name2, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
          {
            var serialized = "";
            var delimiter = "";
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node, styles) {
          var style2 = node.style;
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style2.setProperty(styleName, styleValue);
            } else {
              style2[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value) {
          return value == null || typeof value === "boolean" || value === "";
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key3 in styles) {
            var longhands = shorthandToLonghand[key3] || [key3];
            for (var i9 = 0; i9 < longhands.length; i9++) {
              expanded[longhands[i9]] = key3;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key3 in expandedUpdates) {
              var originalKey = expandedUpdates[key3];
              var correctOriginalKey = expandedStyles[key3];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
          // NOTE: menuitem's close tag should be omitted, but that causes problems.
        };
        var voidElementTags = assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (props.children != null || props.dangerouslySetInnerHTML != null) {
              throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (props.children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (props.style != null && typeof props.style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name2) {
          {
            if (hasOwnProperty2.call(warnedProperties, name2) && warnedProperties[name2]) {
              return true;
            }
            if (rARIACamel.test(name2)) {
              var ariaName = "aria-" + name2.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
                warnedProperties[name2] = true;
                return true;
              }
              if (name2 !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
                warnedProperties[name2] = true;
                return true;
              }
            }
            if (rARIA.test(name2)) {
              var lowerCasedName = name2.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name2] = true;
                return false;
              }
              if (name2 !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties[name2] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key3 in props) {
              var isValid = validateProperty(type, key3);
              if (!isValid) {
                invalidProps.push(key3);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name2, value, eventRegistry) {
            if (hasOwnProperty2.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
              return true;
            }
            var lowerCasedName = name2.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name2)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name2)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name2);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name2)) {
              if (INVALID_EVENT_NAME_REGEX.test(name2)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name2);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name2) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (!isReserved && name2 !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              if (value) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              warnedProperties$1[name2] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
              warnedProperties$1[name2] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key3 in props) {
              var isValid = validateProperty$1(type, key3, props[key3], eventRegistry);
              if (!isValid) {
                unknownProps.push(key3);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
          {
            if (currentReplayingEvent !== null) {
              error2("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
          {
            if (currentReplayingEvent === null) {
              error2("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
          return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (typeof restoreImpl !== "function") {
            throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i9 = 0; i9 < queuedTargets.length; i9++) {
              restoreStateOfTarget(queuedTargets[i9]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn, bookkeeping) {
          return fn(bookkeeping);
        };
        var flushSyncImpl = function() {
        };
        var isInsideEventHandler = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushSyncImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn, a7, b5) {
          if (isInsideEventHandler) {
            return fn(a7, b5);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn, a7, b5);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name2, type, props) {
          switch (name2) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props.disabled && isInteractive(type));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props = getFiberCurrentPropsFromNode(stateNode);
          if (props === null) {
            return null;
          }
          var listener = props[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
            return null;
          }
          if (listener && typeof listener !== "function") {
            throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
          }
          return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM) {
          try {
            var options3 = {};
            Object.defineProperty(options3, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options3, options3);
            window.removeEventListener("test", options3, options3);
          } catch (e5) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name2, func, context, a7, b5, c8, d6, e5, f5) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context, funcArgs);
          } catch (error3) {
            this.onError(error3);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a7, b5, c8, d6, e5, f5) {
              if (typeof document === "undefined" || document === null) {
                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context, funcArgs);
                didError = false;
              }
              var error3;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error3 = event.error;
                didSetError = true;
                if (error3 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error3 != null && typeof error3 === "object") {
                    try {
                      error3._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error3);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error3) {
            hasError = true;
            caughtError = error3;
          }
        };
        function invokeGuardedCallback(name2, func, context, a7, b5, c8, d6, e5, f5) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a7, b5, c8, d6, e5, f5) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error3 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error3;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error3 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error3;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error3 = caughtError;
            hasError = false;
            caughtError = null;
            return error3;
          } else {
            throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function get4(key3) {
          return key3._reactInternals;
        }
        function has2(key3) {
          return key3._reactInternals !== void 0;
        }
        function set2(key3, value) {
          key3._reactInternals = value;
        }
        var NoFlags = (
          /*                      */
          0
        );
        var PerformedWork = (
          /*                */
          1
        );
        var Placement = (
          /*                    */
          2
        );
        var Update = (
          /*                       */
          4
        );
        var ChildDeletion = (
          /*                */
          16
        );
        var ContentReset = (
          /*                 */
          32
        );
        var Callback = (
          /*                     */
          64
        );
        var DidCapture = (
          /*                   */
          128
        );
        var ForceClientRender = (
          /*            */
          256
        );
        var Ref = (
          /*                          */
          512
        );
        var Snapshot = (
          /*                     */
          1024
        );
        var Passive = (
          /*                      */
          2048
        );
        var Hydrating = (
          /*                    */
          4096
        );
        var Visibility = (
          /*                   */
          8192
        );
        var StoreConsistency = (
          /*             */
          16384
        );
        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
        var HostEffectMask = (
          /*               */
          32767
        );
        var Incomplete = (
          /*                   */
          32768
        );
        var ShouldCapture = (
          /*                */
          65536
        );
        var ForceUpdateForLegacySuspense = (
          /* */
          131072
        );
        var Forked = (
          /*                       */
          1048576
        );
        var RefStatic = (
          /*                    */
          2097152
        );
        var LayoutStatic = (
          /*                 */
          4194304
        );
        var PassiveStatic = (
          /*                */
          8388608
        );
        var MountLayoutDev = (
          /*               */
          16777216
        );
        var MountPassiveDev = (
          /*              */
          33554432
        );
        var BeforeMutationMask = (
          // TODO: Remove Update flag from before mutation phase by re-landing Visibility
          // flag logic (see #20043)
          Update | Snapshot | 0
        );
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node;
            do {
              node = nextNode;
              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node.return;
              }
              nextNode = node.return;
            } while (nextNode);
          } else {
            while (node.return) {
              node = node.return;
            }
          }
          if (node.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current2 = fiber.alternate;
              if (current2 !== null) {
                suspenseState = current2.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component7) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance2 = ownerFiber.stateNode;
              if (!instance2._warnedAboutRefsInRender) {
                error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
              }
              instance2._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get4(component7);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) {
            throw new Error("Unable to find node on an unmounted component.");
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (nearestMounted === null) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a7 = fiber;
          var b5 = alternate;
          while (true) {
            var parentA = a7.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a7 = b5 = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a7) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b5) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a7.return !== b5.return) {
              a7 = parentA;
              b5 = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a7) {
                  didFindChild = true;
                  a7 = parentA;
                  b5 = parentB;
                  break;
                }
                if (_child === b5) {
                  didFindChild = true;
                  b5 = parentA;
                  a7 = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a7) {
                    didFindChild = true;
                    a7 = parentB;
                    b5 = parentA;
                    break;
                  }
                  if (_child === b5) {
                    didFindChild = true;
                    b5 = parentB;
                    a7 = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
              }
            }
            if (a7.alternate !== b5) {
              throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (a7.tag !== HostRoot) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a7.stateNode.current === a7) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            var match = findCurrentHostFiberImpl(child);
            if (match !== null) {
              return match;
            }
            child = child.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            if (child.tag !== HostPortal) {
              var match = findCurrentHostFiberWithNoPortalsImpl(child);
              if (match !== null) {
                return match;
              }
            }
            child = child.sibling;
          }
          return null;
        }
        var scheduleCallback = Scheduler.unstable_scheduleCallback;
        var cancelCallback = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            if (enableSchedulingProfiler) {
              internals = assign({}, internals, {
                getLaneLabelMap,
                injectProfilingHooks
              });
            }
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err) {
            {
              error2("React instrumentation encountered an error: %s.", err);
            }
          }
          if (hook.checkDCE) {
            return true;
          } else {
            return false;
          }
        }
        function onScheduleRoot(root3, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root3, children);
              } catch (err) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitRoot(root3, eventPriority) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root3.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                var schedulerPriority;
                switch (eventPriority) {
                  case DiscreteEventPriority:
                    schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority;
                    break;
                }
                injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root3, void 0, didError);
              }
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onPostCommitRoot(root3) {
          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root3);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          {
            if (typeof unstable_yieldValue === "function") {
              unstable_setDisableYieldValue(newIsStrictMode);
              setSuppressWarning(newIsStrictMode);
            }
            if (injectedHook && typeof injectedHook.setStrictMode === "function") {
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
          {
            var map = /* @__PURE__ */ new Map();
            var lane = 1;
            for (var index8 = 0; index8 < TotalLanes; index8++) {
              var label = getLabelForLane(lane);
              map.set(lane, label);
              lane *= 2;
            }
            return map;
          }
        }
        function markCommitStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
              injectedProfilingHooks.markCommitStarted(lanes);
            }
          }
        }
        function markCommitStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
              injectedProfilingHooks.markCommitStopped();
            }
          }
        }
        function markComponentRenderStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
              injectedProfilingHooks.markComponentRenderStarted(fiber);
            }
          }
        }
        function markComponentRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
              injectedProfilingHooks.markComponentRenderStopped();
            }
          }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStopped();
            }
          }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
            }
          }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
            }
          }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
            }
          }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
            }
          }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
            }
          }
        }
        function markLayoutEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
              injectedProfilingHooks.markLayoutEffectsStarted(lanes);
            }
          }
        }
        function markLayoutEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
              injectedProfilingHooks.markLayoutEffectsStopped();
            }
          }
        }
        function markPassiveEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            }
          }
        }
        function markPassiveEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
              injectedProfilingHooks.markPassiveEffectsStopped();
            }
          }
        }
        function markRenderStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
              injectedProfilingHooks.markRenderStarted(lanes);
            }
          }
        }
        function markRenderYielded() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
              injectedProfilingHooks.markRenderYielded();
            }
          }
        }
        function markRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
              injectedProfilingHooks.markRenderStopped();
            }
          }
        }
        function markRenderScheduled(lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
              injectedProfilingHooks.markRenderScheduled(lane);
            }
          }
        }
        function markForceUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
            }
          }
        }
        function markStateUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
            }
          }
        }
        var NoMode = (
          /*                         */
          0
        );
        var ConcurrentMode = (
          /*                 */
          1
        );
        var ProfileMode = (
          /*                    */
          2
        );
        var StrictLegacyMode = (
          /*               */
          8
        );
        var StrictEffectsMode = (
          /*              */
          16
        );
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log3 = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x4) {
          var asUint = x4 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log3(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = (
          /*                        */
          0
        );
        var NoLane = (
          /*                          */
          0
        );
        var SyncLane = (
          /*                        */
          1
        );
        var InputContinuousHydrationLane = (
          /*    */
          2
        );
        var InputContinuousLane = (
          /*             */
          4
        );
        var DefaultHydrationLane = (
          /*            */
          8
        );
        var DefaultLane = (
          /*                     */
          16
        );
        var TransitionHydrationLane = (
          /*                */
          32
        );
        var TransitionLanes = (
          /*                       */
          4194240
        );
        var TransitionLane1 = (
          /*                        */
          64
        );
        var TransitionLane2 = (
          /*                        */
          128
        );
        var TransitionLane3 = (
          /*                        */
          256
        );
        var TransitionLane4 = (
          /*                        */
          512
        );
        var TransitionLane5 = (
          /*                        */
          1024
        );
        var TransitionLane6 = (
          /*                        */
          2048
        );
        var TransitionLane7 = (
          /*                        */
          4096
        );
        var TransitionLane8 = (
          /*                        */
          8192
        );
        var TransitionLane9 = (
          /*                        */
          16384
        );
        var TransitionLane10 = (
          /*                       */
          32768
        );
        var TransitionLane11 = (
          /*                       */
          65536
        );
        var TransitionLane12 = (
          /*                       */
          131072
        );
        var TransitionLane13 = (
          /*                       */
          262144
        );
        var TransitionLane14 = (
          /*                       */
          524288
        );
        var TransitionLane15 = (
          /*                       */
          1048576
        );
        var TransitionLane16 = (
          /*                       */
          2097152
        );
        var RetryLanes = (
          /*                            */
          130023424
        );
        var RetryLane1 = (
          /*                             */
          4194304
        );
        var RetryLane2 = (
          /*                             */
          8388608
        );
        var RetryLane3 = (
          /*                             */
          16777216
        );
        var RetryLane4 = (
          /*                             */
          33554432
        );
        var RetryLane5 = (
          /*                             */
          67108864
        );
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = (
          /*          */
          134217728
        );
        var NonIdleLanes = (
          /*                          */
          268435455
        );
        var IdleHydrationLane = (
          /*               */
          268435456
        );
        var IdleLane = (
          /*                        */
          536870912
        );
        var OffscreenLane = (
          /*                   */
          1073741824
        );
        function getLabelForLane(lane) {
          {
            if (lane & SyncLane) {
              return "Sync";
            }
            if (lane & InputContinuousHydrationLane) {
              return "InputContinuousHydration";
            }
            if (lane & InputContinuousLane) {
              return "InputContinuous";
            }
            if (lane & DefaultHydrationLane) {
              return "DefaultHydration";
            }
            if (lane & DefaultLane) {
              return "Default";
            }
            if (lane & TransitionHydrationLane) {
              return "TransitionHydration";
            }
            if (lane & TransitionLanes) {
              return "Transition";
            }
            if (lane & RetryLanes) {
              return "Retry";
            }
            if (lane & SelectiveHydrationLane) {
              return "SelectiveHydration";
            }
            if (lane & IdleHydrationLane) {
              return "IdleHydration";
            }
            if (lane & IdleLane) {
              return "Idle";
            }
            if (lane & OffscreenLane) {
              return "Offscreen";
            }
          }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
          switch (getHighestPriorityLane(lanes)) {
            case SyncLane:
              return SyncLane;
            case InputContinuousHydrationLane:
              return InputContinuousHydrationLane;
            case InputContinuousLane:
              return InputContinuousLane;
            case DefaultHydrationLane:
              return DefaultHydrationLane;
            case DefaultLane:
              return DefaultLane;
            case TransitionHydrationLane:
              return TransitionHydrationLane;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return lanes & TransitionLanes;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return lanes & RetryLanes;
            case SelectiveHydrationLane:
              return SelectiveHydrationLane;
            case IdleHydrationLane:
              return IdleHydrationLane;
            case IdleLane:
              return IdleLane;
            case OffscreenLane:
              return OffscreenLane;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return lanes;
          }
        }
        function getNextLanes(root3, wipLanes) {
          var pendingLanes = root3.pendingLanes;
          if (pendingLanes === NoLanes) {
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var suspendedLanes = root3.suspendedLanes;
          var pingedLanes = root3.pingedLanes;
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
            } else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              if (nonIdlePingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
              }
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            if (unblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(unblockedLanes);
            } else {
              if (pingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(pingedLanes);
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
          // bother waiting until the root is complete.
          (wipLanes & suspendedLanes) === NoLanes) {
            var nextLane = getHighestPriorityLane(nextLanes);
            var wipLane = getHighestPriorityLane(wipLanes);
            if (
              // Tests whether the next lane is equal or lower priority than the wip
              // one. This works because the bits decrease in priority as you go left.
              nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
              // only difference between default updates and transition updates is that
              // default updates do not support refresh transitions.
              nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
            ) {
              return wipLanes;
            }
          }
          if ((nextLanes & InputContinuousLane) !== NoLanes) {
            nextLanes |= pendingLanes & DefaultLane;
          }
          var entangledLanes = root3.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root3.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index8 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index8;
              nextLanes |= entanglements[index8];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root3, lanes) {
          var eventTimes = root3.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index8 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index8;
            var eventTime = eventTimes[index8];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case SyncLane:
            case InputContinuousHydrationLane:
            case InputContinuousLane:
              return currentTime + 250;
            case DefaultHydrationLane:
            case DefaultLane:
            case TransitionHydrationLane:
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return currentTime + 5e3;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return NoTimestamp;
            case SelectiveHydrationLane:
            case IdleHydrationLane:
            case IdleLane:
            case OffscreenLane:
              return NoTimestamp;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root3, currentTime) {
          var pendingLanes = root3.pendingLanes;
          var suspendedLanes = root3.suspendedLanes;
          var pingedLanes = root3.pingedLanes;
          var expirationTimes = root3.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index8 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index8;
            var expirationTime = expirationTimes[index8];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index8] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root3.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getHighestPriorityPendingLanes(root3) {
          return getHighestPriorityLanes(root3.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root3) {
          var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function includesSyncLane(lanes) {
          return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
          return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root3, lanes) {
          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
          return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root3, lanes) {
          return (lanes & root3.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
          return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          if ((nextTransitionLane & TransitionLanes) === NoLanes) {
            nextTransitionLane = TransitionLane1;
          }
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          if ((nextRetryLane & RetryLanes) === NoLanes) {
            nextRetryLane = RetryLane1;
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a7, b5) {
          return (a7 & b5) !== NoLanes;
        }
        function isSubsetOfLanes(set3, subset) {
          return (set3 & subset) === subset;
        }
        function mergeLanes(a7, b5) {
          return a7 | b5;
        }
        function removeLanes(set3, subset) {
          return set3 & ~subset;
        }
        function intersectLanes(a7, b5) {
          return a7 & b5;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a7, b5) {
          return a7 !== NoLane && a7 < b5 ? a7 : b5;
        }
        function createLaneMap(initial) {
          var laneMap = [];
          for (var i9 = 0; i9 < TotalLanes; i9++) {
            laneMap.push(initial);
          }
          return laneMap;
        }
        function markRootUpdated(root3, updateLane, eventTime) {
          root3.pendingLanes |= updateLane;
          if (updateLane !== IdleLane) {
            root3.suspendedLanes = NoLanes;
            root3.pingedLanes = NoLanes;
          }
          var eventTimes = root3.eventTimes;
          var index8 = laneToIndex(updateLane);
          eventTimes[index8] = eventTime;
        }
        function markRootSuspended(root3, suspendedLanes) {
          root3.suspendedLanes |= suspendedLanes;
          root3.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root3.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index8 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index8;
            expirationTimes[index8] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root3, pingedLanes, eventTime) {
          root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root3, remainingLanes) {
          var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes;
          root3.pendingLanes = remainingLanes;
          root3.suspendedLanes = NoLanes;
          root3.pingedLanes = NoLanes;
          root3.expiredLanes &= remainingLanes;
          root3.mutableReadLanes &= remainingLanes;
          root3.entangledLanes &= remainingLanes;
          var entanglements = root3.entanglements;
          var eventTimes = root3.eventTimes;
          var expirationTimes = root3.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index8 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index8;
            entanglements[index8] = NoLanes;
            eventTimes[index8] = NoTimestamp;
            expirationTimes[index8] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root3, entangledLanes) {
          var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
          var entanglements = root3.entanglements;
          var lanes = rootEntangledLanes;
          while (lanes) {
            var index8 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index8;
            if (
              // Is this one of the newly entangled lanes?
              lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
              entanglements[index8] & entangledLanes
            ) {
              entanglements[index8] |= entangledLanes;
            }
            lanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root3, renderLanes2) {
          var renderLane = getHighestPriorityLane(renderLanes2);
          var lane;
          switch (renderLane) {
            case InputContinuousLane:
              lane = InputContinuousHydrationLane;
              break;
            case DefaultLane:
              lane = DefaultHydrationLane;
              break;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              lane = TransitionHydrationLane;
              break;
            case IdleLane:
              lane = IdleHydrationLane;
              break;
            default:
              lane = NoLane;
              break;
          }
          if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
            return NoLane;
          }
          return lane;
        }
        function addFiberToLanesMap(root3, fiber, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
          while (lanes > 0) {
            var index8 = laneToIndex(lanes);
            var lane = 1 << index8;
            var updaters = pendingUpdatersLaneMap[index8];
            updaters.add(fiber);
            lanes &= ~lane;
          }
        }
        function movePendingFibersToMemoized(root3, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
          var memoizedUpdaters = root3.memoizedUpdaters;
          while (lanes > 0) {
            var index8 = laneToIndex(lanes);
            var lane = 1 << index8;
            var updaters = pendingUpdatersLaneMap[index8];
            if (updaters.size > 0) {
              updaters.forEach(function(fiber) {
                var alternate = fiber.alternate;
                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                  memoizedUpdaters.add(fiber);
                }
              });
              updaters.clear();
            }
            lanes &= ~lane;
          }
        }
        function getTransitionsForLanes(root3, lanes) {
          {
            return null;
          }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
          return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
          currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn) {
          var previousPriority = currentUpdatePriority;
          try {
            currentUpdatePriority = priority;
            return fn();
          } finally {
            currentUpdatePriority = previousPriority;
          }
        }
        function higherEventPriority(a7, b5) {
          return a7 !== 0 && a7 < b5 ? a7 : b5;
        }
        function lowerEventPriority(a7, b5) {
          return a7 === 0 || a7 > b5 ? a7 : b5;
        }
        function isHigherEventPriority(a7, b5) {
          return a7 !== 0 && a7 < b5;
        }
        function lanesToEventPriority(lanes) {
          var lane = getHighestPriorityLane(lanes);
          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
            return DiscreteEventPriority;
          }
          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
            return ContinuousEventPriority;
          }
          if (includesNonIdleWork(lane)) {
            return DefaultEventPriority;
          }
          return IdleEventPriority;
        }
        function isRootDehydrated(root3) {
          var currentState = root3.current.memoizedState;
          return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn) {
          _attemptSynchronousHydration = fn;
        }
        function attemptSynchronousHydration(fiber) {
          _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn) {
          attemptContinuousHydration = fn;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn) {
          attemptHydrationAtCurrentPriority = fn;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn) {
          getCurrentUpdatePriority$1 = fn;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn) {
          attemptHydrationAtPriority = fn;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = /* @__PURE__ */ new Map();
        var queuedPointerCaptures = /* @__PURE__ */ new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          // Intentionally camelCase
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isDiscreteEventThatRequiresHydration(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance2 = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance2 !== null) {
                  queuedTarget.blockedOn = instance2;
                  attemptHydrationAtPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root3 = nearestMounted.stateNode;
                if (isRootDehydrated(root3)) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
          var updatePriority = getCurrentUpdatePriority$1();
          var queuedTarget = {
            blockedOn: null,
            target,
            priority: updatePriority
          };
          var i9 = 0;
          for (; i9 < queuedExplicitHydrationTargets.length; i9++) {
            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i9].priority)) {
              break;
            }
          }
          queuedExplicitHydrationTargets.splice(i9, 0, queuedTarget);
          if (i9 === 0) {
            attemptExplicitHydrationTarget(queuedTarget);
          }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn === null) {
              {
                var nativeEvent = queuedEvent.nativeEvent;
                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                setReplayingEvent(nativeEventClone);
                nativeEvent.target.dispatchEvent(nativeEventClone);
                resetReplayingEvent();
              }
            } else {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key3, map) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map.delete(key3);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i9 = 1; i9 < queuedDiscreteEvents.length; i9++) {
              var queuedEvent = queuedDiscreteEvents[i9];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriority(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEventPriority:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            case DefaultEventPriority:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(DiscreteEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(ContinuousEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          {
            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
            nativeEvent.stopPropagation();
            return;
          }
          clearIfContinuousEvent(domEventName, nativeEvent);
          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
            while (blockedOn !== null) {
              var fiber = getInstanceFromNode(blockedOn);
              if (fiber !== null) {
                attemptSynchronousHydration(fiber);
              }
              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (nextBlockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              }
              if (nextBlockedOn === blockedOn) {
                break;
              }
              blockedOn = nextBlockedOn;
            }
            if (blockedOn !== null) {
              nativeEvent.stopPropagation();
            }
            return;
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return_targetInst = null;
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance2 = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance2 !== null) {
                  return instance2;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root3 = nearestMounted.stateNode;
                if (isRootDehydrated(root3)) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          return_targetInst = targetInst;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message": {
              var schedulerPriority = getCurrentPriorityLevel();
              switch (schedulerPriority) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            }
            default:
              return DefaultEventPriority;
          }
        }
        function addEventBubbleListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, false);
          return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, true);
          return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            capture: true,
            passive
          });
          return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            passive
          });
          return listener;
        }
        var root2 = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root2 = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset2() {
          root2 = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start;
          var startValue = startText;
          var startLength = startValue.length;
          var end;
          var endValue = getText();
          var endLength = endValue.length;
          for (start = 0; start < startLength; start++) {
            if (startValue[start] !== endValue[start]) {
              break;
            }
          }
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd; end++) {
            if (startValue[startLength - end] !== endValue[endLength - end]) {
              break;
            }
          }
          var sliceTail = end > 1 ? 1 - end : void 0;
          fallbackText = endValue.slice(start, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root2) {
            return root2.value;
          }
          return root2.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize = Interface[_propName];
              if (normalize) {
                this[_propName] = normalize(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            /**
             * We release all dispatched `SyntheticEvent`s after each event loop, adding
             * them back into the pool. This allows a way to hold onto a reference that
             * won't be added back into the pool.
             */
            persist: function() {
            },
            /**
             * Checks if this event should be released back into the pool.
             *
             * @return {boolean} True if this should not be released, false otherwise.
             */
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0)
              return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key3 = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key3 !== "Unidentified") {
              return key3;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          // Legacy Interface
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : (
              // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
              "wheelDeltaX" in event ? -event.wheelDeltaX : 0
            );
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : (
              // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
              "wheelDeltaY" in event ? -event.wheelDeltaY : (
                // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                "wheelDelta" in event ? -event.wheelDelta : 0
              )
            );
          },
          deltaZ: 0,
          // Browsers without "deltaMode" is reporting in raw wheel delta where one
          // notch on the scroll is always +/- 120, roughly equivalent to pixels.
          // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
          // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
        var documentMode = null;
        if (canUseDOM && "documentMode" in document) {
          documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
          !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars5 = nativeEvent.data;
              if (chars5 === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars5;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars5 = getData();
              reset2();
              isComposing = false;
              return chars5;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars5;
          if (canUseTextInputEvent) {
            chars5 = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars5 = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars5) {
            return null;
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.data = chars5;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node) {
          var state = node._wrapperState;
          if (!state || !state.controlled || node.type !== "number") {
            return;
          }
          {
            setDefaultValue(node, "number", node.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && !isReplayingEvent(nativeEvent)) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc = nativeEventTarget.ownerDocument;
            if (doc) {
              win = doc.defaultView || doc.parentWindow;
            } else {
              win = window;
            }
          }
          var from;
          var to;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from = targetInst;
            to = _related ? getClosestInstanceFromNode(_related) : null;
            if (to !== null) {
              var nearestMounted = getNearestMountedFiber(to);
              if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                to = null;
              }
            }
          } else {
            from = null;
            to = targetInst;
          }
          if (from === to) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from == null ? win : getNodeFromInstance(from);
          var toNode = to == null ? win : getNodeFromInstance(to);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
        }
        function is2(x4, y7) {
          return x4 === y7 && (x4 !== 0 || 1 / x4 === 1 / y7) || x4 !== x4 && y7 !== y7;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i9 = 0; i9 < keysA.length; i9++) {
            var currentKey = keysA[i9];
            if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node) {
          while (node && node.firstChild) {
            node = node.firstChild;
          }
          return node;
        }
        function getSiblingNode(node) {
          while (node) {
            if (node.nextSibling) {
              return node.nextSibling;
            }
            node = node.parentNode;
          }
        }
        function getNodeForCharacterOffset(root3, offset) {
          var node = getLeafNode(root3);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node) {
            if (node.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node.textContent.length;
              if (nodeStart <= offset && nodeEnd >= offset) {
                return {
                  node,
                  offset: offset - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e5) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length = 0;
          var start = -1;
          var end = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node = outerNode;
          var parentNode = null;
          outer:
            while (true) {
              var next2 = null;
              while (true) {
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                  start = length + anchorOffset;
                }
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                  end = length + focusOffset;
                }
                if (node.nodeType === TEXT_NODE) {
                  length += node.nodeValue.length;
                }
                if ((next2 = node.firstChild) === null) {
                  break;
                }
                parentNode = node;
                node = next2;
              }
              while (true) {
                if (node === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start = length;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end = length;
                }
                if ((next2 = node.nextSibling) !== null) {
                  break;
                }
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next2;
            }
          if (start === -1 || end === -1) {
            return null;
          }
          return {
            start,
            end
          };
        }
        function setOffsets(node, offsets) {
          var doc = node.ownerDocument || document;
          var win = doc && doc.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length = node.textContent.length;
          var start = Math.min(offsets.start, length);
          var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
          if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
          }
          var startMarker = getNodeForCharacterOffset(node, start);
          var endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
              selection.addRange(range);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range);
            }
          }
        }
        function isTextNode(node) {
          return node && node.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node) {
          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element = getActiveElement();
          while (element instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element)) {
              win = element.contentWindow;
            } else {
              return element;
            }
            element = getActiveElement(win.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i9 = 0; i9 < ancestors.length; i9++) {
              var info = ancestors[i9];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection(input, offsets) {
          var start = offsets.start;
          var end = offsets.end;
          if (end === void 0) {
            end = start;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node) {
          if ("selectionStart" in node && hasSelectionCapabilities(node)) {
            return {
              start: node.selectionStart,
              end: node.selectionEnd
            };
          } else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes2 = {};
          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes2["Webkit" + styleProp] = "webkit" + eventName;
          prefixes2["Moz" + styleProp] = "moz" + eventName;
          return prefixes2;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
        var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
          for (var i9 = 0; i9 < simpleEventPluginEvents.length; i9++) {
            var eventName = simpleEventPluginEvents[i9];
            var domEventName = eventName.toLowerCase();
            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + capitalizedEvent);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
            // nonDelegatedEvents list in DOMPluginEventSystem.
            // Then we can remove this special list.
            // This is a breaking change that can wait until React 18.
            domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
          var type = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i9 = dispatchListeners.length - 1; i9 >= 0; i9--) {
              var _dispatchListeners$i = dispatchListeners[i9], instance2 = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
              if (instance2 !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener, currentTarget);
              previousInstance = instance2;
            }
          } else {
            for (var _i = 0; _i < dispatchListeners.length; _i++) {
              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i9 = 0; i9 < dispatchQueue.length; i9++) {
            var _dispatchQueue$i = dispatchQueue[i9], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          {
            if (!nonDelegatedEvents.has(domEventName)) {
              error2('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          {
            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
              error2('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var eventSystemFlags = 0;
          if (isCapturePhaseListener) {
            eventSystemFlags |= IS_CAPTURE_PHASE;
          }
          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (domEventName !== "selectionchange") {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement);
              }
            });
            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
            if (ownerDocument !== null) {
              if (!ownerDocument[listeningMarker]) {
                ownerDocument[listeningMarker] = true;
                listenToNativeEvent("selectionchange", false, ownerDocument);
              }
            }
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node = targetInst;
              mainLoop:
                while (true) {
                  if (node === null) {
                    return;
                  }
                  var nodeTag = node.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container = node.stateNode.containerInfo;
                    if (isMatchingRootContainer(container, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container !== null) {
                      var parentNode = getClosestInstanceFromNode(container);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container = container.parentNode;
                    }
                  }
                  node = node.return;
                }
            }
          }
          batchedUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance2, listener, currentTarget) {
          return {
            instance: instance2,
            listener,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners = [];
          var instance2 = targetFiber;
          var lastHostComponent = null;
          while (instance2 !== null) {
            var _instance2 = instance2, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener = getListener(instance2, reactEventName);
                if (listener != null) {
                  listeners.push(createDispatchListener(instance2, listener, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance2 = instance2.return;
          }
          return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners = [];
          var instance2 = targetFiber;
          while (instance2 !== null) {
            var _instance3 = instance2, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance2, captureName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance2, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance2, reactName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance2, bubbleListener, currentTarget));
              }
            }
            instance2 = instance2.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners = [];
          var instance2 = target;
          while (instance2 !== null) {
            if (instance2 === common) {
              break;
            }
            var _instance4 = instance2, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance2, registrationName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance2, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance2, registrationName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance2, bubbleListener, currentTarget));
                }
              }
            }
            instance2 = instance2.return;
          }
          if (listeners.length !== 0) {
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
          var common = from && to ? getLowestCommonAncestor(from, to) : null;
          if (from !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
          }
          if (to !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            // There are working polyfills for <dialog>. Let people use it.
            dialog: true,
            // Electron ships a custom <webview> tag to display external web content in
            // an isolated frame and process.
            // This tag is not present in non Electron environments such as JSDom which
            // is often used for testing purposes.
            // @see https://electronjs.org/docs/api/webview-tag
            webview: true
          };
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name2) {
              names.push(name2);
            });
            error2("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener) {
            if (listener === false) {
              error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
            }
          };
          normalizeHTML = function(parent, html) {
            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            testElement.innerHTML = html;
            return testElement.innerHTML;
          };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          {
            checkHtmlStringCoercion(markup);
          }
          var markupString = typeof markup === "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
          if (normalizedServerText === normalizedClientText) {
            return;
          }
          if (shouldWarnDev) {
            {
              if (!didWarnInvalidHydration) {
                didWarnInvalidHydration = true;
                error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
              }
            }
          }
          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
            throw new Error("Text content does not match server-rendered HTML.");
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop4() {
        }
        function trapClickOnNonInteractiveElement(node) {
          node.onclick = noop4;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i9 = 0; i9 < updatePayload.length; i9 += 2) {
            var propKey = updatePayload[i9];
            var propValue = updatePayload[i9 + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement5(type, props, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE) {
            namespaceURI = getIntrinsicNamespace(type);
          }
          if (namespaceURI === HTML_NAMESPACE) {
            {
              isCustomComponentTag = isCustomComponent(type, props);
              if (!isCustomComponentTag && type !== type.toLowerCase()) {
                error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
            if (type === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props.is === "string") {
              domElement = ownerDocument.createElement(type, {
                is: props.is
              });
            } else {
              domElement = ownerDocument.createElement(type);
              if (type === "select") {
                var node = domElement;
                if (props.multiple) {
                  node.multiple = true;
                } else if (props.size) {
                  node.size = props.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type);
          }
          {
            if (namespaceURI === HTML_NAMESPACE) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty2.call(warnedUnknownTags, type)) {
                warnedUnknownTags[type] = true;
                error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text2, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text2);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "video":
            case "audio":
              for (var i9 = 0; i9 < mediaEventTypes.length; i9++) {
                listenToNonDelegatedEvent(mediaEventTypes[i9], domElement);
              }
              props = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props = rawProps;
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props = getHostProps$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props = rawProps;
          }
          assertValidProps(tag, props);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
              ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i9 = 0; i9 < mediaEventTypes.length; i9++) {
                listenToNonDelegatedEvent(mediaEventTypes[i9], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = /* @__PURE__ */ new Set();
            var attributes = domElement.attributes;
            for (var _i = 0; _i < attributes.length; _i++) {
              var name2 = attributes[_i].name.toLowerCase();
              switch (name2) {
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes[_i].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
            typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              propKey === "value" || propKey === "checked" || propKey === "selected")
                ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                var dontWarnCustomElement = enableCustomElementPropertySupport;
                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (shouldWarnDev) {
              if (
                // $FlowFixMe - Should be inferred as not undefined.
                extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
              ) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text2, isConcurrentMode) {
          var isDifferent = textNode.nodeValue !== text2;
          return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text2) {
          {
            if (text2 === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text2, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props);
              return;
            case "select":
              restoreControlledState$1(domElement, props);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
            // TODO: Distinguish by namespace here -- for <title>, including it here
            // errs on the side of fewer warnings
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              case "option":
                return tag === "#text";
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              case "colgroup":
                return tag === "col" || tag === "template";
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error2("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
          var type;
          var namespace;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root3 = rootContainerInstance.documentElement;
              namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container.namespaceURI || null;
              type = container.tagName;
              namespace = getChildNamespace(ownNamespace, type);
              break;
            }
          }
          {
            var validatedTag = type.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace = getChildNamespace(parentHostContextDev.namespace, type);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance2) {
          return instance2;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance2(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type, null, hostContextDev.ancestorInfo);
            if (typeof props.children === "string" || typeof props.children === "number") {
              var string = "" + props.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement5(type, props, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type, props, rootContainerInstance);
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props.autoFocus;
            case "img":
              return true;
            default:
              return false;
          }
        }
        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type, oldProps, newProps);
        }
        function shouldSetTextContent(type, props) {
          return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text2, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text2, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text2, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        function getCurrentEventPriority() {
          var currentEvent = window.event;
          if (currentEvent === void 0) {
            return DefaultEventPriority;
          }
          return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        var localPromise = typeof Promise === "function" ? Promise : void 0;
        var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error3) {
          setTimeout(function() {
            throw error3;
          });
        }
        function commitMount(domElement, type, newProps, internalInstanceHandle) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              if (newProps.autoFocus) {
                domElement.focus();
              }
              return;
            case "img": {
              if (newProps.src) {
                domElement.src = newProps.src;
              }
              return;
            }
          }
        }
        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
          updateProperties(domElement, updatePayload, type, oldProps, newProps);
          updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container, child) {
          var parentNode;
          if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
          } else {
            parentNode = container;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container, child, beforeChild) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.insertBefore(child, beforeChild);
          } else {
            container.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.removeChild(child);
          } else {
            container.removeChild(child);
          }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node = suspenseInstance;
          var depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && nextNode.nodeType === COMMENT_NODE) {
              var data = nextNode.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                depth++;
              }
            }
            node = nextNode;
          } while (node);
          retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
          if (container.nodeType === COMMENT_NODE) {
            clearSuspenseBoundary(container.parentNode, suspenseInstance);
          } else if (container.nodeType === ELEMENT_NODE) {
            clearSuspenseBoundary(container, suspenseInstance);
          }
          retryIfBlockedOn(container);
        }
        function hideInstance(instance2) {
          instance2 = instance2;
          var style2 = instance2.style;
          if (typeof style2.setProperty === "function") {
            style2.setProperty("display", "none", "important");
          } else {
            style2.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance2, props) {
          instance2 = instance2;
          var styleProp = props[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance2.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text2) {
          textInstance.nodeValue = text2;
        }
        function clearContainer(container) {
          if (container.nodeType === ELEMENT_NODE) {
            container.textContent = "";
          } else if (container.nodeType === DOCUMENT_NODE) {
            if (container.documentElement) {
              container.removeChild(container.documentElement);
            }
          }
        }
        function canHydrateInstance(instance2, type, props) {
          if (instance2.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance2.nodeName.toLowerCase()) {
            return null;
          }
          return instance2;
        }
        function canHydrateTextInstance(instance2, text2) {
          if (text2 === "" || instance2.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance2;
        }
        function canHydrateSuspenseInstance(instance2) {
          if (instance2.nodeType !== COMMENT_NODE) {
            return null;
          }
          return instance2;
        }
        function isSuspenseInstancePending(instance2) {
          return instance2.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance2) {
          return instance2.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance2) {
          var dataset = instance2.nextSibling && instance2.nextSibling.dataset;
          var digest2, message2, stack;
          if (dataset) {
            digest2 = dataset.dgst;
            {
              message2 = dataset.msg;
              stack = dataset.stck;
            }
          }
          {
            return {
              message: message2,
              digest: digest2,
              stack
            };
          }
        }
        function registerSuspenseInstanceRetry(instance2, callback) {
          instance2._reactRetry = callback;
        }
        function getNextHydratable(node) {
          for (; node != null; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
            if (nodeType === COMMENT_NODE) {
              var nodeData = node.data;
              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                break;
              }
              if (nodeData === SUSPENSE_END_DATA) {
                return null;
              }
            }
          }
          return node;
        }
        function getNextHydratableSibling(instance2) {
          return getNextHydratable(instance2.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
          return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
          return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance2, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, instance2);
          updateFiberProps(instance2, props);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedProperties(instance2, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text2, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedText(textInstance, text2);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node = suspenseInstance.nextSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node = node.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node = targetInstance.previousSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node = node.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
          return parentType !== "head" && parentType !== "body";
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text2, isConcurrentMode) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text2, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text2, isConcurrentMode) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text2, isConcurrentMode, shouldWarnDev);
          }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance2) {
          {
            if (instance2.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance2);
            } else if (instance2.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentContainer, instance2);
            }
          }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance2) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) {
              if (instance2.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentNode, instance2);
              } else if (instance2.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentNode, instance2);
              }
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance2, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance2.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance2);
              } else if (instance2.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance2);
              }
            }
          }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
          {
            warnForInsertedHydratedElement(parentContainer, type);
          }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text2) {
          {
            warnForInsertedHydratedText(parentContainer, text2);
          }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedElement(parentNode, type);
          }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text2) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedText(parentNode, text2);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type);
            }
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text2, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text2);
            }
          }
        }
        function errorHydratingContainer(parentContainer) {
          {
            error2("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
          }
        }
        function preparePortalMount(portalInstance) {
          listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
        var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node) {
          node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
          node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
          node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
          return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          throw new Error("getNodeFromInstance: Invalid argument.");
        }
        function getFiberCurrentPropsFromNode(node) {
          return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props) {
          node[internalPropsKey] = props;
        }
        function getEventListenerSet(node) {
          var elementListenerSet = node[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has3 = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has3(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index7 = -1;
        function createCursor(defaultValue) {
          return {
            current: defaultValue
          };
        }
        function pop2(cursor, fiber) {
          if (index7 < 0) {
            {
              error2("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index7]) {
              error2("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index7];
          valueStack[index7] = null;
          {
            fiberStack[index7] = null;
          }
          index7--;
        }
        function push2(cursor, value, fiber) {
          index7++;
          valueStack[index7] = cursor.current;
          {
            fiberStack[index7] = fiber;
          }
          cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance2 = workInProgress2.stateNode;
            instance2.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance2.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type = workInProgress2.type;
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance2 = workInProgress2.stateNode;
            if (instance2 && instance2.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance2.__reactInternalMemoizedMaskedChildContext;
            }
            var context = {};
            for (var key3 in contextTypes) {
              context[key3] = unmaskedContext[key3];
            }
            {
              var name2 = getComponentNameFromFiber(workInProgress2) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name2);
            }
            if (instance2) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return context;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type) {
          {
            var childContextTypes = type.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop2(didPerformWorkStackCursor, fiber);
            pop2(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop2(didPerformWorkStackCursor, fiber);
            pop2(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
          {
            if (contextStackCursor.current !== emptyContextObject) {
              throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
            }
            push2(contextStackCursor, context, fiber);
            push2(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type, parentContext) {
          {
            var instance2 = fiber.stateNode;
            var childContextTypes = type.childContextTypes;
            if (typeof instance2.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance2.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name2 = getComponentNameFromFiber(fiber) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name2);
            }
            return assign({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance2 = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance2 && instance2.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push2(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push2(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type, didChange) {
          {
            var instance2 = workInProgress2.stateNode;
            if (!instance2) {
              throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type, previousContext);
              instance2.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop2(didPerformWorkStackCursor, workInProgress2);
              pop2(contextStackCursor, workInProgress2);
              push2(contextStackCursor, mergedContext, workInProgress2);
              push2(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop2(didPerformWorkStackCursor, workInProgress2);
              push2(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
              throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
            }
            var node = fiber;
            do {
              switch (node.tag) {
                case HostRoot:
                  return node.stateNode.context;
                case ClassComponent: {
                  var Component = node.type;
                  if (isContextProvider(Component)) {
                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node = node.return;
            } while (node !== null);
            throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
          } else {
            syncQueue.push(callback);
          }
        }
        function scheduleLegacySyncCallback(callback) {
          includesLegacySyncCallbacks = true;
          scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
          if (includesLegacySyncCallbacks) {
            flushSyncCallbacks();
          }
        }
        function flushSyncCallbacks() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i9 = 0;
            var previousUpdatePriority = getCurrentUpdatePriority();
            try {
              var isSync = true;
              var queue = syncQueue;
              setCurrentUpdatePriority(DiscreteEventPriority);
              for (; i9 < queue.length; i9++) {
                var callback = queue[i9];
                do {
                  callback = callback(isSync);
                } while (callback !== null);
              }
              syncQueue = null;
              includesLegacySyncCallbacks = false;
            } catch (error3) {
              if (syncQueue !== null) {
                syncQueue = syncQueue.slice(i9 + 1);
              }
              scheduleCallback(ImmediatePriority, flushSyncCallbacks);
              throw error3;
            } finally {
              setCurrentUpdatePriority(previousUpdatePriority);
              isFlushingSyncQueue = false;
            }
          }
          return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = "";
        function isForkedChild(workInProgress2) {
          warnIfNotHydrating();
          return (workInProgress2.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress2) {
          warnIfNotHydrating();
          return treeForkCount;
        }
        function getTreeId() {
          var overflow = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index8) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          var baseOverflow = treeContextOverflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot2 = index8 + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot2 << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            treeContextId = 1 << restOfLength | id;
            treeContextOverflow = overflow;
          } else {
            var newBits = slot2 << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            treeContextId = 1 << length | _id;
            treeContextOverflow = _overflow;
          }
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          var returnFiber = workInProgress2.return;
          if (returnFiber !== null) {
            var numberOfForks = 1;
            var slotIndex = 0;
            pushTreeFork(workInProgress2, numberOfForks);
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        function popTreeContext(workInProgress2) {
          while (workInProgress2 === treeForkProvider) {
            treeForkProvider = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
            treeForkCount = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
          }
          while (workInProgress2 === treeContextProvider) {
            treeContextProvider = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextOverflow = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextId = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
          }
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          if (treeContextProvider !== null) {
            return {
              id: treeContextId,
              overflow: treeContextOverflow
            };
          } else {
            return null;
          }
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          {
            if (!getIsHydrating()) {
              error2("Expected to be hydrating. This is a bug in React. Please file an issue.");
            }
          }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
          {
            if (isHydrating) {
              error2("We should not be hydrating here. This is a bug in React. Please file a bug.");
            }
          }
        }
        function markDidThrowWhileHydratingDEV() {
          {
            didSuspendOrErrorDEV = true;
          }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
          {
            return didSuspendOrErrorDEV;
          }
        }
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          if (treeContext !== null) {
            restoreSuspendedTreeContext(fiber, treeContext);
          }
          return true;
        }
        function warnUnhydratedInstance(returnFiber, instance2) {
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance2);
                break;
              }
              case HostComponent: {
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotHydrateInstance(
                  returnFiber.type,
                  returnFiber.memoizedProps,
                  returnFiber.stateNode,
                  instance2,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                if (suspenseState.dehydrated !== null)
                  didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance2);
                break;
              }
            }
          }
        }
        function deleteHydratableInstance(returnFiber, instance2) {
          warnUnhydratedInstance(returnFiber, instance2);
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance2;
          childToDelete.return = returnFiber;
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
          {
            if (didSuspendOrErrorDEV) {
              return;
            }
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                    break;
                  case HostText:
                    var text2 = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text2);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent: {
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _type,
                      _props,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostText: {
                    var _text = fiber.pendingProps;
                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _text,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode
                    );
                    break;
                  }
                }
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                var _parentInstance = suspenseState.dehydrated;
                if (_parentInstance !== null)
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type2 = fiber.type;
                      var _props2 = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                      break;
                    case HostText:
                      var _text2 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                      break;
                  }
                break;
              }
              default:
                return;
            }
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance2 = canHydrateInstance(nextInstance, type);
              if (instance2 !== null) {
                fiber.stateNode = instance2;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance2);
                return true;
              }
              return false;
            }
            case HostText: {
              var text2 = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text2);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
              if (suspenseInstance !== null) {
                var suspenseState = {
                  dehydrated: suspenseInstance,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState;
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        }
        function shouldClientRenderOnMismatch(fiber) {
          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
          throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance2 = fiber.stateNode;
          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
          var updatePayload = hydrateInstance(instance2, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedContainerTextInstance(
                    parentContainer,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode2
                  );
                  break;
                }
              }
            }
          }
          return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent = fiber.return;
          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
            parent = parent.return;
          }
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
            var nextInstance = nextHydratableInstance;
            if (nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnIfUnhydratedTailNodes(fiber);
                throwOnHydrationMismatch();
              } else {
                while (nextInstance) {
                  deleteHydratableInstance(fiber, nextInstance);
                  nextInstance = getNextHydratableSibling(nextInstance);
                }
              }
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function hasUnhydratedTailNodes() {
          return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
          var nextInstance = nextHydratableInstance;
          while (nextInstance) {
            warnUnhydratedInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
          didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          if (hydrationErrors !== null) {
            queueRecoverableErrors(hydrationErrors);
            hydrationErrors = null;
          }
        }
        function getIsHydrating() {
          return isHydrating;
        }
        function queueHydrationError(error3) {
          if (hydrationErrors === null) {
            hydrationErrors = [error3];
          } else {
            hydrationErrors.push(error3);
          }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance2) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance2) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node = fiber;
            while (node !== null) {
              if (node.mode & StrictLegacyMode) {
                maybeStrictRoot = node;
              }
              node = node.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set3) {
            var array2 = [];
            set3.forEach(function(value) {
              array2.push(value);
            });
            return array2.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance2) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance2.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
            instance2.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn2("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn2("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn2("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance2) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance2 !== null && typeof instance2.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, context, nextValue) {
          {
            push2(valueCursor, context._currentValue, providerFiber);
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(context, providerFiber) {
          var currentValue = valueCursor.current;
          pop2(valueCursor, providerFiber);
          {
            {
              context._currentValue = currentValue;
            }
          }
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          var node = parent;
          while (node !== null) {
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
              node.childLanes = mergeLanes(node.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
            if (node === propagationRoot) {
              break;
            }
            node = node.return;
          }
          {
            if (node !== propagationRoot) {
              error2("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function propagateContextChange(workInProgress2, context, renderLanes2) {
          {
            propagateContextChange_eager(workInProgress2, context, renderLanes2);
          }
        }
        function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list = fiber.dependencies;
            if (list !== null) {
              nextFiber = fiber.child;
              var dependency = list.firstContext;
              while (dependency !== null) {
                if (dependency.context === context) {
                  if (fiber.tag === ClassComponent) {
                    var lane = pickArbitraryLane(renderLanes2);
                    var update2 = createUpdate(NoTimestamp, lane);
                    update2.tag = ForceUpdate;
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null)
                      ;
                    else {
                      var sharedQueue = updateQueue.shared;
                      var pending = sharedQueue.pending;
                      if (pending === null) {
                        update2.next = update2;
                      } else {
                        update2.next = pending.next;
                        pending.next = update2;
                      }
                      sharedQueue.pending = update2;
                    }
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                  list.lanes = mergeLanes(list.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else if (fiber.tag === DehydratedFragment) {
              var parentSuspense = fiber.return;
              if (parentSuspense === null) {
                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
              }
              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
              var _alternate = parentSuspense.alternate;
              if (_alternate !== null) {
                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
              }
              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
              nextFiber = fiber.sibling;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
        }
        function readContext(context) {
          {
            if (isDisallowedContextReadInDEV) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          var value = context._currentValue;
          if (lastFullyObservedContext === context)
            ;
          else {
            var contextItem = {
              context,
              memoizedValue: value,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null) {
                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return value;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue) {
          if (concurrentQueues === null) {
            concurrentQueues = [queue];
          } else {
            concurrentQueues.push(queue);
          }
        }
        function finishQueueingConcurrentUpdates() {
          if (concurrentQueues !== null) {
            for (var i9 = 0; i9 < concurrentQueues.length; i9++) {
              var queue = concurrentQueues[i9];
              var lastInterleavedUpdate = queue.interleaved;
              if (lastInterleavedUpdate !== null) {
                queue.interleaved = null;
                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                var lastPendingUpdate = queue.pending;
                if (lastPendingUpdate !== null) {
                  var firstPendingUpdate = lastPendingUpdate.next;
                  lastPendingUpdate.next = firstInterleavedUpdate;
                  lastInterleavedUpdate.next = firstPendingUpdate;
                }
                queue.pending = lastInterleavedUpdate;
              }
            }
            concurrentQueues = null;
          }
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update2, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update2.next = update2;
            pushConcurrentUpdateQueue(queue);
          } else {
            update2.next = interleaved.next;
            interleaved.next = update2;
          }
          queue.interleaved = update2;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update2, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update2.next = update2;
            pushConcurrentUpdateQueue(queue);
          } else {
            update2.next = interleaved.next;
            interleaved.next = update2;
          }
          queue.interleaved = update2;
        }
        function enqueueConcurrentClassUpdate(fiber, queue, update2, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update2.next = update2;
            pushConcurrentUpdateQueue(queue);
          } else {
            update2.next = interleaved.next;
            interleaved.next = update2;
          }
          queue.interleaved = update2;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node = sourceFiber;
          var parent = sourceFiber.return;
          while (parent !== null) {
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node = parent;
            parent = parent.return;
          }
          if (node.tag === HostRoot) {
            var root3 = node.stateNode;
            return root3;
          } else {
            return null;
          }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: NoLanes
            },
            effects: null
          };
          fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          var queue = workInProgress2.updateQueue;
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var clone2 = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: currentQueue.firstBaseUpdate,
              lastBaseUpdate: currentQueue.lastBaseUpdate,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = clone2;
          }
        }
        function createUpdate(eventTime, lane) {
          var update2 = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update2;
        }
        function enqueueUpdate(fiber, update2, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return null;
          }
          var sharedQueue = updateQueue.shared;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
          if (isUnsafeClassRenderPhaseUpdate()) {
            var pending = sharedQueue.pending;
            if (pending === null) {
              update2.next = update2;
            } else {
              update2.next = pending.next;
              pending.next = update2;
            }
            sharedQueue.pending = update2;
            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
          } else {
            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update2, lane);
          }
        }
        function entangleTransitions(root3, fiber, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes;
            markRootEntangled(root3, newQueueLanes);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update2 = firstBaseUpdate;
                do {
                  var clone2 = {
                    eventTime: update2.eventTime,
                    lane: update2.lane,
                    tag: update2.tag,
                    payload: update2.payload,
                    callback: update2.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone2;
                  } else {
                    newLast.next = clone2;
                    newLast = clone2;
                  }
                  update2 = update2.next;
                } while (update2 !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = queue;
              return;
            }
          }
          var lastBaseUpdate = queue.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue, update2, prevState, nextProps, instance2) {
          switch (update2.tag) {
            case ReplaceState: {
              var payload = update2.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance2, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      payload.call(instance2, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            case UpdateState: {
              var _payload = update2.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance2, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      _payload.call(instance2, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return assign({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props, instance2, renderLanes2) {
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue.shared;
          }
          var firstBaseUpdate = queue.firstBaseUpdate;
          var lastBaseUpdate = queue.lastBaseUpdate;
          var pendingQueue = queue.shared.pending;
          if (pendingQueue !== null) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update2 = firstBaseUpdate;
            do {
              var updateLane = update2.lane;
              var updateEventTime = update2.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone2 = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update2.tag,
                  payload: update2.payload,
                  callback: update2.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone2;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone2;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone = {
                    eventTime: updateEventTime,
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    tag: update2.tag,
                    payload: update2.payload,
                    callback: update2.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                }
                newState = getStateFromUpdate(workInProgress2, queue, update2, newState, props, instance2);
                var callback = update2.callback;
                if (callback !== null && // If the update was already committed, we should not queue its
                // callback again.
                update2.lane !== NoLane) {
                  workInProgress2.flags |= Callback;
                  var effects = queue.effects;
                  if (effects === null) {
                    queue.effects = [update2];
                  } else {
                    effects.push(update2);
                  }
                }
              }
              update2 = update2.next;
              if (update2 === null) {
                pendingQueue = queue.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update2 = _firstPendingUpdate;
                  queue.lastBaseUpdate = _lastPendingUpdate;
                  queue.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate;
            var lastInterleaved = queue.shared.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                newLanes = mergeLanes(newLanes, interleaved.lane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (firstBaseUpdate === null) {
              queue.shared.lanes = NoLanes;
            }
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context) {
          if (typeof callback !== "function") {
            throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
          }
          callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance2) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i9 = 0; i9 < effects.length; i9++) {
              var effect2 = effects[i9];
              var callback = effect2.callback;
              if (callback !== null) {
                effect2.callback = null;
                callCallback(callback, instance2);
              }
            }
          }
        }
        var fakeInternalInstance = {};
        var emptyRefsObject = new React2.Component().refs;
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key3 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key3)) {
              didWarnOnInvalidCallback.add(key3);
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get4(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update2 = createUpdate(eventTime, lane);
            update2.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update2.callback = callback;
            }
            var root3 = enqueueUpdate(fiber, update2, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitions(root3, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get4(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update2 = createUpdate(eventTime, lane);
            update2.tag = ReplaceState;
            update2.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update2.callback = callback;
            }
            var root3 = enqueueUpdate(fiber, update2, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitions(root3, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get4(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update2 = createUpdate(eventTime, lane);
            update2.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update2.callback = callback;
            }
            var root3 = enqueueUpdate(fiber, update2, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitions(root3, fiber, lane);
            }
            {
              markForceUpdateScheduled(fiber, lane);
            }
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance2 = workInProgress2.stateNode;
          if (typeof instance2.shouldComponentUpdate === "function") {
            var shouldUpdate = instance2.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  shouldUpdate = instance2.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              if (shouldUpdate === void 0) {
                error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance2 = workInProgress2.stateNode;
          {
            var name2 = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance2.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
              } else {
                error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
              }
            }
            if (instance2.getInitialState && !instance2.getInitialState.isReactClassApproved && !instance2.state) {
              error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
            }
            if (instance2.getDefaultProps && !instance2.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
            }
            if (instance2.propTypes) {
              error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
            }
            if (instance2.contextType) {
              error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
            }
            {
              if (instance2.contextTypes) {
                error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
              }
            }
            if (typeof instance2.componentShouldUpdate === "function") {
              error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance2.shouldComponentUpdate !== "undefined") {
              error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance2.componentDidUnmount === "function") {
              error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
            }
            if (typeof instance2.componentDidReceiveProps === "function") {
              error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
            }
            if (typeof instance2.componentWillRecieveProps === "function") {
              error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
            }
            if (typeof instance2.UNSAFE_componentWillRecieveProps === "function") {
              error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
            }
            var hasMutatedProps = instance2.props !== newProps;
            if (instance2.props !== void 0 && hasMutatedProps) {
              error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
            }
            if (instance2.defaultProps) {
              error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function" && typeof instance2.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance2.getDerivedStateFromProps === "function") {
              error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof instance2.getDerivedStateFromError === "function") {
              error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
            }
            var _state = instance2.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error2("%s.state: must be set to an object or null", name2);
            }
            if (typeof instance2.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance2) {
          instance2.updater = classComponentUpdater;
          workInProgress2.stateNode = instance2;
          set2(instance2, workInProgress2);
          {
            instance2._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          var instance2 = new ctor(props, context);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance2 = new ctor(props, context);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          var state = workInProgress2.memoizedState = instance2.state !== null && instance2.state !== void 0 ? instance2.state : null;
          adoptClassInstance(workInProgress2, instance2);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance2.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance2.componentWillMount === "function" && instance2.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance2.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return instance2;
        }
        function callComponentWillMount(workInProgress2, instance2) {
          var oldState = instance2.state;
          if (typeof instance2.componentWillMount === "function") {
            instance2.componentWillMount();
          }
          if (typeof instance2.UNSAFE_componentWillMount === "function") {
            instance2.UNSAFE_componentWillMount();
          }
          if (oldState !== instance2.state) {
            {
              error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext) {
          var oldState = instance2.state;
          if (typeof instance2.componentWillReceiveProps === "function") {
            instance2.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
            instance2.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance2.state !== oldState) {
            {
              var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance2 = workInProgress2.stateNode;
          instance2.props = newProps;
          instance2.state = workInProgress2.memoizedState;
          instance2.refs = emptyRefsObject;
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance2.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance2.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance2.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance2);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance2);
            }
          }
          instance2.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance2.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance2.getSnapshotBeforeUpdate !== "function" && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance2);
            processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
            instance2.state = workInProgress2.memoizedState;
          }
          if (typeof instance2.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance2 = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance2.props = oldProps;
          var oldContext = instance2.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance2.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance2.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
              if (typeof instance2.componentWillMount === "function") {
                instance2.componentWillMount();
              }
              if (typeof instance2.UNSAFE_componentWillMount === "function") {
                instance2.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance2.componentDidMount === "function") {
              var _fiberFlags = Update;
              {
                _fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags;
            }
          } else {
            if (typeof instance2.componentDidMount === "function") {
              var _fiberFlags2 = Update;
              {
                _fiberFlags2 |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags2 |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags2;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance2.props = newProps;
          instance2.state = newState;
          instance2.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
          var instance2 = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance2.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance2.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance2.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
            if (typeof instance2.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
          // both before and after `shouldComponentUpdate` has been called. Not ideal,
          // but I'm loath to refactor this function. This only happens for memoized
          // components so it's not that common.
          enableLazyContextPropagation;
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillUpdate === "function" || typeof instance2.componentWillUpdate === "function")) {
              if (typeof instance2.componentWillUpdate === "function") {
                instance2.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
                instance2.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance2.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance2.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance2.props = newProps;
          instance2.state = newState;
          instance2.context = nextContext;
          return shouldUpdate;
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (typeof child._store !== "object") {
              throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            }
            child._store.validated = true;
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        function coerceRef(returnFiber, current2, element) {
          var mixedRef = element.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
              // because these cannot be automatically converted to an arrow function
              // using a codemod. Therefore, we don't have to warn about string refs again.
              !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element._owner) {
              var owner = element._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (ownerFiber.tag !== ClassComponent) {
                  throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
              }
              var resolvedInst = inst;
              {
                checkPropStringCoercion(mixedRef, "ref");
              }
              var stringRef = "" + mixedRef;
              if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                return current2.ref;
              }
              var ref = function(value) {
                var refs = resolvedInst.refs;
                if (refs === emptyRefsObject) {
                  refs = resolvedInst.refs = {};
                }
                if (value === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value;
                }
              };
              ref._stringRef = stringRef;
              return ref;
            } else {
              if (typeof mixedRef !== "string") {
                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
              }
              if (!element._owner) {
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var childString = Object.prototype.toString.call(newChild);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function resolveLazy(lazyType) {
          var payload = lazyType._payload;
          var init3 = lazyType._init;
          return init3(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = /* @__PURE__ */ new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone2 = createWorkInProgress(fiber, pendingProps);
            clone2.index = 0;
            clone2.sibling = null;
            return clone2;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              newFiber.flags |= Forked;
              return lastPlacedIndex;
            }
            var current2 = newFiber.alternate;
            if (current2 !== null) {
              var oldIndex = current2.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags |= Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (current2 === null || current2.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE) {
              return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
            }
            if (current2 !== null) {
              if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
              isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
              // We need to do this after the Hot Reloading check above,
              // because hot reloading has different semantics than prod because
              // it doesn't resuspend. So we can't let the call below suspend.
              typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                var existing = useFiber(current2, element.props);
                existing.ref = coerceRef(returnFiber, current2, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current2, element);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current2, fragment, lanes, key3) {
            if (current2 === null || current2.tag !== Fragment) {
              var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key3);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, fragment);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return createChild(returnFiber, init3(payload), lanes);
                }
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key3 = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              if (key3 !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  if (newChild.key === key3) {
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE: {
                  if (newChild.key === key3) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return updateSlot(returnFiber, oldFiber, init3(payload), lanes);
                }
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                if (key3 !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return updateFromMap(existingChildren, returnFiber, newIdx, init3(payload), lanes);
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(child, returnFiber);
                  var key3 = child.key;
                  if (typeof key3 !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key3);
                    break;
                  }
                  if (!knownKeys.has(key3)) {
                    knownKeys.add(key3);
                    break;
                  }
                  error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key3);
                  break;
                case REACT_LAZY_TYPE:
                  var payload = child._payload;
                  var init3 = child._init;
                  warnOnInvalidKey(init3(payload), knownKeys, returnFiber);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i9 = 0; i9 < newChildren.length; i9++) {
                var child = newChildren[i9];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              if (getIsHydrating()) {
                var _numberOfForks = newIdx;
                pushTreeFork(returnFiber, _numberOfForks);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks2 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks2);
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (typeof iteratorFn !== "function") {
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
              newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (newChildren == null) {
              throw new Error("An iterable object provided no iterator.");
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              if (getIsHydrating()) {
                var _numberOfForks3 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks3);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks4 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks4);
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key3 = element.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key3) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                  if (child.tag === Fragment) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element._source;
                      existing._debugOwner = element._owner;
                    }
                    return existing;
                  }
                } else {
                  if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                  isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                  // We need to do this after the Hot Reloading check above,
                  // because hot reloading has different semantics than prod because
                  // it doesn't resuspend. So we can't let the call below suspend.
                  typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing = useFiber(child, element.props);
                    _existing.ref = coerceRef(returnFiber, child, element);
                    _existing.return = returnFiber;
                    {
                      _existing._debugSource = element._source;
                      _existing._debugOwner = element._owner;
                    }
                    return _existing;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key3 = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key3) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return reconcileChildFibers2(returnFiber, currentFirstChild, init3(payload), lanes);
              }
              if (isArray(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current2, workInProgress2) {
          if (current2 !== null && workInProgress2.child !== current2.child) {
            throw new Error("Resuming work not yet implemented.");
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c8) {
          if (c8 === NO_CONTEXT) {
            throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
          }
          return c8;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push2(rootInstanceStackCursor, nextRootInstance, fiber);
          push2(contextFiberStackCursor, fiber, fiber);
          push2(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop2(contextStackCursor$1, fiber);
          push2(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop2(contextStackCursor$1, fiber);
          pop2(contextFiberStackCursor, fiber);
          pop2(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context = requiredContext(contextStackCursor$1.current);
          return context;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context, fiber.type);
          if (context === nextContext) {
            return;
          }
          push2(contextFiberStackCursor, fiber, fiber);
          push2(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop2(contextStackCursor$1, fiber);
          pop2(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push2(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop2(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props = workInProgress2.memoizedProps;
          {
            return true;
          }
        }
        function findFirstSuspended(row) {
          var node = row;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                var dehydrated = state.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node;
                }
              }
            } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
            // keep track of whether it suspended or not.
            node.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) {
              return null;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === row) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        var NoFlags$1 = (
          /*   */
          0
        );
        var HasEffect = (
          /* */
          1
        );
        var Insertion = (
          /*  */
          2
        );
        var Layout2 = (
          /*    */
          4
        );
        var Passive$1 = (
          /*   */
          8
        );
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
          for (var i9 = 0; i9 < workInProgressSources.length; i9++) {
            var mutableSource = workInProgressSources[i9];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root3, mutableSource) {
          var getVersion = mutableSource._getVersion;
          var version = getVersion(mutableSource._source);
          if (root3.mutableSourceEagerHydrationData == null) {
            root3.mutableSourceEagerHydrationData = [mutableSource, version];
          } else {
            root3.mutableSourceEagerHydrationData.push(mutableSource, version);
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !isArray(deps)) {
              error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table = "";
                var secondColumnStart = 30;
                for (var i9 = 0; i9 <= hookTypesUpdateIndexDev; i9++) {
                  var oldHookName = hookTypesDev[i9];
                  var newHookName = i9 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i9 + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table += row;
                }
                error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
              }
            }
          }
        }
        function throwInvalidHookError() {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i9 = 0; i9 < prevDeps.length && i9 < nextDeps.length; i9++) {
            if (objectIs(nextDeps[i9], prevDeps[i9])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current2 !== null && current2.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component(props, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              localIdCounter = 0;
              if (numberOfReRenders >= RE_RENDER_LIMIT) {
                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component(props, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
            // and creates false positives. To make this work in legacy mode, we'd
            // need to mark fibers that commit in an incomplete state, somehow. For
            // now I'll disable the warning that most of the bugs that would trigger
            // it are either exclusive to concurrent mode or exist in both.
            (current2.mode & ConcurrentMode) !== NoMode) {
              error2("Internal React error: Expected static flag was missing. Please notify the React team.");
            }
          }
          didScheduleRenderPhaseUpdate = false;
          if (didRenderTooFewHooks) {
            throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
          }
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
          } else {
            workInProgress2.flags &= ~(Passive | Update);
          }
          current2.lanes = removeLanes(current2.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue = hook.queue;
              if (queue !== null) {
                queue.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current2 = currentlyRenderingFiber$1.alternate;
            if (current2 !== null) {
              nextCurrentHook = current2.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (nextCurrentHook === null) {
              throw new Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            stores: null
          };
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init3) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init3 !== void 0) {
            initialState = init3(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer, initialArg, init3) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var current2 = currentHook;
          var baseQueue = current2.baseQueue;
          var pendingQueue = queue.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current2.baseQueue !== baseQueue) {
                error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          if (baseQueue !== null) {
            var first = baseQueue.next;
            var newState = current2.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update2 = first;
            do {
              var updateLane = update2.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone2 = {
                  lane: updateLane,
                  action: update2.action,
                  hasEagerState: update2.hasEagerState,
                  eagerState: update2.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone2;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone2;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone = {
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    action: update2.action,
                    hasEagerState: update2.hasEagerState,
                    eagerState: update2.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (update2.hasEagerState) {
                  newState = update2.eagerState;
                } else {
                  var action = update2.action;
                  newState = reducer(newState, action);
                }
              }
              update2 = update2.next;
            } while (update2 !== null && update2 !== first);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
          }
          var lastInterleaved = queue.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              var interleavedLane = interleaved.lane;
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
              markSkippedUpdateLanes(interleavedLane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (baseQueue === null) {
            queue.lanes = NoLanes;
          }
          var dispatch = queue.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer, initialArg, init3) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch;
          var lastRenderPhaseUpdate = queue.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update2 = firstRenderPhaseUpdate;
            do {
              var action = update2.action;
              newState = reducer(newState, action);
              update2 = update2.next;
            } while (update2 !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountMutableSource(source2, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function updateMutableSource(source2, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = mountWorkInProgressHook();
          var nextSnapshot;
          var isHydrating2 = getIsHydrating();
          if (isHydrating2) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            nextSnapshot = getServerSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                if (nextSnapshot !== getServerSnapshot()) {
                  error2("The result of getServerSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
          } else {
            nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var root3 = getWorkInProgressRoot();
            if (root3 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root3, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          hook.memoizedState = nextSnapshot;
          var inst = {
            value: nextSnapshot,
            getSnapshot
          };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = updateWorkInProgressHook();
          var nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error2("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var prevSnapshot = hook.memoizedState;
          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
          if (snapshotChanged) {
            hook.memoizedState = nextSnapshot;
            markWorkInProgressReceivedUpdate();
          }
          var inst = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
          // checking whether we scheduled a subscription effect above.
          workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            var root3 = getWorkInProgressRoot();
            if (root3 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root3, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= StoreConsistency;
          var check = {
            getSnapshot,
            value: renderedSnapshot
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.stores = [check];
          } else {
            var stores = componentUpdateQueue.stores;
            if (stores === null) {
              componentUpdateQueue.stores = [check];
            } else {
              stores.push(check);
            }
          }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        }
        function subscribeToStore(fiber, inst, subscribe) {
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          };
          return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error3) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
          }
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create4, destroy, deps) {
          var effect2 = {
            tag,
            create: create4,
            destroy,
            deps,
            // Circular
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect2.next = effect2;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect2.next = effect2;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect2;
              effect2.next = firstEffect;
              componentUpdateQueue.lastEffect = effect2;
            }
          }
          return effect2;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          {
            var _ref2 = {
              current: initialValue
            };
            hook.memoizedState = _ref2;
            return _ref2;
          }
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create4, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create4, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create4, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create4, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create4, destroy, nextDeps);
        }
        function mountEffect(create4, deps) {
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create4, deps);
          } else {
            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create4, deps);
          }
        }
        function updateEffect(create4, deps) {
          return updateEffectImpl(Passive, Passive$1, create4, deps);
        }
        function mountInsertionEffect(create4, deps) {
          return mountEffectImpl(Update, Insertion, create4, deps);
        }
        function updateInsertionEffect(create4, deps) {
          return updateEffectImpl(Update, Insertion, create4, deps);
        }
        function mountLayoutEffect(create4, deps) {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout2, create4, deps);
        }
        function updateLayoutEffect(create4, deps) {
          return updateEffectImpl(Update, Layout2, create4, deps);
        }
        function imperativeHandleEffect(create4, ref) {
          if (typeof ref === "function") {
            var refCallback = ref;
            var _inst = create4();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref !== null && ref !== void 0) {
            var refObject = ref;
            {
              if (!refObject.hasOwnProperty("current")) {
                error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create4();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref, create4, deps) {
          {
            if (typeof create4 !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create4 !== null ? typeof create4 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout2, imperativeHandleEffect.bind(null, create4, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create4, deps) {
          {
            if (typeof create4 !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create4 !== null ? typeof create4 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return updateEffectImpl(Update, Layout2, imperativeHandleEffect.bind(null, create4, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = value;
          return value;
        }
        function updateDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          var resolvedCurrentHook = currentHook;
          var prevValue = resolvedCurrentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          if (currentHook === null) {
            hook.memoizedState = value;
            return value;
          } else {
            var prevValue = currentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
        }
        function updateDeferredValueImpl(hook, prevValue, value) {
          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
          if (shouldDeferValue) {
            if (!objectIs(value, prevValue)) {
              var deferredLane = claimNextTransitionLane();
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
              markSkippedUpdateLanes(deferredLane);
              hook.baseState = true;
            }
            return prevValue;
          } else {
            if (hook.baseState) {
              hook.baseState = false;
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = value;
            return value;
          }
        }
        function startTransition(setPending, callback, options4) {
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
          setPending(true);
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = {};
          var currentTransition = ReactCurrentBatchConfig$2.transition;
          {
            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            setPending(false);
            callback();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$2.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        function mountTransition() {
          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
          var start = startTransition.bind(null, setPending);
          var hook = mountWorkInProgressHook();
          hook.memoizedState = start;
          return [isPending, start];
        }
        function updateTransition() {
          var _updateState = updateState(), isPending = _updateState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        function rerenderTransition() {
          var _rerenderState = rerenderState(), isPending = _rerenderState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function mountId() {
          var hook = mountWorkInProgressHook();
          var root3 = getWorkInProgressRoot();
          var identifierPrefix = root3.identifierPrefix;
          var id;
          if (getIsHydrating()) {
            var treeId = getTreeId();
            id = ":" + identifierPrefix + "R" + treeId;
            var localId = localIdCounter++;
            if (localId > 0) {
              id += "H" + localId.toString(32);
            }
            id += ":";
          } else {
            var globalClientId = globalClientIdCounter++;
            id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
          }
          hook.memoizedState = id;
          return id;
        }
        function updateId() {
          var hook = updateWorkInProgressHook();
          var id = hook.memoizedState;
          return id;
        }
        function dispatchReducerAction(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update2 = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update2);
          } else {
            var root3 = enqueueConcurrentHookUpdate(fiber, queue, update2, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitionUpdate(root3, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update2 = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update2);
          } else {
            var alternate = fiber.alternate;
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update2.hasEagerState = true;
                  update2.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update2, lane);
                    return;
                  }
                } catch (error3) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            var root3 = enqueueConcurrentHookUpdate(fiber, queue, update2, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitionUpdate(root3, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update2) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          if (pending === null) {
            update2.next = update2;
          } else {
            update2.next = pending.next;
            pending.next = update2;
          }
          queue.pending = update2;
        }
        function entangleTransitionUpdate(root3, queue, lane) {
          if (isTransitionLane(lane)) {
            var queueLanes = queue.lanes;
            queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            queue.lanes = newQueueLanes;
            markRootEntangled(root3, newQueueLanes);
          }
        }
        function markUpdateInDevTools(fiber, lane, action) {
          {
            markStateUpdateScheduled(fiber, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create4, deps);
            },
            useImperativeHandle: function(ref, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source2, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create4, deps);
            },
            useImperativeHandle: function(ref, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return mountInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source2, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source2, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source2, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create4, deps);
            },
            useImperativeHandle: function(ref, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source2, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source2, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source2, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
          return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
          {
            nestedUpdateScheduled = true;
          }
        }
        function resetNestedUpdateFlag() {
          {
            currentUpdateIsNested = false;
            nestedUpdateScheduled = false;
          }
        }
        function syncNestedUpdateFlag() {
          {
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
          }
        }
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function recordLayoutEffectDuration(fiber) {
          if (layoutEffectStartTime >= 0) {
            var elapsedTime = now$1() - layoutEffectStartTime;
            layoutEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root3 = parentFiber.stateNode;
                  root3.effectDuration += elapsedTime;
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.effectDuration += elapsedTime;
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function recordPassiveEffectDuration(fiber) {
          if (passiveEffectStartTime >= 0) {
            var elapsedTime = now$1() - passiveEffectStartTime;
            passiveEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root3 = parentFiber.stateNode;
                  if (root3 !== null) {
                    root3.passiveEffectDuration += elapsedTime;
                  }
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  if (parentStateNode !== null) {
                    parentStateNode.passiveEffectDuration += elapsedTime;
                  }
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function startLayoutEffectTimer() {
          layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
          passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        function createCapturedValueAtFiber(value, source2) {
          return {
            value,
            source: source2,
            stack: getStackByFiberInDevAndProd(source2),
            digest: null
          };
        }
        function createCapturedValue(value, digest2, stack) {
          return {
            value,
            source: null,
            stack: stack != null ? stack : null,
            digest: digest2 != null ? digest2 : null
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error3 = errorInfo.value;
            if (true) {
              var source2 = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error3 != null && error3._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error3);
              }
              var componentName = source2 ? getComponentNameFromFiber(source2) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (boundary.tag === HostRoot) {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              } else {
                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error3);
            }
          } catch (e5) {
            setTimeout(function() {
              throw e5;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update2 = createUpdate(NoTimestamp, lane);
          update2.tag = CaptureUpdate;
          update2.payload = {
            element: null
          };
          var error3 = errorInfo.value;
          update2.callback = function() {
            onUncaughtError(error3);
            logCapturedError(fiber, errorInfo);
          };
          return update2;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update2 = createUpdate(NoTimestamp, lane);
          update2.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update2.payload = function() {
              return getDerivedStateFromError(error$1);
            };
            update2.callback = function() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update2.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                  }
                }
              }
            };
          }
          return update2;
        }
        function attachPingListener(root3, wakeable, lanes) {
          var pingCache = root3.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root3.pingCache = new PossiblyWeakMap$1();
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes);
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root3, lanes);
              }
            }
            wakeable.then(ping, ping);
          }
        }
        function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
          var wakeables = suspenseBoundary.updateQueue;
          if (wakeables === null) {
            var updateQueue = /* @__PURE__ */ new Set();
            updateQueue.add(wakeable);
            suspenseBoundary.updateQueue = updateQueue;
          } else {
            wakeables.add(wakeable);
          }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
          var tag = sourceFiber.tag;
          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
            var currentSource = sourceFiber.alternate;
            if (currentSource) {
              sourceFiber.updateQueue = currentSource.updateQueue;
              sourceFiber.memoizedState = currentSource.memoizedState;
              sourceFiber.lanes = currentSource.lanes;
            } else {
              sourceFiber.updateQueue = null;
              sourceFiber.memoizedState = null;
            }
          }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
          var node = returnFiber;
          do {
            if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
              return node;
            }
            node = node.return;
          } while (node !== null);
          return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes) {
          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
            if (suspenseBoundary === returnFiber) {
              suspenseBoundary.flags |= ShouldCapture;
            } else {
              suspenseBoundary.flags |= DidCapture;
              sourceFiber.flags |= ForceUpdateForLegacySuspense;
              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
              if (sourceFiber.tag === ClassComponent) {
                var currentSourceFiber = sourceFiber.alternate;
                if (currentSourceFiber === null) {
                  sourceFiber.tag = IncompleteClassComponent;
                } else {
                  var update2 = createUpdate(NoTimestamp, SyncLane);
                  update2.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update2, SyncLane);
                }
              }
              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
            }
            return suspenseBoundary;
          }
          suspenseBoundary.flags |= ShouldCapture;
          suspenseBoundary.lanes = rootRenderLanes;
          return suspenseBoundary;
        }
        function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root3, rootRenderLanes);
            }
          }
          if (value !== null && typeof value === "object" && typeof value.then === "function") {
            var wakeable = value;
            resetSuspendedComponent(sourceFiber);
            {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
              }
            }
            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (suspenseBoundary !== null) {
              suspenseBoundary.flags &= ~ForceClientRender;
              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
              if (suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root3, wakeable, rootRenderLanes);
              }
              attachRetryListener(suspenseBoundary, root3, wakeable);
              return;
            } else {
              if (!includesSyncLane(rootRenderLanes)) {
                attachPingListener(root3, wakeable, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return;
              }
              var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
              value = uncaughtSuspenseError;
            }
          } else {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (_suspenseBoundary !== null) {
                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                  _suspenseBoundary.flags |= ForceClientRender;
                }
                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                return;
              }
            }
          }
          value = createCapturedValueAtFiber(value, sourceFiber);
          renderDidError(value);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update2 = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, update2);
                return;
              }
              case ClassComponent:
                var errorInfo = value;
                var ctor = workInProgress2.type;
                var instance2 = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance2 !== null && typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        function getSuspendedCache() {
          {
            return null;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          if (current2 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var render3 = Component.render;
          var ref = workInProgress2.ref;
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (current2 === null) {
            var type = Component.type;
            if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
            Component.defaultProps === void 0) {
              var resolvedType = type;
              {
                resolvedType = resolveFunctionForHotReloading(type);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type);
              }
              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
            }
            {
              var innerPropTypes = type.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(type)
                );
              }
            }
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(
                _innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(_type)
              );
            }
          }
          var currentChild = current2.child;
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
          if (!hasScheduledUpdateOrContext) {
            var prevProps = currentChild.memoizedProps;
            var compare = Component.compare;
            compare = compare !== null ? compare : shallowEqual;
            if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  outerMemoType = init3(payload);
                } catch (x4) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    nextProps,
                    // Resolved (SimpleMemoComponent has no defaultProps)
                    "prop",
                    getComponentNameFromType(outerMemoType)
                  );
                }
              }
            }
          }
          if (current2 !== null) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
            workInProgress2.type === current2.type) {
              didReceiveUpdate = false;
              workInProgress2.pendingProps = nextProps = prevProps;
              if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                workInProgress2.lanes = current2.lanes;
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current2 !== null ? current2.memoizedState : null;
          if (nextProps.mode === "hidden" || enableLegacyHidden) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var spawnedCachePool = null;
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes,
                cachePool: spawnedCachePool,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState;
              workInProgress2.updateQueue = null;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateFragment(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current2, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            switch (shouldError(workInProgress2)) {
              case false: {
                var _instance = workInProgress2.stateNode;
                var ctor = workInProgress2.type;
                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                var state = tempInstance.state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
              }
              case true: {
                workInProgress2.flags |= DidCapture;
                workInProgress2.flags |= ShouldCapture;
                var error$1 = new Error("Simulated error coming from DevTools");
                var lane = pickArbitraryLane(renderLanes2);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update2 = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                enqueueCapturedUpdate(workInProgress2, update2);
                break;
              }
            }
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance2 = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance2 === null) {
            resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current2 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
          markRef(current2, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, false);
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          var instance2 = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              setIsRendering(true);
              nextChildren = instance2.render();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance2.render();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current2 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance2.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root3 = workInProgress2.stateNode;
          if (root3.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
          } else if (root3.context) {
            pushTopLevelContextObject(workInProgress2, root3.context, false);
          }
          pushHostContainer(workInProgress2, root3.containerInfo);
        }
        function updateHostRoot(current2, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          if (current2 === null) {
            throw new Error("Should have a current fiber. This is a bug in React.");
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState.element;
          cloneUpdateQueue(current2, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var root3 = workInProgress2.stateNode;
          var nextChildren = nextState.element;
          if (prevState.isDehydrated) {
            var overrideState = {
              element: nextChildren,
              isDehydrated: false,
              cache: nextState.cache,
              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
              transitions: nextState.transitions
            };
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = overrideState;
            workInProgress2.memoizedState = overrideState;
            if (workInProgress2.flags & ForceClientRender) {
              var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
            } else if (nextChildren !== prevChildren) {
              var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
            } else {
              enterHydrationState(workInProgress2);
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            }
          } else {
            resetHydrationState();
            if (nextChildren === prevChildren) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
          resetHydrationState();
          queueHydrationError(recoverableError);
          workInProgress2.flags |= ForceClientRender;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostComponent(current2, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current2 !== null ? current2.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current2, workInProgress2);
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current2, workInProgress2) {
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init3 = lazyComponent._init;
          var Component = init3(payload);
          workInProgress2.type = Component;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
          var resolvedProps = resolveDefaultProps(Component, props);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component);
                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
              }
              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component = resolveClassForHotReloading(Component);
              }
              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef: {
              {
                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
              }
              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      resolvedProps,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(Component)
                    );
                  }
                }
              }
              child = updateMemoComponent(
                null,
                workInProgress2,
                Component,
                resolveDefaultProps(Component.type, resolvedProps),
                // The inner type can have defaults too
                renderLanes2
              );
              return child;
            }
          }
          var hint = "";
          {
            if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value;
          var hasId;
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
            initializeUpdateQueue(workInProgress2);
            adoptClassInstance(workInProgress2, value);
            mountClassInstance(workInProgress2, Component, props, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            reconcileChildren(null, workInProgress2, value, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error2("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2,
            cachePool: getSuspendedCache(),
            transitions: null
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          var cachePool = null;
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
            cachePool,
            transitions: prevOffscreenState.transitions
          };
        }
        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            var suspenseState = current2.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
          return removeLanes(current2.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current2 === null || current2.memoizedState !== null) {
              {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null) {
              var dehydrated = suspenseState.dehydrated;
              if (dehydrated !== null) {
                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
              }
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
            }
          } else {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var _dehydrated = prevState.dehydrated;
              if (_dehydrated !== null) {
                return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
              }
            }
            if (showFallback) {
              var _nextFallbackChildren = nextProps.fallback;
              var _nextPrimaryChildren = nextProps.children;
              var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
              var _primaryChildFragment2 = workInProgress2.child;
              var prevOffscreenState = current2.child.memoizedState;
              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
              workInProgress2.memoizedState = null;
              return _primaryChildFragment3;
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
          return createWorkInProgress(current2, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            var deletions = workInProgress2.deletions;
            if (deletions === null) {
              workInProgress2.deletions = [currentFallbackChildFragment];
              workInProgress2.flags |= ChildDeletion;
            } else {
              deletions.push(currentFallbackChildFragment);
            }
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if (
            // In legacy mode, we commit the primary tree as if it successfully
            // completed, even though it's in an inconsistent state.
            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
            // already cloned. In legacy mode, the only case where this isn't true is
            // when DevTools forces us to display a fallback; we skip the first render
            // pass entirely and go straight to rendering the fallback. (In Concurrent
            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
            // only codepath.)
            workInProgress2.child !== currentPrimaryChildFragment
          ) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            workInProgress2.deletions = null;
          } else {
            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
          if (recoverableError !== null) {
            queueHydrationError(recoverableError);
          }
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          var nextProps = workInProgress2.pendingProps;
          var primaryChildren = nextProps.children;
          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          primaryChildFragment.flags |= Placement;
          workInProgress2.memoizedState = null;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var fiberMode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          }
          return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            {
              error2("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
            }
            workInProgress2.lanes = laneToLanes(SyncLane);
          } else if (isSuspenseInstanceFallback(suspenseInstance)) {
            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
          } else {
            workInProgress2.lanes = laneToLanes(OffscreenLane);
          }
          return null;
        }
        function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
          if (!didSuspend) {
            warnIfHydrating();
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              return retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2,
                // TODO: When we delete legacy mode, we should make this error argument
                // required  every concurrent mode path that causes hydration to
                // de-opt to client rendering should have an error message.
                null
              );
            }
            if (isSuspenseInstanceFallback(suspenseInstance)) {
              var digest2, message2, stack;
              {
                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                digest2 = _getSuspenseInstanceF.digest;
                message2 = _getSuspenseInstanceF.message;
                stack = _getSuspenseInstanceF.stack;
              }
              var error3;
              if (message2) {
                error3 = new Error(message2);
              } else {
                error3 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
              }
              var capturedValue = createCapturedValue(error3, digest2, stack);
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
            }
            var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
            if (didReceiveUpdate || hasContextChanged2) {
              var root3 = getWorkInProgressRoot();
              if (root3 !== null) {
                var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2);
                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                  suspenseState.retryLane = attemptHydrationAtLane;
                  var eventTime = NoTimestamp;
                  enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                  scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime);
                }
              }
              renderDidSuspendDelayIfPossible();
              var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
            } else if (isSuspenseInstancePending(suspenseInstance)) {
              workInProgress2.flags |= DidCapture;
              workInProgress2.child = current2.child;
              var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
              registerSuspenseInstanceRetry(suspenseInstance, retry);
              return null;
            } else {
              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
              var primaryChildren = nextProps.children;
              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
              primaryChildFragment.flags |= Hydrating;
              return primaryChildFragment;
            }
          } else {
            if (workInProgress2.flags & ForceClientRender) {
              workInProgress2.flags &= ~ForceClientRender;
              var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
            } else if (workInProgress2.memoizedState !== null) {
              workInProgress2.child = current2.child;
              workInProgress2.flags |= DidCapture;
              return null;
            } else {
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment4 = workInProgress2.child;
              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            }
          }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node = firstChild;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              }
            } else if (node.tag === SuspenseListComponent) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index8) {
          {
            var isAnArray = isArray(childSlot);
            var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
            if (isAnArray || isIterable) {
              var type = isAnArray ? "array" : "iterable";
              error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index8, type);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (isArray(children)) {
                for (var i9 = 0; i9 < children.length; i9++) {
                  if (!validateSuspenseListNestedChild(children[i9], i9)) {
                    return;
                  }
                }
              } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === "function") {
                  var childrenIterator = iteratorFn.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i)) {
                        return;
                      }
                      _i++;
                    }
                  }
                } else {
                  error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
          }
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail;
                if (lastContentRow === null) {
                  tail = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  tail,
                  lastContentRow,
                  tailMode
                );
                break;
              }
              case "backwards": {
                var _tail = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail;
                  _tail = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  true,
                  // isBackwards
                  _tail,
                  null,
                  // last
                  tailMode
                );
                break;
              }
              case "together": {
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  null,
                  // tail
                  null,
                  // last
                  void 0
                );
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current2, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current2 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current2, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, context, newValue);
          {
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              if (objectIs(oldValue, newValue)) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context, renderLanes2);
              }
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current2, workInProgress2, renderLanes2) {
          var context = workInProgress2.type;
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render3 = newProps.children;
          {
            if (typeof render3 !== "function") {
              error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context);
          {
            markComponentRenderStarted(workInProgress2);
          }
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render3(newValue);
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            if (current2 !== null) {
              current2.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
          }
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            workInProgress2.dependencies = current2.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            {
              return null;
            }
          }
          cloneChildFibers(current2, workInProgress2);
          return workInProgress2.child;
        }
        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current2.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [current2];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(current2);
            }
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          var updateLanes = current2.lanes;
          if (includesSomeLane(updateLanes, renderLanes2)) {
            return true;
          }
          return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress2);
              var root3 = workInProgress2.stateNode;
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress2);
              break;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                pushContextProvider(workInProgress2);
              }
              break;
            }
            case HostPortal:
              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
              break;
            case ContextProvider: {
              var newValue = workInProgress2.memoizedProps.value;
              var context = workInProgress2.type._context;
              pushProvider(workInProgress2, context, newValue);
              break;
            }
            case Profiler:
              {
                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (hasChildWork) {
                  workInProgress2.flags |= Update;
                }
                {
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0;
                  stateNode.passiveEffectDuration = 0;
                }
              }
              break;
            case SuspenseComponent: {
              var state = workInProgress2.memoizedState;
              if (state !== null) {
                if (state.dehydrated !== null) {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  workInProgress2.flags |= DidCapture;
                  return null;
                }
                var primaryChildFragment = workInProgress2.child;
                var primaryChildLanes = primaryChildFragment.childLanes;
                if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                  return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  if (child !== null) {
                    return child.sibling;
                  } else {
                    return null;
                  }
                }
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              }
              break;
            }
            case SuspenseListComponent: {
              var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (didSuspendBefore) {
                if (_hasChildWork) {
                  return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                }
                workInProgress2.flags |= DidCapture;
              }
              var renderState = workInProgress2.memoizedState;
              if (renderState !== null) {
                renderState.rendering = null;
                renderState.tail = null;
                renderState.lastEffect = null;
              }
              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
              if (_hasChildWork) {
                break;
              } else {
                return null;
              }
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              workInProgress2.lanes = NoLanes;
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          {
            if (workInProgress2._debugNeedsRemount && current2 !== null) {
              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current2 !== null) {
            var oldProps = current2.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
            workInProgress2.type !== current2.type) {
              didReceiveUpdate = true;
            } else {
              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
              if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
              // may not be work scheduled on `current`, so we check for this flag.
              (workInProgress2.flags & DidCapture) === NoFlags) {
                didReceiveUpdate = false;
                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
              }
              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
            if (getIsHydrating() && isForkedChild(workInProgress2)) {
              var slotIndex = workInProgress2.index;
              var numberOfForks = getForksAtLevel();
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
            }
            case FunctionComponent: {
              var Component = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
              return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
              return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current2, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current2, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current2, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current2, workInProgress2, renderLanes2);
            case ForwardRef: {
              var type = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
              return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
            }
            case Fragment:
              return updateFragment(current2, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current2, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current2, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current2, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current2, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      _resolvedProps3,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(_type2)
                    );
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
              return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden3) {
            var node = workInProgress2.child;
            while (node !== null) {
              if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node.stateNode);
              } else if (node.tag === HostPortal)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          };
          updateHostContainer = function(current2, workInProgress2) {
          };
          updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
            var oldProps = current2.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance2 = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance2, type, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function bubbleProperties(completedWork) {
          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
          var newChildLanes = NoLanes;
          var subtreeFlags = NoFlags;
          if (!didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                subtreeFlags |= child.subtreeFlags;
                subtreeFlags |= child.flags;
                actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                subtreeFlags |= _child.subtreeFlags;
                subtreeFlags |= _child.flags;
                _child.return = completedWork;
                _child = _child.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          } else {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var _treeBaseDuration = completedWork.selfBaseDuration;
              var _child2 = completedWork.child;
              while (_child2 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                subtreeFlags |= _child2.flags & StaticMask;
                _treeBaseDuration += _child2.treeBaseDuration;
                _child2 = _child2.sibling;
              }
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else {
              var _child3 = completedWork.child;
              while (_child3 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                subtreeFlags |= _child3.flags & StaticMask;
                _child3.return = completedWork;
                _child3 = _child3.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          }
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
            warnIfUnhydratedTailNodes(workInProgress2);
            resetHydrationState();
            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
            return false;
          }
          var wasHydrated = popHydrationState(workInProgress2);
          if (nextState !== null && nextState.dehydrated !== null) {
            if (current2 === null) {
              if (!wasHydrated) {
                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              }
              prepareToHydrateHostSuspenseInstance(workInProgress2);
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var isTimedOutSuspense = nextState !== null;
                  if (isTimedOutSuspense) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            } else {
              resetHydrationState();
              if ((workInProgress2.flags & DidCapture) === NoFlags) {
                workInProgress2.memoizedState = null;
              }
              workInProgress2.flags |= Update;
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var _isTimedOutSuspense = nextState !== null;
                  if (_isTimedOutSuspense) {
                    var _primaryChildFragment = workInProgress2.child;
                    if (_primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            }
          } else {
            upgradeHydrationErrorsToRecoverable();
            return true;
          }
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              bubbleProperties(workInProgress2);
              return null;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostRoot: {
              var fiberRoot = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current2 === null || current2.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else {
                  if (current2 !== null) {
                    var prevState = current2.memoizedState;
                    if (
                      // Check if this is a client root
                      !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                      (workInProgress2.flags & ForceClientRender) !== NoFlags
                    ) {
                      workInProgress2.flags |= Snapshot;
                      upgradeHydrationErrorsToRecoverable();
                    }
                  }
                }
              }
              updateHostContainer(current2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress2.type;
              if (current2 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                if (current2.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance2 = createInstance2(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance2, workInProgress2, false, false);
                  workInProgress2.stateNode = instance2;
                  if (finalizeInitialChildren(instance2, type, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current2 && workInProgress2.stateNode != null) {
                var oldText = current2.memoizedProps;
                updateHostText$1(current2, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                if (!fallthroughToNormalSuspensePath) {
                  if (workInProgress2.flags & ShouldCapture) {
                    return workInProgress2;
                  } else {
                    return null;
                  }
                }
              }
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
              if (nextDidTimeout !== prevDidTimeout) {
                if (nextDidTimeout) {
                  var _offscreenFiber2 = workInProgress2.child;
                  _offscreenFiber2.flags |= Visibility;
                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
              }
              var wakeables = workInProgress2.updateQueue;
              if (wakeables !== null) {
                workInProgress2.flags |= Update;
              }
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  if (nextDidTimeout) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(current2, workInProgress2);
              if (current2 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              bubbleProperties(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                bubbleProperties(workInProgress2);
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThenables = suspended.updateQueue;
                        if (newThenables !== null) {
                          workInProgress2.updateQueue = newThenables;
                          workInProgress2.flags |= Update;
                        }
                        workInProgress2.subtreeFlags = NoFlags;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThenables = _suspended.updateQueue;
                    if (_newThenables !== null) {
                      workInProgress2.updateQueue = _newThenables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                  } else if (
                    // The time it took to render last row is greater than the remaining
                    // time we have to render. So rendering one more row would likely
                    // exceed it.
                    now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                  ) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next2 = renderState.tail;
                renderState.rendering = next2;
                renderState.tail = next2.sibling;
                renderState.renderingStartTime = now();
                next2.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next2;
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              var _nextState = workInProgress2.memoizedState;
              var nextIsHidden = _nextState !== null;
              if (current2 !== null) {
                var _prevState = current2.memoizedState;
                var prevIsHidden = _prevState !== null;
                if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                !enableLegacyHidden) {
                  workInProgress2.flags |= Visibility;
                }
              }
              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                bubbleProperties(workInProgress2);
              } else {
                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                  bubbleProperties(workInProgress2);
                  {
                    if (workInProgress2.subtreeFlags & (Placement | Update)) {
                      workInProgress2.flags |= Visibility;
                    }
                  }
                }
              }
              return null;
            }
            case CacheComponent: {
              return null;
            }
            case TracingMarkerComponent: {
              return null;
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function unwindWork(current2, workInProgress2, renderLanes2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              var root3 = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null && suspenseState.dehydrated !== null) {
                if (workInProgress2.alternate === null) {
                  throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                }
                resetHydrationState();
              }
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            case CacheComponent:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              var root3 = interruptedWork.stateNode;
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              var context = interruptedWork.type._context;
              popProvider(context, interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error3) {
          {
            invokeGuardedCallback(null, function() {
              throw error3;
            });
            clearCaughtError();
          }
        }
        var callComponentWillUnmountWithTimer = function(current2, instance2) {
          instance2.props = current2.memoizedProps;
          instance2.state = current2.memoizedState;
          if (current2.mode & ProfileMode) {
            try {
              startLayoutEffectTimer();
              instance2.componentWillUnmount();
            } finally {
              recordLayoutEffectDuration(current2);
            }
          } else {
            instance2.componentWillUnmount();
          }
        };
        function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
          try {
            commitHookEffectListMount(Layout2, current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance2) {
          try {
            callComponentWillUnmountWithTimer(current2, instance2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance2) {
          try {
            instance2.componentDidMount();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            commitAttachRef(current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref;
          if (ref !== null) {
            if (typeof ref === "function") {
              var retVal;
              try {
                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(null);
                  } finally {
                    recordLayoutEffectDuration(current2);
                  }
                } else {
                  retVal = ref(null);
                }
              } catch (error3) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error3);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                }
              }
            } else {
              ref.current = null;
            }
          }
        }
        function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root3, firstChild) {
          focusedInstanceHandle = prepareForCommit(root3.containerInfo);
          nextEffect = firstChild;
          commitBeforeMutationEffects_begin();
          var shouldFire = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          focusedInstanceHandle = null;
          return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitBeforeMutationEffects_complete();
            }
          }
        }
        function commitBeforeMutationEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              commitBeforeMutationEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          if ((flags & Snapshot) !== NoFlags) {
            setCurrentFiber(finishedWork);
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                break;
              }
              case ClassComponent: {
                if (current2 !== null) {
                  var prevProps = current2.memoizedProps;
                  var prevState = current2.memoizedState;
                  var instance2 = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance2.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance2.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  var snapshot = instance2.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                    }
                  }
                  instance2.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              }
              case HostRoot: {
                {
                  var root3 = finishedWork.stateNode;
                  clearContainer(root3.containerInfo);
                }
                break;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                break;
              default: {
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            resetCurrentFiber();
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect2 = firstEffect;
            do {
              if ((effect2.tag & flags) === flags) {
                var destroy = effect2.destroy;
                effect2.destroy = void 0;
                if (destroy !== void 0) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStarted(finishedWork);
                    } else if ((flags & Layout2) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStarted(finishedWork);
                    }
                  }
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStopped();
                    } else if ((flags & Layout2) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStopped();
                    }
                  }
                }
              }
              effect2 = effect2.next;
            } while (effect2 !== firstEffect);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect2 = firstEffect;
            do {
              if ((effect2.tag & flags) === flags) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStarted(finishedWork);
                  } else if ((flags & Layout2) !== NoFlags$1) {
                    markComponentLayoutEffectMountStarted(finishedWork);
                  }
                }
                var create4 = effect2.create;
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                effect2.destroy = create4();
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStopped();
                  } else if ((flags & Layout2) !== NoFlags$1) {
                    markComponentLayoutEffectMountStopped();
                  }
                }
                {
                  var destroy = effect2.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var hookName = void 0;
                    if ((effect2.tag & Layout2) !== NoFlags) {
                      hookName = "useLayoutEffect";
                    } else if ((effect2.tag & Insertion) !== NoFlags) {
                      hookName = "useInsertionEffect";
                    } else {
                      hookName = "useEffect";
                    }
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error2("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                  }
                }
              }
              effect2 = effect2.next;
            } while (effect2 !== firstEffect);
          }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
          {
            if ((finishedWork.flags & Update) !== NoFlags) {
              switch (finishedWork.tag) {
                case Profiler: {
                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                  var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                  var commitTime2 = getCommitTime();
                  var phase = finishedWork.alternate === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onPostCommit === "function") {
                    onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                  }
                  var parentFiber = finishedWork.return;
                  outer:
                    while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root3 = parentFiber.stateNode;
                          root3.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                  break;
                }
              }
            }
          }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
          if ((finishedWork.flags & LayoutMask) !== NoFlags) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListMount(Layout2 | HasEffect, finishedWork);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  } else {
                    commitHookEffectListMount(Layout2 | HasEffect, finishedWork);
                  }
                }
                break;
              }
              case ClassComponent: {
                var instance2 = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (!offscreenSubtreeWasHidden) {
                    if (current2 === null) {
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance2.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance2.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance2.componentDidMount();
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance2.componentDidMount();
                      }
                    } else {
                      var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                      var prevState = current2.memoizedState;
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance2.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance2.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance2.componentDidUpdate(prevProps, prevState, instance2.__reactInternalSnapshotBeforeUpdate);
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance2.componentDidUpdate(prevProps, prevState, instance2.__reactInternalSnapshotBeforeUpdate);
                      }
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance2.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance2.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance2);
                }
                break;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                break;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type, props);
                }
                break;
              }
              case HostText: {
                break;
              }
              case HostPortal: {
                break;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  var phase = current2 === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onRender === "function") {
                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                  }
                  {
                    if (typeof onCommit === "function") {
                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                    }
                    enqueuePendingPassiveProfilerEffect(finishedWork);
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root3 = parentFiber.stateNode;
                            root3.effectDuration += effectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += effectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                  }
                }
                break;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
              case TracingMarkerComponent: {
                break;
              }
              default:
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (!offscreenSubtreeWasHidden) {
            {
              if (finishedWork.flags & Ref) {
                commitAttachRef(finishedWork);
              }
            }
          }
        }
        function reappearLayoutEffectsOnFiber(node) {
          switch (node.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (node.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                } finally {
                  recordLayoutEffectDuration(node);
                }
              } else {
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              }
              break;
            }
            case ClassComponent: {
              var instance2 = node.stateNode;
              if (typeof instance2.componentDidMount === "function") {
                safelyCallComponentDidMount(node, node.return, instance2);
              }
              safelyAttachRef(node, node.return);
              break;
            }
            case HostComponent: {
              safelyAttachRef(node, node.return);
              break;
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden3) {
          var hostSubtreeRoot = null;
          {
            var node = finishedWork;
            while (true) {
              if (node.tag === HostComponent) {
                if (hostSubtreeRoot === null) {
                  hostSubtreeRoot = node;
                  try {
                    var instance2 = node.stateNode;
                    if (isHidden3) {
                      hideInstance(instance2);
                    } else {
                      unhideInstance(node.stateNode, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if (node.tag === HostText) {
                if (hostSubtreeRoot === null) {
                  try {
                    var _instance3 = node.stateNode;
                    if (isHidden3) {
                      hideTextInstance(_instance3);
                    } else {
                      unhideTextInstance(_instance3, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === finishedWork) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node = node.return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (ref !== null) {
            var instance2 = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance2);
                break;
              default:
                instanceToUse = instance2;
            }
            if (typeof ref === "function") {
              var retVal;
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(instanceToUse);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              } else {
                retVal = ref(instanceToUse);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                }
              }
            } else {
              {
                if (!ref.hasOwnProperty("current")) {
                  error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                }
              }
              ref.current = instanceToUse;
            }
          }
        }
        function detachFiberMutation(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.return = null;
          }
          fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            fiber.alternate = null;
            detachFiberAfterEffects(alternate);
          }
          {
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            if (fiber.tag === HostComponent) {
              var hostInstance = fiber.stateNode;
              if (hostInstance !== null) {
                detachDeletedInstance(hostInstance);
              }
            }
            fiber.stateNode = null;
            {
              fiber._debugOwner = null;
            }
            {
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
          }
        }
        function getHostParentFiber(fiber) {
          var parent = fiber.return;
          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }
            parent = parent.return;
          }
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node = fiber;
          siblings:
            while (true) {
              while (node.sibling === null) {
                if (node.return === null || isHostParent(node.return)) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
              while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                if (node.flags & Placement) {
                  continue siblings;
                }
                if (node.child === null || node.tag === HostPortal) {
                  continue siblings;
                } else {
                  node.child.return = node;
                  node = node.child;
                }
              }
              if (!(node.flags & Placement)) {
                return node.stateNode;
              }
            }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent = parentFiber.stateNode;
              if (parentFiber.flags & ContentReset) {
                resetTextContent(parent);
                parentFiber.flags &= ~ContentReset;
              }
              var before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo;
              var _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertInContainerBefore(parent, stateNode, before);
            } else {
              appendChildToContainer(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertBefore(parent, stateNode, before);
            } else {
              appendChild(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root3, returnFiber, deletedFiber) {
          {
            var parent = returnFiber;
            findParent:
              while (parent !== null) {
                switch (parent.tag) {
                  case HostComponent: {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break findParent;
                  }
                  case HostRoot: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                  case HostPortal: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                }
                parent = parent.return;
              }
            if (hostParent === null) {
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          }
          detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          var child = parent.child;
          while (child !== null) {
            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
            child = child.sibling;
          }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          onCommitUnmount(deletedFiber);
          switch (deletedFiber.tag) {
            case HostComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              }
            }
            case HostText: {
              {
                var prevHostParent = hostParent;
                var prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    removeChild(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case DehydratedFragment: {
              {
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case HostPortal: {
              {
                var _prevHostParent = hostParent;
                var _prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = _prevHostParent;
                hostParentIsContainer = _prevHostParentIsContainer;
              }
              return;
            }
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                var updateQueue = deletedFiber.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect2 = firstEffect;
                    do {
                      var _effect = effect2, destroy = _effect.destroy, tag = _effect.tag;
                      if (destroy !== void 0) {
                        if ((tag & Insertion) !== NoFlags$1) {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        } else if ((tag & Layout2) !== NoFlags$1) {
                          {
                            markComponentLayoutEffectUnmountStarted(deletedFiber);
                          }
                          if (deletedFiber.mode & ProfileMode) {
                            startLayoutEffectTimer();
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            recordLayoutEffectDuration(deletedFiber);
                          } else {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          }
                          {
                            markComponentLayoutEffectUnmountStopped();
                          }
                        }
                      }
                      effect2 = effect2.next;
                    } while (effect2 !== firstEffect);
                  }
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ClassComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var instance2 = deletedFiber.stateNode;
                if (typeof instance2.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance2);
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ScopeComponent: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case OffscreenComponent: {
              if (
                // TODO: Remove this dead flag
                deletedFiber.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              }
              break;
            }
            default: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
          }
        }
        function commitSuspenseCallback(finishedWork) {
          var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current2 = finishedWork.alternate;
            if (current2 !== null) {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                {
                  if (isDevToolsPresent) {
                    if (inProgressLanes !== null && inProgressRoot !== null) {
                      restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    } else {
                      throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                    }
                  }
                }
                wakeable.then(retry, retry);
              }
            });
          }
        }
        function commitMutationEffects(root3, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root3;
          setCurrentFiber(finishedWork);
          commitMutationEffectsOnFiber(finishedWork, root3);
          setCurrentFiber(finishedWork);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
          var deletions = parentFiber.deletions;
          if (deletions !== null) {
            for (var i9 = 0; i9 < deletions.length; i9++) {
              var childToDelete = deletions[i9];
              try {
                commitDeletionEffects(root3, parentFiber, childToDelete);
              } catch (error3) {
                captureCommitPhaseError(childToDelete, parentFiber, error3);
              }
            }
          }
          var prevDebugFiber = getCurrentFiber();
          if (parentFiber.subtreeFlags & MutationMask) {
            var child = parentFiber.child;
            while (child !== null) {
              setCurrentFiber(child);
              commitMutationEffectsOnFiber(child, root3);
              child = child.sibling;
            }
          }
          setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                try {
                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout2 | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  recordLayoutEffectDuration(finishedWork);
                } else {
                  try {
                    commitHookEffectListUnmount(Layout2 | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case ClassComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              return;
            }
            case HostComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              {
                if (finishedWork.flags & ContentReset) {
                  var instance2 = finishedWork.stateNode;
                  try {
                    resetTextContent(instance2);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
                if (flags & Update) {
                  var _instance4 = finishedWork.stateNode;
                  if (_instance4 != null) {
                    var newProps = finishedWork.memoizedProps;
                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                    var type = finishedWork.type;
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) {
                      try {
                        commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostText: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (finishedWork.stateNode === null) {
                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  var textInstance = finishedWork.stateNode;
                  var newText = finishedWork.memoizedProps;
                  var oldText = current2 !== null ? current2.memoizedProps : newText;
                  try {
                    commitTextUpdate(textInstance, oldText, newText);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case HostRoot: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (current2 !== null) {
                    var prevRootState = current2.memoizedState;
                    if (prevRootState.isDehydrated) {
                      try {
                        commitHydratedContainer(root3.containerInfo);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostPortal: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
            case SuspenseComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              var offscreenFiber = finishedWork.child;
              if (offscreenFiber.flags & Visibility) {
                var offscreenInstance = offscreenFiber.stateNode;
                var newState = offscreenFiber.memoizedState;
                var isHidden3 = newState !== null;
                offscreenInstance.isHidden = isHidden3;
                if (isHidden3) {
                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                  if (!wasHidden) {
                    markCommitTimeOfFallback();
                  }
                }
              }
              if (flags & Update) {
                try {
                  commitSuspenseCallback(finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case OffscreenComponent: {
              var _wasHidden = current2 !== null && current2.memoizedState !== null;
              if (
                // TODO: Remove this dead flag
                finishedWork.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                recursivelyTraverseMutationEffects(root3, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseMutationEffects(root3, finishedWork);
              }
              commitReconciliationEffects(finishedWork);
              if (flags & Visibility) {
                var _offscreenInstance = finishedWork.stateNode;
                var _newState = finishedWork.memoizedState;
                var _isHidden = _newState !== null;
                var offscreenBoundary = finishedWork;
                _offscreenInstance.isHidden = _isHidden;
                {
                  if (_isHidden) {
                    if (!_wasHidden) {
                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                        nextEffect = offscreenBoundary;
                        var offscreenChild = offscreenBoundary.child;
                        while (offscreenChild !== null) {
                          nextEffect = offscreenChild;
                          disappearLayoutEffects_begin(offscreenChild);
                          offscreenChild = offscreenChild.sibling;
                        }
                      }
                    }
                  }
                }
                {
                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                }
              }
              return;
            }
            case SuspenseListComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case ScopeComponent: {
              return;
            }
            default: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & Placement) {
            try {
              commitPlacement(finishedWork);
            } catch (error3) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error3);
            }
            finishedWork.flags &= ~Placement;
          }
          if (flags & Hydrating) {
            finishedWork.flags &= ~Hydrating;
          }
        }
        function commitLayoutEffects(finishedWork, root3, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root3;
          nextEffect = finishedWork;
          commitLayoutEffects_begin(finishedWork, root3, committedLanes);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent && isModernRoot) {
              var isHidden3 = fiber.memoizedState !== null;
              var newOffscreenSubtreeIsHidden = isHidden3 || offscreenSubtreeIsHidden;
              if (newOffscreenSubtreeIsHidden) {
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                continue;
              } else {
                var current2 = fiber.alternate;
                var wasHidden = current2 !== null && current2.memoizedState !== null;
                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                  nextEffect = fiber;
                  reappearLayoutEffects_begin(fiber);
                }
                var child = firstChild;
                while (child !== null) {
                  nextEffect = child;
                  commitLayoutEffects_begin(
                    child,
                    // New root; bubble back up to here and stop.
                    root3,
                    committedLanes
                  );
                  child = child.sibling;
                }
                nextEffect = fiber;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                continue;
              }
            }
            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
            }
          }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & LayoutMask) !== NoFlags) {
              var current2 = fiber.alternate;
              setCurrentFiber(fiber);
              try {
                commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (fiber.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout2, fiber, fiber.return);
                  } finally {
                    recordLayoutEffectDuration(fiber);
                  }
                } else {
                  commitHookEffectListUnmount(Layout2, fiber, fiber.return);
                }
                break;
              }
              case ClassComponent: {
                safelyDetachRef(fiber, fiber.return);
                var instance2 = fiber.stateNode;
                if (typeof instance2.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance2);
                }
                break;
              }
              case HostComponent: {
                safelyDetachRef(fiber, fiber.return);
                break;
              }
              case OffscreenComponent: {
                var isHidden3 = fiber.memoizedState !== null;
                if (isHidden3) {
                  disappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
                break;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              disappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent) {
              var isHidden3 = fiber.memoizedState !== null;
              if (isHidden3) {
                reappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              reappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              reappearLayoutEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountEffects(root3, finishedWork, committedLanes, committedTransitions) {
          nextEffect = finishedWork;
          commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root3, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions);
            }
          }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              try {
                commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                } finally {
                  recordPassiveEffectDuration(finishedWork);
                }
              } else {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffects(firstChild) {
          nextEffect = firstChild;
          commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
              var deletions = fiber.deletions;
              if (deletions !== null) {
                for (var i9 = 0; i9 < deletions.length; i9++) {
                  var fiberToDelete = deletions[i9];
                  nextEffect = fiberToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                }
                {
                  var previousFiber = fiber.alternate;
                  if (previousFiber !== null) {
                    var detachedChild = previousFiber.child;
                    if (detachedChild !== null) {
                      previousFiber.child = null;
                      do {
                        var detachedSibling = detachedChild.sibling;
                        detachedChild.sibling = null;
                        detachedChild = detachedSibling;
                      } while (detachedChild !== null);
                    }
                  }
                }
                nextEffect = fiber;
              }
            }
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffects_complete();
            }
          }
        }
        function commitPassiveUnmountEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              commitPassiveUnmountOnFiber(fiber);
              resetCurrentFiber();
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                recordPassiveEffectDuration(finishedWork);
              } else {
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
            resetCurrentFiber();
            var child = fiber.child;
            if (child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var sibling = fiber.sibling;
            var returnFiber = fiber.return;
            {
              detachFiberAfterEffects(fiber);
              if (fiber === deletedSubtreeRoot) {
                nextEffect = null;
                return;
              }
            }
            if (sibling !== null) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              return;
            }
            nextEffect = returnFiber;
          }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
          switch (current2.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (current2.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                recordPassiveEffectDuration(current2);
              } else {
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              }
              break;
            }
          }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Layout2 | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance2 = fiber.stateNode;
                try {
                  instance2.componentDidMount();
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Layout2 | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance2 = fiber.stateNode;
                if (typeof instance2.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance2);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
              }
            }
          }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          COMPONENT_TYPE = symbolFor("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor("selector.role");
          TEST_NAME_TYPE = symbolFor("selector.test_id");
          TEXT_TYPE = symbolFor("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            var jestIsDefined = typeof jest !== "undefined";
            return jestIsDefined && isReactActEnvironmentGlobal !== false;
          }
        }
        function isConcurrentActEnvironment() {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
              error2("The current testing environment is not configured to support act(...)");
            }
            return isReactActEnvironmentGlobal;
          }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = (
          /*             */
          0
        );
        var BatchedContext = (
          /*               */
          1
        );
        var RenderContext = (
          /*                */
          2
        );
        var CommitContext = (
          /*                */
          4
        );
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
            return pickArbitraryLane(workInProgressRootRenderLanes);
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (ReactCurrentBatchConfig$3.transition !== null) {
              var transition = ReactCurrentBatchConfig$3.transition;
              if (!transition._updatedFibers) {
                transition._updatedFibers = /* @__PURE__ */ new Set();
              }
              transition._updatedFibers.add(fiber);
            }
            if (currentEventTransitionLane === NoLane) {
              currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
          }
          var updateLane = getCurrentUpdatePriority();
          if (updateLane !== NoLane) {
            return updateLane;
          }
          var eventLane = getCurrentEventPriority();
          return eventLane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          }
          return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
          checkForNestedUpdates();
          {
            if (isRunningInsertionEffect) {
              error2("useInsertionEffect must not schedule updates.");
            }
          }
          {
            if (isFlushingPassiveEffects) {
              didScheduleUpdateDuringPassiveEffects = true;
            }
          }
          markRootUpdated(root3, lane, eventTime);
          if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
            warnAboutRenderPhaseUpdatesInDEV(fiber);
          } else {
            {
              if (isDevToolsPresent) {
                addFiberToLanesMap(root3, fiber, lane);
              }
            }
            warnIfUpdatesNotWrappedWithActDEV(fiber);
            if (root3 === workInProgressRoot) {
              if ((executionContext & RenderContext) === NoContext) {
                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root3, workInProgressRootRenderLanes);
              }
            }
            ensureRootIsScheduled(root3, eventTime);
            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
          var current2 = root3.current;
          current2.lanes = lane;
          markRootUpdated(root3, lane, eventTime);
          ensureRootIsScheduled(root3, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
          return (
            // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
            // decided not to enable it.
            (executionContext & RenderContext) !== NoContext
          );
        }
        function ensureRootIsScheduled(root3, currentTime) {
          var existingCallbackNode = root3.callbackNode;
          markStarvedLanesAsExpired(root3, currentTime);
          var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback$1(existingCallbackNode);
            }
            root3.callbackNode = null;
            root3.callbackPriority = NoLane;
            return;
          }
          var newCallbackPriority = getHighestPriorityLane(nextLanes);
          var existingCallbackPriority = root3.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
          // Scheduler task, rather than an `act` task, cancel it and re-scheduled
          // on the `act` queue.
          !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
            {
              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                error2("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return;
          }
          if (existingCallbackNode != null) {
            cancelCallback$1(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLane) {
            if (root3.tag === LegacyRoot) {
              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
              }
              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3));
            } else {
              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
            }
            {
              if (ReactCurrentActQueue$1.current !== null) {
                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
              } else {
                scheduleMicrotask(function() {
                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                  }
                });
              }
            }
            newCallbackNode = null;
          } else {
            var schedulerPriorityLevel;
            switch (lanesToEventPriority(nextLanes)) {
              case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriorityLevel = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriorityLevel = IdlePriority;
                break;
              default:
                schedulerPriorityLevel = NormalPriority;
                break;
            }
            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
          }
          root3.callbackPriority = newCallbackPriority;
          root3.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root3, didTimeout) {
          {
            resetNestedUpdateFlag();
          }
          currentEventTime = NoTimestamp;
          currentEventTransitionLane = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var originalCallbackNode = root3.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root3.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var shouldTimeSlice = !includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout;
          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes);
          if (exitStatus !== RootInProgress) {
            if (exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root3, NoLanes);
              markRootSuspended$1(root3, lanes);
              ensureRootIsScheduled(root3, now());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              markRootSuspended$1(root3, lanes);
            } else {
              var renderWasConcurrent = !includesBlockingLane(root3, lanes);
              var finishedWork = root3.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                exitStatus = renderRootSync(root3, lanes);
                if (exitStatus === RootErrored) {
                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                  if (_errorRetryLanes !== NoLanes) {
                    lanes = _errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes);
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  var _fatalError = workInProgressRootFatalError;
                  prepareFreshStack(root3, NoLanes);
                  markRootSuspended$1(root3, lanes);
                  ensureRootIsScheduled(root3, now());
                  throw _fatalError;
                }
              }
              root3.finishedWork = finishedWork;
              root3.finishedLanes = lanes;
              finishConcurrentRender(root3, exitStatus, lanes);
            }
          }
          ensureRootIsScheduled(root3, now());
          if (root3.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root3);
          }
          return null;
        }
        function recoverFromConcurrentError(root3, errorRetryLanes) {
          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
          if (isRootDehydrated(root3)) {
            var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes);
            rootWorkInProgress.flags |= ForceClientRender;
            {
              errorHydratingContainer(root3.containerInfo);
            }
          }
          var exitStatus = renderRootSync(root3, errorRetryLanes);
          if (exitStatus !== RootErrored) {
            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
            if (errorsFromSecondAttempt !== null) {
              queueRecoverableErrors(errorsFromSecondAttempt);
            }
          }
          return exitStatus;
        }
        function queueRecoverableErrors(errors) {
          if (workInProgressRootRecoverableErrors === null) {
            workInProgressRootRecoverableErrors = errors;
          } else {
            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
          }
        }
        function finishConcurrentRender(root3, exitStatus, lanes) {
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored: {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            case RootErrored: {
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root3, lanes);
              if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
              !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root3, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root3.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root3, suspendedLanes);
                    break;
                  }
                  root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root3, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootCompleted: {
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            default: {
              throw new Error("Unknown root exit status.");
            }
          }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          var node = finishedWork;
          while (true) {
            if (node.flags & StoreConsistency) {
              var updateQueue = node.updateQueue;
              if (updateQueue !== null) {
                var checks = updateQueue.stores;
                if (checks !== null) {
                  for (var i9 = 0; i9 < checks.length; i9++) {
                    var check = checks[i9];
                    var getSnapshot = check.getSnapshot;
                    var renderedValue = check.value;
                    try {
                      if (!objectIs(getSnapshot(), renderedValue)) {
                        return false;
                      }
                    } catch (error3) {
                      return false;
                    }
                  }
                }
              }
            }
            var child = node.child;
            if (node.subtreeFlags & StoreConsistency && child !== null) {
              child.return = node;
              node = child;
              continue;
            }
            if (node === finishedWork) {
              return true;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return true;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return true;
        }
        function markRootSuspended$1(root3, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
          markRootSuspended(root3, suspendedLanes);
        }
        function performSyncWorkOnRoot(root3) {
          {
            syncNestedUpdateFlag();
          }
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          flushPassiveEffects();
          var lanes = getNextLanes(root3, NoLanes);
          if (!includesSomeLane(lanes, SyncLane)) {
            ensureRootIsScheduled(root3, now());
            return null;
          }
          var exitStatus = renderRootSync(root3, lanes);
          if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root3, NoLanes);
            markRootSuspended$1(root3, lanes);
            ensureRootIsScheduled(root3, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          var finishedWork = root3.current.alternate;
          root3.finishedWork = finishedWork;
          root3.finishedLanes = lanes;
          commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
          ensureRootIsScheduled(root3, now());
          return null;
        }
        function flushRoot(root3, lanes) {
          if (lanes !== NoLanes) {
            markRootEntangled(root3, mergeLanes(lanes, SyncLane));
            ensureRootIsScheduled(root3, now());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbacks();
            }
          }
        }
        function batchedUpdates$1(fn, a7) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn(a7);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function discreteUpdates(fn, a7, b5, c8, d6) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            return fn(a7, b5, c8, d6);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            if (executionContext === NoContext) {
              resetRenderTimer();
            }
          }
        }
        function flushSync2(fn) {
          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushPassiveEffects();
          }
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            if (fn) {
              return fn();
            } else {
              return void 0;
            }
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            executionContext = prevExecutionContext;
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushSyncCallbacks();
            }
          }
        }
        function isAlreadyRendering() {
          return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
          push2(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop2(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root3, lanes) {
          root3.finishedWork = null;
          root3.finishedLanes = NoLanes;
          var timeoutHandle = root3.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root3.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              var current2 = interruptedWork.alternate;
              unwindInterruptedWork(current2, interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root3;
          var rootWorkInProgress = createWorkInProgress(root3.current, null);
          workInProgress = rootWorkInProgress;
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootInterleavedUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          workInProgressRootConcurrentErrors = null;
          workInProgressRootRecoverableErrors = null;
          finishQueueingConcurrentUpdates();
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
          return rootWorkInProgress;
        }
        function handleError(root3, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              if (enableSchedulingProfiler) {
                markComponentRenderStopped();
                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                  var wakeable = thrownValue;
                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                } else {
                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                }
              }
              throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError(error3) {
          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
            workInProgressRootExitStatus = RootErrored;
          }
          if (workInProgressRootConcurrentErrors === null) {
            workInProgressRootConcurrentErrors = [error3];
          } else {
            workInProgressRootConcurrentErrors.push(error3);
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root3, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root3, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            prepareFreshStack(root3, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root3, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root3, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root3, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            resetRenderTimer();
            prepareFreshStack(root3, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root3, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            {
              markRenderYielded();
            }
            return RootInProgress;
          } else {
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next2;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next2 === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next2;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current2 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next2 = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next2 = completeWork(current2, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next2 = completeWork(current2, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next2 !== null) {
                workInProgress = next2;
                return;
              }
            } else {
              var _next = unwindWork(current2, completedWork);
              if (_next !== null) {
                _next.flags &= HostEffectMask;
                workInProgress = _next;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.flags |= Incomplete;
                returnFiber.subtreeFlags = NoFlags;
                returnFiber.deletions = null;
              } else {
                workInProgressRootExitStatus = RootDidNotComplete;
                workInProgress = null;
                return;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function commitRoot(root3, recoverableErrors, transitions) {
          var previousUpdateLanePriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority);
          } finally {
            ReactCurrentBatchConfig$3.transition = prevTransition;
            setCurrentUpdatePriority(previousUpdateLanePriority);
          }
          return null;
        }
        function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var finishedWork = root3.finishedWork;
          var lanes = root3.finishedLanes;
          {
            markCommitStarted(lanes);
          }
          if (finishedWork === null) {
            {
              markCommitStopped();
            }
            return null;
          } else {
            {
              if (lanes === NoLanes) {
                error2("root.finishedLanes should not be empty during a commit. This is a bug in React.");
              }
            }
          }
          root3.finishedWork = null;
          root3.finishedLanes = NoLanes;
          if (finishedWork === root3.current) {
            throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          }
          root3.callbackNode = null;
          root3.callbackPriority = NoLane;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root3, remainingLanes);
          if (root3 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              pendingPassiveTransitions = transitions;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          if (subtreeHasEffects || rootHasEffect) {
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            ReactCurrentBatchConfig$3.transition = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(DiscreteEventPriority);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            ReactCurrentOwner$2.current = null;
            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root3, finishedWork);
            {
              recordCommitTime();
            }
            commitMutationEffects(root3, finishedWork, lanes);
            resetAfterCommit(root3.containerInfo);
            root3.current = finishedWork;
            {
              markLayoutEffectsStarted(lanes);
            }
            commitLayoutEffects(finishedWork, root3, lanes);
            {
              markLayoutEffectsStopped();
            }
            requestPaint();
            executionContext = prevExecutionContext;
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          } else {
            root3.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root3;
            pendingPassiveEffectsLanes = lanes;
          } else {
            {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
            }
          }
          remainingLanes = root3.pendingLanes;
          if (remainingLanes === NoLanes) {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              commitDoubleInvokeEffectsInDEV(root3.current, false);
            }
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            if (isDevToolsPresent) {
              root3.memoizedUpdaters.clear();
            }
          }
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root3, now());
          if (recoverableErrors !== null) {
            var onRecoverableError = root3.onRecoverableError;
            for (var i9 = 0; i9 < recoverableErrors.length; i9++) {
              var recoverableError = recoverableErrors[i9];
              var componentStack = recoverableError.stack;
              var digest2 = recoverableError.digest;
              onRecoverableError(recoverableError.value, {
                componentStack,
                digest: digest2
              });
            }
          }
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var error$1 = firstUncaughtError;
            firstUncaughtError = null;
            throw error$1;
          }
          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
            flushPassiveEffects();
          }
          remainingLanes = root3.pendingLanes;
          if (includesSomeLane(remainingLanes, SyncLane)) {
            {
              markNestedUpdateScheduled();
            }
            if (root3 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root3;
            }
          } else {
            nestedUpdateCount = 0;
          }
          flushSyncCallbacks();
          {
            markCommitStopped();
          }
          return null;
        }
        function flushPassiveEffects() {
          if (rootWithPendingPassiveEffects !== null) {
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(priority);
              return flushPassiveEffectsImpl();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            }
          }
          return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
          {
            pendingPassiveProfilerEffects.push(fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var transitions = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root3 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Cannot flush passive effects while already rendering.");
          }
          {
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          {
            markPassiveEffectsStarted(lanes);
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountEffects(root3.current);
          commitPassiveMountEffects(root3, root3.current, lanes, transitions);
          {
            var profilerEffects = pendingPassiveProfilerEffects;
            pendingPassiveProfilerEffects = [];
            for (var i9 = 0; i9 < profilerEffects.length; i9++) {
              var _fiber = profilerEffects[i9];
              commitPassiveEffectDurations(root3, _fiber);
            }
          }
          {
            markPassiveEffectsStopped();
          }
          {
            commitDoubleInvokeEffectsInDEV(root3.current, true);
          }
          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          {
            if (didScheduleUpdateDuringPassiveEffects) {
              if (root3 === rootWithPassiveNestedUpdates) {
                nestedPassiveUpdateCount++;
              } else {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = root3;
              }
            } else {
              nestedPassiveUpdateCount = 0;
            }
            isFlushingPassiveEffects = false;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          onPostCommitRoot(root3);
          {
            var stateNode = root3.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance2) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance2);
        }
        function markLegacyErrorBoundaryAsFailed(instance2) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance2]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance2);
          }
        }
        function prepareToThrowUncaughtError(error3) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error3;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
          var errorInfo = createCapturedValueAtFiber(error3, sourceFiber);
          var update2 = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          var root3 = enqueueUpdate(rootFiber, update2, SyncLane);
          var eventTime = requestEventTime();
          if (root3 !== null) {
            markRootUpdated(root3, SyncLane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
          {
            reportUncaughtErrorInDEV(error$1);
            setIsRunningInsertionEffect(false);
          }
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
            return;
          }
          var fiber = null;
          {
            fiber = nearestMountedAncestor;
          }
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance2 = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2)) {
                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                var update2 = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                var root3 = enqueueUpdate(fiber, update2, SyncLane);
                var eventTime = requestEventTime();
                if (root3 !== null) {
                  markRootUpdated(root3, SyncLane, eventTime);
                  ensureRootIsScheduled(root3, eventTime);
                }
                return;
              }
            }
            fiber = fiber.return;
          }
          {
            error2("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
          }
        }
        function pingSuspendedRoot(root3, wakeable, pingedLanes) {
          var pingCache = root3.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root3, pingedLanes);
          warnIfSuspenseResolutionNotWrappedWithActDEV(root3);
          if (workInProgressRoot === root3 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root3, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root3, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          if (root3 !== null) {
            markRootUpdated(root3, retryLane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState;
          var retryLane = NoLane;
          if (suspenseState !== null) {
            retryLane = suspenseState.retryLane;
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
              }
              break;
            case SuspenseListComponent:
              retryCache = boundaryFiber.stateNode;
              break;
            default:
              throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
              error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
          {
            setCurrentFiber(fiber);
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
            }
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
            }
            resetCurrentFiber();
          }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
          {
            var current2 = firstChild;
            var subtreeRoot = null;
            while (current2 !== null) {
              var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
              if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                current2 = current2.child;
              } else {
                if ((current2.flags & fiberFlags) !== NoFlags) {
                  invokeEffectFn(current2);
                }
                if (current2.sibling !== null) {
                  current2 = current2.sibling;
                } else {
                  current2 = subtreeRoot = current2.return;
                }
              }
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & ConcurrentMode)) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
              return;
            }
            var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
            }
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current2, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current2, unitOfWork, lanes);
            } catch (originalError) {
              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(current2, unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                  originalError._suppressLogging = true;
                }
              }
              throw originalError;
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                    error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        function restorePendingUpdaters(root3, lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              memoizedUpdaters.forEach(function(schedulingFiber) {
                addFiberToLanesMap(root3, schedulingFiber, lanes);
              });
            }
          }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
          {
            var actQueue = ReactCurrentActQueue$1.current;
            if (actQueue !== null) {
              actQueue.push(callback);
              return fakeActCallbackNode;
            } else {
              return scheduleCallback(priorityLevel, callback);
            }
          }
        }
        function cancelCallback$1(callbackNode) {
          if (callbackNode === fakeActCallbackNode) {
            return;
          }
          return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
          return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          {
            if (fiber.mode & ConcurrentMode) {
              if (!isConcurrentActEnvironment()) {
                return;
              }
            } else {
              if (!isLegacyActEnvironment()) {
                return;
              }
              if (executionContext !== NoContext) {
                return;
              }
              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                return;
              }
            }
            if (ReactCurrentActQueue$1.current === null) {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
          {
            if (root3.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
              error2("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
            }
          }
        }
        function setIsRunningInsertionEffect(isRunning) {
          {
            isRunningInsertionEffect = isRunning;
          }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              return type;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type) {
          return resolveFunctionForHotReloading(type);
        }
        function resolveForwardRefForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              if (type !== null && type !== void 0 && typeof type.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type.render);
                if (type.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: currentRender
                  };
                  if (type.displayName !== void 0) {
                    syntheticType.displayName = type.displayName;
                  }
                  return syntheticType;
                }
              }
              return type;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = /* @__PURE__ */ new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root3, update2) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update2.staleFamilies, updatedFamilies = update2.updatedFamilies;
            flushPassiveEffects();
            flushSync2(function() {
              scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root3, element) {
          {
            if (root3.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync2(function() {
              updateContainer(element, root3, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (_root !== null) {
                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
              }
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root3, families) {
          {
            var hostInstances = /* @__PURE__ */ new Set();
            var types2 = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root3.current, types2, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types2.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node = fiber;
            while (true) {
              switch (node.tag) {
                case HostComponent:
                  hostInstances.add(node.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
              }
              if (node.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node = node.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node.stateNode);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return foundHostInstances;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === fiber) {
                  return foundHostInstances;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e5) {
            hasBadMapPolyfill = true;
          }
        }
        function FiberNode(tag, pendingProps, key3, mode) {
          this.tag = tag;
          this.key = key3;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key3, mode) {
          return new FiberNode(tag, pendingProps, key3, mode);
        };
        function shouldConstruct$1(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type) {
          return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component) {
          if (typeof Component === "function") {
            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
          } else if (Component !== void 0 && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              return ForwardRef;
            }
            if ($$typeof === REACT_MEMO_TYPE) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
            workInProgress2.elementType = current2.elementType;
            workInProgress2.type = current2.type;
            workInProgress2.stateNode = current2.stateNode;
            {
              workInProgress2._debugSource = current2._debugSource;
              workInProgress2._debugOwner = current2._debugOwner;
              workInProgress2._debugHookTypes = current2._debugHookTypes;
            }
            workInProgress2.alternate = current2;
            current2.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current2.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.flags = current2.flags & StaticMask;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current2.type);
                break;
              case ForwardRef:
                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= StaticMask | Placement;
          var current2 = workInProgress2.alternate;
          if (current2 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.type = current2.type;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode;
            if (isStrictMode === true) {
              mode |= StrictLegacyMode;
              {
                mode |= StrictEffectsMode;
              }
            }
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type, key3, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type;
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type === "string") {
            fiberTag = HostComponent;
          } else {
            getTag:
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key3);
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictLegacyMode;
                  if ((mode & ConcurrentMode) !== NoMode) {
                    mode |= StrictEffectsMode;
                  }
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key3);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key3);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key3);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key3);
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_SCOPE_TYPE:
                case REACT_CACHE_TYPE:
                case REACT_TRACING_MARKER_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                default: {
                  if (typeof type === "object" && type !== null) {
                    switch (type.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                }
              }
          }
          var fiber = createFiber(fiberTag, pendingProps, key3, mode);
          fiber.elementType = type;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
          var owner = null;
          {
            owner = element._owner;
          }
          var type = element.type;
          var key3 = element.key;
          var pendingProps = element.props;
          var fiber = createFiberFromTypeAndProps(type, key3, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element._source;
            fiber._debugOwner = element._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key3) {
          var fiber = createFiber(Fragment, elements, key3, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key3) {
          {
            if (typeof pendingProps.id !== "string") {
              error2('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key3, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key3) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key3, mode);
          fiber.elementType = REACT_SUSPENSE_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key3) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key3, mode);
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key3) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key3, mode);
          fiber.elementType = REACT_OFFSCREEN_TYPE;
          fiber.lanes = lanes;
          var primaryChildInstance = {
            isHidden: false
          };
          fiber.stateNode = primaryChildInstance;
          return fiber;
        }
        function createFiberFromText(content, mode, lanes) {
          var fiber = createFiber(HostText, content, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(DehydratedFragment, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            // Used by persistent updates
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source2) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source2.tag;
          target.key = source2.key;
          target.elementType = source2.elementType;
          target.type = source2.type;
          target.stateNode = source2.stateNode;
          target.return = source2.return;
          target.child = source2.child;
          target.sibling = source2.sibling;
          target.index = source2.index;
          target.ref = source2.ref;
          target.pendingProps = source2.pendingProps;
          target.memoizedProps = source2.memoizedProps;
          target.updateQueue = source2.updateQueue;
          target.memoizedState = source2.memoizedState;
          target.dependencies = source2.dependencies;
          target.mode = source2.mode;
          target.flags = source2.flags;
          target.subtreeFlags = source2.subtreeFlags;
          target.deletions = source2.deletions;
          target.lanes = source2.lanes;
          target.childLanes = source2.childLanes;
          target.alternate = source2.alternate;
          {
            target.actualDuration = source2.actualDuration;
            target.actualStartTime = source2.actualStartTime;
            target.selfBaseDuration = source2.selfBaseDuration;
            target.treeBaseDuration = source2.treeBaseDuration;
          }
          target._debugSource = source2._debugSource;
          target._debugOwner = source2._debugOwner;
          target._debugNeedsRemount = source2._debugNeedsRemount;
          target._debugHookTypes = source2._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.callbackNode = null;
          this.callbackPriority = NoLane;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          this.identifierPrefix = identifierPrefix;
          this.onRecoverableError = onRecoverableError;
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.effectDuration = 0;
            this.passiveEffectDuration = 0;
          }
          {
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
            for (var _i = 0; _i < TotalLanes; _i++) {
              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
            }
          }
          {
            switch (tag) {
              case ConcurrentRoot:
                this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var root3 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
          root3.current = uninitializedFiber;
          uninitializedFiber.stateNode = root3;
          {
            var _initialState = {
              element: initialChildren,
              isDehydrated: hydrate2,
              cache: null,
              // not enabled yet
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            uninitializedFiber.memoizedState = _initialState;
          }
          initializeUpdateQueue(uninitializedFiber);
          return root3;
        }
        var ReactVersion = "18.2.0";
        function createPortal(children, containerInfo, implementation) {
          var key3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          {
            checkKeyStringCoercion(key3);
          }
          return {
            // This tag allow us to uniquely identify this as a React Portal
            $$typeof: REACT_PORTAL_TYPE,
            key: key3 == null ? null : "" + key3,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get4(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) {
              return processChildContext(fiber, Component, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component7, methodName) {
          {
            var fiber = get4(component7);
            if (fiber === void 0) {
              if (typeof component7.render === "function") {
                throw new Error("Unable to find node on an unmounted component.");
              } else {
                var keys = Object.keys(component7).join(",");
                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictLegacyMode) {
              var componentName = getComponentNameFromFiber(fiber) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictLegacyMode) {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = false;
          var initialChildren = null;
          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = true;
          var root3 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          root3.context = getContextForSubtree(null);
          var current2 = root3.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current2);
          var update2 = createUpdate(eventTime, lane);
          update2.callback = callback !== void 0 && callback !== null ? callback : null;
          enqueueUpdate(current2, update2, lane);
          scheduleInitialHydrationOnRoot(root3, lane, eventTime);
          return root3;
        }
        function updateContainer(element, container, parentComponent, callback) {
          {
            onScheduleRoot(container, element);
          }
          var current$1 = container.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current$1);
          {
            markRenderScheduled(lane);
          }
          var context = getContextForSubtree(parentComponent);
          if (container.context === null) {
            container.context = context;
          } else {
            container.pendingContext = context;
          }
          {
            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
            }
          }
          var update2 = createUpdate(eventTime, lane);
          update2.payload = {
            element
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update2.callback = callback;
          }
          var root3 = enqueueUpdate(current$1, update2, lane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, current$1, lane, eventTime);
            entangleTransitions(root3, current$1, lane);
          }
          return lane;
        }
        function getPublicRootInstance(container) {
          var containerFiber = container.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function attemptSynchronousHydration$1(fiber) {
          switch (fiber.tag) {
            case HostRoot: {
              var root3 = fiber.stateNode;
              if (isRootDehydrated(root3)) {
                var lanes = getHighestPriorityPendingLanes(root3);
                flushRoot(root3, lanes);
              }
              break;
            }
            case SuspenseComponent: {
              flushSync2(function() {
                var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root4 !== null) {
                  var eventTime = requestEventTime();
                  scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime);
                }
              });
              var retryLane = SyncLane;
              markRetryLaneIfNotHydrated(fiber, retryLane);
              break;
            }
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = SelectiveHydrationLane;
          var root3 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root3 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = requestUpdateLane(fiber);
          var root3 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root3 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        var shouldErrorImpl = function(fiber) {
          return null;
        };
        function shouldError(fiber) {
          return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path2, index8) {
            var key3 = path2[index8];
            var updated2 = isArray(obj) ? obj.slice() : assign({}, obj);
            if (index8 + 1 === path2.length) {
              if (isArray(updated2)) {
                updated2.splice(key3, 1);
              } else {
                delete updated2[key3];
              }
              return updated2;
            }
            updated2[key3] = copyWithDeleteImpl(obj[key3], path2, index8 + 1);
            return updated2;
          };
          var copyWithDelete = function(obj, path2) {
            return copyWithDeleteImpl(obj, path2, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index8) {
            var oldKey = oldPath[index8];
            var updated2 = isArray(obj) ? obj.slice() : assign({}, obj);
            if (index8 + 1 === oldPath.length) {
              var newKey = newPath[index8];
              updated2[newKey] = updated2[oldKey];
              if (isArray(updated2)) {
                updated2.splice(oldKey, 1);
              } else {
                delete updated2[oldKey];
              }
            } else {
              updated2[oldKey] = copyWithRenameImpl(
                // $FlowFixMe number or string is fine here
                obj[oldKey],
                oldPath,
                newPath,
                index8 + 1
              );
            }
            return updated2;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn2("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i9 = 0; i9 < newPath.length - 1; i9++) {
                if (oldPath[i9] !== newPath[i9]) {
                  warn2("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path2, index8, value) {
            if (index8 >= path2.length) {
              return value;
            }
            var key3 = path2[index8];
            var updated2 = isArray(obj) ? obj.slice() : assign({}, obj);
            updated2[key3] = copyWithSetImpl(obj[key3], path2, index8 + 1, value);
            return updated2;
          };
          var copyWithSet = function(obj, path2, value) {
            return copyWithSetImpl(obj, path2, 0, value);
          };
          var findHook = function(fiber, id) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id > 0) {
              currentHook2 = currentHook2.next;
              id--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id, path2, value) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path2, value);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateDeletePath = function(fiber, id, path2) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path2);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideProps = function(fiber, path2, value) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path2, value);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsDeletePath = function(fiber, path2) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path2);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          scheduleUpdate = function(fiber) {
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance2) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setErrorHandler,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            // React Refresh
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            // Enables DevTools to append owner stacks to error messages in DEV mode.
            getCurrentFiber: getCurrentFiberForDevTools,
            // Enables DevTools to detect reconciler version rather than renderer version
            // which may not match for third party renderers.
            reconcilerVersion: ReactVersion
          });
        }
        var defaultOnRecoverableError = typeof reportError === "function" ? (
          // In modern browsers, reportError will dispatch an error event,
          // emulating an uncaught JavaScript error.
          reportError
        ) : function(error3) {
          console["error"](error3);
        };
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root3 = this._internalRoot;
          if (root3 === null) {
            throw new Error("Cannot update an unmounted root.");
          }
          {
            if (typeof arguments[1] === "function") {
              error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            } else if (isValidContainer(arguments[1])) {
              error2("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
            } else if (typeof arguments[1] !== "undefined") {
              error2("You passed a second argument to root.render(...) but it only accepts one argument.");
            }
            var container = root3.containerInfo;
            if (container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root3.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root3, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root3 = this._internalRoot;
          if (root3 !== null) {
            this._internalRoot = null;
            var container = root3.containerInfo;
            {
              if (isAlreadyRendering()) {
                error2("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
              }
            }
            flushSync2(function() {
              updateContainer(null, root3, null, null);
            });
            unmarkContainerAsRoot(container);
          }
        };
        function createRoot(container, options4) {
          if (!isValidContainer(container)) {
            throw new Error("createRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          var transitionCallbacks = null;
          if (options4 !== null && options4 !== void 0) {
            {
              if (options4.hydrate) {
                warn2("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
              } else {
                if (typeof options4 === "object" && options4 !== null && options4.$$typeof === REACT_ELEMENT_TYPE) {
                  error2("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                }
              }
            }
            if (options4.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options4.identifierPrefix !== void 0) {
              identifierPrefix = options4.identifierPrefix;
            }
            if (options4.onRecoverableError !== void 0) {
              onRecoverableError = options4.onRecoverableError;
            }
            if (options4.transitionCallbacks !== void 0) {
              transitionCallbacks = options4.transitionCallbacks;
            }
          }
          var root3 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root3.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          return new ReactDOMRoot(root3);
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
          if (target) {
            queueExplicitHydrationTarget(target);
          }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container, initialChildren, options4) {
          if (!isValidContainer(container)) {
            throw new Error("hydrateRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          {
            if (initialChildren === void 0) {
              error2("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            }
          }
          var hydrationCallbacks = options4 != null ? options4 : null;
          var mutableSources = options4 != null && options4.hydratedSources || null;
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          if (options4 !== null && options4 !== void 0) {
            if (options4.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options4.identifierPrefix !== void 0) {
              identifierPrefix = options4.identifierPrefix;
            }
            if (options4.onRecoverableError !== void 0) {
              onRecoverableError = options4.onRecoverableError;
            }
          }
          var root3 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root3.current, container);
          listenToAllSupportedEvents(container);
          if (mutableSources) {
            for (var i9 = 0; i9 < mutableSources.length; i9++) {
              var mutableSource = mutableSources[i9];
              registerMutableSourceForHydration(root3, mutableSource);
            }
          }
          return new ReactDOMHydrationRoot(root3);
        }
        function isValidContainer(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
        }
        function warnIfReactDOMContainerInDEV(container) {
          {
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error2("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
            }
            if (isContainerMarkedAsRoot(container)) {
              if (container._reactRootContainer) {
                error2("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
              } else {
                error2("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
              }
            }
          }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
          topLevelUpdateWarnings = function(container) {
            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container) {
          if (!container) {
            return null;
          }
          if (container.nodeType === DOCUMENT_NODE) {
            return container.documentElement;
          } else {
            return container.firstChild;
          }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
          if (isHydrationContainer) {
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance2 = getPublicRootInstance(root3);
                originalCallback.call(instance2);
              };
            }
            var root3 = createHydrationContainer(
              initialChildren,
              callback,
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = root3;
            markContainerAsRoot(root3.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            flushSync2();
            return root3;
          } else {
            var rootSibling;
            while (rootSibling = container.lastChild) {
              container.removeChild(rootSibling);
            }
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance2 = getPublicRootInstance(_root);
                _originalCallback.call(instance2);
              };
            }
            var _root = createContainer(
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = _root;
            markContainerAsRoot(_root.current, container);
            var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(_rootContainerElement);
            flushSync2(function() {
              updateContainer(initialChildren, _root, parentComponent, callback);
            });
            return _root;
          }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var maybeRoot = container._reactRootContainer;
          var root3;
          if (!maybeRoot) {
            root3 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
          } else {
            root3 = maybeRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance2 = getPublicRootInstance(root3);
                originalCallback.call(instance2);
              };
            }
            updateContainer(children, root3, parentComponent, callback);
          }
          return getPublicRootInstance(root3);
        }
        function findDOMNode(componentOrElement) {
          {
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate(element, container, callback) {
          {
            error2("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
        }
        function render2(element, container, callback) {
          {
            error2("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          {
            error2("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(containerNode)) {
            throw new Error("Target container is not a DOM element.");
          }
          if (parentComponent == null || !has2(parentComponent)) {
            throw new Error("parentComponent must be a valid React Component");
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        function unmountComponentAtNode(container) {
          if (!isValidContainerLegacy(container)) {
            throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            flushSync2(function() {
              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                container._reactRootContainer = null;
                unmarkContainerAsRoot(container);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
          if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
          Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
          Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync2);
        function createPortal$1(children, container) {
          var key3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          return createPortal(children, container, null, key3);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        var Internals = {
          usingClientEntryPoint: false,
          // Keep in sync with ReactTestUtils.js.
          // This is an array for better minification.
          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container, options4) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return createRoot(container, options4);
        }
        function hydrateRoot$1(container, initialChildren, options4) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return hydrateRoot(container, initialChildren, options4);
        }
        function flushSync$1(fn) {
          {
            if (isAlreadyRendering()) {
              error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
          }
          return flushSync2(fn);
        }
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol2 = window.location.protocol;
              if (/^(https?|file):$/.test(protocol2)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol2 === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.createRoot = createRoot$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync$1;
        exports.hydrate = hydrate;
        exports.hydrateRoot = hydrateRoot$1;
        exports.render = render2;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    if (false) {
      checkDCE();
      module2.exports = null;
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// node_modules/@corbado/web-core/dist/index.js
function n(r8) {
  var s9 = t[r8];
  if (void 0 !== s9)
    return s9.exports;
  var o7 = t[r8] = { exports: {} };
  return e[r8].call(o7.exports, o7, o7.exports, n), o7.exports;
}
var e, t, r2, s2, o, i3, a2, c2, u2, l3, h2, p2, d2, f2, y3, m, w3, g3, v2, b, S2, E2;
var init_dist3 = __esm({
  "node_modules/@corbado/web-core/dist/index.js"() {
    e = { 640: function(e5, t8, n7) {
      var r8, s9;
      r8 = function() {
        var e6 = function() {
        }, t9 = "undefined", n8 = typeof window !== t9 && typeof window.navigator !== t9 && /Trident\/|MSIE /.test(window.navigator.userAgent), r9 = ["trace", "debug", "info", "warn", "error"];
        function s10(e7, t10) {
          var n9 = e7[t10];
          if ("function" == typeof n9.bind)
            return n9.bind(e7);
          try {
            return Function.prototype.bind.call(n9, e7);
          } catch (t11) {
            return function() {
              return Function.prototype.apply.apply(n9, [e7, arguments]);
            };
          }
        }
        function o7() {
          console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
        }
        function i9(t10, n9) {
          for (var s11 = 0; s11 < r9.length; s11++) {
            var o8 = r9[s11];
            this[o8] = s11 < t10 ? e6 : this.methodFactory(o8, t10, n9);
          }
          this.log = this.debug;
        }
        function a7(e7, n9, r10) {
          return function() {
            typeof console !== t9 && (i9.call(this, n9, r10), this[e7].apply(this, arguments));
          };
        }
        function c8(r10, i10, c9) {
          return function(r11) {
            return "debug" === r11 && (r11 = "log"), typeof console !== t9 && ("trace" === r11 && n8 ? o7 : void 0 !== console[r11] ? s10(console, r11) : void 0 !== console.log ? s10(console, "log") : e6);
          }(r10) || a7.apply(this, arguments);
        }
        function u6(e7, n9, s11) {
          var o8, a8 = this;
          n9 = null == n9 ? "WARN" : n9;
          var u7 = "loglevel";
          function l8() {
            var e8;
            if (typeof window !== t9 && u7) {
              try {
                e8 = window.localStorage[u7];
              } catch (e9) {
              }
              if (typeof e8 === t9)
                try {
                  var n10 = window.document.cookie, r10 = n10.indexOf(encodeURIComponent(u7) + "=");
                  -1 !== r10 && (e8 = /^([^;]+)/.exec(n10.slice(r10))[1]);
                } catch (e9) {
                }
              return void 0 === a8.levels[e8] && (e8 = void 0), e8;
            }
          }
          "string" == typeof e7 ? u7 += ":" + e7 : "symbol" == typeof e7 && (u7 = void 0), a8.name = e7, a8.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }, a8.methodFactory = s11 || c8, a8.getLevel = function() {
            return o8;
          }, a8.setLevel = function(n10, s12) {
            if ("string" == typeof n10 && void 0 !== a8.levels[n10.toUpperCase()] && (n10 = a8.levels[n10.toUpperCase()]), !("number" == typeof n10 && n10 >= 0 && n10 <= a8.levels.SILENT))
              throw "log.setLevel() called with invalid level: " + n10;
            if (o8 = n10, false !== s12 && function(e8) {
              var n11 = (r9[e8] || "silent").toUpperCase();
              if (typeof window !== t9 && u7) {
                try {
                  return void (window.localStorage[u7] = n11);
                } catch (e9) {
                }
                try {
                  window.document.cookie = encodeURIComponent(u7) + "=" + n11 + ";";
                } catch (e9) {
                }
              }
            }(n10), i9.call(a8, n10, e7), typeof console === t9 && n10 < a8.levels.SILENT)
              return "No console available for logging";
          }, a8.setDefaultLevel = function(e8) {
            n9 = e8, l8() || a8.setLevel(e8, false);
          }, a8.resetLevel = function() {
            a8.setLevel(n9, false), function() {
              if (typeof window !== t9 && u7) {
                try {
                  return void window.localStorage.removeItem(u7);
                } catch (e8) {
                }
                try {
                  window.document.cookie = encodeURIComponent(u7) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
                } catch (e8) {
                }
              }
            }();
          }, a8.enableAll = function(e8) {
            a8.setLevel(a8.levels.TRACE, e8);
          }, a8.disableAll = function(e8) {
            a8.setLevel(a8.levels.SILENT, e8);
          };
          var h7 = l8();
          null == h7 && (h7 = n9), a8.setLevel(h7, false);
        }
        var l7 = new u6(), h6 = {};
        l7.getLogger = function(e7) {
          if ("symbol" != typeof e7 && "string" != typeof e7 || "" === e7)
            throw new TypeError("You must supply a name when creating a logger.");
          var t10 = h6[e7];
          return t10 || (t10 = h6[e7] = new u6(e7, l7.getLevel(), l7.methodFactory)), t10;
        };
        var p5 = typeof window !== t9 ? window.log : void 0;
        return l7.noConflict = function() {
          return typeof window !== t9 && window.log === l7 && (window.log = p5), l7;
        }, l7.getLoggers = function() {
          return h6;
        }, l7.default = l7, l7;
      }, void 0 === (s9 = r8.call(t8, n7, t8, e5)) || (e5.exports = s9);
    } };
    t = {};
    n.n = (e5) => {
      var t8 = e5 && e5.__esModule ? () => e5.default : () => e5;
      return n.d(t8, { a: t8 }), t8;
    }, n.d = (e5, t8) => {
      for (var r8 in t8)
        n.o(t8, r8) && !n.o(e5, r8) && Object.defineProperty(e5, r8, { enumerable: true, get: t8[r8] });
    }, n.o = (e5, t8) => Object.prototype.hasOwnProperty.call(e5, t8), n.r = (e5) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e5, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e5, "__esModule", { value: true });
    };
    r2 = {};
    (() => {
      n.d(r2, { jq: () => s9, CO: () => A5, dL: () => L5, Xy: () => os, rI: () => y7, lH: () => k4, bu: () => C5, zT: () => R3, CU: () => E6, EE: () => x4, nJ: () => S5, X1: () => w6, Ck: () => v5, X$: () => O3, MW: () => m5, Ko: () => P4, eA: () => b5, k5: () => g7, aH: () => t8 });
      var e5 = {};
      n.r(e5), n.d(e5, { hasBrowserEnv: () => vt, hasStandardBrowserEnv: () => bt, hasStandardBrowserWebWorkerEnv: () => Et2 });
      const t8 = 3e4;
      var s9;
      !function(e6) {
        e6[e6.LoggedOut = 0] = "LoggedOut", e6[e6.LoggedIn = 1] = "LoggedIn";
      }(s9 || (s9 = {}));
      var o7 = function(e6, t9) {
        return o7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e7, t10) {
          e7.__proto__ = t10;
        } || function(e7, t10) {
          for (var n7 in t10)
            Object.prototype.hasOwnProperty.call(t10, n7) && (e7[n7] = t10[n7]);
        }, o7(e6, t9);
      };
      function i9(e6, t9) {
        if ("function" != typeof t9 && null !== t9)
          throw new TypeError("Class extends value " + String(t9) + " is not a constructor or null");
        function n7() {
          this.constructor = e6;
        }
        o7(e6, t9), e6.prototype = null === t9 ? Object.create(t9) : (n7.prototype = t9.prototype, new n7());
      }
      function a7(e6) {
        var t9 = "function" == typeof Symbol && Symbol.iterator, n7 = t9 && e6[t9], r8 = 0;
        if (n7)
          return n7.call(e6);
        if (e6 && "number" == typeof e6.length)
          return { next: function() {
            return e6 && r8 >= e6.length && (e6 = void 0), { value: e6 && e6[r8++], done: !e6 };
          } };
        throw new TypeError(t9 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function c8(e6, t9) {
        var n7 = "function" == typeof Symbol && e6[Symbol.iterator];
        if (!n7)
          return e6;
        var r8, s10, o8 = n7.call(e6), i10 = [];
        try {
          for (; (void 0 === t9 || t9-- > 0) && !(r8 = o8.next()).done; )
            i10.push(r8.value);
        } catch (e7) {
          s10 = { error: e7 };
        } finally {
          try {
            r8 && !r8.done && (n7 = o8.return) && n7.call(o8);
          } finally {
            if (s10)
              throw s10.error;
          }
        }
        return i10;
      }
      function u6(e6, t9, n7) {
        if (n7 || 2 === arguments.length)
          for (var r8, s10 = 0, o8 = t9.length; s10 < o8; s10++)
            !r8 && s10 in t9 || (r8 || (r8 = Array.prototype.slice.call(t9, 0, s10)), r8[s10] = t9[s10]);
        return e6.concat(r8 || Array.prototype.slice.call(t9));
      }
      function l7(e6, t9, n7, r8) {
        if ("a" === n7 && !r8)
          throw new TypeError("Private accessor was defined without a getter");
        if ("function" == typeof t9 ? e6 !== t9 || !r8 : !t9.has(e6))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return "m" === n7 ? r8 : "a" === n7 ? r8.call(e6) : r8 ? r8.value : t9.get(e6);
      }
      function h6(e6, t9, n7, r8, s10) {
        if ("m" === r8)
          throw new TypeError("Private method is not writable");
        if ("a" === r8 && !s10)
          throw new TypeError("Private accessor was defined without a setter");
        if ("function" == typeof t9 ? e6 !== t9 || !s10 : !t9.has(e6))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return "a" === r8 ? s10.call(e6, n7) : s10 ? s10.value = n7 : t9.set(e6, n7), n7;
      }
      Object.create, Object.create, "function" == typeof SuppressedError && SuppressedError;
      var p5, d6 = n(640), f5 = n.n(d6);
      class y7 extends Error {
        constructor(e6, t9) {
          super(e6), p5.set(this, void 0), this.name = "CorbadoError", this.recoverable = t9;
        }
        get translatedMessage() {
          if (!l7(this, p5, "f"))
            throw new Error("error has not been translated.");
          return l7(this, p5, "f");
        }
        set translatedMessage(e6) {
          h6(this, p5, e6, "f");
        }
        static fromAxiosError(e6) {
          var t9, n7, r8;
          if (f5().debug("axios error", e6), !e6.response || !e6.response.data)
            return w6.unknown();
          if (e6.response.status >= 500 || 422 === e6.response.status)
            try {
              const r9 = e6.response.data, s11 = null !== (t9 = r9.error.details) && void 0 !== t9 ? t9 : e6.message;
              return w6.server(s11, r9.requestData.requestID, null !== (n7 = r9.error.links.pop()) && void 0 !== n7 ? n7 : "", r9.error.type, r9.requestData.link);
            } catch (t10) {
              return w6.server(e6.message, "", "", "");
            }
          const s10 = e6.response.data.error;
          switch (s10.type) {
            case "validation_error": {
              if (!(null === (r8 = s10.validation) || void 0 === r8 ? void 0 : r8.length))
                return m5.unknown();
              const e7 = s10.validation[0];
              if ("username" === e7.field)
                switch (e7.message) {
                  case "user already exists":
                    return new g7();
                  case "cannot be blank":
                  case "Invalid email address":
                  case "Invalid / unreachable email address":
                    return new k4();
                  case "user doesn't exist":
                    return new b5();
                }
              if ("sessionToken" === e7.field && "user already exists" === e7.message)
                return new v5();
              break;
            }
            case "not_found":
              if ("user doesn't exist" === s10.details)
                return new b5();
              if ("Used invalid credentials" === s10.details)
                return new E6();
              if ("Email code not valid" === s10.details)
                return new R3();
              if ("Email link not valid" === s10.details)
                return new x4();
              break;
            case "client_error":
              if ("Unconfirmed credential" === s10.details)
                return new L5();
          }
          return w6.unknown();
        }
        static fromDOMException(e6) {
          switch (e6.name) {
            case "NotAllowedError":
            case "AbortError":
              return new O3();
            case "SecurityError":
              return new w6("server", "The relying party ID is not a registrable domain suffix of, nor equal to the current domain.", "https://docs.corbado.com");
            default:
              return f5().warn("unhandled DOM exception", e6.name, e6.message), w6.client(e6.message);
          }
        }
        static fromUnknownException(e6) {
          return f5().debug("unknown exception", e6), w6.unknown();
        }
        static illegalState(e6, t9) {
          return w6.client(e6, t9);
        }
        static noPasskeyAvailable() {
          return new S5();
        }
        static unknown() {
          return new P4();
        }
      }
      p5 = /* @__PURE__ */ new WeakMap();
      class m5 extends y7 {
        constructor(e6) {
          super(e6, true), this.name = "RecoverableError";
        }
        static unknown() {
          return new m5("An unknown error occurred");
        }
      }
      class w6 extends y7 {
        constructor(e6, t9, n7, r8, s10, o8) {
          super(t9, false), this.name = "Integration error", this.type = e6, this.link = n7, this.details = r8, this.detailedType = s10, this.requestId = o8;
        }
        static unknown() {
          return new w6("server", "An unknown error occurred", "https://docs.corbado.com");
        }
        static invalidConfig(e6) {
          return w6.client(e6, "https://docs.corbado.com");
        }
        static server(e6, t9, n7, r8, s10) {
          return new w6("server", e6, n7, s10, r8, t9);
        }
        static client(e6, t9) {
          return new w6("client", e6, t9);
        }
        static userRegistrationNotAllowed() {
          return new w6("server", "User registration is not allowed for this project", "https://docs.corbado.com/overview/sign-up-and-login-with-passkeys/user-flow-configuration#id-2.-public-sign-ups");
        }
      }
      class g7 extends m5 {
        constructor() {
          super("User already exists"), this.name = "errors.userAlreadyExists";
        }
      }
      class v5 extends m5 {
        constructor() {
          super("Passkey for this device already exists"), this.name = "errors.passkeyAlreadyExists";
        }
      }
      class b5 extends m5 {
        constructor() {
          super("User does not exist"), this.name = "errors.unknownUser";
        }
      }
      class S5 extends m5 {
        constructor() {
          super("No passkey available"), this.name = "errors.noPasskeyAvailable";
        }
      }
      class E6 extends m5 {
        constructor() {
          super("The provided passkey is no longer valid."), this.name = "errors.invalidPasskey";
        }
      }
      class O3 extends m5 {
        constructor() {
          super("Passkey challenge cancelled"), this.name = "errors.passkeyChallengeCancelled";
        }
      }
      class C5 extends m5 {
        constructor() {
          super("Invalid fullName"), this.name = "errors.invalidFullname";
        }
      }
      class k4 extends m5 {
        constructor() {
          super("Invalid email"), this.name = "errors.invalidName";
        }
      }
      class R3 extends m5 {
        constructor() {
          super("The provided OTP is no longer valid"), this.name = "errors.invalidOtp";
        }
      }
      class x4 extends m5 {
        constructor() {
          super("The provided token is not valid for user verification"), this.name = "errors.invalidToken";
        }
      }
      class A5 extends m5 {
        constructor() {
          super("Conditional UI is not supported by your device"), this.name = "errors.noConditionalUiSupport";
        }
      }
      class L5 extends m5 {
        constructor() {
          super("Unconfirmed credential"), this.name = "errors.conditionalUiUnconfirmedCredential";
        }
      }
      class P4 extends m5 {
        constructor() {
          super("An unknown error occurred"), this.name = "errors.unknownError";
        }
      }
      function T2(e6) {
        return "function" == typeof e6;
      }
      function j4(e6) {
        var t9 = e6(function(e7) {
          Error.call(e7), e7.stack = new Error().stack;
        });
        return t9.prototype = Object.create(Error.prototype), t9.prototype.constructor = t9, t9;
      }
      var U4 = j4(function(e6) {
        return function(t9) {
          e6(this), this.message = t9 ? t9.length + " errors occurred during unsubscription:\n" + t9.map(function(e7, t10) {
            return t10 + 1 + ") " + e7.toString();
          }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = t9;
        };
      });
      function _4(e6, t9) {
        if (e6) {
          var n7 = e6.indexOf(t9);
          0 <= n7 && e6.splice(n7, 1);
        }
      }
      var D4 = function() {
        function e6(e7) {
          this.initialTeardown = e7, this.closed = false, this._parentage = null, this._finalizers = null;
        }
        var t9;
        return e6.prototype.unsubscribe = function() {
          var e7, t10, n7, r8, s10;
          if (!this.closed) {
            this.closed = true;
            var o8 = this._parentage;
            if (o8)
              if (this._parentage = null, Array.isArray(o8))
                try {
                  for (var i10 = a7(o8), l8 = i10.next(); !l8.done; l8 = i10.next())
                    l8.value.remove(this);
                } catch (t11) {
                  e7 = { error: t11 };
                } finally {
                  try {
                    l8 && !l8.done && (t10 = i10.return) && t10.call(i10);
                  } finally {
                    if (e7)
                      throw e7.error;
                  }
                }
              else
                o8.remove(this);
            var h7 = this.initialTeardown;
            if (T2(h7))
              try {
                h7();
              } catch (e8) {
                s10 = e8 instanceof U4 ? e8.errors : [e8];
              }
            var p6 = this._finalizers;
            if (p6) {
              this._finalizers = null;
              try {
                for (var d7 = a7(p6), f6 = d7.next(); !f6.done; f6 = d7.next()) {
                  var y8 = f6.value;
                  try {
                    N4(y8);
                  } catch (e8) {
                    s10 = null != s10 ? s10 : [], e8 instanceof U4 ? s10 = u6(u6([], c8(s10)), c8(e8.errors)) : s10.push(e8);
                  }
                }
              } catch (e8) {
                n7 = { error: e8 };
              } finally {
                try {
                  f6 && !f6.done && (r8 = d7.return) && r8.call(d7);
                } finally {
                  if (n7)
                    throw n7.error;
                }
              }
            }
            if (s10)
              throw new U4(s10);
          }
        }, e6.prototype.add = function(t10) {
          var n7;
          if (t10 && t10 !== this)
            if (this.closed)
              N4(t10);
            else {
              if (t10 instanceof e6) {
                if (t10.closed || t10._hasParent(this))
                  return;
                t10._addParent(this);
              }
              (this._finalizers = null !== (n7 = this._finalizers) && void 0 !== n7 ? n7 : []).push(t10);
            }
        }, e6.prototype._hasParent = function(e7) {
          var t10 = this._parentage;
          return t10 === e7 || Array.isArray(t10) && t10.includes(e7);
        }, e6.prototype._addParent = function(e7) {
          var t10 = this._parentage;
          this._parentage = Array.isArray(t10) ? (t10.push(e7), t10) : t10 ? [t10, e7] : e7;
        }, e6.prototype._removeParent = function(e7) {
          var t10 = this._parentage;
          t10 === e7 ? this._parentage = null : Array.isArray(t10) && _4(t10, e7);
        }, e6.prototype.remove = function(t10) {
          var n7 = this._finalizers;
          n7 && _4(n7, t10), t10 instanceof e6 && t10._removeParent(this);
        }, e6.EMPTY = ((t9 = new e6()).closed = true, t9), e6;
      }(), I4 = D4.EMPTY;
      function K3(e6) {
        return e6 instanceof D4 || e6 && "closed" in e6 && T2(e6.remove) && T2(e6.add) && T2(e6.unsubscribe);
      }
      function N4(e6) {
        T2(e6) ? e6() : e6.unsubscribe();
      }
      var M4 = null, F4 = null, W4 = void 0, q4 = false, B3 = false, X4 = { setTimeout: function(e6, t9) {
        for (var n7 = [], r8 = 2; r8 < arguments.length; r8++)
          n7[r8 - 2] = arguments[r8];
        var s10 = X4.delegate;
        return (null == s10 ? void 0 : s10.setTimeout) ? s10.setTimeout.apply(s10, u6([e6, t9], c8(n7))) : setTimeout.apply(void 0, u6([e6, t9], c8(n7)));
      }, clearTimeout: function(e6) {
        var t9 = X4.delegate;
        return ((null == t9 ? void 0 : t9.clearTimeout) || clearTimeout)(e6);
      }, delegate: void 0 };
      function J3() {
      }
      var z3 = G3("C", void 0, void 0);
      function G3(e6, t9, n7) {
        return { kind: e6, value: t9, error: n7 };
      }
      var H3 = null;
      function $3(e6) {
        if (q4) {
          var t9 = !H3;
          if (t9 && (H3 = { errorThrown: false, error: null }), e6(), t9) {
            var n7 = H3, r8 = n7.errorThrown, s10 = n7.error;
            if (H3 = null, r8)
              throw s10;
          }
        } else
          e6();
      }
      var V3 = function(e6) {
        function t9(t10) {
          var n7 = e6.call(this) || this;
          return n7.isStopped = false, t10 ? (n7.destination = t10, K3(t10) && t10.add(n7)) : n7.destination = re3, n7;
        }
        return i9(t9, e6), t9.create = function(e7, t10, n7) {
          return new ee3(e7, t10, n7);
        }, t9.prototype.next = function(e7) {
          this.isStopped ? ne3(function(e8) {
            return G3("N", e8, void 0);
          }(e7), this) : this._next(e7);
        }, t9.prototype.error = function(e7) {
          this.isStopped ? ne3(G3("E", void 0, e7), this) : (this.isStopped = true, this._error(e7));
        }, t9.prototype.complete = function() {
          this.isStopped ? ne3(z3, this) : (this.isStopped = true, this._complete());
        }, t9.prototype.unsubscribe = function() {
          this.closed || (this.isStopped = true, e6.prototype.unsubscribe.call(this), this.destination = null);
        }, t9.prototype._next = function(e7) {
          this.destination.next(e7);
        }, t9.prototype._error = function(e7) {
          try {
            this.destination.error(e7);
          } finally {
            this.unsubscribe();
          }
        }, t9.prototype._complete = function() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }, t9;
      }(D4), Y3 = Function.prototype.bind;
      function Q3(e6, t9) {
        return Y3.call(e6, t9);
      }
      var Z4 = function() {
        function e6(e7) {
          this.partialObserver = e7;
        }
        return e6.prototype.next = function(e7) {
          var t9 = this.partialObserver;
          if (t9.next)
            try {
              t9.next(e7);
            } catch (e8) {
              te3(e8);
            }
        }, e6.prototype.error = function(e7) {
          var t9 = this.partialObserver;
          if (t9.error)
            try {
              t9.error(e7);
            } catch (e8) {
              te3(e8);
            }
          else
            te3(e7);
        }, e6.prototype.complete = function() {
          var e7 = this.partialObserver;
          if (e7.complete)
            try {
              e7.complete();
            } catch (e8) {
              te3(e8);
            }
        }, e6;
      }(), ee3 = function(e6) {
        function t9(t10, n7, r8) {
          var s10, o8, i10 = e6.call(this) || this;
          return T2(t10) || !t10 ? s10 = { next: null != t10 ? t10 : void 0, error: null != n7 ? n7 : void 0, complete: null != r8 ? r8 : void 0 } : i10 && B3 ? ((o8 = Object.create(t10)).unsubscribe = function() {
            return i10.unsubscribe();
          }, s10 = { next: t10.next && Q3(t10.next, o8), error: t10.error && Q3(t10.error, o8), complete: t10.complete && Q3(t10.complete, o8) }) : s10 = t10, i10.destination = new Z4(s10), i10;
        }
        return i9(t9, e6), t9;
      }(V3);
      function te3(e6) {
        var t9;
        q4 ? (t9 = e6, q4 && H3 && (H3.errorThrown = true, H3.error = t9)) : function(e7) {
          X4.setTimeout(function() {
            if (!M4)
              throw e7;
            M4(e7);
          });
        }(e6);
      }
      function ne3(e6, t9) {
        var n7 = F4;
        n7 && X4.setTimeout(function() {
          return n7(e6, t9);
        });
      }
      var re3 = { closed: true, next: J3, error: function(e6) {
        throw e6;
      }, complete: J3 }, se4 = "function" == typeof Symbol && Symbol.observable || "@@observable";
      function oe3(e6) {
        return e6;
      }
      var ie4 = function() {
        function e6(e7) {
          e7 && (this._subscribe = e7);
        }
        return e6.prototype.lift = function(t9) {
          var n7 = new e6();
          return n7.source = this, n7.operator = t9, n7;
        }, e6.prototype.subscribe = function(e7, t9, n7) {
          var r8, s10 = this, o8 = (r8 = e7) && r8 instanceof V3 || function(e8) {
            return e8 && T2(e8.next) && T2(e8.error) && T2(e8.complete);
          }(r8) && K3(r8) ? e7 : new ee3(e7, t9, n7);
          return $3(function() {
            var e8 = s10, t10 = e8.operator, n8 = e8.source;
            o8.add(t10 ? t10.call(o8, n8) : n8 ? s10._subscribe(o8) : s10._trySubscribe(o8));
          }), o8;
        }, e6.prototype._trySubscribe = function(e7) {
          try {
            return this._subscribe(e7);
          } catch (t9) {
            e7.error(t9);
          }
        }, e6.prototype.forEach = function(e7, t9) {
          var n7 = this;
          return new (t9 = ae3(t9))(function(t10, r8) {
            var s10 = new ee3({ next: function(t11) {
              try {
                e7(t11);
              } catch (e8) {
                r8(e8), s10.unsubscribe();
              }
            }, error: r8, complete: t10 });
            n7.subscribe(s10);
          });
        }, e6.prototype._subscribe = function(e7) {
          var t9;
          return null === (t9 = this.source) || void 0 === t9 ? void 0 : t9.subscribe(e7);
        }, e6.prototype[se4] = function() {
          return this;
        }, e6.prototype.pipe = function() {
          for (var e7 = [], t9 = 0; t9 < arguments.length; t9++)
            e7[t9] = arguments[t9];
          return (0 === (n7 = e7).length ? oe3 : 1 === n7.length ? n7[0] : function(e8) {
            return n7.reduce(function(e9, t10) {
              return t10(e9);
            }, e8);
          })(this);
          var n7;
        }, e6.prototype.toPromise = function(e7) {
          var t9 = this;
          return new (e7 = ae3(e7))(function(e8, n7) {
            var r8;
            t9.subscribe(function(e9) {
              return r8 = e9;
            }, function(e9) {
              return n7(e9);
            }, function() {
              return e8(r8);
            });
          });
        }, e6.create = function(t9) {
          return new e6(t9);
        }, e6;
      }();
      function ae3(e6) {
        var t9;
        return null !== (t9 = null != e6 ? e6 : W4) && void 0 !== t9 ? t9 : Promise;
      }
      var ce3 = j4(function(e6) {
        return function() {
          e6(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
        };
      }), ue3 = function(e6) {
        function t9() {
          var t10 = e6.call(this) || this;
          return t10.closed = false, t10.currentObservers = null, t10.observers = [], t10.isStopped = false, t10.hasError = false, t10.thrownError = null, t10;
        }
        return i9(t9, e6), t9.prototype.lift = function(e7) {
          var t10 = new le3(this, this);
          return t10.operator = e7, t10;
        }, t9.prototype._throwIfClosed = function() {
          if (this.closed)
            throw new ce3();
        }, t9.prototype.next = function(e7) {
          var t10 = this;
          $3(function() {
            var n7, r8;
            if (t10._throwIfClosed(), !t10.isStopped) {
              t10.currentObservers || (t10.currentObservers = Array.from(t10.observers));
              try {
                for (var s10 = a7(t10.currentObservers), o8 = s10.next(); !o8.done; o8 = s10.next())
                  o8.value.next(e7);
              } catch (e8) {
                n7 = { error: e8 };
              } finally {
                try {
                  o8 && !o8.done && (r8 = s10.return) && r8.call(s10);
                } finally {
                  if (n7)
                    throw n7.error;
                }
              }
            }
          });
        }, t9.prototype.error = function(e7) {
          var t10 = this;
          $3(function() {
            if (t10._throwIfClosed(), !t10.isStopped) {
              t10.hasError = t10.isStopped = true, t10.thrownError = e7;
              for (var n7 = t10.observers; n7.length; )
                n7.shift().error(e7);
            }
          });
        }, t9.prototype.complete = function() {
          var e7 = this;
          $3(function() {
            if (e7._throwIfClosed(), !e7.isStopped) {
              e7.isStopped = true;
              for (var t10 = e7.observers; t10.length; )
                t10.shift().complete();
            }
          });
        }, t9.prototype.unsubscribe = function() {
          this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
        }, Object.defineProperty(t9.prototype, "observed", { get: function() {
          var e7;
          return (null === (e7 = this.observers) || void 0 === e7 ? void 0 : e7.length) > 0;
        }, enumerable: false, configurable: true }), t9.prototype._trySubscribe = function(t10) {
          return this._throwIfClosed(), e6.prototype._trySubscribe.call(this, t10);
        }, t9.prototype._subscribe = function(e7) {
          return this._throwIfClosed(), this._checkFinalizedStatuses(e7), this._innerSubscribe(e7);
        }, t9.prototype._innerSubscribe = function(e7) {
          var t10 = this, n7 = this, r8 = n7.hasError, s10 = n7.isStopped, o8 = n7.observers;
          return r8 || s10 ? I4 : (this.currentObservers = null, o8.push(e7), new D4(function() {
            t10.currentObservers = null, _4(o8, e7);
          }));
        }, t9.prototype._checkFinalizedStatuses = function(e7) {
          var t10 = this, n7 = t10.hasError, r8 = t10.thrownError, s10 = t10.isStopped;
          n7 ? e7.error(r8) : s10 && e7.complete();
        }, t9.prototype.asObservable = function() {
          var e7 = new ie4();
          return e7.source = this, e7;
        }, t9.create = function(e7, t10) {
          return new le3(e7, t10);
        }, t9;
      }(ie4), le3 = function(e6) {
        function t9(t10, n7) {
          var r8 = e6.call(this) || this;
          return r8.destination = t10, r8.source = n7, r8;
        }
        return i9(t9, e6), t9.prototype.next = function(e7) {
          var t10, n7;
          null === (n7 = null === (t10 = this.destination) || void 0 === t10 ? void 0 : t10.next) || void 0 === n7 || n7.call(t10, e7);
        }, t9.prototype.error = function(e7) {
          var t10, n7;
          null === (n7 = null === (t10 = this.destination) || void 0 === t10 ? void 0 : t10.error) || void 0 === n7 || n7.call(t10, e7);
        }, t9.prototype.complete = function() {
          var e7, t10;
          null === (t10 = null === (e7 = this.destination) || void 0 === e7 ? void 0 : e7.complete) || void 0 === t10 || t10.call(e7);
        }, t9.prototype._subscribe = function(e7) {
          var t10, n7;
          return null !== (n7 = null === (t10 = this.source) || void 0 === t10 ? void 0 : t10.subscribe(e7)) && void 0 !== n7 ? n7 : I4;
        }, t9;
      }(ue3), he3 = function(e6) {
        function t9(t10) {
          var n7 = e6.call(this) || this;
          return n7._value = t10, n7;
        }
        return i9(t9, e6), Object.defineProperty(t9.prototype, "value", { get: function() {
          return this.getValue();
        }, enumerable: false, configurable: true }), t9.prototype._subscribe = function(t10) {
          var n7 = e6.prototype._subscribe.call(this, t10);
          return !n7.closed && t10.next(this._value), n7;
        }, t9.prototype.getValue = function() {
          var e7 = this, t10 = e7.hasError, n7 = e7.thrownError, r8 = e7._value;
          if (t10)
            throw n7;
          return this._throwIfClosed(), r8;
        }, t9.prototype.next = function(t10) {
          e6.prototype.next.call(this, this._value = t10);
        }, t9;
      }(ue3);
      function pe3(e6) {
        var t9 = String(e6);
        if ("[object Object]" === t9)
          try {
            t9 = JSON.stringify(e6);
          } catch (e7) {
          }
        return t9;
      }
      var de3 = new (function() {
        function e6() {
          this.some = false, this.none = true;
        }
        return e6.prototype[Symbol.iterator] = function() {
          return { next: function() {
            return { done: true, value: void 0 };
          } };
        }, e6.prototype.unwrapOr = function(e7) {
          return e7;
        }, e6.prototype.expect = function(e7) {
          throw new Error("" + e7);
        }, e6.prototype.unwrap = function() {
          throw new Error("Tried to unwrap None");
        }, e6.prototype.map = function(e7) {
          return this;
        }, e6.prototype.andThen = function(e7) {
          return this;
        }, e6.prototype.toResult = function(e7) {
          return we3(e7);
        }, e6.prototype.toString = function() {
          return "None";
        }, e6;
      }())();
      Object.freeze(de3);
      var fe3, ye3 = function() {
        function e6(t9) {
          if (!(this instanceof e6))
            return new e6(t9);
          this.some = true, this.none = false, this.val = t9;
        }
        return e6.prototype[Symbol.iterator] = function() {
          var e7 = Object(this.val);
          return Symbol.iterator in e7 ? e7[Symbol.iterator]() : { next: function() {
            return { done: true, value: void 0 };
          } };
        }, e6.prototype.unwrapOr = function(e7) {
          return this.val;
        }, e6.prototype.expect = function(e7) {
          return this.val;
        }, e6.prototype.unwrap = function() {
          return this.val;
        }, e6.prototype.map = function(e7) {
          return ye3(e7(this.val));
        }, e6.prototype.andThen = function(e7) {
          return e7(this.val);
        }, e6.prototype.toResult = function(e7) {
          return ge3(this.val);
        }, e6.prototype.safeUnwrap = function() {
          return this.val;
        }, e6.prototype.toString = function() {
          return "Some(" + pe3(this.val) + ")";
        }, e6.EMPTY = new e6(void 0), e6;
      }();
      !function(e6) {
        e6.all = function() {
          for (var e7 = [], t9 = 0; t9 < arguments.length; t9++)
            e7[t9] = arguments[t9];
          for (var n7 = [], r8 = 0, s10 = e7; r8 < s10.length; r8++) {
            var o8 = s10[r8];
            if (!o8.some)
              return o8;
            n7.push(o8.val);
          }
          return ye3(n7);
        }, e6.any = function() {
          for (var e7 = [], t9 = 0; t9 < arguments.length; t9++)
            e7[t9] = arguments[t9];
          for (var n7 = 0, r8 = e7; n7 < r8.length; n7++) {
            var s10 = r8[n7];
            return s10.some, s10;
          }
          return de3;
        }, e6.isOption = function(e7) {
          return e7 instanceof ye3 || e7 === de3;
        };
      }(fe3 || (fe3 = {}));
      var me3, we3 = function() {
        function e6(t9) {
          if (!(this instanceof e6))
            return new e6(t9);
          this.ok = false, this.err = true, this.val = t9;
          var n7 = new Error().stack.split("\n").slice(2);
          n7 && n7.length > 0 && n7[0].includes("ErrImpl") && n7.shift(), this._stack = n7.join("\n");
        }
        return e6.prototype[Symbol.iterator] = function() {
          return { next: function() {
            return { done: true, value: void 0 };
          } };
        }, e6.prototype.else = function(e7) {
          return e7;
        }, e6.prototype.unwrapOr = function(e7) {
          return e7;
        }, e6.prototype.expect = function(e7) {
          throw new Error(e7 + " - Error: " + pe3(this.val) + "\n" + this._stack);
        }, e6.prototype.unwrap = function() {
          throw new Error("Tried to unwrap Error: " + pe3(this.val) + "\n" + this._stack);
        }, e6.prototype.map = function(e7) {
          return this;
        }, e6.prototype.andThen = function(e7) {
          return this;
        }, e6.prototype.mapErr = function(e7) {
          return new we3(e7(this.val));
        }, e6.prototype.toOption = function() {
          return de3;
        }, e6.prototype.toString = function() {
          return "Err(" + pe3(this.val) + ")";
        }, Object.defineProperty(e6.prototype, "stack", { get: function() {
          return this + "\n" + this._stack;
        }, enumerable: false, configurable: true }), e6.EMPTY = new e6(void 0), e6;
      }(), ge3 = function() {
        function e6(t9) {
          if (!(this instanceof e6))
            return new e6(t9);
          this.ok = true, this.err = false, this.val = t9;
        }
        return e6.prototype[Symbol.iterator] = function() {
          var e7 = Object(this.val);
          return Symbol.iterator in e7 ? e7[Symbol.iterator]() : { next: function() {
            return { done: true, value: void 0 };
          } };
        }, e6.prototype.else = function(e7) {
          return this.val;
        }, e6.prototype.unwrapOr = function(e7) {
          return this.val;
        }, e6.prototype.expect = function(e7) {
          return this.val;
        }, e6.prototype.unwrap = function() {
          return this.val;
        }, e6.prototype.map = function(e7) {
          return new ge3(e7(this.val));
        }, e6.prototype.andThen = function(e7) {
          return e7(this.val);
        }, e6.prototype.mapErr = function(e7) {
          return this;
        }, e6.prototype.toOption = function() {
          return ye3(this.val);
        }, e6.prototype.safeUnwrap = function() {
          return this.val;
        }, e6.prototype.toString = function() {
          return "Ok(" + pe3(this.val) + ")";
        }, e6.EMPTY = new e6(void 0), e6;
      }();
      !function(e6) {
        e6.all = function() {
          for (var e7 = [], t9 = 0; t9 < arguments.length; t9++)
            e7[t9] = arguments[t9];
          for (var n7 = [], r8 = 0, s10 = e7; r8 < s10.length; r8++) {
            var o8 = s10[r8];
            if (!o8.ok)
              return o8;
            n7.push(o8.val);
          }
          return new ge3(n7);
        }, e6.any = function() {
          for (var e7 = [], t9 = 0; t9 < arguments.length; t9++)
            e7[t9] = arguments[t9];
          for (var n7 = [], r8 = 0, s10 = e7; r8 < s10.length; r8++) {
            var o8 = s10[r8];
            if (o8.ok)
              return o8;
            n7.push(o8.val);
          }
          return new we3(n7);
        }, e6.wrap = function(e7) {
          try {
            return new ge3(e7());
          } catch (e8) {
            return new we3(e8);
          }
        }, e6.wrapAsync = function(e7) {
          try {
            return e7().then(function(e8) {
              return new ge3(e8);
            }).catch(function(e8) {
              return new we3(e8);
            });
          } catch (e8) {
            return Promise.resolve(new we3(e8));
          }
        }, e6.isResult = function(e7) {
          return e7 instanceof we3 || e7 instanceof ge3;
        };
      }(me3 || (me3 = {}));
      const ve3 = () => {
        var e6;
        const t9 = new URLSearchParams(window.location.search), n7 = t9.get("corbadoEmailLinkID");
        if (!n7)
          return we3(new x4());
        const r8 = null === (e6 = t9.get("corbadoToken")) || void 0 === e6 ? void 0 : e6.split("#email-link-confirm")[0];
        return r8 ? ge3({ emailLinkId: n7, token: r8 }) : we3(new x4());
      };
      function be3(e6, t9) {
        return function() {
          return e6.apply(t9, arguments);
        };
      }
      const { toString: Se3 } = Object.prototype, { getPrototypeOf: Ee3 } = Object, Oe2 = (Ce3 = /* @__PURE__ */ Object.create(null), (e6) => {
        const t9 = Se3.call(e6);
        return Ce3[t9] || (Ce3[t9] = t9.slice(8, -1).toLowerCase());
      });
      var Ce3;
      const ke3 = (e6) => (e6 = e6.toLowerCase(), (t9) => Oe2(t9) === e6), Re = (e6) => (t9) => typeof t9 === e6, { isArray: xe3 } = Array, Ae3 = Re("undefined"), Le3 = ke3("ArrayBuffer"), Pe2 = Re("string"), Te3 = Re("function"), je3 = Re("number"), Ue3 = (e6) => null !== e6 && "object" == typeof e6, _e2 = (e6) => {
        if ("object" !== Oe2(e6))
          return false;
        const t9 = Ee3(e6);
        return !(null !== t9 && t9 !== Object.prototype && null !== Object.getPrototypeOf(t9) || Symbol.toStringTag in e6 || Symbol.iterator in e6);
      }, De3 = ke3("Date"), Ie3 = ke3("File"), Ke2 = ke3("Blob"), Ne3 = ke3("FileList"), Me3 = ke3("URLSearchParams");
      function Fe2(e6, t9, { allOwnKeys: n7 = false } = {}) {
        if (null == e6)
          return;
        let r8, s10;
        if ("object" != typeof e6 && (e6 = [e6]), xe3(e6))
          for (r8 = 0, s10 = e6.length; r8 < s10; r8++)
            t9.call(null, e6[r8], r8, e6);
        else {
          const s11 = n7 ? Object.getOwnPropertyNames(e6) : Object.keys(e6), o8 = s11.length;
          let i10;
          for (r8 = 0; r8 < o8; r8++)
            i10 = s11[r8], t9.call(null, e6[i10], i10, e6);
        }
      }
      function We2(e6, t9) {
        t9 = t9.toLowerCase();
        const n7 = Object.keys(e6);
        let r8, s10 = n7.length;
        for (; s10-- > 0; )
          if (r8 = n7[s10], t9 === r8.toLowerCase())
            return r8;
        return null;
      }
      const qe2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, Be3 = (e6) => !Ae3(e6) && e6 !== qe2, Xe2 = (Je2 = "undefined" != typeof Uint8Array && Ee3(Uint8Array), (e6) => Je2 && e6 instanceof Je2);
      var Je2;
      const ze3 = ke3("HTMLFormElement"), Ge2 = (({ hasOwnProperty: e6 }) => (t9, n7) => e6.call(t9, n7))(Object.prototype), He2 = ke3("RegExp"), $e2 = (e6, t9) => {
        const n7 = Object.getOwnPropertyDescriptors(e6), r8 = {};
        Fe2(n7, (n8, s10) => {
          let o8;
          false !== (o8 = t9(n8, s10, e6)) && (r8[s10] = o8 || n8);
        }), Object.defineProperties(e6, r8);
      }, Ve2 = "abcdefghijklmnopqrstuvwxyz", Ye3 = "0123456789", Qe3 = { DIGIT: Ye3, ALPHA: Ve2, ALPHA_DIGIT: Ve2 + Ve2.toUpperCase() + Ye3 }, Ze2 = ke3("AsyncFunction"), et2 = { isArray: xe3, isArrayBuffer: Le3, isBuffer: function(e6) {
        return null !== e6 && !Ae3(e6) && null !== e6.constructor && !Ae3(e6.constructor) && Te3(e6.constructor.isBuffer) && e6.constructor.isBuffer(e6);
      }, isFormData: (e6) => {
        let t9;
        return e6 && ("function" == typeof FormData && e6 instanceof FormData || Te3(e6.append) && ("formdata" === (t9 = Oe2(e6)) || "object" === t9 && Te3(e6.toString) && "[object FormData]" === e6.toString()));
      }, isArrayBufferView: function(e6) {
        let t9;
        return t9 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e6) : e6 && e6.buffer && Le3(e6.buffer), t9;
      }, isString: Pe2, isNumber: je3, isBoolean: (e6) => true === e6 || false === e6, isObject: Ue3, isPlainObject: _e2, isUndefined: Ae3, isDate: De3, isFile: Ie3, isBlob: Ke2, isRegExp: He2, isFunction: Te3, isStream: (e6) => Ue3(e6) && Te3(e6.pipe), isURLSearchParams: Me3, isTypedArray: Xe2, isFileList: Ne3, forEach: Fe2, merge: function e6() {
        const { caseless: t9 } = Be3(this) && this || {}, n7 = {}, r8 = (r9, s10) => {
          const o8 = t9 && We2(n7, s10) || s10;
          _e2(n7[o8]) && _e2(r9) ? n7[o8] = e6(n7[o8], r9) : _e2(r9) ? n7[o8] = e6({}, r9) : xe3(r9) ? n7[o8] = r9.slice() : n7[o8] = r9;
        };
        for (let e7 = 0, t10 = arguments.length; e7 < t10; e7++)
          arguments[e7] && Fe2(arguments[e7], r8);
        return n7;
      }, extend: (e6, t9, n7, { allOwnKeys: r8 } = {}) => (Fe2(t9, (t10, r9) => {
        n7 && Te3(t10) ? e6[r9] = be3(t10, n7) : e6[r9] = t10;
      }, { allOwnKeys: r8 }), e6), trim: (e6) => e6.trim ? e6.trim() : e6.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e6) => (65279 === e6.charCodeAt(0) && (e6 = e6.slice(1)), e6), inherits: (e6, t9, n7, r8) => {
        e6.prototype = Object.create(t9.prototype, r8), e6.prototype.constructor = e6, Object.defineProperty(e6, "super", { value: t9.prototype }), n7 && Object.assign(e6.prototype, n7);
      }, toFlatObject: (e6, t9, n7, r8) => {
        let s10, o8, i10;
        const a8 = {};
        if (t9 = t9 || {}, null == e6)
          return t9;
        do {
          for (s10 = Object.getOwnPropertyNames(e6), o8 = s10.length; o8-- > 0; )
            i10 = s10[o8], r8 && !r8(i10, e6, t9) || a8[i10] || (t9[i10] = e6[i10], a8[i10] = true);
          e6 = false !== n7 && Ee3(e6);
        } while (e6 && (!n7 || n7(e6, t9)) && e6 !== Object.prototype);
        return t9;
      }, kindOf: Oe2, kindOfTest: ke3, endsWith: (e6, t9, n7) => {
        e6 = String(e6), (void 0 === n7 || n7 > e6.length) && (n7 = e6.length), n7 -= t9.length;
        const r8 = e6.indexOf(t9, n7);
        return -1 !== r8 && r8 === n7;
      }, toArray: (e6) => {
        if (!e6)
          return null;
        if (xe3(e6))
          return e6;
        let t9 = e6.length;
        if (!je3(t9))
          return null;
        const n7 = new Array(t9);
        for (; t9-- > 0; )
          n7[t9] = e6[t9];
        return n7;
      }, forEachEntry: (e6, t9) => {
        const n7 = (e6 && e6[Symbol.iterator]).call(e6);
        let r8;
        for (; (r8 = n7.next()) && !r8.done; ) {
          const n8 = r8.value;
          t9.call(e6, n8[0], n8[1]);
        }
      }, matchAll: (e6, t9) => {
        let n7;
        const r8 = [];
        for (; null !== (n7 = e6.exec(t9)); )
          r8.push(n7);
        return r8;
      }, isHTMLForm: ze3, hasOwnProperty: Ge2, hasOwnProp: Ge2, reduceDescriptors: $e2, freezeMethods: (e6) => {
        $e2(e6, (t9, n7) => {
          if (Te3(e6) && -1 !== ["arguments", "caller", "callee"].indexOf(n7))
            return false;
          const r8 = e6[n7];
          Te3(r8) && (t9.enumerable = false, "writable" in t9 ? t9.writable = false : t9.set || (t9.set = () => {
            throw Error("Can not rewrite read-only method '" + n7 + "'");
          }));
        });
      }, toObjectSet: (e6, t9) => {
        const n7 = {}, r8 = (e7) => {
          e7.forEach((e8) => {
            n7[e8] = true;
          });
        };
        return xe3(e6) ? r8(e6) : r8(String(e6).split(t9)), n7;
      }, toCamelCase: (e6) => e6.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e7, t9, n7) {
        return t9.toUpperCase() + n7;
      }), noop: () => {
      }, toFiniteNumber: (e6, t9) => (e6 = +e6, Number.isFinite(e6) ? e6 : t9), findKey: We2, global: qe2, isContextDefined: Be3, ALPHABET: Qe3, generateString: (e6 = 16, t9 = Qe3.ALPHA_DIGIT) => {
        let n7 = "";
        const { length: r8 } = t9;
        for (; e6--; )
          n7 += t9[Math.random() * r8 | 0];
        return n7;
      }, isSpecCompliantForm: function(e6) {
        return !!(e6 && Te3(e6.append) && "FormData" === e6[Symbol.toStringTag] && e6[Symbol.iterator]);
      }, toJSONObject: (e6) => {
        const t9 = new Array(10), n7 = (e7, r8) => {
          if (Ue3(e7)) {
            if (t9.indexOf(e7) >= 0)
              return;
            if (!("toJSON" in e7)) {
              t9[r8] = e7;
              const s10 = xe3(e7) ? [] : {};
              return Fe2(e7, (e8, t10) => {
                const o8 = n7(e8, r8 + 1);
                !Ae3(o8) && (s10[t10] = o8);
              }), t9[r8] = void 0, s10;
            }
          }
          return e7;
        };
        return n7(e6, 0);
      }, isAsyncFn: Ze2, isThenable: (e6) => e6 && (Ue3(e6) || Te3(e6)) && Te3(e6.then) && Te3(e6.catch) };
      function tt2(e6, t9, n7, r8, s10) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e6, this.name = "AxiosError", t9 && (this.code = t9), n7 && (this.config = n7), r8 && (this.request = r8), s10 && (this.response = s10);
      }
      et2.inherits(tt2, Error, { toJSON: function() {
        return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: et2.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null };
      } });
      const nt2 = tt2.prototype, rt2 = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e6) => {
        rt2[e6] = { value: e6 };
      }), Object.defineProperties(tt2, rt2), Object.defineProperty(nt2, "isAxiosError", { value: true }), tt2.from = (e6, t9, n7, r8, s10, o8) => {
        const i10 = Object.create(nt2);
        return et2.toFlatObject(e6, i10, function(e7) {
          return e7 !== Error.prototype;
        }, (e7) => "isAxiosError" !== e7), tt2.call(i10, e6.message, t9, n7, r8, s10), i10.cause = e6, i10.name = e6.name, o8 && Object.assign(i10, o8), i10;
      };
      const st2 = tt2;
      function ot2(e6) {
        return et2.isPlainObject(e6) || et2.isArray(e6);
      }
      function it2(e6) {
        return et2.endsWith(e6, "[]") ? e6.slice(0, -2) : e6;
      }
      function at2(e6, t9, n7) {
        return e6 ? e6.concat(t9).map(function(e7, t10) {
          return e7 = it2(e7), !n7 && t10 ? "[" + e7 + "]" : e7;
        }).join(n7 ? "." : "") : t9;
      }
      const ct2 = et2.toFlatObject(et2, {}, null, function(e6) {
        return /^is[A-Z]/.test(e6);
      }), ut2 = function(e6, t9, n7) {
        if (!et2.isObject(e6))
          throw new TypeError("target must be an object");
        t9 = t9 || new FormData();
        const r8 = (n7 = et2.toFlatObject(n7, { metaTokens: true, dots: false, indexes: false }, false, function(e7, t10) {
          return !et2.isUndefined(t10[e7]);
        })).metaTokens, s10 = n7.visitor || u7, o8 = n7.dots, i10 = n7.indexes, a8 = (n7.Blob || "undefined" != typeof Blob && Blob) && et2.isSpecCompliantForm(t9);
        if (!et2.isFunction(s10))
          throw new TypeError("visitor must be a function");
        function c9(e7) {
          if (null === e7)
            return "";
          if (et2.isDate(e7))
            return e7.toISOString();
          if (!a8 && et2.isBlob(e7))
            throw new st2("Blob is not supported. Use a Buffer instead.");
          return et2.isArrayBuffer(e7) || et2.isTypedArray(e7) ? a8 && "function" == typeof Blob ? new Blob([e7]) : Buffer.from(e7) : e7;
        }
        function u7(e7, n8, s11) {
          let a9 = e7;
          if (e7 && !s11 && "object" == typeof e7) {
            if (et2.endsWith(n8, "{}"))
              n8 = r8 ? n8 : n8.slice(0, -2), e7 = JSON.stringify(e7);
            else if (et2.isArray(e7) && function(e8) {
              return et2.isArray(e8) && !e8.some(ot2);
            }(e7) || (et2.isFileList(e7) || et2.endsWith(n8, "[]")) && (a9 = et2.toArray(e7)))
              return n8 = it2(n8), a9.forEach(function(e8, r9) {
                !et2.isUndefined(e8) && null !== e8 && t9.append(true === i10 ? at2([n8], r9, o8) : null === i10 ? n8 : n8 + "[]", c9(e8));
              }), false;
          }
          return !!ot2(e7) || (t9.append(at2(s11, n8, o8), c9(e7)), false);
        }
        const l8 = [], h7 = Object.assign(ct2, { defaultVisitor: u7, convertValue: c9, isVisitable: ot2 });
        if (!et2.isObject(e6))
          throw new TypeError("data must be an object");
        return function e7(n8, r9) {
          if (!et2.isUndefined(n8)) {
            if (-1 !== l8.indexOf(n8))
              throw Error("Circular reference detected in " + r9.join("."));
            l8.push(n8), et2.forEach(n8, function(n9, o9) {
              true === (!(et2.isUndefined(n9) || null === n9) && s10.call(t9, n9, et2.isString(o9) ? o9.trim() : o9, r9, h7)) && e7(n9, r9 ? r9.concat(o9) : [o9]);
            }), l8.pop();
          }
        }(e6), t9;
      };
      function lt(e6) {
        const t9 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
        return encodeURIComponent(e6).replace(/[!'()~]|%20|%00/g, function(e7) {
          return t9[e7];
        });
      }
      function ht2(e6, t9) {
        this._pairs = [], e6 && ut2(e6, this, t9);
      }
      const pt3 = ht2.prototype;
      pt3.append = function(e6, t9) {
        this._pairs.push([e6, t9]);
      }, pt3.toString = function(e6) {
        const t9 = e6 ? function(t10) {
          return e6.call(this, t10, lt);
        } : lt;
        return this._pairs.map(function(e7) {
          return t9(e7[0]) + "=" + t9(e7[1]);
        }, "").join("&");
      };
      const dt2 = ht2;
      function ft2(e6) {
        return encodeURIComponent(e6).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function yt2(e6, t9, n7) {
        if (!t9)
          return e6;
        const r8 = n7 && n7.encode || ft2, s10 = n7 && n7.serialize;
        let o8;
        if (o8 = s10 ? s10(t9, n7) : et2.isURLSearchParams(t9) ? t9.toString() : new dt2(t9, n7).toString(r8), o8) {
          const t10 = e6.indexOf("#");
          -1 !== t10 && (e6 = e6.slice(0, t10)), e6 += (-1 === e6.indexOf("?") ? "?" : "&") + o8;
        }
        return e6;
      }
      const mt2 = class {
        constructor() {
          this.handlers = [];
        }
        use(e6, t9, n7) {
          return this.handlers.push({ fulfilled: e6, rejected: t9, synchronous: !!n7 && n7.synchronous, runWhen: n7 ? n7.runWhen : null }), this.handlers.length - 1;
        }
        eject(e6) {
          this.handlers[e6] && (this.handlers[e6] = null);
        }
        clear() {
          this.handlers && (this.handlers = []);
        }
        forEach(e6) {
          et2.forEach(this.handlers, function(t9) {
            null !== t9 && e6(t9);
          });
        }
      }, wt2 = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, gt2 = { isBrowser: true, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : dt2, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, vt = "undefined" != typeof window && "undefined" != typeof document, bt = (St2 = "undefined" != typeof navigator && navigator.product, vt && ["ReactNative", "NativeScript", "NS"].indexOf(St2) < 0);
      var St2;
      const Et2 = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, Ot = { ...e5, ...gt2 }, Ct = function(e6) {
        function t9(e7, n7, r8, s10) {
          let o8 = e7[s10++];
          if ("__proto__" === o8)
            return true;
          const i10 = Number.isFinite(+o8), a8 = s10 >= e7.length;
          return o8 = !o8 && et2.isArray(r8) ? r8.length : o8, a8 ? (et2.hasOwnProp(r8, o8) ? r8[o8] = [r8[o8], n7] : r8[o8] = n7, !i10) : (r8[o8] && et2.isObject(r8[o8]) || (r8[o8] = []), t9(e7, n7, r8[o8], s10) && et2.isArray(r8[o8]) && (r8[o8] = function(e8) {
            const t10 = {}, n8 = Object.keys(e8);
            let r9;
            const s11 = n8.length;
            let o9;
            for (r9 = 0; r9 < s11; r9++)
              o9 = n8[r9], t10[o9] = e8[o9];
            return t10;
          }(r8[o8])), !i10);
        }
        if (et2.isFormData(e6) && et2.isFunction(e6.entries)) {
          const n7 = {};
          return et2.forEachEntry(e6, (e7, r8) => {
            t9(function(e8) {
              return et2.matchAll(/\w+|\[(\w*)]/g, e8).map((e9) => "[]" === e9[0] ? "" : e9[1] || e9[0]);
            }(e7), r8, n7, 0);
          }), n7;
        }
        return null;
      }, kt = { transitional: wt2, adapter: ["xhr", "http"], transformRequest: [function(e6, t9) {
        const n7 = t9.getContentType() || "", r8 = n7.indexOf("application/json") > -1, s10 = et2.isObject(e6);
        if (s10 && et2.isHTMLForm(e6) && (e6 = new FormData(e6)), et2.isFormData(e6))
          return r8 && r8 ? JSON.stringify(Ct(e6)) : e6;
        if (et2.isArrayBuffer(e6) || et2.isBuffer(e6) || et2.isStream(e6) || et2.isFile(e6) || et2.isBlob(e6))
          return e6;
        if (et2.isArrayBufferView(e6))
          return e6.buffer;
        if (et2.isURLSearchParams(e6))
          return t9.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e6.toString();
        let o8;
        if (s10) {
          if (n7.indexOf("application/x-www-form-urlencoded") > -1)
            return function(e7, t10) {
              return ut2(e7, new Ot.classes.URLSearchParams(), Object.assign({ visitor: function(e8, t11, n8, r9) {
                return Ot.isNode && et2.isBuffer(e8) ? (this.append(t11, e8.toString("base64")), false) : r9.defaultVisitor.apply(this, arguments);
              } }, t10));
            }(e6, this.formSerializer).toString();
          if ((o8 = et2.isFileList(e6)) || n7.indexOf("multipart/form-data") > -1) {
            const t10 = this.env && this.env.FormData;
            return ut2(o8 ? { "files[]": e6 } : e6, t10 && new t10(), this.formSerializer);
          }
        }
        return s10 || r8 ? (t9.setContentType("application/json", false), function(e7, t10, n8) {
          if (et2.isString(e7))
            try {
              return (0, JSON.parse)(e7), et2.trim(e7);
            } catch (e8) {
              if ("SyntaxError" !== e8.name)
                throw e8;
            }
          return (0, JSON.stringify)(e7);
        }(e6)) : e6;
      }], transformResponse: [function(e6) {
        const t9 = this.transitional || kt.transitional, n7 = t9 && t9.forcedJSONParsing, r8 = "json" === this.responseType;
        if (e6 && et2.isString(e6) && (n7 && !this.responseType || r8)) {
          const n8 = !(t9 && t9.silentJSONParsing) && r8;
          try {
            return JSON.parse(e6);
          } catch (e7) {
            if (n8) {
              if ("SyntaxError" === e7.name)
                throw st2.from(e7, st2.ERR_BAD_RESPONSE, this, null, this.response);
              throw e7;
            }
          }
        }
        return e6;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Ot.classes.FormData, Blob: Ot.classes.Blob }, validateStatus: function(e6) {
        return e6 >= 200 && e6 < 300;
      }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
      et2.forEach(["delete", "get", "head", "post", "put", "patch"], (e6) => {
        kt.headers[e6] = {};
      });
      const Rt = kt, xt2 = et2.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), At = Symbol("internals");
      function Lt(e6) {
        return e6 && String(e6).trim().toLowerCase();
      }
      function Pt(e6) {
        return false === e6 || null == e6 ? e6 : et2.isArray(e6) ? e6.map(Pt) : String(e6);
      }
      function Tt2(e6, t9, n7, r8, s10) {
        return et2.isFunction(r8) ? r8.call(this, t9, n7) : (s10 && (t9 = n7), et2.isString(t9) ? et2.isString(r8) ? -1 !== t9.indexOf(r8) : et2.isRegExp(r8) ? r8.test(t9) : void 0 : void 0);
      }
      class jt {
        constructor(e6) {
          e6 && this.set(e6);
        }
        set(e6, t9, n7) {
          const r8 = this;
          function s10(e7, t10, n8) {
            const s11 = Lt(t10);
            if (!s11)
              throw new Error("header name must be a non-empty string");
            const o9 = et2.findKey(r8, s11);
            (!o9 || void 0 === r8[o9] || true === n8 || void 0 === n8 && false !== r8[o9]) && (r8[o9 || t10] = Pt(e7));
          }
          const o8 = (e7, t10) => et2.forEach(e7, (e8, n8) => s10(e8, n8, t10));
          return et2.isPlainObject(e6) || e6 instanceof this.constructor ? o8(e6, t9) : et2.isString(e6) && (e6 = e6.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e6.trim()) ? o8(((e7) => {
            const t10 = {};
            let n8, r9, s11;
            return e7 && e7.split("\n").forEach(function(e8) {
              s11 = e8.indexOf(":"), n8 = e8.substring(0, s11).trim().toLowerCase(), r9 = e8.substring(s11 + 1).trim(), !n8 || t10[n8] && xt2[n8] || ("set-cookie" === n8 ? t10[n8] ? t10[n8].push(r9) : t10[n8] = [r9] : t10[n8] = t10[n8] ? t10[n8] + ", " + r9 : r9);
            }), t10;
          })(e6), t9) : null != e6 && s10(t9, e6, n7), this;
        }
        get(e6, t9) {
          if (e6 = Lt(e6)) {
            const n7 = et2.findKey(this, e6);
            if (n7) {
              const e7 = this[n7];
              if (!t9)
                return e7;
              if (true === t9)
                return function(e8) {
                  const t10 = /* @__PURE__ */ Object.create(null), n8 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let r8;
                  for (; r8 = n8.exec(e8); )
                    t10[r8[1]] = r8[2];
                  return t10;
                }(e7);
              if (et2.isFunction(t9))
                return t9.call(this, e7, n7);
              if (et2.isRegExp(t9))
                return t9.exec(e7);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(e6, t9) {
          if (e6 = Lt(e6)) {
            const n7 = et2.findKey(this, e6);
            return !(!n7 || void 0 === this[n7] || t9 && !Tt2(0, this[n7], n7, t9));
          }
          return false;
        }
        delete(e6, t9) {
          const n7 = this;
          let r8 = false;
          function s10(e7) {
            if (e7 = Lt(e7)) {
              const s11 = et2.findKey(n7, e7);
              !s11 || t9 && !Tt2(0, n7[s11], s11, t9) || (delete n7[s11], r8 = true);
            }
          }
          return et2.isArray(e6) ? e6.forEach(s10) : s10(e6), r8;
        }
        clear(e6) {
          const t9 = Object.keys(this);
          let n7 = t9.length, r8 = false;
          for (; n7--; ) {
            const s10 = t9[n7];
            e6 && !Tt2(0, this[s10], s10, e6, true) || (delete this[s10], r8 = true);
          }
          return r8;
        }
        normalize(e6) {
          const t9 = this, n7 = {};
          return et2.forEach(this, (r8, s10) => {
            const o8 = et2.findKey(n7, s10);
            if (o8)
              return t9[o8] = Pt(r8), void delete t9[s10];
            const i10 = e6 ? function(e7) {
              return e7.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e8, t10, n8) => t10.toUpperCase() + n8);
            }(s10) : String(s10).trim();
            i10 !== s10 && delete t9[s10], t9[i10] = Pt(r8), n7[i10] = true;
          }), this;
        }
        concat(...e6) {
          return this.constructor.concat(this, ...e6);
        }
        toJSON(e6) {
          const t9 = /* @__PURE__ */ Object.create(null);
          return et2.forEach(this, (n7, r8) => {
            null != n7 && false !== n7 && (t9[r8] = e6 && et2.isArray(n7) ? n7.join(", ") : n7);
          }), t9;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([e6, t9]) => e6 + ": " + t9).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(e6) {
          return e6 instanceof this ? e6 : new this(e6);
        }
        static concat(e6, ...t9) {
          const n7 = new this(e6);
          return t9.forEach((e7) => n7.set(e7)), n7;
        }
        static accessor(e6) {
          const t9 = (this[At] = this[At] = { accessors: {} }).accessors, n7 = this.prototype;
          function r8(e7) {
            const r9 = Lt(e7);
            t9[r9] || (function(e8, t10) {
              const n8 = et2.toCamelCase(" " + t10);
              ["get", "set", "has"].forEach((r10) => {
                Object.defineProperty(e8, r10 + n8, { value: function(e9, n9, s10) {
                  return this[r10].call(this, t10, e9, n9, s10);
                }, configurable: true });
              });
            }(n7, e7), t9[r9] = true);
          }
          return et2.isArray(e6) ? e6.forEach(r8) : r8(e6), this;
        }
      }
      jt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), et2.reduceDescriptors(jt.prototype, ({ value: e6 }, t9) => {
        let n7 = t9[0].toUpperCase() + t9.slice(1);
        return { get: () => e6, set(e7) {
          this[n7] = e7;
        } };
      }), et2.freezeMethods(jt);
      const Ut = jt;
      function _t2(e6, t9) {
        const n7 = this || Rt, r8 = t9 || n7, s10 = Ut.from(r8.headers);
        let o8 = r8.data;
        return et2.forEach(e6, function(e7) {
          o8 = e7.call(n7, o8, s10.normalize(), t9 ? t9.status : void 0);
        }), s10.normalize(), o8;
      }
      function Dt(e6) {
        return !(!e6 || !e6.__CANCEL__);
      }
      function It(e6, t9, n7) {
        st2.call(this, null == e6 ? "canceled" : e6, st2.ERR_CANCELED, t9, n7), this.name = "CanceledError";
      }
      et2.inherits(It, st2, { __CANCEL__: true });
      const Kt = It, Nt = Ot.hasStandardBrowserEnv ? { write(e6, t9, n7, r8, s10, o8) {
        const i10 = [e6 + "=" + encodeURIComponent(t9)];
        et2.isNumber(n7) && i10.push("expires=" + new Date(n7).toGMTString()), et2.isString(r8) && i10.push("path=" + r8), et2.isString(s10) && i10.push("domain=" + s10), true === o8 && i10.push("secure"), document.cookie = i10.join("; ");
      }, read(e6) {
        const t9 = document.cookie.match(new RegExp("(^|;\\s*)(" + e6 + ")=([^;]*)"));
        return t9 ? decodeURIComponent(t9[3]) : null;
      }, remove(e6) {
        this.write(e6, "", Date.now() - 864e5);
      } } : { write() {
      }, read: () => null, remove() {
      } };
      function Mt(e6, t9) {
        return e6 && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t9) ? function(e7, t10) {
          return t10 ? e7.replace(/\/?\/$/, "") + "/" + t10.replace(/^\/+/, "") : e7;
        }(e6, t9) : t9;
      }
      const Ft = Ot.hasStandardBrowserEnv ? function() {
        const e6 = /(msie|trident)/i.test(navigator.userAgent), t9 = document.createElement("a");
        let n7;
        function r8(n8) {
          let r9 = n8;
          return e6 && (t9.setAttribute("href", r9), r9 = t9.href), t9.setAttribute("href", r9), { href: t9.href, protocol: t9.protocol ? t9.protocol.replace(/:$/, "") : "", host: t9.host, search: t9.search ? t9.search.replace(/^\?/, "") : "", hash: t9.hash ? t9.hash.replace(/^#/, "") : "", hostname: t9.hostname, port: t9.port, pathname: "/" === t9.pathname.charAt(0) ? t9.pathname : "/" + t9.pathname };
        }
        return n7 = r8(window.location.href), function(e7) {
          const t10 = et2.isString(e7) ? r8(e7) : e7;
          return t10.protocol === n7.protocol && t10.host === n7.host;
        };
      }() : function() {
        return true;
      };
      function Wt(e6, t9) {
        let n7 = 0;
        const r8 = function(e7, t10) {
          e7 = e7 || 10;
          const n8 = new Array(e7), r9 = new Array(e7);
          let s10, o8 = 0, i10 = 0;
          return t10 = void 0 !== t10 ? t10 : 1e3, function(a8) {
            const c9 = Date.now(), u7 = r9[i10];
            s10 || (s10 = c9), n8[o8] = a8, r9[o8] = c9;
            let l8 = i10, h7 = 0;
            for (; l8 !== o8; )
              h7 += n8[l8++], l8 %= e7;
            if (o8 = (o8 + 1) % e7, o8 === i10 && (i10 = (i10 + 1) % e7), c9 - s10 < t10)
              return;
            const p6 = u7 && c9 - u7;
            return p6 ? Math.round(1e3 * h7 / p6) : void 0;
          };
        }(50, 250);
        return (s10) => {
          const o8 = s10.loaded, i10 = s10.lengthComputable ? s10.total : void 0, a8 = o8 - n7, c9 = r8(a8);
          n7 = o8;
          const u7 = { loaded: o8, total: i10, progress: i10 ? o8 / i10 : void 0, bytes: a8, rate: c9 || void 0, estimated: c9 && i10 && o8 <= i10 ? (i10 - o8) / c9 : void 0, event: s10 };
          u7[t9 ? "download" : "upload"] = true, e6(u7);
        };
      }
      const qt = "undefined" != typeof XMLHttpRequest && function(e6) {
        return new Promise(function(t9, n7) {
          let r8 = e6.data;
          const s10 = Ut.from(e6.headers).normalize();
          let o8, i10, { responseType: a8, withXSRFToken: c9 } = e6;
          function u7() {
            e6.cancelToken && e6.cancelToken.unsubscribe(o8), e6.signal && e6.signal.removeEventListener("abort", o8);
          }
          if (et2.isFormData(r8)) {
            if (Ot.hasStandardBrowserEnv || Ot.hasStandardBrowserWebWorkerEnv)
              s10.setContentType(false);
            else if (false !== (i10 = s10.getContentType())) {
              const [e7, ...t10] = i10 ? i10.split(";").map((e8) => e8.trim()).filter(Boolean) : [];
              s10.setContentType([e7 || "multipart/form-data", ...t10].join("; "));
            }
          }
          let l8 = new XMLHttpRequest();
          if (e6.auth) {
            const t10 = e6.auth.username || "", n8 = e6.auth.password ? unescape(encodeURIComponent(e6.auth.password)) : "";
            s10.set("Authorization", "Basic " + btoa(t10 + ":" + n8));
          }
          const h7 = Mt(e6.baseURL, e6.url);
          function p6() {
            if (!l8)
              return;
            const r9 = Ut.from("getAllResponseHeaders" in l8 && l8.getAllResponseHeaders());
            !function(e7, t10, n8) {
              const r10 = n8.config.validateStatus;
              n8.status && r10 && !r10(n8.status) ? t10(new st2("Request failed with status code " + n8.status, [st2.ERR_BAD_REQUEST, st2.ERR_BAD_RESPONSE][Math.floor(n8.status / 100) - 4], n8.config, n8.request, n8)) : e7(n8);
            }(function(e7) {
              t9(e7), u7();
            }, function(e7) {
              n7(e7), u7();
            }, { data: a8 && "text" !== a8 && "json" !== a8 ? l8.response : l8.responseText, status: l8.status, statusText: l8.statusText, headers: r9, config: e6, request: l8 }), l8 = null;
          }
          if (l8.open(e6.method.toUpperCase(), yt2(h7, e6.params, e6.paramsSerializer), true), l8.timeout = e6.timeout, "onloadend" in l8 ? l8.onloadend = p6 : l8.onreadystatechange = function() {
            l8 && 4 === l8.readyState && (0 !== l8.status || l8.responseURL && 0 === l8.responseURL.indexOf("file:")) && setTimeout(p6);
          }, l8.onabort = function() {
            l8 && (n7(new st2("Request aborted", st2.ECONNABORTED, e6, l8)), l8 = null);
          }, l8.onerror = function() {
            n7(new st2("Network Error", st2.ERR_NETWORK, e6, l8)), l8 = null;
          }, l8.ontimeout = function() {
            let t10 = e6.timeout ? "timeout of " + e6.timeout + "ms exceeded" : "timeout exceeded";
            const r9 = e6.transitional || wt2;
            e6.timeoutErrorMessage && (t10 = e6.timeoutErrorMessage), n7(new st2(t10, r9.clarifyTimeoutError ? st2.ETIMEDOUT : st2.ECONNABORTED, e6, l8)), l8 = null;
          }, Ot.hasStandardBrowserEnv && (c9 && et2.isFunction(c9) && (c9 = c9(e6)), c9 || false !== c9 && Ft(h7))) {
            const t10 = e6.xsrfHeaderName && e6.xsrfCookieName && Nt.read(e6.xsrfCookieName);
            t10 && s10.set(e6.xsrfHeaderName, t10);
          }
          void 0 === r8 && s10.setContentType(null), "setRequestHeader" in l8 && et2.forEach(s10.toJSON(), function(e7, t10) {
            l8.setRequestHeader(t10, e7);
          }), et2.isUndefined(e6.withCredentials) || (l8.withCredentials = !!e6.withCredentials), a8 && "json" !== a8 && (l8.responseType = e6.responseType), "function" == typeof e6.onDownloadProgress && l8.addEventListener("progress", Wt(e6.onDownloadProgress, true)), "function" == typeof e6.onUploadProgress && l8.upload && l8.upload.addEventListener("progress", Wt(e6.onUploadProgress)), (e6.cancelToken || e6.signal) && (o8 = (t10) => {
            l8 && (n7(!t10 || t10.type ? new Kt(null, e6, l8) : t10), l8.abort(), l8 = null);
          }, e6.cancelToken && e6.cancelToken.subscribe(o8), e6.signal && (e6.signal.aborted ? o8() : e6.signal.addEventListener("abort", o8)));
          const d7 = function(e7) {
            const t10 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e7);
            return t10 && t10[1] || "";
          }(h7);
          d7 && -1 === Ot.protocols.indexOf(d7) ? n7(new st2("Unsupported protocol " + d7 + ":", st2.ERR_BAD_REQUEST, e6)) : l8.send(r8 || null);
        });
      }, Bt = { http: null, xhr: qt };
      et2.forEach(Bt, (e6, t9) => {
        if (e6) {
          try {
            Object.defineProperty(e6, "name", { value: t9 });
          } catch (e7) {
          }
          Object.defineProperty(e6, "adapterName", { value: t9 });
        }
      });
      const Xt = (e6) => `- ${e6}`, Jt = (e6) => et2.isFunction(e6) || null === e6 || false === e6, zt = (e6) => {
        e6 = et2.isArray(e6) ? e6 : [e6];
        const { length: t9 } = e6;
        let n7, r8;
        const s10 = {};
        for (let o8 = 0; o8 < t9; o8++) {
          let t10;
          if (n7 = e6[o8], r8 = n7, !Jt(n7) && (r8 = Bt[(t10 = String(n7)).toLowerCase()], void 0 === r8))
            throw new st2(`Unknown adapter '${t10}'`);
          if (r8)
            break;
          s10[t10 || "#" + o8] = r8;
        }
        if (!r8) {
          const e7 = Object.entries(s10).map(([e8, t10]) => `adapter ${e8} ` + (false === t10 ? "is not supported by the environment" : "is not available in the build"));
          let n8 = t9 ? e7.length > 1 ? "since :\n" + e7.map(Xt).join("\n") : " " + Xt(e7[0]) : "as no adapter specified";
          throw new st2("There is no suitable adapter to dispatch the request " + n8, "ERR_NOT_SUPPORT");
        }
        return r8;
      };
      function Gt(e6) {
        if (e6.cancelToken && e6.cancelToken.throwIfRequested(), e6.signal && e6.signal.aborted)
          throw new Kt(null, e6);
      }
      function Ht(e6) {
        return Gt(e6), e6.headers = Ut.from(e6.headers), e6.data = _t2.call(e6, e6.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e6.method) && e6.headers.setContentType("application/x-www-form-urlencoded", false), zt(e6.adapter || Rt.adapter)(e6).then(function(t9) {
          return Gt(e6), t9.data = _t2.call(e6, e6.transformResponse, t9), t9.headers = Ut.from(t9.headers), t9;
        }, function(t9) {
          return Dt(t9) || (Gt(e6), t9 && t9.response && (t9.response.data = _t2.call(e6, e6.transformResponse, t9.response), t9.response.headers = Ut.from(t9.response.headers))), Promise.reject(t9);
        });
      }
      const $t = (e6) => e6 instanceof Ut ? e6.toJSON() : e6;
      function Vt(e6, t9) {
        t9 = t9 || {};
        const n7 = {};
        function r8(e7, t10, n8) {
          return et2.isPlainObject(e7) && et2.isPlainObject(t10) ? et2.merge.call({ caseless: n8 }, e7, t10) : et2.isPlainObject(t10) ? et2.merge({}, t10) : et2.isArray(t10) ? t10.slice() : t10;
        }
        function s10(e7, t10, n8) {
          return et2.isUndefined(t10) ? et2.isUndefined(e7) ? void 0 : r8(void 0, e7, n8) : r8(e7, t10, n8);
        }
        function o8(e7, t10) {
          if (!et2.isUndefined(t10))
            return r8(void 0, t10);
        }
        function i10(e7, t10) {
          return et2.isUndefined(t10) ? et2.isUndefined(e7) ? void 0 : r8(void 0, e7) : r8(void 0, t10);
        }
        function a8(n8, s11, o9) {
          return o9 in t9 ? r8(n8, s11) : o9 in e6 ? r8(void 0, n8) : void 0;
        }
        const c9 = { url: o8, method: o8, data: o8, baseURL: i10, transformRequest: i10, transformResponse: i10, paramsSerializer: i10, timeout: i10, timeoutMessage: i10, withCredentials: i10, withXSRFToken: i10, adapter: i10, responseType: i10, xsrfCookieName: i10, xsrfHeaderName: i10, onUploadProgress: i10, onDownloadProgress: i10, decompress: i10, maxContentLength: i10, maxBodyLength: i10, beforeRedirect: i10, transport: i10, httpAgent: i10, httpsAgent: i10, cancelToken: i10, socketPath: i10, responseEncoding: i10, validateStatus: a8, headers: (e7, t10) => s10($t(e7), $t(t10), true) };
        return et2.forEach(Object.keys(Object.assign({}, e6, t9)), function(r9) {
          const o9 = c9[r9] || s10, i11 = o9(e6[r9], t9[r9], r9);
          et2.isUndefined(i11) && o9 !== a8 || (n7[r9] = i11);
        }), n7;
      }
      const Yt = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((e6, t9) => {
        Yt[e6] = function(n7) {
          return typeof n7 === e6 || "a" + (t9 < 1 ? "n " : " ") + e6;
        };
      });
      const Qt = {};
      Yt.transitional = function(e6, t9, n7) {
        function r8(e7, t10) {
          return "[Axios v1.6.5] Transitional option '" + e7 + "'" + t10 + (n7 ? ". " + n7 : "");
        }
        return (n8, s10, o8) => {
          if (false === e6)
            throw new st2(r8(s10, " has been removed" + (t9 ? " in " + t9 : "")), st2.ERR_DEPRECATED);
          return t9 && !Qt[s10] && (Qt[s10] = true, console.warn(r8(s10, " has been deprecated since v" + t9 + " and will be removed in the near future"))), !e6 || e6(n8, s10, o8);
        };
      };
      const Zt = { assertOptions: function(e6, t9, n7) {
        if ("object" != typeof e6)
          throw new st2("options must be an object", st2.ERR_BAD_OPTION_VALUE);
        const r8 = Object.keys(e6);
        let s10 = r8.length;
        for (; s10-- > 0; ) {
          const o8 = r8[s10], i10 = t9[o8];
          if (i10) {
            const t10 = e6[o8], n8 = void 0 === t10 || i10(t10, o8, e6);
            if (true !== n8)
              throw new st2("option " + o8 + " must be " + n8, st2.ERR_BAD_OPTION_VALUE);
          } else if (true !== n7)
            throw new st2("Unknown option " + o8, st2.ERR_BAD_OPTION);
        }
      }, validators: Yt }, en = Zt.validators;
      class tn {
        constructor(e6) {
          this.defaults = e6, this.interceptors = { request: new mt2(), response: new mt2() };
        }
        request(e6, t9) {
          "string" == typeof e6 ? (t9 = t9 || {}).url = e6 : t9 = e6 || {}, t9 = Vt(this.defaults, t9);
          const { transitional: n7, paramsSerializer: r8, headers: s10 } = t9;
          void 0 !== n7 && Zt.assertOptions(n7, { silentJSONParsing: en.transitional(en.boolean), forcedJSONParsing: en.transitional(en.boolean), clarifyTimeoutError: en.transitional(en.boolean) }, false), null != r8 && (et2.isFunction(r8) ? t9.paramsSerializer = { serialize: r8 } : Zt.assertOptions(r8, { encode: en.function, serialize: en.function }, true)), t9.method = (t9.method || this.defaults.method || "get").toLowerCase();
          let o8 = s10 && et2.merge(s10.common, s10[t9.method]);
          s10 && et2.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e7) => {
            delete s10[e7];
          }), t9.headers = Ut.concat(o8, s10);
          const i10 = [];
          let a8 = true;
          this.interceptors.request.forEach(function(e7) {
            "function" == typeof e7.runWhen && false === e7.runWhen(t9) || (a8 = a8 && e7.synchronous, i10.unshift(e7.fulfilled, e7.rejected));
          });
          const c9 = [];
          let u7;
          this.interceptors.response.forEach(function(e7) {
            c9.push(e7.fulfilled, e7.rejected);
          });
          let l8, h7 = 0;
          if (!a8) {
            const e7 = [Ht.bind(this), void 0];
            for (e7.unshift.apply(e7, i10), e7.push.apply(e7, c9), l8 = e7.length, u7 = Promise.resolve(t9); h7 < l8; )
              u7 = u7.then(e7[h7++], e7[h7++]);
            return u7;
          }
          l8 = i10.length;
          let p6 = t9;
          for (h7 = 0; h7 < l8; ) {
            const e7 = i10[h7++], t10 = i10[h7++];
            try {
              p6 = e7(p6);
            } catch (e8) {
              t10.call(this, e8);
              break;
            }
          }
          try {
            u7 = Ht.call(this, p6);
          } catch (e7) {
            return Promise.reject(e7);
          }
          for (h7 = 0, l8 = c9.length; h7 < l8; )
            u7 = u7.then(c9[h7++], c9[h7++]);
          return u7;
        }
        getUri(e6) {
          return yt2(Mt((e6 = Vt(this.defaults, e6)).baseURL, e6.url), e6.params, e6.paramsSerializer);
        }
      }
      et2.forEach(["delete", "get", "head", "options"], function(e6) {
        tn.prototype[e6] = function(t9, n7) {
          return this.request(Vt(n7 || {}, { method: e6, url: t9, data: (n7 || {}).data }));
        };
      }), et2.forEach(["post", "put", "patch"], function(e6) {
        function t9(t10) {
          return function(n7, r8, s10) {
            return this.request(Vt(s10 || {}, { method: e6, headers: t10 ? { "Content-Type": "multipart/form-data" } : {}, url: n7, data: r8 }));
          };
        }
        tn.prototype[e6] = t9(), tn.prototype[e6 + "Form"] = t9(true);
      });
      const nn = tn;
      class rn {
        constructor(e6) {
          if ("function" != typeof e6)
            throw new TypeError("executor must be a function.");
          let t9;
          this.promise = new Promise(function(e7) {
            t9 = e7;
          });
          const n7 = this;
          this.promise.then((e7) => {
            if (!n7._listeners)
              return;
            let t10 = n7._listeners.length;
            for (; t10-- > 0; )
              n7._listeners[t10](e7);
            n7._listeners = null;
          }), this.promise.then = (e7) => {
            let t10;
            const r8 = new Promise((e8) => {
              n7.subscribe(e8), t10 = e8;
            }).then(e7);
            return r8.cancel = function() {
              n7.unsubscribe(t10);
            }, r8;
          }, e6(function(e7, r8, s10) {
            n7.reason || (n7.reason = new Kt(e7, r8, s10), t9(n7.reason));
          });
        }
        throwIfRequested() {
          if (this.reason)
            throw this.reason;
        }
        subscribe(e6) {
          this.reason ? e6(this.reason) : this._listeners ? this._listeners.push(e6) : this._listeners = [e6];
        }
        unsubscribe(e6) {
          if (!this._listeners)
            return;
          const t9 = this._listeners.indexOf(e6);
          -1 !== t9 && this._listeners.splice(t9, 1);
        }
        static source() {
          let e6;
          return { token: new rn(function(t9) {
            e6 = t9;
          }), cancel: e6 };
        }
      }
      const sn = rn, on = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
      Object.entries(on).forEach(([e6, t9]) => {
        on[t9] = e6;
      });
      const an = on, cn2 = function e6(t9) {
        const n7 = new nn(t9), r8 = be3(nn.prototype.request, n7);
        return et2.extend(r8, nn.prototype, n7, { allOwnKeys: true }), et2.extend(r8, n7, null, { allOwnKeys: true }), r8.create = function(n8) {
          return e6(Vt(t9, n8));
        }, r8;
      }(Rt);
      cn2.Axios = nn, cn2.CanceledError = Kt, cn2.CancelToken = sn, cn2.isCancel = Dt, cn2.VERSION = "1.6.5", cn2.toFormData = ut2, cn2.AxiosError = st2, cn2.Cancel = cn2.CanceledError, cn2.all = function(e6) {
        return Promise.all(e6);
      }, cn2.spread = function(e6) {
        return function(t9) {
          return e6.apply(null, t9);
        };
      }, cn2.isAxiosError = function(e6) {
        return et2.isObject(e6) && true === e6.isAxiosError;
      }, cn2.mergeConfig = Vt, cn2.AxiosHeaders = Ut, cn2.formToJSON = (e6) => Ct(et2.isHTMLForm(e6) ? new FormData(e6) : e6), cn2.getAdapter = zt, cn2.HttpStatusCode = an, cn2.default = cn2;
      const un = cn2, ln = "https://<project ID>.frontendapi.corbado.io".replace(/\/+$/, "");
      class hn {
        constructor(e6, t9 = ln, n7 = un) {
          this.basePath = t9, this.axios = n7, e6 && (this.configuration = e6, this.basePath = e6.basePath || this.basePath);
        }
      }
      class pn extends Error {
        constructor(e6, t9) {
          super(t9), this.field = e6, this.name = "RequiredError";
        }
      }
      const dn = "https://example.com", fn = function(e6, t9, n7) {
        if (null == n7)
          throw new pn(t9, `Required parameter ${t9} was null or undefined when calling ${e6}.`);
      }, yn = async function(e6, t9, n7) {
        if (n7 && n7.apiKey) {
          const r8 = "function" == typeof n7.apiKey ? await n7.apiKey(t9) : await n7.apiKey;
          e6[t9] = r8;
        }
      }, mn = async function(e6, t9) {
        if (t9 && t9.accessToken) {
          const n7 = "function" == typeof t9.accessToken ? await t9.accessToken() : await t9.accessToken;
          e6.Authorization = "Bearer " + n7;
        }
      };
      function wn(e6, t9, n7 = "") {
        null != t9 && ("object" == typeof t9 ? Array.isArray(t9) ? t9.forEach((t10) => wn(e6, t10, n7)) : Object.keys(t9).forEach((r8) => wn(e6, t9[r8], `${n7}${"" !== n7 ? "." : ""}${r8}`)) : e6.has(n7) ? e6.append(n7, t9) : e6.set(n7, t9));
      }
      const gn = function(e6, ...t9) {
        const n7 = new URLSearchParams(e6.search);
        wn(n7, t9), e6.search = n7.toString();
      }, vn = function(e6, t9, n7) {
        const r8 = "string" != typeof e6;
        return (r8 && n7 && n7.isJsonMime ? n7.isJsonMime(t9.headers["Content-Type"]) : r8) ? JSON.stringify(void 0 !== e6 ? e6 : {}) : e6 || "";
      }, bn = function(e6) {
        return e6.pathname + e6.search + e6.hash;
      }, Sn = function(e6, t9, n7, r8) {
        return (s10 = t9, o8 = n7) => {
          const i10 = { ...e6.options, url: ((null == r8 ? void 0 : r8.basePath) || s10.defaults.baseURL || o8) + e6.url };
          return s10.request(i10);
        };
      }, En = function(e6) {
        const t9 = /* @__PURE__ */ function(e7) {
          return { appleAppSiteAssociation: async (t10 = {}) => {
            const n7 = new URL("/.well-known/apple-app-site-association", dn);
            let r8;
            e7 && (r8 = e7.baseOptions);
            const s10 = { method: "GET", ...r8, ...t10 }, o8 = {};
            await mn(o8, e7), await yn(o8, "X-Corbado-ProjectID", e7), gn(n7, {});
            let i10 = r8 && r8.headers ? r8.headers : {};
            return s10.headers = { ...o8, ...i10, ...t10.headers }, { url: bn(n7), options: s10 };
          }, assetLinks: async (t10 = {}) => {
            const n7 = new URL("/.well-known/assetlinks.json", dn);
            let r8;
            e7 && (r8 = e7.baseOptions);
            const s10 = { method: "GET", ...r8, ...t10 }, o8 = {};
            await mn(o8, e7), await yn(o8, "X-Corbado-ProjectID", e7), gn(n7, {});
            let i10 = r8 && r8.headers ? r8.headers : {};
            return s10.headers = { ...o8, ...i10, ...t10.headers }, { url: bn(n7), options: s10 };
          } };
        }(e6);
        return { async appleAppSiteAssociation(n7) {
          const r8 = await t9.appleAppSiteAssociation(n7);
          return Sn(r8, un, ln, e6);
        }, async assetLinks(n7) {
          const r8 = await t9.assetLinks(n7);
          return Sn(r8, un, ln, e6);
        } };
      };
      class On extends hn {
        appleAppSiteAssociation(e6) {
          return En(this.configuration).appleAppSiteAssociation(e6).then((e7) => e7(this.axios, this.basePath));
        }
        assetLinks(e6) {
          return En(this.configuration).assetLinks(e6).then((e7) => e7(this.axios, this.basePath));
        }
      }
      class Cn extends hn {
        projectConfig(e6) {
          return (/* @__PURE__ */ function(e7) {
            const t9 = /* @__PURE__ */ function(e8) {
              return { projectConfig: async (t10 = {}) => {
                const n7 = new URL("/v1/projects/projectConfig", dn);
                let r8;
                e8 && (r8 = e8.baseOptions);
                const s10 = { method: "GET", ...r8, ...t10 }, o8 = {};
                await mn(o8, e8), await yn(o8, "X-Corbado-ProjectID", e8), gn(n7, {});
                let i10 = r8 && r8.headers ? r8.headers : {};
                return s10.headers = { ...o8, ...i10, ...t10.headers }, { url: bn(n7), options: s10 };
              } };
            }(e7);
            return { async projectConfig(n7) {
              const r8 = await t9.projectConfig(n7);
              return Sn(r8, un, ln, e7);
            } };
          }(this.configuration)).projectConfig(e6).then((e7) => e7(this.axios, this.basePath));
        }
      }
      const kn = function(e6) {
        const t9 = /* @__PURE__ */ function(e7) {
          return { sessionLogout: async (t10, n7 = {}) => {
            fn("sessionLogout", "emptyReq", t10);
            const r8 = new URL("/v1/sessions/logout", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "DELETE", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, sessionRefresh: async (t10, n7 = {}) => {
            fn("sessionRefresh", "emptyReq", t10);
            const r8 = new URL("/v1/sessions/refresh", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "PUT", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, wellKnownJWKSList: async (t10 = {}) => {
            const n7 = new URL("/.well-known/jwks", dn);
            let r8;
            e7 && (r8 = e7.baseOptions);
            const s10 = { method: "GET", ...r8, ...t10 }, o8 = {};
            await mn(o8, e7), await yn(o8, "X-Corbado-ProjectID", e7), gn(n7, {});
            let i10 = r8 && r8.headers ? r8.headers : {};
            return s10.headers = { ...o8, ...i10, ...t10.headers }, { url: bn(n7), options: s10 };
          } };
        }(e6);
        return { async sessionLogout(n7, r8) {
          const s10 = await t9.sessionLogout(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async sessionRefresh(n7, r8) {
          const s10 = await t9.sessionRefresh(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async wellKnownJWKSList(n7) {
          const r8 = await t9.wellKnownJWKSList(n7);
          return Sn(r8, un, ln, e6);
        } };
      };
      class Rn extends hn {
        sessionLogout(e6, t9) {
          return kn(this.configuration).sessionLogout(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        sessionRefresh(e6, t9) {
          return kn(this.configuration).sessionRefresh(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        wellKnownJWKSList(e6) {
          return kn(this.configuration).wellKnownJWKSList(e6).then((e7) => e7(this.axios, this.basePath));
        }
      }
      const xn = function(e6) {
        const t9 = /* @__PURE__ */ function(e7) {
          return { authMethodsList: async (t10, n7 = {}) => {
            fn("authMethodsList", "authMethodsListReq", t10);
            const r8 = new URL("/v1/users/authmethods", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, currentUserGet: async (t10 = {}) => {
            const n7 = new URL("/v1/me", dn);
            let r8;
            e7 && (r8 = e7.baseOptions);
            const s10 = { method: "GET", ...r8, ...t10 }, o8 = {};
            await mn(o8, e7), await yn(o8, "X-Corbado-ProjectID", e7), gn(n7, {});
            let i10 = r8 && r8.headers ? r8.headers : {};
            return s10.headers = { ...o8, ...i10, ...t10.headers }, { url: bn(n7), options: s10 };
          }, currentUserPassKeyDelete: async (t10, n7 = {}) => {
            fn("currentUserPassKeyDelete", "credentialID", t10);
            const r8 = "/v1/me/passkeys/{credentialID}".replace("{credentialID}", encodeURIComponent(String(t10))), s10 = new URL(r8, dn);
            let o8;
            e7 && (o8 = e7.baseOptions);
            const i10 = { method: "DELETE", ...o8, ...n7 }, a8 = {};
            await mn(a8, e7), await yn(a8, "X-Corbado-ProjectID", e7), gn(s10, {});
            let c9 = o8 && o8.headers ? o8.headers : {};
            return i10.headers = { ...a8, ...c9, ...n7.headers }, { url: bn(s10), options: i10 };
          }, currentUserPassKeyGet: async (t10 = {}) => {
            const n7 = new URL("/v1/me/passkeys", dn);
            let r8;
            e7 && (r8 = e7.baseOptions);
            const s10 = { method: "GET", ...r8, ...t10 }, o8 = {};
            await mn(o8, e7), await yn(o8, "X-Corbado-ProjectID", e7), gn(n7, {});
            let i10 = r8 && r8.headers ? r8.headers : {};
            return s10.headers = { ...o8, ...i10, ...t10.headers }, { url: bn(n7), options: s10 };
          }, emailCodeConfirm: async (t10, n7 = {}) => {
            fn("emailCodeConfirm", "emailCodeConfirmReq", t10);
            const r8 = new URL("/v1/users/emailcodes/confirm", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, emailCodeLoginStart: async (t10, n7 = {}) => {
            fn("emailCodeLoginStart", "emailCodeLoginStartReq", t10);
            const r8 = new URL("/v1/users/emailcodes/login/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, emailCodeRegisterStart: async (t10, n7 = {}) => {
            fn("emailCodeRegisterStart", "emailCodeRegisterStartReq", t10);
            const r8 = new URL("/v1/users/emailcodes/register/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, emailCodeStatus: async (t10, n7 = {}) => {
            fn("emailCodeStatus", "emailCodeStatusReq", t10);
            const r8 = new URL("/v1/users/emailcodes/status", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, emailLinkConfirm: async (t10, n7 = {}) => {
            fn("emailLinkConfirm", "emailLinkConfirmReq", t10);
            const r8 = new URL("/v1/users/emaillinks/confirm", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, emailLinkLoginStart: async (t10, n7 = {}) => {
            fn("emailLinkLoginStart", "emailLinkLoginStartReq", t10);
            const r8 = new URL("/v1/users/emaillinks/login/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, emailLinkRegisterStart: async (t10, n7 = {}) => {
            fn("emailLinkRegisterStart", "emailLinkRegisterStartReq", t10);
            const r8 = new URL("/v1/users/emaillinks/register/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, emailLinkStatus: async (t10, n7 = {}) => {
            fn("emailLinkStatus", "emailLinkStatusReq", t10);
            const r8 = new URL("/v1/users/emaillinks/status", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, loginToken: async (t10, n7 = {}) => {
            fn("loginToken", "loginTokenReq", t10);
            const r8 = new URL("/v1/users/logintoken", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyAppendFinish: async (t10, n7 = {}) => {
            fn("passKeyAppendFinish", "passKeyFinishReq", t10);
            const r8 = new URL("/v1/users/passkey/append/finish", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyAppendStart: async (t10, n7 = {}) => {
            fn("passKeyAppendStart", "emptyReq", t10);
            const r8 = new URL("/v1/users/passkey/append/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyAssociateStart: async (t10, n7 = {}) => {
            fn("passKeyAssociateStart", "passKeyAssociateStartReq", t10);
            const r8 = new URL("/v1/users/passkey/associate/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyCredentialExists: async (t10, n7 = {}) => {
            fn("passKeyCredentialExists", "passKeyCredentialExistsReq", t10);
            const r8 = new URL("/v1/users/device/passkey", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyLoginFinish: async (t10, n7 = {}) => {
            fn("passKeyLoginFinish", "passKeyFinishReq", t10);
            const r8 = new URL("/v1/users/passkey/login/finish", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyLoginStart: async (t10, n7 = {}) => {
            fn("passKeyLoginStart", "passKeyLoginStartReq", t10);
            const r8 = new URL("/v1/users/passkey/login/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyMediationStart: async (t10, n7 = {}) => {
            fn("passKeyMediationStart", "passKeyMediationStartReq", t10);
            const r8 = new URL("/v1/users/passkey/mediation/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyRegisterFinish: async (t10, n7 = {}) => {
            fn("passKeyRegisterFinish", "passKeyFinishReq", t10);
            const r8 = new URL("/v1/users/passkey/register/finish", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, passKeyRegisterStart: async (t10, n7 = {}) => {
            fn("passKeyRegisterStart", "passKeyRegisterStartReq", t10);
            const r8 = new URL("/v1/users/passkey/register/start", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, password: async (t10, n7 = {}) => {
            fn("password", "passwordVerifyReq", t10);
            const r8 = new URL("/v1/users/password/verify", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "POST", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          }, userExists: async (t10, n7 = {}) => {
            fn("userExists", "userExistsReq", t10);
            const r8 = new URL("/v1/users/exists", dn);
            let s10;
            e7 && (s10 = e7.baseOptions);
            const o8 = { method: "PUT", ...s10, ...n7 }, i10 = {};
            await mn(i10, e7), await yn(i10, "X-Corbado-ProjectID", e7), i10["Content-Type"] = "application/json", gn(r8, {});
            let a8 = s10 && s10.headers ? s10.headers : {};
            return o8.headers = { ...i10, ...a8, ...n7.headers }, o8.data = vn(t10, o8, e7), { url: bn(r8), options: o8 };
          } };
        }(e6);
        return { async authMethodsList(n7, r8) {
          const s10 = await t9.authMethodsList(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async currentUserGet(n7) {
          const r8 = await t9.currentUserGet(n7);
          return Sn(r8, un, ln, e6);
        }, async currentUserPassKeyDelete(n7, r8) {
          const s10 = await t9.currentUserPassKeyDelete(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async currentUserPassKeyGet(n7) {
          const r8 = await t9.currentUserPassKeyGet(n7);
          return Sn(r8, un, ln, e6);
        }, async emailCodeConfirm(n7, r8) {
          const s10 = await t9.emailCodeConfirm(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async emailCodeLoginStart(n7, r8) {
          const s10 = await t9.emailCodeLoginStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async emailCodeRegisterStart(n7, r8) {
          const s10 = await t9.emailCodeRegisterStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async emailCodeStatus(n7, r8) {
          const s10 = await t9.emailCodeStatus(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async emailLinkConfirm(n7, r8) {
          const s10 = await t9.emailLinkConfirm(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async emailLinkLoginStart(n7, r8) {
          const s10 = await t9.emailLinkLoginStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async emailLinkRegisterStart(n7, r8) {
          const s10 = await t9.emailLinkRegisterStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async emailLinkStatus(n7, r8) {
          const s10 = await t9.emailLinkStatus(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async loginToken(n7, r8) {
          const s10 = await t9.loginToken(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyAppendFinish(n7, r8) {
          const s10 = await t9.passKeyAppendFinish(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyAppendStart(n7, r8) {
          const s10 = await t9.passKeyAppendStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyAssociateStart(n7, r8) {
          const s10 = await t9.passKeyAssociateStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyCredentialExists(n7, r8) {
          const s10 = await t9.passKeyCredentialExists(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyLoginFinish(n7, r8) {
          const s10 = await t9.passKeyLoginFinish(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyLoginStart(n7, r8) {
          const s10 = await t9.passKeyLoginStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyMediationStart(n7, r8) {
          const s10 = await t9.passKeyMediationStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyRegisterFinish(n7, r8) {
          const s10 = await t9.passKeyRegisterFinish(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async passKeyRegisterStart(n7, r8) {
          const s10 = await t9.passKeyRegisterStart(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async password(n7, r8) {
          const s10 = await t9.password(n7, r8);
          return Sn(s10, un, ln, e6);
        }, async userExists(n7, r8) {
          const s10 = await t9.userExists(n7, r8);
          return Sn(s10, un, ln, e6);
        } };
      };
      class An extends hn {
        authMethodsList(e6, t9) {
          return xn(this.configuration).authMethodsList(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        currentUserGet(e6) {
          return xn(this.configuration).currentUserGet(e6).then((e7) => e7(this.axios, this.basePath));
        }
        currentUserPassKeyDelete(e6, t9) {
          return xn(this.configuration).currentUserPassKeyDelete(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        currentUserPassKeyGet(e6) {
          return xn(this.configuration).currentUserPassKeyGet(e6).then((e7) => e7(this.axios, this.basePath));
        }
        emailCodeConfirm(e6, t9) {
          return xn(this.configuration).emailCodeConfirm(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        emailCodeLoginStart(e6, t9) {
          return xn(this.configuration).emailCodeLoginStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        emailCodeRegisterStart(e6, t9) {
          return xn(this.configuration).emailCodeRegisterStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        emailCodeStatus(e6, t9) {
          return xn(this.configuration).emailCodeStatus(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        emailLinkConfirm(e6, t9) {
          return xn(this.configuration).emailLinkConfirm(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        emailLinkLoginStart(e6, t9) {
          return xn(this.configuration).emailLinkLoginStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        emailLinkRegisterStart(e6, t9) {
          return xn(this.configuration).emailLinkRegisterStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        emailLinkStatus(e6, t9) {
          return xn(this.configuration).emailLinkStatus(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        loginToken(e6, t9) {
          return xn(this.configuration).loginToken(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyAppendFinish(e6, t9) {
          return xn(this.configuration).passKeyAppendFinish(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyAppendStart(e6, t9) {
          return xn(this.configuration).passKeyAppendStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyAssociateStart(e6, t9) {
          return xn(this.configuration).passKeyAssociateStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyCredentialExists(e6, t9) {
          return xn(this.configuration).passKeyCredentialExists(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyLoginFinish(e6, t9) {
          return xn(this.configuration).passKeyLoginFinish(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyLoginStart(e6, t9) {
          return xn(this.configuration).passKeyLoginStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyMediationStart(e6, t9) {
          return xn(this.configuration).passKeyMediationStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyRegisterFinish(e6, t9) {
          return xn(this.configuration).passKeyRegisterFinish(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        passKeyRegisterStart(e6, t9) {
          return xn(this.configuration).passKeyRegisterStart(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        password(e6, t9) {
          return xn(this.configuration).password(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
        userExists(e6, t9) {
          return xn(this.configuration).userExists(e6, t9).then((e7) => e7(this.axios, this.basePath));
        }
      }
      class Ln {
        constructor(e6 = {}) {
          this.apiKey = e6.apiKey, this.username = e6.username, this.password = e6.password, this.accessToken = e6.accessToken, this.basePath = e6.basePath, this.baseOptions = e6.baseOptions, this.formDataCtor = e6.formDataCtor;
        }
        isJsonMime(e6) {
          const t9 = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
          return null !== e6 && (t9.test(e6) || "application/json-patch+json" === e6.toLowerCase());
        }
      }
      var Pn, Tn, jn, Un, _n, Dn, In, Kn, Nn, Mn, Fn, Wn, qn, Bn, Xn, Jn, zn, Gn, Hn, $n, Vn, Yn, Qn, Zn, er, tr, nr, rr, sr, or, ir;
      class ar {
        constructor(e6) {
          Pn.set(this, void 0), Tn.set(this, void 0), h6(this, Pn, e6, "f");
          const t9 = e6.split(".");
          h6(this, Tn, JSON.parse(atob(t9[1])), "f");
        }
        get value() {
          return l7(this, Pn, "f");
        }
        get user() {
          return l7(this, Tn, "f");
        }
        isValidForXMoreSeconds(e6) {
          const t9 = (/* @__PURE__ */ new Date()).getTime() / 1e3;
          return l7(this, Tn, "f").exp > t9 + e6;
        }
        toString() {
          return l7(this, Pn, "f");
        }
      }
      Pn = /* @__PURE__ */ new WeakMap(), Tn = /* @__PURE__ */ new WeakMap();
      class cr {
        constructor(e6, t9, n7) {
          this.shortSession = e6, this.redirectURL = t9, this.longSession = n7;
        }
        static fromApiAuthenticationRsp(e6) {
          var t9;
          if (!(null === (t9 = e6.shortSession) || void 0 === t9 ? void 0 : t9.value))
            throw new Error("ShortSession is undefined. This must never happen.");
          return new cr(new ar(e6.shortSession.value), e6.redirectURL, e6.longSession);
        }
      }
      class ur {
        constructor(e6, t9, n7 = 3e4, r8) {
          jn.add(this), Un.set(this, new An()), _n.set(this, new On()), Dn.set(this, new Cn()), In.set(this, new Rn()), Kn.set(this, void 0), Nn.set(this, void 0), Mn.set(this, void 0), Fn.set(this, void 0), h6(this, Kn, e6, "f"), h6(this, Nn, t9, "f"), h6(this, Mn, n7, "f"), h6(this, Fn, r8 || `https://${l7(this, Nn, "f")}.frontendapi.corbado.io`, "f"), l7(this, jn, "m", qn).call(this, "");
        }
        get usersApi() {
          return l7(this, Un, "f");
        }
        get assetsApi() {
          return l7(this, _n, "f");
        }
        get projectsApi() {
          return l7(this, Dn, "f");
        }
        get sessionsApi() {
          return l7(this, In, "f");
        }
        setInstanceWithToken(e6) {
          l7(this, jn, "m", qn).call(this, e6);
        }
        passKeyRegisterStart(e6, t9) {
          return me3.wrapAsync(async () => (await this.usersApi.passKeyRegisterStart({ username: e6, fullName: t9 })).data.data.challenge);
        }
        passKeyRegisterFinish(e6) {
          return me3.wrapAsync(async () => {
            const t9 = await this.usersApi.passKeyRegisterFinish({ signedChallenge: e6 });
            return cr.fromApiAuthenticationRsp(t9.data.data);
          });
        }
        passKeyAppendStart() {
          return me3.wrapAsync(async () => (await this.usersApi.passKeyAppendStart({})).data.data.challenge);
        }
        passKeyAppendFinish(e6) {
          return me3.wrapAsync(async () => {
            await this.usersApi.passKeyAppendFinish({ signedChallenge: e6 });
          });
        }
        passKeyLoginStart(e6) {
          return me3.wrapAsync(async () => {
            const t9 = await this.usersApi.passKeyLoginStart({ username: e6 });
            return "" === t9.data.data.challenge ? Promise.reject(y7.noPasskeyAvailable()) : t9.data.data.challenge;
          });
        }
        passKeyLoginFinish(e6) {
          return me3.wrapAsync(async () => {
            const t9 = await this.usersApi.passKeyLoginFinish({ signedChallenge: e6 });
            return cr.fromApiAuthenticationRsp(t9.data.data);
          });
        }
        passKeyMediationStart() {
          return me3.wrapAsync(async () => (await this.usersApi.passKeyMediationStart({ username: "" })).data.data.challenge);
        }
        emailCodeRegisterStart(e6, t9) {
          return me3.wrapAsync(async () => (await this.usersApi.emailCodeRegisterStart({ email: e6, username: t9 })).data.data.emailCodeID);
        }
        emailCodeLoginStart(e6) {
          return me3.wrapAsync(async () => (await this.usersApi.emailCodeLoginStart({ username: e6 })).data.data.emailCodeID);
        }
        async emailCodeConfirm(e6, t9) {
          return "" === e6 ? we3(y7.illegalState("email OTP challenge has not been started", "")) : me3.wrapAsync(async () => {
            const n7 = await this.usersApi.emailCodeConfirm({ emailCodeID: e6, code: t9 });
            return cr.fromApiAuthenticationRsp(n7.data.data);
          });
        }
        emailLinkRegisterStart(e6, t9) {
          return me3.wrapAsync(async () => (await this.usersApi.emailLinkRegisterStart({ email: e6, username: t9 })).data.data.emailLinkID);
        }
        emailLinkLoginStart(e6) {
          return me3.wrapAsync(async () => (await this.usersApi.emailLinkLoginStart({ username: e6 })).data.data.emailLinkID);
        }
        async emailLinkConfirm(e6, t9) {
          return "" === e6 ? we3(y7.illegalState("email magic link challenge has not been started", "")) : me3.wrapAsync(async () => {
            const n7 = await this.usersApi.emailLinkConfirm({ emailLinkID: e6, token: t9 });
            return cr.fromApiAuthenticationRsp(n7.data.data);
          });
        }
        async authMethodsList(e6) {
          return me3.wrapAsync(async () => (await this.usersApi.authMethodsList({ username: e6 })).data.data);
        }
        async getProjectConfig() {
          return me3.wrapAsync(async () => (await this.projectsApi.projectConfig()).data.data);
        }
        async passkeyList() {
          return me3.wrapAsync(async () => (await l7(this, Un, "f").currentUserPassKeyGet()).data.data);
        }
        async passkeyDelete(e6) {
          return me3.wrapAsync(async () => {
            await l7(this, Un, "f").currentUserPassKeyDelete(e6);
          });
        }
        async userExists(e6, t9) {
          return me3.wrapAsync(async () => (await this.usersApi.userExists({ loginIdentifierType: e6, loginIdentifier: t9 })).data.exists);
        }
      }
      Un = /* @__PURE__ */ new WeakMap(), _n = /* @__PURE__ */ new WeakMap(), Dn = /* @__PURE__ */ new WeakMap(), In = /* @__PURE__ */ new WeakMap(), Kn = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakMap(), Mn = /* @__PURE__ */ new WeakMap(), Fn = /* @__PURE__ */ new WeakMap(), jn = /* @__PURE__ */ new WeakSet(), Wn = function(e6) {
        const t9 = { "Content-Type": "application/json", "X-Corbado-WC-Version": JSON.stringify({ name: "web-core", sdkVersion: "0.0.0" }) }, n7 = un.create({ timeout: l7(this, Mn, "f"), withCredentials: true, headers: e6 ? { ...t9, Authorization: `Bearer ${e6}` } : t9 });
        return n7.interceptors.response.use((e7) => e7, (e7) => {
          const t10 = y7.fromAxiosError(e7);
          return f5().warn("error", t10), t10 instanceof w6 ? (l7(this, Kn, "f").next(t10), Promise.reject()) : Promise.reject(t10);
        }), n7;
      }, qn = function(e6) {
        const t9 = new Ln({ apiKey: l7(this, Nn, "f"), basePath: l7(this, Fn, "f"), accessToken: e6 }), n7 = l7(this, jn, "m", Wn).call(this, e6);
        h6(this, Un, new An(t9, l7(this, Fn, "f"), n7), "f"), h6(this, _n, new On(t9, l7(this, Fn, "f"), n7), "f"), h6(this, Dn, new Cn(t9, l7(this, Fn, "f"), n7), "f"), h6(this, In, new Rn(t9, l7(this, Fn, "f"), n7), "f");
      };
      const lr = "cbo_short_session", hr = "cbo_long_session";
      class pr {
        constructor(e6, t9) {
          Bn.add(this), Jn.set(this, void 0), zn.set(this, void 0), Gn.set(this, void 0), Hn.set(this, void 0), $n.set(this, void 0), Vn.set(this, void 0), h6(this, Jn, e6, "f"), h6(this, Hn, void 0, "f"), h6(this, zn, t9, "f");
        }
        async init(e6) {
          h6(this, $n, e6, "f"), h6(this, Hn, l7(Xn, Xn, "m", er).call(Xn), "f"), h6(this, Gn, l7(Xn, Xn, "m", Yn).call(Xn), "f"), l7(this, Gn, "f") && l7(this, Gn, "f").isValidForXMoreSeconds(0) ? (f5().debug("emit shortsession", l7(this, Gn, "f")), l7(this, $n, "f").call(this, l7(this, Gn, "f")), l7(this, Jn, "f").setInstanceWithToken(l7(this, Gn, "f").value)) : await l7(this, Bn, "m", sr).call(this), h6(this, Vn, setInterval(() => {
            l7(this, Bn, "m", sr).call(this);
          }, 1e4), "f"), document.addEventListener("visibilitychange", () => {
            l7(this, Bn, "m", ir).call(this);
          });
        }
        get shortSession() {
          return l7(this, Gn, "f");
        }
        getUser() {
          if (!l7(this, Gn, "f"))
            return;
          const e6 = l7(this, Gn, "f").value.split("."), t9 = JSON.parse(atob(e6[1]));
          return { email: t9.email, name: t9.name, orig: t9.orig, sub: t9.sub, exp: t9.exp };
        }
        async getCorbadoUser() {
          return (await l7(this, Jn, "f").usersApi.currentUserGet()).data.data;
        }
        setSession(e6, t9) {
          l7(this, Bn, "m", tr).call(this, e6), l7(this, Jn, "f").setInstanceWithToken(e6.value), l7(this, $n, "f") && l7(this, $n, "f").call(this, e6), l7(this, Bn, "m", rr).call(this, t9);
        }
        clear() {
          l7(this, Bn, "m", nr).call(this), l7(this, Bn, "m", Zn).call(this), l7(this, Vn, "f") && clearInterval(l7(this, Vn, "f"));
        }
        logout() {
          f5().debug("logging out user"), this.clear(), l7(this, $n, "f") && l7(this, $n, "f").call(this, void 0);
        }
      }
      function dr(e6) {
        const t9 = "==".slice(0, (4 - e6.length % 4) % 4), n7 = e6.replace(/-/g, "+").replace(/_/g, "/") + t9, r8 = atob(n7), s10 = new ArrayBuffer(r8.length), o8 = new Uint8Array(s10);
        for (let e7 = 0; e7 < r8.length; e7++)
          o8[e7] = r8.charCodeAt(e7);
        return s10;
      }
      function fr(e6) {
        const t9 = new Uint8Array(e6);
        let n7 = "";
        for (const e7 of t9)
          n7 += String.fromCharCode(e7);
        return btoa(n7).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }
      Xn = pr, Jn = /* @__PURE__ */ new WeakMap(), zn = /* @__PURE__ */ new WeakMap(), Gn = /* @__PURE__ */ new WeakMap(), Hn = /* @__PURE__ */ new WeakMap(), $n = /* @__PURE__ */ new WeakMap(), Vn = /* @__PURE__ */ new WeakMap(), Bn = /* @__PURE__ */ new WeakSet(), Yn = function() {
        const e6 = localStorage.getItem(lr);
        if (e6)
          return new ar(e6);
        const t9 = l7(this, Xn, "m", Qn).call(this, lr);
        return t9 ? new ar(t9) : void 0;
      }, Qn = function(e6) {
        const t9 = new RegExp(`(^| )${e6}=([^;]+)`), n7 = document.cookie.match(t9);
        if (n7)
          return n7[2];
      }, Zn = function() {
        localStorage.removeItem(hr), h6(this, Hn, "", "f");
      }, er = function() {
        var e6;
        return null !== (e6 = localStorage.getItem(hr)) && void 0 !== e6 ? e6 : "";
      }, tr = function(e6) {
        localStorage.setItem(lr, e6.toString()), h6(this, Gn, e6, "f"), l7(this, zn, "f") && (document.cookie = `${lr}=${e6.toString()}; path=/;`);
      }, nr = function() {
        localStorage.removeItem(lr), h6(this, Gn, void 0, "f"), l7(this, zn, "f") && (document.cookie = `${lr}=; path=/; expires=${(/* @__PURE__ */ new Date()).toUTCString()}`);
      }, rr = function(e6) {
        e6 && (localStorage.setItem(hr, e6), h6(this, Hn, e6, "f"));
      }, sr = async function() {
        l7(this, Gn, "f") ? (l7(this, Gn, "f").isValidForXMoreSeconds(60) || await l7(this, Bn, "m", or).call(this), f5().debug("no refresh, no refresh, token still valid")) : f5().debug("session refresh: no refresh, user not logged in");
      }, or = async function() {
        var e6, t9;
        f5().debug("session refresh: starting refresh");
        try {
          const n7 = { headers: { Authorization: `Bearer ${l7(this, Hn, "f")}` } }, r8 = await l7(this, Jn, "f").sessionsApi.sessionRefresh({}, n7);
          if (200 !== r8.status)
            return void f5().warn(`refresh error, status code: ${r8.status}`);
          if (!(null === (e6 = r8.data.shortSession) || void 0 === e6 ? void 0 : e6.value))
            return void f5().warn("refresh error, missing short session");
          const s10 = new ar(null === (t9 = r8.data.shortSession) || void 0 === t9 ? void 0 : t9.value);
          this.setSession(s10, void 0);
        } catch (e7) {
          f5().warn(e7), this.logout();
        }
      }, ir = function() {
        if (document.hidden)
          f5().debug("session refresh: no refresh, page is hidden");
        else
          try {
            l7(this, Bn, "m", sr).call(this);
          } catch (e6) {
            f5().error(e6);
          }
      };
      var yr = "copy", mr = "convert";
      function wr(e6, t9, n7) {
        if (t9 === yr)
          return n7;
        if (t9 === mr)
          return e6(n7);
        if (t9 instanceof Array)
          return n7.map((n8) => wr(e6, t9[0], n8));
        if (t9 instanceof Object) {
          const r8 = {};
          for (const [s10, o8] of Object.entries(t9)) {
            if (o8.derive) {
              const e7 = o8.derive(n7);
              void 0 !== e7 && (n7[s10] = e7);
            }
            if (s10 in n7)
              null != n7[s10] ? r8[s10] = wr(e6, o8.schema, n7[s10]) : r8[s10] = null;
            else if (o8.required)
              throw new Error(`Missing key: ${s10}`);
          }
          return r8;
        }
      }
      function gr(e6, t9) {
        return { required: true, schema: e6, derive: t9 };
      }
      function vr(e6) {
        return { required: true, schema: e6 };
      }
      function br(e6) {
        return { required: false, schema: e6 };
      }
      var Sr, Er, Or, Cr, kr, Rr, xr, Ar, Lr, Pr, Tr, jr, Ur, _r, Dr, Ir, Kr, Nr, Mr, Fr, Wr, qr, Br2, Xr, Jr, zr, Gr, Hr2, $r = { type: vr(yr), id: vr(mr), transports: br(yr) }, Vr = { appid: br(yr), appidExclude: br(yr), credProps: br(yr) }, Yr = { appid: br(yr), appidExclude: br(yr), credProps: br(yr) }, Qr = { publicKey: vr({ rp: vr(yr), user: vr({ id: vr(mr), name: vr(yr), displayName: vr(yr) }), challenge: vr(mr), pubKeyCredParams: vr(yr), timeout: br(yr), excludeCredentials: br([$r]), authenticatorSelection: br(yr), attestation: br(yr), extensions: br(Vr) }), signal: br(yr) }, Zr = { type: vr(yr), id: vr(yr), rawId: vr(mr), authenticatorAttachment: br(yr), response: vr({ clientDataJSON: vr(mr), attestationObject: vr(mr), transports: gr(yr, (e6) => {
        var t9;
        return (null == (t9 = e6.getTransports) ? void 0 : t9.call(e6)) || [];
      }) }), clientExtensionResults: gr(Yr, (e6) => e6.getClientExtensionResults()) }, es = { mediation: br(yr), publicKey: vr({ challenge: vr(mr), timeout: br(yr), rpId: br(yr), allowCredentials: br([$r]), userVerification: br(yr), extensions: br(Vr) }), signal: br(yr) }, ts = { type: vr(yr), id: vr(yr), rawId: vr(mr), authenticatorAttachment: br(yr), response: vr({ clientDataJSON: vr(mr), authenticatorData: vr(mr), signature: vr(mr), userHandle: vr(mr) }), clientExtensionResults: gr(Yr, (e6) => e6.getClientExtensionResults()) };
      class ns {
        constructor(e6) {
          Sr.add(this), Er.set(this, void 0), Or.set(this, void 0), h6(this, Er, e6, "f");
        }
        createPasskey(e6) {
          return l7(this, Sr, "m", Cr).call(this, async () => {
            try {
              this.abortOngoingOperation();
              const t9 = JSON.parse(e6), n7 = new AbortController();
              t9.signal = n7.signal, h6(this, Or, n7, "f");
              const r8 = await async function(e7) {
                return function(e8) {
                  return wr(fr, Zr, e8);
                }(await navigator.credentials.create(function(e8) {
                  return wr(dr, Qr, e8);
                }(e7)));
              }(t9), s10 = JSON.stringify(r8);
              return ge3(s10);
            } catch (e7) {
              return e7 instanceof DOMException ? we3(y7.fromDOMException(e7)) : we3(y7.fromUnknownException(e7));
            }
          });
        }
        async login(e6, t9) {
          return l7(this, Sr, "m", Cr).call(this, async () => {
            try {
              this.abortOngoingOperation();
              const n7 = JSON.parse(e6), r8 = new AbortController();
              n7.signal = r8.signal, t9 && (n7.mediation = "conditional"), h6(this, Or, r8, "f");
              const s10 = await async function(e7) {
                return function(e8) {
                  return wr(fr, ts, e8);
                }(await navigator.credentials.get(function(e8) {
                  return wr(dr, es, e8);
                }(e7)));
              }(n7), o8 = JSON.stringify(s10);
              return ge3(o8);
            } catch (e7) {
              return e7 instanceof DOMException ? we3(y7.fromDOMException(e7)) : we3(y7.fromUnknownException(e7));
            }
          });
        }
        abortOngoingOperation() {
          var e6;
          null === (e6 = l7(this, Or, "f")) || void 0 === e6 || e6.abort();
        }
      }
      Er = /* @__PURE__ */ new WeakMap(), Or = /* @__PURE__ */ new WeakMap(), Sr = /* @__PURE__ */ new WeakSet(), Cr = async function(e6) {
        const t9 = await e6();
        return t9.err && t9.val instanceof w6 ? (l7(this, Er, "f").next(t9.val), t9) : t9;
      };
      class rs {
        constructor(e6, t9, n7) {
          kr.add(this), Rr.set(this, void 0), xr.set(this, void 0), Ar.set(this, void 0), Lr.set(this, ""), Pr.set(this, new he3(void 0)), Tr.set(this, new he3(void 0)), jr.set(this, new he3(s9.LoggedOut)), Ur.set(this, (e7) => {
            l7(this, Ar, "f").setSession(e7.shortSession, e7.longSession);
          }), Dr.set(this, async () => {
            await l7(this, Ar, "f").init((e7) => {
              const t10 = l7(this, Ar, "f").getUser();
              t10 && e7 ? (l7(this, Tr, "f").next(e7.value), l7(this, Kr, "f").call(this, s9.LoggedIn), l7(this, Ir, "f").call(this, t10)) : (l7(this, Tr, "f").next(void 0), l7(this, Kr, "f").call(this, s9.LoggedOut), l7(this, Ir, "f").call(this, void 0));
            });
          }), Ir.set(this, (e7) => {
            const t10 = l7(this, Pr, "f").value;
            t10 !== e7 && ((null == t10 ? void 0 : t10.email) === (null == e7 ? void 0 : e7.email) && (null == t10 ? void 0 : t10.name) === (null == e7 ? void 0 : e7.name) && (null == t10 ? void 0 : t10.orig) === (null == e7 ? void 0 : e7.orig) && (null == t10 ? void 0 : t10.sub) === (null == e7 ? void 0 : e7.sub) || l7(this, Pr, "f").next(e7));
          }), Kr.set(this, (e7) => {
            l7(this, jr, "f").value !== e7 && l7(this, jr, "f").next(e7);
          }), h6(this, Rr, e6, "f"), h6(this, xr, new ns(t9), "f"), h6(this, Ar, new pr(e6, n7), "f");
        }
        get userChanges() {
          return l7(this, Pr, "f");
        }
        get shortSessionChanges() {
          return l7(this, Tr, "f");
        }
        get authStateChanges() {
          return l7(this, jr, "f");
        }
        async init(e6 = false) {
          return e6 ? f5().setLevel("debug") : f5().setLevel("error"), await l7(this, Dr, "f").call(this), ge3(void 0);
        }
        async initSignUpWithEmailOTP(e6, t9) {
          const n7 = await l7(this, Rr, "f").emailCodeRegisterStart(e6, t9);
          return n7.err ? n7 : (h6(this, Lr, n7.val, "f"), ge3(void 0));
        }
        async completeSignupWithEmailOTP(e6) {
          const t9 = await l7(this, Rr, "f").emailCodeConfirm(l7(this, Lr, "f"), e6);
          return t9.err ? t9 : (l7(this, Ur, "f").call(this, t9.val), ge3(void 0));
        }
        async initLoginWithEmailOTP(e6) {
          const t9 = await l7(this, Rr, "f").emailCodeLoginStart(e6);
          return t9.err ? t9 : (h6(this, Lr, t9.val, "f"), ge3(void 0));
        }
        async completeLoginWithEmailOTP(e6) {
          const t9 = await l7(this, Rr, "f").emailCodeConfirm(l7(this, Lr, "f"), e6);
          return t9.err ? t9 : (l7(this, Ur, "f").call(this, t9.val), ge3(void 0));
        }
        async initSignUpWithEmailLink(e6, t9) {
          const n7 = await l7(this, Rr, "f").emailLinkRegisterStart(e6, t9);
          return n7.err ? n7 : ge3(void 0);
        }
        async completeSignupWithEmailLink() {
          const e6 = ve3();
          if (e6.err)
            return e6;
          const { emailLinkId: t9, token: n7 } = e6.val, r8 = await l7(this, Rr, "f").emailLinkConfirm(t9, n7);
          return r8.err ? r8 : (l7(this, Ur, "f").call(this, r8.val), ge3(void 0));
        }
        async initLoginWithEmailLink(e6) {
          const t9 = await l7(this, Rr, "f").emailLinkLoginStart(e6);
          return t9.err ? t9 : ge3(void 0);
        }
        async completeLoginWithEmailLink() {
          const e6 = ve3();
          if (e6.err)
            return e6;
          const { emailLinkId: t9, token: n7 } = e6.val, r8 = await l7(this, Rr, "f").emailLinkConfirm(t9, n7);
          return r8.err ? r8 : (l7(this, Ur, "f").call(this, r8.val), ge3(void 0));
        }
        async signUpWithPasskey(e6, t9) {
          const n7 = await l7(this, Rr, "f").passKeyRegisterStart(e6, t9);
          if (n7.err)
            return n7;
          const r8 = await l7(this, xr, "f").createPasskey(n7.val);
          if (r8.err)
            return r8;
          const s10 = await l7(this, Rr, "f").passKeyRegisterFinish(r8.val);
          return s10.err ? s10 : (l7(this, Ur, "f").call(this, s10.val), ge3(void 0));
        }
        async loginWithPasskey(e6) {
          return l7(this, kr, "m", _r).call(this, e6, false);
        }
        async loginWithConditionalUI() {
          return await PublicKeyCredential.isConditionalMediationAvailable() ? l7(this, kr, "m", _r).call(this, "", true) : we3(new A5());
        }
        abortOngoingPasskeyOperation() {
          l7(this, xr, "f").abortOngoingOperation();
        }
        async appendPasskey() {
          const e6 = await l7(this, Rr, "f").passKeyAppendStart();
          if (e6.err)
            return e6;
          const t9 = await l7(this, xr, "f").createPasskey(e6.val);
          if (t9.err)
            return t9;
          const n7 = await l7(this, Rr, "f").passKeyAppendFinish(t9.val);
          return n7.err ? n7 : ge3(void 0);
        }
        async passkeyList() {
          return await l7(this, Rr, "f").passkeyList();
        }
        async passkeyDelete(e6) {
          return await l7(this, Rr, "f").passkeyDelete(e6);
        }
        async authMethods(e6) {
          return await l7(this, Rr, "f").authMethodsList(e6);
        }
        userExists(e6) {
          return l7(this, Rr, "f").userExists("email", e6);
        }
        logout() {
          return l7(this, Ar, "f").logout();
        }
      }
      Rr = /* @__PURE__ */ new WeakMap(), xr = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), Lr = /* @__PURE__ */ new WeakMap(), Pr = /* @__PURE__ */ new WeakMap(), Tr = /* @__PURE__ */ new WeakMap(), jr = /* @__PURE__ */ new WeakMap(), Ur = /* @__PURE__ */ new WeakMap(), Dr = /* @__PURE__ */ new WeakMap(), Ir = /* @__PURE__ */ new WeakMap(), Kr = /* @__PURE__ */ new WeakMap(), kr = /* @__PURE__ */ new WeakSet(), _r = async function(e6, t9 = false) {
        let n7;
        if (n7 = t9 ? await l7(this, Rr, "f").passKeyMediationStart() : await l7(this, Rr, "f").passKeyLoginStart(e6), n7.err)
          return n7;
        const r8 = await l7(this, xr, "f").login(n7.val, t9);
        if (r8.err)
          return r8;
        const s10 = await l7(this, Rr, "f").passKeyLoginFinish(r8.val);
        return s10.err ? s10 : (l7(this, Ur, "f").call(this, s10.val), ge3(void 0));
      };
      class ss {
        constructor(e6) {
          Nr.set(this, null), Mr.set(this, void 0), h6(this, Mr, e6, "f");
        }
        get projConfig() {
          return l7(this, Nr, "f");
        }
        async getProjectConfig(e6 = false) {
          if (l7(this, Nr, "f") && !e6)
            return ge3(l7(this, Nr, "f"));
          const t9 = await l7(this, Mr, "f").getProjectConfig();
          return t9.ok ? (h6(this, Nr, t9.val, "f"), ge3(l7(this, Nr, "f"))) : t9;
        }
      }
      Nr = /* @__PURE__ */ new WeakMap(), Mr = /* @__PURE__ */ new WeakMap();
      class os {
        constructor(e6) {
          Fr.add(this), Wr.set(this, void 0), qr.set(this, void 0), Br2.set(this, void 0), Xr.set(this, void 0), Jr.set(this, void 0), zr.set(this, new he3(void 0)), Gr.set(this, false);
          const { projectId: n7, apiTimeout: r8 = t8, frontendApiUrl: s10, isDevMode: o8 = false, setShortSessionCookie: i10 = false } = e6;
          h6(this, Xr, n7, "f"), h6(this, Jr, o8, "f"), h6(this, Wr, new ur(l7(this, zr, "f"), l7(this, Xr, "f"), r8, s10), "f"), h6(this, qr, new rs(l7(this, Wr, "f"), l7(this, zr, "f"), i10), "f"), h6(this, Br2, new ss(l7(this, Wr, "f")), "f");
        }
        get apiService() {
          return l7(this, Wr, "f");
        }
        get authService() {
          return l7(this, qr, "f");
        }
        get projectService() {
          return l7(this, Br2, "f");
        }
        get globalErrors() {
          return l7(this, zr, "f");
        }
        get initialized() {
          return l7(this, Gr, "f");
        }
        async init() {
          l7(this, Gr, "f") || (l7(this, Fr, "m", Hr2).call(this, l7(this, Xr, "f")) ? (await l7(this, qr, "f").init(l7(this, Jr, "f")), h6(this, Gr, true, "f")) : l7(this, zr, "f").next(w6.invalidConfig("Invalid project ID")));
        }
        dispose() {
          l7(this, qr, "f").abortOngoingPasskeyOperation();
        }
        clearGlobalErrors() {
          l7(this, zr, "f").next(void 0);
        }
      }
      Wr = /* @__PURE__ */ new WeakMap(), qr = /* @__PURE__ */ new WeakMap(), Br2 = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap(), Jr = /* @__PURE__ */ new WeakMap(), zr = /* @__PURE__ */ new WeakMap(), Gr = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakSet(), Hr2 = function(e6) {
        return /^pro-\d+$/.test(e6);
      };
    })();
    s2 = r2.jq;
    o = r2.CO;
    i3 = r2.dL;
    a2 = r2.Xy;
    c2 = r2.rI;
    u2 = r2.lH;
    l3 = r2.bu;
    h2 = r2.zT;
    p2 = r2.CU;
    d2 = r2.EE;
    f2 = r2.nJ;
    y3 = r2.X1;
    m = r2.Ck;
    w3 = r2.X$;
    g3 = r2.MW;
    v2 = r2.Ko;
    b = r2.eA;
    S2 = r2.k5;
    E2 = r2.aH;
  }
});

// node_modules/@corbado/react-sdk/dist/index.js
var r3, a3, i4, t2, o2, s3, l4, n2, u3, c3, d3, E3, h3, p3, g4, k2, b2, m2, v3, C2, P2, S3, y4, W2, U2, A2, L2, f3;
var init_dist4 = __esm({
  "node_modules/@corbado/react-sdk/dist/index.js"() {
    init_dist3();
    r3 = __toESM(require_react());
    a3 = { d: (e5, r8) => {
      for (var i9 in r8)
        a3.o(r8, i9) && !a3.o(e5, i9) && Object.defineProperty(e5, i9, { enumerable: true, get: r8[i9] });
    }, o: (e5, r8) => Object.prototype.hasOwnProperty.call(e5, r8) };
    i4 = {};
    a3.d(i4, { Hg: () => p3, lH: () => t2.InvalidEmailError, bu: () => t2.InvalidFullnameError, zT: () => t2.InvalidOtpInputError, CU: () => t2.InvalidPasskeyError, nJ: () => t2.NoPasskeyAvailableError, X1: () => t2.NonRecoverableError, X$: () => t2.PasskeyChallengeCancelledError, eA: () => t2.UnknownUserError, k5: () => t2.UserAlreadyExistsError, km: () => g4, Ye: () => k2 });
    t2 = (o2 = { CorbadoApp: () => a2, InvalidEmailError: () => u2, InvalidFullnameError: () => l3, InvalidOtpInputError: () => h2, InvalidPasskeyError: () => p2, NoPasskeyAvailableError: () => f2, NonRecoverableError: () => y3, PasskeyChallengeCancelledError: () => w3, UnknownUserError: () => b, UserAlreadyExistsError: () => S2 }, s3 = {}, a3.d(s3, o2), s3);
    l4 = ((e5) => {
      var r8 = {};
      return a3.d(r8, e5), r8;
    })({ createContext: () => r3.createContext, default: () => r3.default, memo: () => r3.memo, useCallback: () => r3.useCallback, useContext: () => r3.useContext, useEffect: () => r3.useEffect, useRef: () => r3.useRef, useState: () => r3.useState });
    n2 = () => {
      throw new Error("Please make sure that your components are wrapped inside <CorbadoProvider/>");
    };
    u3 = { corbadoApp: void 0, globalError: void 0, loading: false, isAuthenticated: false, signUpWithPasskey: n2, loginWithPasskey: n2, loginWithConditionalUI: n2, initLoginWithEmailOTP: n2, completeLoginWithEmailOTP: n2, logout: n2, initSignUpWithEmailOTP: n2, completeSignUpWithEmailOTP: n2, initSignUpWithEmailLink: n2, completeSignUpWithEmailLink: n2, initLoginWithEmailLink: n2, completeLoginWithEmailLink: n2, appendPasskey: n2, getPasskeys: n2, deletePasskey: n2, getUserAuthMethods: n2, getProjectConfig: n2, userExists: n2, setGlobalError: n2 };
    c3 = (0, l4.createContext)(u3);
    d3 = (0, l4.memo)(({ children: e5, corbadoApp: r8, loading: a7, globalError: i9, isAuthenticated: t8, setGlobalError: o7 }) => {
      const s9 = (0, l4.useCallback)((e6, a8) => r8.authService.signUpWithPasskey(e6, a8), [r8]), n7 = (0, l4.useCallback)((e6) => r8.authService.loginWithPasskey(e6), [r8]), u6 = (0, l4.useCallback)(() => r8.authService.loginWithConditionalUI(), [r8]), d6 = (0, l4.useCallback)(() => r8.authService.appendPasskey(), [r8]), E6 = (0, l4.useCallback)(() => r8.authService.passkeyList(), [r8]), h6 = (0, l4.useCallback)((e6) => r8.authService.passkeyDelete(e6), [r8]), p5 = (0, l4.useCallback)((e6) => r8.authService.initLoginWithEmailLink(e6), [r8]), g7 = (0, l4.useCallback)(() => r8.authService.completeLoginWithEmailLink(), [r8]), k4 = (0, l4.useCallback)((e6, a8) => r8.authService.initSignUpWithEmailLink(e6, a8), [r8]), b5 = (0, l4.useCallback)(() => r8.authService.completeSignupWithEmailLink(), [r8]), m5 = (0, l4.useCallback)((e6) => r8.authService.initLoginWithEmailOTP(e6), [r8]), v5 = (0, l4.useCallback)((e6) => r8.authService.completeLoginWithEmailOTP(e6), [r8]), C5 = (0, l4.useCallback)((e6, a8) => r8.authService.initSignUpWithEmailOTP(e6, a8), [r8]), P4 = (0, l4.useCallback)((e6) => r8.authService.completeSignupWithEmailOTP(e6), [r8]), S5 = (0, l4.useCallback)((e6) => r8.authService.authMethods(e6), [r8]), y7 = (0, l4.useCallback)((e6) => r8.authService.userExists(e6), [r8]), W4 = (0, l4.useCallback)(() => r8.projectService.getProjectConfig(), [r8]), U4 = (0, l4.useCallback)(() => {
        r8.authService.logout(), r8.clearGlobalErrors();
      }, [r8]);
      return l4.default.createElement(c3.Provider, { value: { corbadoApp: r8, globalError: i9, loading: a7, isAuthenticated: t8, signUpWithPasskey: s9, loginWithPasskey: n7, loginWithConditionalUI: u6, initLoginWithEmailOTP: m5, completeLoginWithEmailOTP: v5, initSignUpWithEmailOTP: C5, completeSignUpWithEmailOTP: P4, initLoginWithEmailLink: p5, completeLoginWithEmailLink: g7, initSignUpWithEmailLink: k4, completeSignUpWithEmailLink: b5, appendPasskey: d6, getPasskeys: E6, deletePasskey: h6, getUserAuthMethods: S5, getProjectConfig: W4, userExists: y7, logout: U4, setGlobalError: o7 } }, e5);
    });
    E3 = (0, l4.createContext)({ shortSession: void 0, loading: true, isAuthenticated: false, user: void 0 });
    h3 = ({ children: e5, loading: r8, isAuthenticated: a7, shortSession: i9, user: t8 }) => l4.default.createElement(E3.Provider, { value: { shortSession: i9, loading: r8, user: t8, isAuthenticated: a7 } }, e5);
    p3 = ({ children: e5, corbadoAppInstance: r8, ...a7 }) => {
      const [i9] = (0, l4.useState)(() => null != r8 ? r8 : new t2.CorbadoApp(a7)), [o7, s9] = (0, l4.useState)(true), [n7, u6] = (0, l4.useState)(), [c8, E6] = (0, l4.useState)(), [p5, g7] = (0, l4.useState)(false), [k4, b5] = (0, l4.useState)(), m5 = (0, l4.useRef)(false);
      return (0, l4.useEffect)(() => {
        m5.current || (s9(true), i9.init().then(() => {
          m5.current = true, s9(false);
        }), i9.authService.userChanges.subscribe((e6) => {
          u6(e6);
        }), i9.globalErrors.subscribe((e6) => {
          E6(e6);
        }), i9.authService.authStateChanges.subscribe((e6) => {
          g7(!!e6);
        }), i9.authService.shortSessionChanges.subscribe((e6) => {
          b5(e6);
        }));
      }, []), l4.default.createElement(h3, { loading: o7, user: n7, isAuthenticated: p5, shortSession: k4 }, l4.default.createElement(d3, { corbadoApp: i9, loading: o7, isAuthenticated: p5, globalError: c8, setGlobalError: (e6) => {
        i9.globalErrors.next(e6);
      } }, e5));
    };
    g4 = (e5 = c3) => {
      const r8 = (0, l4.useContext)(e5);
      if (!r8)
        throw new Error("Please make sure that your components are wrapped inside <CorbadoProvider />");
      return r8;
    };
    k2 = (e5 = E3) => {
      const r8 = (0, l4.useContext)(e5);
      if (!r8)
        throw new Error("Please make sure that your components are wrapped inside <CorbadoProvider />");
      return r8;
    };
    b2 = i4.Hg;
    m2 = i4.lH;
    v3 = i4.bu;
    C2 = i4.zT;
    P2 = i4.CU;
    S3 = i4.nJ;
    y4 = i4.X1;
    W2 = i4.X$;
    U2 = i4.eA;
    A2 = i4.k5;
    L2 = i4.km;
    f3 = i4.Ye;
  }
});

// node_modules/@corbado/shared-ui/dist/index.js
function i5(n7) {
  var t8 = r4[n7];
  if (void 0 !== t8)
    return t8.exports;
  var o7 = r4[n7] = { id: n7, exports: {} };
  return e2[n7].call(o7.exports, o7, o7.exports, i5), o7.exports;
}
var e2, r4, t3, o3, a4, M3, s4, c4, A3, l5, u4, I2, N3, g5, y5, d4, j2, b3, D2, w4, C3, m3, L3, E4, z;
var init_dist5 = __esm({
  "node_modules/@corbado/shared-ui/dist/index.js"() {
    init_dist3();
    e2 = { 502: (n7, e5, r8) => {
      r8.d(e5, { Z: () => M4 });
      var i9 = r8(272), t8 = r8.n(i9), o7 = r8(609), a7 = r8.n(o7)()(t8());
      a7.push([n7.id, ".error-page {\n  .container {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    gap: 2rem;\n    padding: 1rem 1.25rem;\n  }\n\n  .title {\n    color: var(--cb-error-color);\n    text-align: center;\n    font-size: 1.88rem;\n    font-style: normal;\n    font-weight: 700;\n    line-height: normal;\n    font-family: 'Space Grotesk', sans-serif;\n  }\n\n  .error-details {\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n    gap: 0.5rem;\n  }\n\n  .error-detail-row {\n    display: flex;\n    flex-direction: row;\n    gap: 1rem;\n    color: var(--cb-primary-text-color);\n    font-size: 1rem;\n    font-weight: 400;\n  }\n\n  .error-detail-title {\n    direction: rtl;\n    flex: 1;\n    font-weight: 700;\n  }\n\n  .error-detail-value {\n    flex: 3;\n    line-break: anywhere;\n  }\n\n  .error-button {\n    border-color: var(--cb-error-color);\n    color: var(--cb-error-color);\n    background-color: var(--cb-white);\n    border-radius: 1.5rem;\n    font-size: 1rem;\n    height: 2.5rem;\n    font-weight: 700;\n    transition:\n      background-color 0.3s,\n      color 0.3s;\n    cursor: pointer;\n  }\n\n  .prod-error-container {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    gap: 2rem;\n    padding: 0rem 2.5rem;\n    text-align: center;\n  }\n\n  .prod-error-title {\n    color: var(--cb-primary-text-color);\n    text-align: center;\n    font-size: 1.88rem;\n    font-style: normal;\n    font-weight: 700;\n    line-height: normal;\n    font-family: 'Space Grotesk', sans-serif;\n  }\n\n  .prod-error-details {\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n    gap: 1rem;\n    color: var(--cb-primary-text-color);\n    font-size: 1rem;\n    font-style: normal;\n    font-weight: 500;\n    line-height: 1.25rem;\n    font-family: 'Space Grotesk', sans-serif;\n  }\n\n  .prod-error-apology {\n    padding-bottom: 3rem;\n  }\n\n  .prod-error-button {\n    border: none;\n    color: var(--cb-secondary-text-color);\n    background-color: var(--cb-primary-color);\n    border-radius: 1.5rem;\n    font-size: 1rem;\n    height: 2.5rem;\n    cursor: pointer;\n    font-weight: 700;\n    transition:\n      background-color 0.3s,\n      color 0.3s;\n  }\n\n  .prod-error-button:hover {\n    background-color: #c91717;\n  }\n\n  .dark & {\n    --cb-primary-error-color: #ff4747;\n\n    .error-detail-row {\n      color: var(--cb-white);\n    }\n\n    .prod-error-title {\n      color: var(--cb-secondary-text-color);\n    }\n\n    .prod-error-details {\n      color: var(--cb-secondary-text-color);\n    }\n  }\n}\n", "", { version: 3, sources: ["webpack://./src/styles/error_page.css"], names: [], mappings: "AAAA;EACE;IACE,aAAa;IACb,sBAAsB;IACtB,uBAAuB;IACvB,SAAS;IACT,qBAAqB;EACvB;;EAEA;IACE,4BAA4B;IAC5B,kBAAkB;IAClB,kBAAkB;IAClB,kBAAkB;IAClB,gBAAgB;IAChB,mBAAmB;IACnB,wCAAwC;EAC1C;;EAEA;IACE,aAAa;IACb,sBAAsB;IACtB,8BAA8B;IAC9B,WAAW;EACb;;EAEA;IACE,aAAa;IACb,mBAAmB;IACnB,SAAS;IACT,mCAAmC;IACnC,eAAe;IACf,gBAAgB;EAClB;;EAEA;IACE,cAAc;IACd,OAAO;IACP,gBAAgB;EAClB;;EAEA;IACE,OAAO;IACP,oBAAoB;EACtB;;EAEA;IACE,mCAAmC;IACnC,4BAA4B;IAC5B,iCAAiC;IACjC,qBAAqB;IACrB,eAAe;IACf,cAAc;IACd,gBAAgB;IAChB;;gBAEY;IACZ,eAAe;EACjB;;EAEA;IACE,aAAa;IACb,sBAAsB;IACtB,uBAAuB;IACvB,SAAS;IACT,oBAAoB;IACpB,kBAAkB;EACpB;;EAEA;IACE,mCAAmC;IACnC,kBAAkB;IAClB,kBAAkB;IAClB,kBAAkB;IAClB,gBAAgB;IAChB,mBAAmB;IACnB,wCAAwC;EAC1C;;EAEA;IACE,aAAa;IACb,sBAAsB;IACtB,8BAA8B;IAC9B,SAAS;IACT,mCAAmC;IACnC,eAAe;IACf,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;IACpB,wCAAwC;EAC1C;;EAEA;IACE,oBAAoB;EACtB;;EAEA;IACE,YAAY;IACZ,qCAAqC;IACrC,yCAAyC;IACzC,qBAAqB;IACrB,eAAe;IACf,cAAc;IACd,eAAe;IACf,gBAAgB;IAChB;;gBAEY;EACd;;EAEA;IACE,yBAAyB;EAC3B;;EAEA;IACE,iCAAiC;;IAEjC;MACE,sBAAsB;IACxB;;IAEA;MACE,qCAAqC;IACvC;;IAEA;MACE,qCAAqC;IACvC;EACF;AACF", sourcesContent: [".error-page {\r\n  .container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    gap: 2rem;\r\n    padding: 1rem 1.25rem;\r\n  }\r\n\r\n  .title {\r\n    color: var(--cb-error-color);\r\n    text-align: center;\r\n    font-size: 1.88rem;\r\n    font-style: normal;\r\n    font-weight: 700;\r\n    line-height: normal;\r\n    font-family: 'Space Grotesk', sans-serif;\r\n  }\r\n\r\n  .error-details {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-between;\r\n    gap: 0.5rem;\r\n  }\r\n\r\n  .error-detail-row {\r\n    display: flex;\r\n    flex-direction: row;\r\n    gap: 1rem;\r\n    color: var(--cb-primary-text-color);\r\n    font-size: 1rem;\r\n    font-weight: 400;\r\n  }\r\n\r\n  .error-detail-title {\r\n    direction: rtl;\r\n    flex: 1;\r\n    font-weight: 700;\r\n  }\r\n\r\n  .error-detail-value {\r\n    flex: 3;\r\n    line-break: anywhere;\r\n  }\r\n\r\n  .error-button {\r\n    border-color: var(--cb-error-color);\r\n    color: var(--cb-error-color);\r\n    background-color: var(--cb-white);\r\n    border-radius: 1.5rem;\r\n    font-size: 1rem;\r\n    height: 2.5rem;\r\n    font-weight: 700;\r\n    transition:\r\n      background-color 0.3s,\r\n      color 0.3s;\r\n    cursor: pointer;\r\n  }\r\n\r\n  .prod-error-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    gap: 2rem;\r\n    padding: 0rem 2.5rem;\r\n    text-align: center;\r\n  }\r\n\r\n  .prod-error-title {\r\n    color: var(--cb-primary-text-color);\r\n    text-align: center;\r\n    font-size: 1.88rem;\r\n    font-style: normal;\r\n    font-weight: 700;\r\n    line-height: normal;\r\n    font-family: 'Space Grotesk', sans-serif;\r\n  }\r\n\r\n  .prod-error-details {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-between;\r\n    gap: 1rem;\r\n    color: var(--cb-primary-text-color);\r\n    font-size: 1rem;\r\n    font-style: normal;\r\n    font-weight: 500;\r\n    line-height: 1.25rem;\r\n    font-family: 'Space Grotesk', sans-serif;\r\n  }\r\n\r\n  .prod-error-apology {\r\n    padding-bottom: 3rem;\r\n  }\r\n\r\n  .prod-error-button {\r\n    border: none;\r\n    color: var(--cb-secondary-text-color);\r\n    background-color: var(--cb-primary-color);\r\n    border-radius: 1.5rem;\r\n    font-size: 1rem;\r\n    height: 2.5rem;\r\n    cursor: pointer;\r\n    font-weight: 700;\r\n    transition:\r\n      background-color 0.3s,\r\n      color 0.3s;\r\n  }\r\n\r\n  .prod-error-button:hover {\r\n    background-color: #c91717;\r\n  }\r\n\r\n  .dark & {\r\n    --cb-primary-error-color: #ff4747;\r\n\r\n    .error-detail-row {\r\n      color: var(--cb-white);\r\n    }\r\n\r\n    .prod-error-title {\r\n      color: var(--cb-secondary-text-color);\r\n    }\r\n\r\n    .prod-error-details {\r\n      color: var(--cb-secondary-text-color);\r\n    }\r\n  }\r\n}\r\n"], sourceRoot: "" }]);
      const M4 = a7;
    }, 74: (n7, e5, r8) => {
      r8.d(e5, { Z: () => M4 });
      var i9 = r8(272), t8 = r8.n(i9), o7 = r8(609), a7 = r8.n(o7)()(t8());
      a7.push([n7.id, "@import url(https://fonts.googleapis.com/css2?family=Space+Grotesk);"]), a7.push([n7.id, ":root {\n  --cb-primary-color: #1953ff;\n  --cb-secondary-color: #59acff;\n  --cb-error-color: #e71919;\n  --cb-primary-text-color: #000;\n  --cb-secondary-text-color: #fff;\n  --cb-white: #fff;\n  --cb-black: #000;\n  --cb-horizontal-divider-color: #d9d9d9;\n  --cb-input-color: #090f1f;\n  --cb-primary-font: 'Space Grotesk', sans-serif;\n  --cb-secondary-font: Inter, sans-serif;\n}\n\n/***** Main *****/\n.cb-container {\n  padding: 2.5rem 1.3rem 1.25rem 1.3rem;\n  border-radius: 0.5rem;\n  width: 30rem;\n  box-sizing: border-box;\n  box-shadow: 0 0.5rem 1rem rgb(0 0 0 / 15%);\n  background-color: var(--cb-white);\n  color: var(--cb-primary-text-color);\n}\n\n.cb-loading {\n  height: 18rem;\n  display: flex;\n}\n\n/********** Typography **********/\n.cb-header {\n  font-family: var(--cb-primary-font);\n  color: var(--cb-primary-text-color);\n  font-size: 1.88rem;\n  margin-top: 0;\n  margin-bottom: 0;\n  text-align: center;\n  font-style: normal;\n  font-weight: 700;\n  line-height: normal;\n}\n\n.cb-subheader {\n  margin-top: 0.5rem;\n  color: var(--cb-primary-text-color);\n  text-align: center;\n  font-size: 1rem;\n  font-style: normal;\n  font-weight: 700;\n  line-height: normal;\n  font-family: var(--cb-primary-font);\n}\n\n.cb-body {\n  margin-top: 0.5rem;\n  color: var(--cb-primary-text-color);\n  text-align: center;\n  font-size: 1rem;\n  font-style: normal;\n  font-weight: 500;\n  line-height: normal;\n  font-family: var(--cb-secondary-font);\n}\n\n.cb-link-primary {\n  color: var(--cb-primary-color);\n  cursor: pointer;\n  text-decoration: underline;\n  font-weight: 700;\n}\n\n.cb-link-secondary {\n  color: var(--cb-secondary-color);\n  cursor: pointer;\n}\n\n.cb-error {\n  color: var(--cb-error-color);\n  margin: 0;\n  font-size: 0.75rem;\n  text-align: left;\n  padding-left: 1.4rem;\n}\n\n.cb-text-primary {\n  color: var(--cb-primary-color);\n}\n\n.cb-text-secondary {\n  color: var(--cb-secondary-color);\n}\n\n.cb-text-bold {\n  font-weight: bold;\n}\n\n.cb-horizontal-divider {\n  width: 110%;\n  text-align: center;\n  position: relative;\n  line-height: 0.1em;\n  margin-top: 1rem;\n  margin-bottom: 1rem;\n  margin-left: -1.2rem;\n  color: var(--cb-horizontal-divider-color);\n}\n\n.cb-horizontal-divider:before,\n.cb-horizontal-divider:after {\n  content: '';\n  background: var(--cb-horizontal-divider-color);\n  display: inline-block;\n  width: 40%;\n  height: 1px;\n  vertical-align: middle;\n  position: relative;\n}\n\n.cb-horizontal-divider:before {\n  right: 5%;\n  margin-left: -50%;\n}\n\n.cb-horizontal-divider:after {\n  left: 5%;\n  margin-right: -50%;\n}\n\n/********** Form **********/\n.cb-form {\n  margin: 1rem 0;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n}\n\n.cb-form-body {\n  margin-bottom: 1.5rem;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n}\n\n.cb-input {\n  color: var(--cb-input-color);\n  font-size: 1rem;\n  padding: 1rem 1.4rem;\n  height: 3rem;\n  width: 100%;\n  border-width: 1px;\n  border-style: solid;\n  border-radius: 1.5rem;\n  border-color: #8f9bbf80;\n  position: relative;\n  background: transparent;\n  z-index: 2;\n  box-sizing: border-box;\n  -webkit-text-fill-color: var(--cb-input-color);\n  -webkit-background-clip: text !important;\n  background-clip: text !important;\n  line-height: 1;\n}\n\n.cb-input.cb-error {\n  border-color: var(--cb-error-color);\n}\n\n.cb-input[disabled] {\n  color: var(--cb-input-color);\n}\n\n.cb-input:-webkit-autofill,\n.cb-input:-webkit-autofill:hover,\n.cb-input:-webkit-autofill:focus,\n.cb-input:-webkit-autofill:active {\n  -webkit-box-shadow: 0 0 0 30px var(--cb-white) inset !important;\n  box-shadow: 0 0 0 1000px var(--cb-white) inset;\n}\n\n.cb-input:-webkit-autofill {\n  -webkit-text-fill-color: var(--cb-input-color) !important;\n}\n\n.cb-input:focus {\n  outline: none;\n}\n\n.cb-input::-ms-input-placeholder {\n  opacity: 0;\n}\n\n.cb-input::placeholder {\n  opacity: 0;\n}\n\n.cb-form-input {\n  position: relative;\n  margin-top: 1.5rem;\n  width: 100%;\n}\n\n.cb-form-input.cb-has-content,\n.cb-form-input.cb-has-focus,\n.cb-form-input.cb-has-error {\n  margin-top: 1.5rem;\n  transition: 0.3s;\n}\n\n.cb-form-input label {\n  font-weight: bold;\n  color: var(--cb-secondary-color);\n  position: absolute;\n  left: 1.4rem;\n  top: 0.8rem;\n  transition: 0.3s;\n  z-index: 1;\n  opacity: 1;\n  font-family: var(--cb-primary-font);\n}\n\n.cb-form-input.cb-has-content label,\n.cb-form-input.cb-has-focus label,\n.cb-form-input.cb-has-error label {\n  font-weight: normal;\n  top: -1.1rem;\n  left: 1.4rem;\n  font-size: 0.75rem;\n  color: #535e80;\n  transition: 0.3s;\n}\n\n.cb-form-input-error {\n  height: 1rem;\n}\n\n/********** Buttons **********/\n.cb-button-primary {\n  border: none;\n  color: var(--cb-secondary-text-color);\n  background-color: var(--cb-primary-color);\n  border-radius: 1.5rem;\n  font-size: 1rem;\n  height: 3rem;\n  padding: 0 2rem;\n  cursor: pointer;\n  font-weight: 700;\n  transition:\n    background-color 0.3s,\n    color 0.3s;\n  font-family: var(--cb-primary-font);\n}\n\n.cb-button-primary[disabled] {\n  background-color: #7586b9;\n  cursor: not-allowed;\n}\n\n.cb-button-primary[disabled]:hover {\n  background-color: #7586b9;\n}\n\n.cb-button-primary:hover {\n  background-color: #1145df;\n}\n\n.cb-button-secondary {\n  border: 2px solid var(--cb-secondary-color);\n  background-color: var(--cb-white);\n  color: var(--cb-secondary-color);\n  border-radius: 1.5rem;\n  font-size: 1rem;\n  height: 3rem;\n  padding: 0 2rem;\n  cursor: pointer;\n  transition:\n    background-color 0.3s,\n    color 0.3s;\n  font-family: var(--cb-primary-font);\n}\n\n.cb-button-secondary:hover {\n  background-color: #e6e6e6;\n}\n\n.cb-button-tertiary {\n  font-family: 'Inter', var(--cb-primary-font);\n  font-weight: bold;\n  background: none;\n  border: none;\n  color: var(--cb-secondary-color);\n  padding: 0;\n  cursor: pointer;\n  font-size: 1rem;\n  height: 2.5rem;\n  box-shadow: none;\n}\n\n.cb-button-tertiary:hover,\n.cb-button-tertiary:focus {\n  text-decoration: none;\n  border: none;\n  box-shadow: none;\n  outline: none;\n}\n\n.cb-spinner-primary {\n  display: block;\n  position: relative;\n  width: 1.1rem;\n  height: 1.1rem;\n  margin: auto;\n  border: 0.25rem solid rgba(0, 0, 0, 0.55);\n  border-top-color: var(--cb-white);\n  border-radius: 100%;\n  animation: cb-spin-animation 1s ease infinite;\n}\n\n.cb-spinner-secondary {\n  border: 0.25rem solid rgba(0, 0, 0, 0.55);\n  border-top-color: var(--cb-primary-color);\n}\n\n@keyframes cb-spin-animation {\n  from {\n    transform: rotate(0turn);\n  }\n\n  to {\n    transform: rotate(1turn);\n  }\n}\n\n/********** Layout **********/\n.cb-layout-passkey {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n.cb-email-screen {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n.cb-email-screen .cb-body {\n  margin-top: 0.5rem;\n  margin-left: 1.5rem;\n  margin-right: 1.5rem;\n}\n\n.cb-email-links {\n  display: flex;\n  flex-direction: row;\n  gap: 1rem;\n  justify-content: space-around;\n}\n\n.cb-email-otp-input-container {\n  display: flex;\n  flex-direction: row;\n  gap: 1rem;\n  justify-content: center;\n  margin-left: 0.25rem;\n  margin-right: 0.25rem;\n}\n\n.cb-email-otp-input {\n  height: 4.5rem;\n  border: 1px solid #d9d9d9;\n  border-radius: 1.75rem;\n  font-size: 1rem;\n  text-align: center;\n  font-family: var(--cb-secondary-font);\n  padding: 0;\n}\n\n/********** Icons **********/\n.cb-finger-print-icon {\n  width: 6.4375rem;\n  height: 7.5625rem;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.cb-link-icon {\n  display: flex;\n  gap: 0.3rem;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  width: 29.875rem;\n  height: 3rem;\n  border: 1px solid #d9d9d9;\n  border-radius: 9999px;\n  text-decoration: none;\n  color: var(--cb-primary-text-color);\n  font-family: var(--cb-secondary-font);\n  cursor: pointer;\n}\n\n.cb-link-icon:hover {\n  background-color: #f5f5f5;\n}\n\n.cb-link-icon .cb-icon {\n  flex-shrink: 0;\n  height: 1.5rem;\n}\n\n.cb-pointer {\n  cursor: pointer;\n}\n\n/********** Dialog / Modal **********/\n.cb-dialog {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: rgba(0, 0, 0, 0.5);\n  z-index: 1000;\n}\n\n.cb-dialog-content {\n  background: var(--cb-white);\n  padding: 1.3rem;\n  border-radius: 10px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n  max-width: 400px;\n}\n\n.cb-dialog-header {\n  font-size: 1.4rem;\n  font-weight: bold;\n  margin-bottom: 1rem;\n}\n\n.cb-dialog-body {\n  margin-bottom: 1.5rem;\n}\n\n.cb-dialog-footer {\n  display: flex;\n  justify-content: flex-end;\n  gap: 1rem;\n}\n\n.cb-dialog-x-button {\n  float: right;\n  cursor: pointer;\n  font-size: 1rem;\n}\n\n.cb-dialog-button {\n  padding: 0 0.5rem;\n  min-width: 10rem;\n}\n\n/********** Passkey List **********/\n.cb-passkey-list-card {\n  display: flex;\n  flex-direction: row;\n  gap: 1rem;\n  border-radius: 10px;\n  border: var(--cb-primary-text-color) 1px solid;\n  margin: 0.5rem 0;\n  padding: 0.5rem;\n  font-family: 'Inter', sans-serif;\n}\n\n.cb-passkey-list-icon {\n  display: flex;\n  flex: 1;\n  justify-content: center;\n  align-items: center;\n}\n\n.cb-passkey-list-icon img {\n  width: 2rem;\n  height: 2rem;\n}\n\n.cb-passkey-list-icon svg {\n  width: 2rem;\n  height: 2rem;\n  fill: var(--cb-primary-text-color);\n}\n\n.cb-passkey-list-details {\n  flex: 5;\n  display: flex;\n  flex-direction: column;\n  justify-content: left;\n  font-size: 1rem;\n  line-height: normal;\n  font-weight: 500;\n  gap: 0.5rem;\n}\n\n.cb-passkey-list-header {\n  display: flex;\n  flex-direction: row;\n  justify-content: left;\n  gap: 1rem;\n}\n\n.cb-passkey-list-header-title {\n  font-weight: 700;\n  margin: auto 0;\n}\n\n.cb-passkey-list-header-badge {\n  border-radius: 2rem;\n  border: var(--cb-black) 1px solid;\n  padding: 0.5rem;\n}\n\n.cb-passkey-list-delete:hover {\n  fill: var(--cb-error-color);\n  cursor: pointer;\n}\n\n.cb-passkey-list-primary-button {\n  padding: 0.5rem;\n  margin: 1rem 0;\n  min-width: 12rem;\n}\n\n/***** Media Queries *****/\n@media screen and (max-width: 768px) {\n  .cb-container {\n    width: 95%;\n    padding: 2.5rem 1.3rem 1.25rem 1.3rem;\n  }\n\n  .cb-email-links {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n    justify-content: center;\n  }\n\n  .cb-link-icon {\n    justify-content: center;\n    width: 100%;\n  }\n\n  .cb-passkey-list-card {\n    flex-direction: column;\n  }\n}\n", "", { version: 3, sources: ["webpack://./src/styles/index.css"], names: [], mappings: "AAEA;EACE,2BAA2B;EAC3B,6BAA6B;EAC7B,yBAAyB;EACzB,6BAA6B;EAC7B,+BAA+B;EAC/B,gBAAgB;EAChB,gBAAgB;EAChB,sCAAsC;EACtC,yBAAyB;EACzB,8CAA8C;EAC9C,sCAAsC;AACxC;;AAEA,iBAAiB;AACjB;EACE,qCAAqC;EACrC,qBAAqB;EACrB,YAAY;EACZ,sBAAsB;EACtB,0CAA0C;EAC1C,iCAAiC;EACjC,mCAAmC;AACrC;;AAEA;EACE,aAAa;EACb,aAAa;AACf;;AAEA,iCAAiC;AACjC;EACE,mCAAmC;EACnC,mCAAmC;EACnC,kBAAkB;EAClB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,kBAAkB;EAClB,gBAAgB;EAChB,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,mCAAmC;EACnC,kBAAkB;EAClB,eAAe;EACf,kBAAkB;EAClB,gBAAgB;EAChB,mBAAmB;EACnB,mCAAmC;AACrC;;AAEA;EACE,kBAAkB;EAClB,mCAAmC;EACnC,kBAAkB;EAClB,eAAe;EACf,kBAAkB;EAClB,gBAAgB;EAChB,mBAAmB;EACnB,qCAAqC;AACvC;;AAEA;EACE,8BAA8B;EAC9B,eAAe;EACf,0BAA0B;EAC1B,gBAAgB;AAClB;;AAEA;EACE,gCAAgC;EAChC,eAAe;AACjB;;AAEA;EACE,4BAA4B;EAC5B,SAAS;EACT,kBAAkB;EAClB,gBAAgB;EAChB,oBAAoB;AACtB;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,gCAAgC;AAClC;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,kBAAkB;EAClB,kBAAkB;EAClB,gBAAgB;EAChB,mBAAmB;EACnB,oBAAoB;EACpB,yCAAyC;AAC3C;;AAEA;;EAEE,WAAW;EACX,8CAA8C;EAC9C,qBAAqB;EACrB,UAAU;EACV,WAAW;EACX,sBAAsB;EACtB,kBAAkB;AACpB;;AAEA;EACE,SAAS;EACT,iBAAiB;AACnB;;AAEA;EACE,QAAQ;EACR,kBAAkB;AACpB;;AAEA,2BAA2B;AAC3B;EACE,cAAc;EACd,WAAW;EACX,aAAa;EACb,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,WAAW;EACX,aAAa;EACb,sBAAsB;AACxB;;AAEA;EACE,4BAA4B;EAC5B,eAAe;EACf,oBAAoB;EACpB,YAAY;EACZ,WAAW;EACX,iBAAiB;EACjB,mBAAmB;EACnB,qBAAqB;EACrB,uBAAuB;EACvB,kBAAkB;EAClB,uBAAuB;EACvB,UAAU;EACV,sBAAsB;EACtB,8CAA8C;EAC9C,wCAAwC;EACxC,gCAAgC;EAChC,cAAc;AAChB;;AAEA;EACE,mCAAmC;AACrC;;AAEA;EACE,4BAA4B;AAC9B;;AAEA;;;;EAIE,+DAA+D;EAC/D,8CAA8C;AAChD;;AAEA;EACE,yDAAyD;AAC3D;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,kBAAkB;EAClB,WAAW;AACb;;AAEA;;;EAGE,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EACE,iBAAiB;EACjB,gCAAgC;EAChC,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,gBAAgB;EAChB,UAAU;EACV,UAAU;EACV,mCAAmC;AACrC;;AAEA;;;EAGE,mBAAmB;EACnB,YAAY;EACZ,YAAY;EACZ,kBAAkB;EAClB,cAAc;EACd,gBAAgB;AAClB;;AAEA;EACE,YAAY;AACd;;AAEA,8BAA8B;AAC9B;EACE,YAAY;EACZ,qCAAqC;EACrC,yCAAyC;EACzC,qBAAqB;EACrB,eAAe;EACf,YAAY;EACZ,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB;;cAEY;EACZ,mCAAmC;AACrC;;AAEA;EACE,yBAAyB;EACzB,mBAAmB;AACrB;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,2CAA2C;EAC3C,iCAAiC;EACjC,gCAAgC;EAChC,qBAAqB;EACrB,eAAe;EACf,YAAY;EACZ,eAAe;EACf,eAAe;EACf;;cAEY;EACZ,mCAAmC;AACrC;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,4CAA4C;EAC5C,iBAAiB;EACjB,gBAAgB;EAChB,YAAY;EACZ,gCAAgC;EAChC,UAAU;EACV,eAAe;EACf,eAAe;EACf,cAAc;EACd,gBAAgB;AAClB;;AAEA;;EAEE,qBAAqB;EACrB,YAAY;EACZ,gBAAgB;EAChB,aAAa;AACf;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,aAAa;EACb,cAAc;EACd,YAAY;EACZ,yCAAyC;EACzC,iCAAiC;EACjC,mBAAmB;EACnB,6CAA6C;AAC/C;;AAEA;EACE,yCAAyC;EACzC,yCAAyC;AAC3C;;AAEA;EACE;IACE,wBAAwB;EAC1B;;EAEA;IACE,wBAAwB;EAC1B;AACF;;AAEA,6BAA6B;AAC7B;EACE,aAAa;EACb,sBAAsB;EACtB,SAAS;AACX;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;AACtB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,SAAS;EACT,6BAA6B;AAC/B;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,SAAS;EACT,uBAAuB;EACvB,oBAAoB;EACpB,qBAAqB;AACvB;;AAEA;EACE,cAAc;EACd,yBAAyB;EACzB,sBAAsB;EACtB,eAAe;EACf,kBAAkB;EAClB,qCAAqC;EACrC,UAAU;AACZ;;AAEA,4BAA4B;AAC5B;EACE,gBAAgB;EAChB,iBAAiB;EACjB,iBAAiB;EACjB,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,WAAW;EACX,mBAAmB;EACnB,mBAAmB;EACnB,uBAAuB;EACvB,gBAAgB;EAChB,YAAY;EACZ,yBAAyB;EACzB,qBAAqB;EACrB,qBAAqB;EACrB,mCAAmC;EACnC,qCAAqC;EACrC,eAAe;AACjB;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,cAAc;EACd,cAAc;AAChB;;AAEA;EACE,eAAe;AACjB;;AAEA,qCAAqC;AACrC;EACE,eAAe;EACf,MAAM;EACN,OAAO;EACP,WAAW;EACX,YAAY;EACZ,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,2BAA2B;EAC3B,eAAe;EACf,mBAAmB;EACnB,wCAAwC;EACxC,gBAAgB;AAClB;;AAEA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,mBAAmB;AACrB;;AAEA;EACE,qBAAqB;AACvB;;AAEA;EACE,aAAa;EACb,yBAAyB;EACzB,SAAS;AACX;;AAEA;EACE,YAAY;EACZ,eAAe;EACf,eAAe;AACjB;;AAEA;EACE,iBAAiB;EACjB,gBAAgB;AAClB;;AAEA,mCAAmC;AACnC;EACE,aAAa;EACb,mBAAmB;EACnB,SAAS;EACT,mBAAmB;EACnB,8CAA8C;EAC9C,gBAAgB;EAChB,eAAe;EACf,gCAAgC;AAClC;;AAEA;EACE,aAAa;EACb,OAAO;EACP,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,kCAAkC;AACpC;;AAEA;EACE,OAAO;EACP,aAAa;EACb,sBAAsB;EACtB,qBAAqB;EACrB,eAAe;EACf,mBAAmB;EACnB,gBAAgB;EAChB,WAAW;AACb;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,qBAAqB;EACrB,SAAS;AACX;;AAEA;EACE,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,mBAAmB;EACnB,iCAAiC;EACjC,eAAe;AACjB;;AAEA;EACE,2BAA2B;EAC3B,eAAe;AACjB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,gBAAgB;AAClB;;AAEA,0BAA0B;AAC1B;EACE;IACE,UAAU;IACV,qCAAqC;EACvC;;EAEA;IACE,aAAa;IACb,sBAAsB;IACtB,SAAS;IACT,uBAAuB;EACzB;;EAEA;IACE,uBAAuB;IACvB,WAAW;EACb;;EAEA;IACE,sBAAsB;EACxB;AACF", sourcesContent: ["@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk');\r\n\r\n:root {\r\n  --cb-primary-color: #1953ff;\r\n  --cb-secondary-color: #59acff;\r\n  --cb-error-color: #e71919;\r\n  --cb-primary-text-color: #000;\r\n  --cb-secondary-text-color: #fff;\r\n  --cb-white: #fff;\r\n  --cb-black: #000;\r\n  --cb-horizontal-divider-color: #d9d9d9;\r\n  --cb-input-color: #090f1f;\r\n  --cb-primary-font: 'Space Grotesk', sans-serif;\r\n  --cb-secondary-font: Inter, sans-serif;\r\n}\r\n\r\n/***** Main *****/\r\n.cb-container {\r\n  padding: 2.5rem 1.3rem 1.25rem 1.3rem;\r\n  border-radius: 0.5rem;\r\n  width: 30rem;\r\n  box-sizing: border-box;\r\n  box-shadow: 0 0.5rem 1rem rgb(0 0 0 / 15%);\r\n  background-color: var(--cb-white);\r\n  color: var(--cb-primary-text-color);\r\n}\r\n\r\n.cb-loading {\r\n  height: 18rem;\r\n  display: flex;\r\n}\r\n\r\n/********** Typography **********/\r\n.cb-header {\r\n  font-family: var(--cb-primary-font);\r\n  color: var(--cb-primary-text-color);\r\n  font-size: 1.88rem;\r\n  margin-top: 0;\r\n  margin-bottom: 0;\r\n  text-align: center;\r\n  font-style: normal;\r\n  font-weight: 700;\r\n  line-height: normal;\r\n}\r\n\r\n.cb-subheader {\r\n  margin-top: 0.5rem;\r\n  color: var(--cb-primary-text-color);\r\n  text-align: center;\r\n  font-size: 1rem;\r\n  font-style: normal;\r\n  font-weight: 700;\r\n  line-height: normal;\r\n  font-family: var(--cb-primary-font);\r\n}\r\n\r\n.cb-body {\r\n  margin-top: 0.5rem;\r\n  color: var(--cb-primary-text-color);\r\n  text-align: center;\r\n  font-size: 1rem;\r\n  font-style: normal;\r\n  font-weight: 500;\r\n  line-height: normal;\r\n  font-family: var(--cb-secondary-font);\r\n}\r\n\r\n.cb-link-primary {\r\n  color: var(--cb-primary-color);\r\n  cursor: pointer;\r\n  text-decoration: underline;\r\n  font-weight: 700;\r\n}\r\n\r\n.cb-link-secondary {\r\n  color: var(--cb-secondary-color);\r\n  cursor: pointer;\r\n}\r\n\r\n.cb-error {\r\n  color: var(--cb-error-color);\r\n  margin: 0;\r\n  font-size: 0.75rem;\r\n  text-align: left;\r\n  padding-left: 1.4rem;\r\n}\r\n\r\n.cb-text-primary {\r\n  color: var(--cb-primary-color);\r\n}\r\n\r\n.cb-text-secondary {\r\n  color: var(--cb-secondary-color);\r\n}\r\n\r\n.cb-text-bold {\r\n  font-weight: bold;\r\n}\r\n\r\n.cb-horizontal-divider {\r\n  width: 110%;\r\n  text-align: center;\r\n  position: relative;\r\n  line-height: 0.1em;\r\n  margin-top: 1rem;\r\n  margin-bottom: 1rem;\r\n  margin-left: -1.2rem;\r\n  color: var(--cb-horizontal-divider-color);\r\n}\r\n\r\n.cb-horizontal-divider:before,\r\n.cb-horizontal-divider:after {\r\n  content: '';\r\n  background: var(--cb-horizontal-divider-color);\r\n  display: inline-block;\r\n  width: 40%;\r\n  height: 1px;\r\n  vertical-align: middle;\r\n  position: relative;\r\n}\r\n\r\n.cb-horizontal-divider:before {\r\n  right: 5%;\r\n  margin-left: -50%;\r\n}\r\n\r\n.cb-horizontal-divider:after {\r\n  left: 5%;\r\n  margin-right: -50%;\r\n}\r\n\r\n/********** Form **********/\r\n.cb-form {\r\n  margin: 1rem 0;\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.cb-form-body {\r\n  margin-bottom: 1.5rem;\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.cb-input {\r\n  color: var(--cb-input-color);\r\n  font-size: 1rem;\r\n  padding: 1rem 1.4rem;\r\n  height: 3rem;\r\n  width: 100%;\r\n  border-width: 1px;\r\n  border-style: solid;\r\n  border-radius: 1.5rem;\r\n  border-color: #8f9bbf80;\r\n  position: relative;\r\n  background: transparent;\r\n  z-index: 2;\r\n  box-sizing: border-box;\r\n  -webkit-text-fill-color: var(--cb-input-color);\r\n  -webkit-background-clip: text !important;\r\n  background-clip: text !important;\r\n  line-height: 1;\r\n}\r\n\r\n.cb-input.cb-error {\r\n  border-color: var(--cb-error-color);\r\n}\r\n\r\n.cb-input[disabled] {\r\n  color: var(--cb-input-color);\r\n}\r\n\r\n.cb-input:-webkit-autofill,\r\n.cb-input:-webkit-autofill:hover,\r\n.cb-input:-webkit-autofill:focus,\r\n.cb-input:-webkit-autofill:active {\r\n  -webkit-box-shadow: 0 0 0 30px var(--cb-white) inset !important;\r\n  box-shadow: 0 0 0 1000px var(--cb-white) inset;\r\n}\r\n\r\n.cb-input:-webkit-autofill {\r\n  -webkit-text-fill-color: var(--cb-input-color) !important;\r\n}\r\n\r\n.cb-input:focus {\r\n  outline: none;\r\n}\r\n\r\n.cb-input::-ms-input-placeholder {\r\n  opacity: 0;\r\n}\r\n\r\n.cb-input::placeholder {\r\n  opacity: 0;\r\n}\r\n\r\n.cb-form-input {\r\n  position: relative;\r\n  margin-top: 1.5rem;\r\n  width: 100%;\r\n}\r\n\r\n.cb-form-input.cb-has-content,\r\n.cb-form-input.cb-has-focus,\r\n.cb-form-input.cb-has-error {\r\n  margin-top: 1.5rem;\r\n  transition: 0.3s;\r\n}\r\n\r\n.cb-form-input label {\r\n  font-weight: bold;\r\n  color: var(--cb-secondary-color);\r\n  position: absolute;\r\n  left: 1.4rem;\r\n  top: 0.8rem;\r\n  transition: 0.3s;\r\n  z-index: 1;\r\n  opacity: 1;\r\n  font-family: var(--cb-primary-font);\r\n}\r\n\r\n.cb-form-input.cb-has-content label,\r\n.cb-form-input.cb-has-focus label,\r\n.cb-form-input.cb-has-error label {\r\n  font-weight: normal;\r\n  top: -1.1rem;\r\n  left: 1.4rem;\r\n  font-size: 0.75rem;\r\n  color: #535e80;\r\n  transition: 0.3s;\r\n}\r\n\r\n.cb-form-input-error {\r\n  height: 1rem;\r\n}\r\n\r\n/********** Buttons **********/\r\n.cb-button-primary {\r\n  border: none;\r\n  color: var(--cb-secondary-text-color);\r\n  background-color: var(--cb-primary-color);\r\n  border-radius: 1.5rem;\r\n  font-size: 1rem;\r\n  height: 3rem;\r\n  padding: 0 2rem;\r\n  cursor: pointer;\r\n  font-weight: 700;\r\n  transition:\r\n    background-color 0.3s,\r\n    color 0.3s;\r\n  font-family: var(--cb-primary-font);\r\n}\r\n\r\n.cb-button-primary[disabled] {\r\n  background-color: #7586b9;\r\n  cursor: not-allowed;\r\n}\r\n\r\n.cb-button-primary[disabled]:hover {\r\n  background-color: #7586b9;\r\n}\r\n\r\n.cb-button-primary:hover {\r\n  background-color: #1145df;\r\n}\r\n\r\n.cb-button-secondary {\r\n  border: 2px solid var(--cb-secondary-color);\r\n  background-color: var(--cb-white);\r\n  color: var(--cb-secondary-color);\r\n  border-radius: 1.5rem;\r\n  font-size: 1rem;\r\n  height: 3rem;\r\n  padding: 0 2rem;\r\n  cursor: pointer;\r\n  transition:\r\n    background-color 0.3s,\r\n    color 0.3s;\r\n  font-family: var(--cb-primary-font);\r\n}\r\n\r\n.cb-button-secondary:hover {\r\n  background-color: #e6e6e6;\r\n}\r\n\r\n.cb-button-tertiary {\r\n  font-family: 'Inter', var(--cb-primary-font);\r\n  font-weight: bold;\r\n  background: none;\r\n  border: none;\r\n  color: var(--cb-secondary-color);\r\n  padding: 0;\r\n  cursor: pointer;\r\n  font-size: 1rem;\r\n  height: 2.5rem;\r\n  box-shadow: none;\r\n}\r\n\r\n.cb-button-tertiary:hover,\r\n.cb-button-tertiary:focus {\r\n  text-decoration: none;\r\n  border: none;\r\n  box-shadow: none;\r\n  outline: none;\r\n}\r\n\r\n.cb-spinner-primary {\r\n  display: block;\r\n  position: relative;\r\n  width: 1.1rem;\r\n  height: 1.1rem;\r\n  margin: auto;\r\n  border: 0.25rem solid rgba(0, 0, 0, 0.55);\r\n  border-top-color: var(--cb-white);\r\n  border-radius: 100%;\r\n  animation: cb-spin-animation 1s ease infinite;\r\n}\r\n\r\n.cb-spinner-secondary {\r\n  border: 0.25rem solid rgba(0, 0, 0, 0.55);\r\n  border-top-color: var(--cb-primary-color);\r\n}\r\n\r\n@keyframes cb-spin-animation {\r\n  from {\r\n    transform: rotate(0turn);\r\n  }\r\n\r\n  to {\r\n    transform: rotate(1turn);\r\n  }\r\n}\r\n\r\n/********** Layout **********/\r\n.cb-layout-passkey {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 1rem;\r\n}\r\n\r\n.cb-email-screen {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 1rem;\r\n}\r\n\r\n.cb-email-screen .cb-body {\r\n  margin-top: 0.5rem;\r\n  margin-left: 1.5rem;\r\n  margin-right: 1.5rem;\r\n}\r\n\r\n.cb-email-links {\r\n  display: flex;\r\n  flex-direction: row;\r\n  gap: 1rem;\r\n  justify-content: space-around;\r\n}\r\n\r\n.cb-email-otp-input-container {\r\n  display: flex;\r\n  flex-direction: row;\r\n  gap: 1rem;\r\n  justify-content: center;\r\n  margin-left: 0.25rem;\r\n  margin-right: 0.25rem;\r\n}\r\n\r\n.cb-email-otp-input {\r\n  height: 4.5rem;\r\n  border: 1px solid #d9d9d9;\r\n  border-radius: 1.75rem;\r\n  font-size: 1rem;\r\n  text-align: center;\r\n  font-family: var(--cb-secondary-font);\r\n  padding: 0;\r\n}\r\n\r\n/********** Icons **********/\r\n.cb-finger-print-icon {\r\n  width: 6.4375rem;\r\n  height: 7.5625rem;\r\n  margin-left: auto;\r\n  margin-right: auto;\r\n}\r\n\r\n.cb-link-icon {\r\n  display: flex;\r\n  gap: 0.3rem;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 29.875rem;\r\n  height: 3rem;\r\n  border: 1px solid #d9d9d9;\r\n  border-radius: 9999px;\r\n  text-decoration: none;\r\n  color: var(--cb-primary-text-color);\r\n  font-family: var(--cb-secondary-font);\r\n  cursor: pointer;\r\n}\r\n\r\n.cb-link-icon:hover {\r\n  background-color: #f5f5f5;\r\n}\r\n\r\n.cb-link-icon .cb-icon {\r\n  flex-shrink: 0;\r\n  height: 1.5rem;\r\n}\r\n\r\n.cb-pointer {\r\n  cursor: pointer;\r\n}\r\n\r\n/********** Dialog / Modal **********/\r\n.cb-dialog {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  background: rgba(0, 0, 0, 0.5);\r\n  z-index: 1000;\r\n}\r\n\r\n.cb-dialog-content {\r\n  background: var(--cb-white);\r\n  padding: 1.3rem;\r\n  border-radius: 10px;\r\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\r\n  max-width: 400px;\r\n}\r\n\r\n.cb-dialog-header {\r\n  font-size: 1.4rem;\r\n  font-weight: bold;\r\n  margin-bottom: 1rem;\r\n}\r\n\r\n.cb-dialog-body {\r\n  margin-bottom: 1.5rem;\r\n}\r\n\r\n.cb-dialog-footer {\r\n  display: flex;\r\n  justify-content: flex-end;\r\n  gap: 1rem;\r\n}\r\n\r\n.cb-dialog-x-button {\r\n  float: right;\r\n  cursor: pointer;\r\n  font-size: 1rem;\r\n}\r\n\r\n.cb-dialog-button {\r\n  padding: 0 0.5rem;\r\n  min-width: 10rem;\r\n}\r\n\r\n/********** Passkey List **********/\r\n.cb-passkey-list-card {\r\n  display: flex;\r\n  flex-direction: row;\r\n  gap: 1rem;\r\n  border-radius: 10px;\r\n  border: var(--cb-primary-text-color) 1px solid;\r\n  margin: 0.5rem 0;\r\n  padding: 0.5rem;\r\n  font-family: 'Inter', sans-serif;\r\n}\r\n\r\n.cb-passkey-list-icon {\r\n  display: flex;\r\n  flex: 1;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.cb-passkey-list-icon img {\r\n  width: 2rem;\r\n  height: 2rem;\r\n}\r\n\r\n.cb-passkey-list-icon svg {\r\n  width: 2rem;\r\n  height: 2rem;\r\n  fill: var(--cb-primary-text-color);\r\n}\r\n\r\n.cb-passkey-list-details {\r\n  flex: 5;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: left;\r\n  font-size: 1rem;\r\n  line-height: normal;\r\n  font-weight: 500;\r\n  gap: 0.5rem;\r\n}\r\n\r\n.cb-passkey-list-header {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: left;\r\n  gap: 1rem;\r\n}\r\n\r\n.cb-passkey-list-header-title {\r\n  font-weight: 700;\r\n  margin: auto 0;\r\n}\r\n\r\n.cb-passkey-list-header-badge {\r\n  border-radius: 2rem;\r\n  border: var(--cb-black) 1px solid;\r\n  padding: 0.5rem;\r\n}\r\n\r\n.cb-passkey-list-delete:hover {\r\n  fill: var(--cb-error-color);\r\n  cursor: pointer;\r\n}\r\n\r\n.cb-passkey-list-primary-button {\r\n  padding: 0.5rem;\r\n  margin: 1rem 0;\r\n  min-width: 12rem;\r\n}\r\n\r\n/***** Media Queries *****/\r\n@media screen and (max-width: 768px) {\r\n  .cb-container {\r\n    width: 95%;\r\n    padding: 2.5rem 1.3rem 1.25rem 1.3rem;\r\n  }\r\n\r\n  .cb-email-links {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1rem;\r\n    justify-content: center;\r\n  }\r\n\r\n  .cb-link-icon {\r\n    justify-content: center;\r\n    width: 100%;\r\n  }\r\n\r\n  .cb-passkey-list-card {\r\n    flex-direction: column;\r\n  }\r\n}\r\n"], sourceRoot: "" }]);
      const M4 = a7;
    }, 57: (n7, e5, r8) => {
      r8.d(e5, { Z: () => M4 });
      var i9 = r8(272), t8 = r8.n(i9), o7 = r8(609), a7 = r8.n(o7)()(t8());
      a7.push([n7.id, ".cb-dark {\n  --cb-primary-color: #4b8fff;\n  --cb-secondary-color: #3a7cdd;\n  --cb-error-color: #ff6b6b;\n  --cb-primary-text-color: #e0e0e0;\n  --cb-secondary-text-color: #ffffff;\n  --cb-white: #1e1e1e;\n  --cb-black: #ffffff;\n  --cb-horizontal-divider-color: #555;\n  --cb-input-color: #e0e0e0;\n  --cb-primary-font: 'Space Grotesk', sans-serif;\n\n  .cb-container {\n    border-color: rgba(255, 255, 255, 0.25);\n  }\n\n  .cb-input {\n    caret-color: var(--cb-input-color);\n    border-color: #ffffff80;\n  }\n\n  .cb-form-input label {\n    color: #c0c0c0;\n  }\n\n  .cb-form-input.cb-has-content label,\n  .cb-form-input.cb-has-focus label {\n    color: #c0c0c0;\n  }\n\n  .cb-button-primary:hover {\n    background-color: #3670c8;\n  }\n\n  .cb-button-secondary:hover {\n    background-color: #333;\n  }\n\n  .cb-link-icon {\n    caret-color: #e0e0e0;\n  }\n\n  .cb-link-icon:hover {\n    background-color: #242222;\n  }\n\n  .cb-finger-print-icon {\n    background-color: #4b8fff;\n    border-radius: 3.5rem;\n  }\n\n  .dialog-x-button:hover {\n    color: var(--cb-error-color);\n  }\n\n  .cb-passkey-list-card {\n    background-color: var(--cb-white);\n    border-color: #ffffff80;\n    color: var(--cb-primary-text-color);\n  }\n\n  .cb-passkey-list-icon svg {\n    fill: var(--cb-input-color);\n  }\n\n  .cb-passkey-list-delete:hover {\n    fill: var(--cb-error-color);\n    cursor: pointer;\n  }\n\n  .cb-passkey-list-header-badge {\n    border-color: var(--cb-input-color);\n  }\n}\n", "", { version: 3, sources: ["webpack://./src/styles/themes/dark.css"], names: [], mappings: "AAAA;EACE,2BAA2B;EAC3B,6BAA6B;EAC7B,yBAAyB;EACzB,gCAAgC;EAChC,kCAAkC;EAClC,mBAAmB;EACnB,mBAAmB;EACnB,mCAAmC;EACnC,yBAAyB;EACzB,8CAA8C;;EAE9C;IACE,uCAAuC;EACzC;;EAEA;IACE,kCAAkC;IAClC,uBAAuB;EACzB;;EAEA;IACE,cAAc;EAChB;;EAEA;;IAEE,cAAc;EAChB;;EAEA;IACE,yBAAyB;EAC3B;;EAEA;IACE,sBAAsB;EACxB;;EAEA;IACE,oBAAoB;EACtB;;EAEA;IACE,yBAAyB;EAC3B;;EAEA;IACE,yBAAyB;IACzB,qBAAqB;EACvB;;EAEA;IACE,4BAA4B;EAC9B;;EAEA;IACE,iCAAiC;IACjC,uBAAuB;IACvB,mCAAmC;EACrC;;EAEA;IACE,2BAA2B;EAC7B;;EAEA;IACE,2BAA2B;IAC3B,eAAe;EACjB;;EAEA;IACE,mCAAmC;EACrC;AACF", sourcesContent: [".cb-dark {\r\n  --cb-primary-color: #4b8fff;\r\n  --cb-secondary-color: #3a7cdd;\r\n  --cb-error-color: #ff6b6b;\r\n  --cb-primary-text-color: #e0e0e0;\r\n  --cb-secondary-text-color: #ffffff;\r\n  --cb-white: #1e1e1e;\r\n  --cb-black: #ffffff;\r\n  --cb-horizontal-divider-color: #555;\r\n  --cb-input-color: #e0e0e0;\r\n  --cb-primary-font: 'Space Grotesk', sans-serif;\r\n\r\n  .cb-container {\r\n    border-color: rgba(255, 255, 255, 0.25);\r\n  }\r\n\r\n  .cb-input {\r\n    caret-color: var(--cb-input-color);\r\n    border-color: #ffffff80;\r\n  }\r\n\r\n  .cb-form-input label {\r\n    color: #c0c0c0;\r\n  }\r\n\r\n  .cb-form-input.cb-has-content label,\r\n  .cb-form-input.cb-has-focus label {\r\n    color: #c0c0c0;\r\n  }\r\n\r\n  .cb-button-primary:hover {\r\n    background-color: #3670c8;\r\n  }\r\n\r\n  .cb-button-secondary:hover {\r\n    background-color: #333;\r\n  }\r\n\r\n  .cb-link-icon {\r\n    caret-color: #e0e0e0;\r\n  }\r\n\r\n  .cb-link-icon:hover {\r\n    background-color: #242222;\r\n  }\r\n\r\n  .cb-finger-print-icon {\r\n    background-color: #4b8fff;\r\n    border-radius: 3.5rem;\r\n  }\r\n\r\n  .dialog-x-button:hover {\r\n    color: var(--cb-error-color);\r\n  }\r\n\r\n  .cb-passkey-list-card {\r\n    background-color: var(--cb-white);\r\n    border-color: #ffffff80;\r\n    color: var(--cb-primary-text-color);\r\n  }\r\n\r\n  .cb-passkey-list-icon svg {\r\n    fill: var(--cb-input-color);\r\n  }\r\n\r\n  .cb-passkey-list-delete:hover {\r\n    fill: var(--cb-error-color);\r\n    cursor: pointer;\r\n  }\r\n\r\n  .cb-passkey-list-header-badge {\r\n    border-color: var(--cb-input-color);\r\n  }\r\n}\r\n"], sourceRoot: "" }]);
      const M4 = a7;
    }, 415: (n7, e5, r8) => {
      r8.d(e5, { Z: () => M4 });
      var i9 = r8(272), t8 = r8.n(i9), o7 = r8(609), a7 = r8.n(o7)()(t8());
      a7.push([n7.id, ".cb-emerald-funk-theme {\n  --cb-primary-color: #21ba45;\n  --cb-secondary-color: #b5ff7d;\n  --cb-white: #1b1d1b;\n  --cb-black: #ffffff;\n  --cb-primary-text-color: #ffffff;\n  --cb-border-color: #21ba45;\n  --cb-error-color: #ff6b6b;\n  --cb-horizontal-divider-color: #555;\n  --cb-input-color: #e0e0e0;\n  --cb-primary-font: 'Comic Sans MS', cursive, sans-serif;\n  --cb-secondary-font: 'Comic Sans MS', cursive, sans-serif;\n\n  .cb-container {\n    border-color: var(--cb-border-color);\n  }\n\n  .cb-input {\n    caret-color: var(--cb-input-color);\n    border-color: #ffffff80;\n  }\n\n  .cb-form-input label {\n    color: var(--cb-input-color);\n  }\n\n  .cb-form-input.cb-has-content label,\n  .cb-form-input.cb-has-focus label {\n    color: var(--cb-input-color);\n  }\n\n  .cb-button-primary[disabled] {\n    background-color: #578f64;\n    cursor: not-allowed;\n  }\n\n  .cb-button-primary[disabled]:hover {\n    background-color: #578f64;\n  }\n\n  .cb-button-primary:hover {\n    background-color: #1b8834;\n  }\n\n  .cb-button-secondary:hover {\n    background-color: #133113;\n  }\n\n  .cb-finger-print-icon {\n    background-color: var(--cb-primary-color);\n    border-radius: 3.5rem;\n  }\n}\n", "", { version: 3, sources: ["webpack://./src/styles/themes/emerald-funk.css"], names: [], mappings: "AAAA;EACE,2BAA2B;EAC3B,6BAA6B;EAC7B,mBAAmB;EACnB,mBAAmB;EACnB,gCAAgC;EAChC,0BAA0B;EAC1B,yBAAyB;EACzB,mCAAmC;EACnC,yBAAyB;EACzB,uDAAuD;EACvD,yDAAyD;;EAEzD;IACE,oCAAoC;EACtC;;EAEA;IACE,kCAAkC;IAClC,uBAAuB;EACzB;;EAEA;IACE,4BAA4B;EAC9B;;EAEA;;IAEE,4BAA4B;EAC9B;;EAEA;IACE,yBAAyB;IACzB,mBAAmB;EACrB;;EAEA;IACE,yBAAyB;EAC3B;;EAEA;IACE,yBAAyB;EAC3B;;EAEA;IACE,yBAAyB;EAC3B;;EAEA;IACE,yCAAyC;IACzC,qBAAqB;EACvB;AACF", sourcesContent: [".cb-emerald-funk-theme {\r\n  --cb-primary-color: #21ba45;\r\n  --cb-secondary-color: #b5ff7d;\r\n  --cb-white: #1b1d1b;\r\n  --cb-black: #ffffff;\r\n  --cb-primary-text-color: #ffffff;\r\n  --cb-border-color: #21ba45;\r\n  --cb-error-color: #ff6b6b;\r\n  --cb-horizontal-divider-color: #555;\r\n  --cb-input-color: #e0e0e0;\r\n  --cb-primary-font: 'Comic Sans MS', cursive, sans-serif;\r\n  --cb-secondary-font: 'Comic Sans MS', cursive, sans-serif;\r\n\r\n  .cb-container {\r\n    border-color: var(--cb-border-color);\r\n  }\r\n\r\n  .cb-input {\r\n    caret-color: var(--cb-input-color);\r\n    border-color: #ffffff80;\r\n  }\r\n\r\n  .cb-form-input label {\r\n    color: var(--cb-input-color);\r\n  }\r\n\r\n  .cb-form-input.cb-has-content label,\r\n  .cb-form-input.cb-has-focus label {\r\n    color: var(--cb-input-color);\r\n  }\r\n\r\n  .cb-button-primary[disabled] {\r\n    background-color: #578f64;\r\n    cursor: not-allowed;\r\n  }\r\n\r\n  .cb-button-primary[disabled]:hover {\r\n    background-color: #578f64;\r\n  }\r\n\r\n  .cb-button-primary:hover {\r\n    background-color: #1b8834;\r\n  }\r\n\r\n  .cb-button-secondary:hover {\r\n    background-color: #133113;\r\n  }\r\n\r\n  .cb-finger-print-icon {\r\n    background-color: var(--cb-primary-color);\r\n    border-radius: 3.5rem;\r\n  }\r\n}\r\n"], sourceRoot: "" }]);
      const M4 = a7;
    }, 609: (n7) => {
      n7.exports = function(n8) {
        var e5 = [];
        return e5.toString = function() {
          return this.map(function(e6) {
            var r8 = "", i9 = void 0 !== e6[5];
            return e6[4] && (r8 += "@supports (".concat(e6[4], ") {")), e6[2] && (r8 += "@media ".concat(e6[2], " {")), i9 && (r8 += "@layer".concat(e6[5].length > 0 ? " ".concat(e6[5]) : "", " {")), r8 += n8(e6), i9 && (r8 += "}"), e6[2] && (r8 += "}"), e6[4] && (r8 += "}"), r8;
          }).join("");
        }, e5.i = function(n9, r8, i9, t8, o7) {
          "string" == typeof n9 && (n9 = [[null, n9, void 0]]);
          var a7 = {};
          if (i9)
            for (var M4 = 0; M4 < this.length; M4++) {
              var s9 = this[M4][0];
              null != s9 && (a7[s9] = true);
            }
          for (var c8 = 0; c8 < n9.length; c8++) {
            var A5 = [].concat(n9[c8]);
            i9 && a7[A5[0]] || (void 0 !== o7 && (void 0 === A5[5] || (A5[1] = "@layer".concat(A5[5].length > 0 ? " ".concat(A5[5]) : "", " {").concat(A5[1], "}")), A5[5] = o7), r8 && (A5[2] ? (A5[1] = "@media ".concat(A5[2], " {").concat(A5[1], "}"), A5[2] = r8) : A5[2] = r8), t8 && (A5[4] ? (A5[1] = "@supports (".concat(A5[4], ") {").concat(A5[1], "}"), A5[4] = t8) : A5[4] = "".concat(t8)), e5.push(A5));
          }
        }, e5;
      };
    }, 272: (n7) => {
      n7.exports = function(n8) {
        var e5 = n8[1], r8 = n8[3];
        if (!r8)
          return e5;
        if ("function" == typeof btoa) {
          var i9 = btoa(unescape(encodeURIComponent(JSON.stringify(r8)))), t8 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(i9), o7 = "/*# ".concat(t8, " */");
          return [e5].concat([o7]).join("\n");
        }
        return [e5].join("\n");
      };
    }, 62: (n7) => {
      var e5 = [];
      function r8(n8) {
        for (var r9 = -1, i10 = 0; i10 < e5.length; i10++)
          if (e5[i10].identifier === n8) {
            r9 = i10;
            break;
          }
        return r9;
      }
      function i9(n8, i10) {
        for (var o7 = {}, a7 = [], M4 = 0; M4 < n8.length; M4++) {
          var s9 = n8[M4], c8 = i10.base ? s9[0] + i10.base : s9[0], A5 = o7[c8] || 0, l7 = "".concat(c8, " ").concat(A5);
          o7[c8] = A5 + 1;
          var u6 = r8(l7), I4 = { css: s9[1], media: s9[2], sourceMap: s9[3], supports: s9[4], layer: s9[5] };
          if (-1 !== u6)
            e5[u6].references++, e5[u6].updater(I4);
          else {
            var N4 = t8(I4, i10);
            i10.byIndex = M4, e5.splice(M4, 0, { identifier: l7, updater: N4, references: 1 });
          }
          a7.push(l7);
        }
        return a7;
      }
      function t8(n8, e6) {
        var r9 = e6.domAPI(e6);
        return r9.update(n8), function(e7) {
          if (e7) {
            if (e7.css === n8.css && e7.media === n8.media && e7.sourceMap === n8.sourceMap && e7.supports === n8.supports && e7.layer === n8.layer)
              return;
            r9.update(n8 = e7);
          } else
            r9.remove();
        };
      }
      n7.exports = function(n8, t9) {
        var o7 = i9(n8 = n8 || [], t9 = t9 || {});
        return function(n9) {
          n9 = n9 || [];
          for (var a7 = 0; a7 < o7.length; a7++) {
            var M4 = r8(o7[a7]);
            e5[M4].references--;
          }
          for (var s9 = i9(n9, t9), c8 = 0; c8 < o7.length; c8++) {
            var A5 = r8(o7[c8]);
            0 === e5[A5].references && (e5[A5].updater(), e5.splice(A5, 1));
          }
          o7 = s9;
        };
      };
    }, 793: (n7) => {
      var e5 = {};
      n7.exports = function(n8, r8) {
        var i9 = function(n9) {
          if (void 0 === e5[n9]) {
            var r9 = document.querySelector(n9);
            if (window.HTMLIFrameElement && r9 instanceof window.HTMLIFrameElement)
              try {
                r9 = r9.contentDocument.head;
              } catch (n10) {
                r9 = null;
              }
            e5[n9] = r9;
          }
          return e5[n9];
        }(n8);
        if (!i9)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        i9.appendChild(r8);
      };
    }, 173: (n7) => {
      n7.exports = function(n8) {
        var e5 = document.createElement("style");
        return n8.setAttributes(e5, n8.attributes), n8.insert(e5, n8.options), e5;
      };
    }, 892: (n7, e5, r8) => {
      n7.exports = function(n8) {
        var e6 = r8.nc;
        e6 && n8.setAttribute("nonce", e6);
      };
    }, 36: (n7) => {
      n7.exports = function(n8) {
        if ("undefined" == typeof document)
          return { update: function() {
          }, remove: function() {
          } };
        var e5 = n8.insertStyleElement(n8);
        return { update: function(r8) {
          !function(n9, e6, r9) {
            var i9 = "";
            r9.supports && (i9 += "@supports (".concat(r9.supports, ") {")), r9.media && (i9 += "@media ".concat(r9.media, " {"));
            var t8 = void 0 !== r9.layer;
            t8 && (i9 += "@layer".concat(r9.layer.length > 0 ? " ".concat(r9.layer) : "", " {")), i9 += r9.css, t8 && (i9 += "}"), r9.media && (i9 += "}"), r9.supports && (i9 += "}");
            var o7 = r9.sourceMap;
            o7 && "undefined" != typeof btoa && (i9 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o7)))), " */")), e6.styleTagTransform(i9, n9, e6.options);
          }(e5, n8, r8);
        }, remove: function() {
          !function(n9) {
            if (null === n9.parentNode)
              return false;
            n9.parentNode.removeChild(n9);
          }(e5);
        } };
      };
    }, 464: (n7) => {
      n7.exports = function(n8, e5) {
        if (e5.styleSheet)
          e5.styleSheet.cssText = n8;
        else {
          for (; e5.firstChild; )
            e5.removeChild(e5.firstChild);
          e5.appendChild(document.createTextNode(n8));
        }
      };
    }, 353: function(n7, e5, r8) {
      var i9;
      !function(t8, o7) {
        var a7 = "function", M4 = "undefined", s9 = "object", c8 = "string", A5 = "major", l7 = "model", u6 = "name", I4 = "type", N4 = "vendor", g7 = "version", y7 = "architecture", d6 = "console", j4 = "mobile", b5 = "tablet", D4 = "smarttv", w6 = "wearable", C5 = "embedded", m5 = "Amazon", L5 = "Apple", E6 = "ASUS", z3 = "BlackBerry", p5 = "Browser", T2 = "Chrome", x4 = "Firefox", k4 = "Google", h6 = "Huawei", f5 = "LG", S5 = "Microsoft", v5 = "Motorola", B3 = "Opera", O3 = "Samsung", Y3 = "Sharp", Q3 = "Sony", P4 = "Xiaomi", Z4 = "Zebra", U4 = "Facebook", W4 = "Chromium OS", G3 = "Mac OS", H3 = function(n8) {
          for (var e6 = {}, r9 = 0; r9 < n8.length; r9++)
            e6[n8[r9].toUpperCase()] = n8[r9];
          return e6;
        }, R3 = function(n8, e6) {
          return typeof n8 === c8 && -1 !== V3(e6).indexOf(V3(n8));
        }, V3 = function(n8) {
          return n8.toLowerCase();
        }, F4 = function(n8, e6) {
          if (typeof n8 === c8)
            return n8 = n8.replace(/^\s\s*/, ""), typeof e6 === M4 ? n8 : n8.substring(0, 500);
        }, J3 = function(n8, e6) {
          for (var r9, i10, t9, M5, c9, A6, l8 = 0; l8 < e6.length && !c9; ) {
            var u7 = e6[l8], I5 = e6[l8 + 1];
            for (r9 = i10 = 0; r9 < u7.length && !c9 && u7[r9]; )
              if (c9 = u7[r9++].exec(n8))
                for (t9 = 0; t9 < I5.length; t9++)
                  A6 = c9[++i10], typeof (M5 = I5[t9]) === s9 && M5.length > 0 ? 2 === M5.length ? typeof M5[1] == a7 ? this[M5[0]] = M5[1].call(this, A6) : this[M5[0]] = M5[1] : 3 === M5.length ? typeof M5[1] !== a7 || M5[1].exec && M5[1].test ? this[M5[0]] = A6 ? A6.replace(M5[1], M5[2]) : o7 : this[M5[0]] = A6 ? M5[1].call(this, A6, M5[2]) : o7 : 4 === M5.length && (this[M5[0]] = A6 ? M5[3].call(this, A6.replace(M5[1], M5[2])) : o7) : this[M5] = A6 || o7;
            l8 += 2;
          }
        }, X4 = function(n8, e6) {
          for (var r9 in e6)
            if (typeof e6[r9] === s9 && e6[r9].length > 0) {
              for (var i10 = 0; i10 < e6[r9].length; i10++)
                if (R3(e6[r9][i10], n8))
                  return "?" === r9 ? o7 : r9;
            } else if (R3(e6[r9], n8))
              return "?" === r9 ? o7 : r9;
          return n8;
        }, _4 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, K3 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [g7, [u6, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [g7, [u6, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [u6, g7], [/opios[\/ ]+([\w\.]+)/i], [g7, [u6, B3 + " Mini"]], [/\bopr\/([\w\.]+)/i], [g7, [u6, B3]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [g7, [u6, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [u6, g7], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [g7, [u6, "UC" + p5]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [g7, [u6, "WeChat"]], [/konqueror\/([\w\.]+)/i], [g7, [u6, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [g7, [u6, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [g7, [u6, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [g7, [u6, "Smart Lenovo " + p5]], [/(avast|avg)\/([\w\.]+)/i], [[u6, /(.+)/, "$1 Secure " + p5], g7], [/\bfocus\/([\w\.]+)/i], [g7, [u6, x4 + " Focus"]], [/\bopt\/([\w\.]+)/i], [g7, [u6, B3 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [g7, [u6, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [g7, [u6, "Dolphin"]], [/coast\/([\w\.]+)/i], [g7, [u6, B3 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [g7, [u6, "MIUI " + p5]], [/fxios\/([-\w\.]+)/i], [g7, [u6, x4]], [/\bqihu|(qi?ho?o?|360)browser/i], [[u6, "360 " + p5]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[u6, /(.+)/, "$1 " + p5], g7], [/samsungbrowser\/([\w\.]+)/i], [g7, [u6, O3 + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[u6, /_/g, " "], g7], [/metasr[\/ ]?([\d\.]+)/i], [g7, [u6, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[u6, "Sogou Mobile"], g7], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [u6, g7], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [u6], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[u6, U4], g7], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [u6, g7], [/\bgsa\/([\w\.]+) .*safari\//i], [g7, [u6, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [g7, [u6, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [g7, [u6, T2 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[u6, T2 + " WebView"], g7], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [g7, [u6, "Android " + p5]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [u6, g7], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [g7, [u6, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [g7, u6], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [u6, [g7, X4, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [u6, g7], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[u6, "Netscape"], g7], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [g7, [u6, x4 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [u6, g7], [/(cobalt)\/([\w\.]+)/i], [u6, [g7, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[y7, "amd64"]], [/(ia32(?=;))/i], [[y7, V3]], [/((?:i[346]|x)86)[;\)]/i], [[y7, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[y7, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[y7, "armhf"]], [/windows (ce|mobile); ppc;/i], [[y7, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[y7, /ower/, "", V3]], [/(sun4\w)[;\)]/i], [[y7, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[y7, V3]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [l7, [N4, O3], [I4, b5]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [l7, [N4, O3], [I4, j4]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [l7, [N4, L5], [I4, j4]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [l7, [N4, L5], [I4, b5]], [/(macintosh);/i], [l7, [N4, L5]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [l7, [N4, Y3], [I4, j4]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [l7, [N4, h6], [I4, b5]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [l7, [N4, h6], [I4, j4]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[l7, /_/g, " "], [N4, P4], [I4, j4]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[l7, /_/g, " "], [N4, P4], [I4, b5]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [l7, [N4, "OPPO"], [I4, j4]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [l7, [N4, "Vivo"], [I4, j4]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [l7, [N4, "Realme"], [I4, j4]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [l7, [N4, v5], [I4, j4]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [l7, [N4, v5], [I4, b5]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [l7, [N4, f5], [I4, b5]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [l7, [N4, f5], [I4, j4]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [l7, [N4, "Lenovo"], [I4, b5]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[l7, /_/g, " "], [N4, "Nokia"], [I4, j4]], [/(pixel c)\b/i], [l7, [N4, k4], [I4, b5]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [l7, [N4, k4], [I4, j4]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [l7, [N4, Q3], [I4, j4]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[l7, "Xperia Tablet"], [N4, Q3], [I4, b5]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [l7, [N4, "OnePlus"], [I4, j4]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [l7, [N4, m5], [I4, b5]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[l7, /(.+)/g, "Fire Phone $1"], [N4, m5], [I4, j4]], [/(playbook);[-\w\),; ]+(rim)/i], [l7, N4, [I4, b5]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [l7, [N4, z3], [I4, j4]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [l7, [N4, E6], [I4, b5]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [l7, [N4, E6], [I4, j4]], [/(nexus 9)/i], [l7, [N4, "HTC"], [I4, b5]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [N4, [l7, /_/g, " "], [I4, j4]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [l7, [N4, "Acer"], [I4, b5]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [l7, [N4, "Meizu"], [I4, j4]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [l7, [N4, "Ulefone"], [I4, j4]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [N4, l7, [I4, j4]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [N4, l7, [I4, b5]], [/(surface duo)/i], [l7, [N4, S5], [I4, b5]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [l7, [N4, "Fairphone"], [I4, j4]], [/(u304aa)/i], [l7, [N4, "AT&T"], [I4, j4]], [/\bsie-(\w*)/i], [l7, [N4, "Siemens"], [I4, j4]], [/\b(rct\w+) b/i], [l7, [N4, "RCA"], [I4, b5]], [/\b(venue[\d ]{2,7}) b/i], [l7, [N4, "Dell"], [I4, b5]], [/\b(q(?:mv|ta)\w+) b/i], [l7, [N4, "Verizon"], [I4, b5]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [l7, [N4, "Barnes & Noble"], [I4, b5]], [/\b(tm\d{3}\w+) b/i], [l7, [N4, "NuVision"], [I4, b5]], [/\b(k88) b/i], [l7, [N4, "ZTE"], [I4, b5]], [/\b(nx\d{3}j) b/i], [l7, [N4, "ZTE"], [I4, j4]], [/\b(gen\d{3}) b.+49h/i], [l7, [N4, "Swiss"], [I4, j4]], [/\b(zur\d{3}) b/i], [l7, [N4, "Swiss"], [I4, b5]], [/\b((zeki)?tb.*\b) b/i], [l7, [N4, "Zeki"], [I4, b5]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[N4, "Dragon Touch"], l7, [I4, b5]], [/\b(ns-?\w{0,9}) b/i], [l7, [N4, "Insignia"], [I4, b5]], [/\b((nxa|next)-?\w{0,9}) b/i], [l7, [N4, "NextBook"], [I4, b5]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[N4, "Voice"], l7, [I4, j4]], [/\b(lvtel\-)?(v1[12]) b/i], [[N4, "LvTel"], l7, [I4, j4]], [/\b(ph-1) /i], [l7, [N4, "Essential"], [I4, j4]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [l7, [N4, "Envizen"], [I4, b5]], [/\b(trio[-\w\. ]+) b/i], [l7, [N4, "MachSpeed"], [I4, b5]], [/\btu_(1491) b/i], [l7, [N4, "Rotor"], [I4, b5]], [/(shield[\w ]+) b/i], [l7, [N4, "Nvidia"], [I4, b5]], [/(sprint) (\w+)/i], [N4, l7, [I4, j4]], [/(kin\.[onetw]{3})/i], [[l7, /\./g, " "], [N4, S5], [I4, j4]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [l7, [N4, Z4], [I4, b5]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [l7, [N4, Z4], [I4, j4]], [/smart-tv.+(samsung)/i], [N4, [I4, D4]], [/hbbtv.+maple;(\d+)/i], [[l7, /^/, "SmartTV"], [N4, O3], [I4, D4]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[N4, f5], [I4, D4]], [/(apple) ?tv/i], [N4, [l7, L5 + " TV"], [I4, D4]], [/crkey/i], [[l7, T2 + "cast"], [N4, k4], [I4, D4]], [/droid.+aft(\w+)( bui|\))/i], [l7, [N4, m5], [I4, D4]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [l7, [N4, Y3], [I4, D4]], [/(bravia[\w ]+)( bui|\))/i], [l7, [N4, Q3], [I4, D4]], [/(mitv-\w{5}) bui/i], [l7, [N4, P4], [I4, D4]], [/Hbbtv.*(technisat) (.*);/i], [N4, l7, [I4, D4]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[N4, F4], [l7, F4], [I4, D4]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[I4, D4]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [N4, l7, [I4, d6]], [/droid.+; (shield) bui/i], [l7, [N4, "Nvidia"], [I4, d6]], [/(playstation [345portablevi]+)/i], [l7, [N4, Q3], [I4, d6]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [l7, [N4, S5], [I4, d6]], [/((pebble))app/i], [N4, l7, [I4, w6]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [l7, [N4, L5], [I4, w6]], [/droid.+; (glass) \d/i], [l7, [N4, k4], [I4, w6]], [/droid.+; (wt63?0{2,3})\)/i], [l7, [N4, Z4], [I4, w6]], [/(quest( 2| pro)?)/i], [l7, [N4, U4], [I4, w6]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [N4, [I4, C5]], [/(aeobc)\b/i], [l7, [N4, m5], [I4, C5]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [l7, [I4, j4]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [l7, [I4, b5]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[I4, b5]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[I4, j4]], [/(android[-\w\. ]{0,9});.+buil/i], [l7, [N4, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [g7, [u6, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [g7, [u6, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [u6, g7], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [g7, u6]], os: [[/microsoft (windows) (vista|xp)/i], [u6, g7], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [u6, [g7, X4, _4]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[g7, X4, _4], [u6, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[g7, /_/g, "."], [u6, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[u6, G3], [g7, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [g7, u6], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [u6, g7], [/\(bb(10);/i], [g7, [u6, z3]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [g7, [u6, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [g7, [u6, x4 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [g7, [u6, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [g7, [u6, "watchOS"]], [/crkey\/([\d\.]+)/i], [g7, [u6, T2 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[u6, W4], g7], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [u6, g7], [/(sunos) ?([\w\.\d]*)/i], [[u6, "Solaris"], g7], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [u6, g7]] }, q4 = function(n8, e6) {
          if (typeof n8 === s9 && (e6 = n8, n8 = o7), !(this instanceof q4))
            return new q4(n8, e6).getResult();
          var r9 = typeof t8 !== M4 && t8.navigator ? t8.navigator : o7, i10 = n8 || (r9 && r9.userAgent ? r9.userAgent : ""), d7 = r9 && r9.userAgentData ? r9.userAgentData : o7, D5 = e6 ? function(n9, e7) {
            var r10 = {};
            for (var i11 in n9)
              e7[i11] && e7[i11].length % 2 == 0 ? r10[i11] = e7[i11].concat(n9[i11]) : r10[i11] = n9[i11];
            return r10;
          }(K3, e6) : K3, w7 = r9 && r9.userAgent == i10;
          return this.getBrowser = function() {
            var n9, e7 = {};
            return e7[u6] = o7, e7[g7] = o7, J3.call(e7, i10, D5.browser), e7[A5] = typeof (n9 = e7[g7]) === c8 ? n9.replace(/[^\d\.]/g, "").split(".")[0] : o7, w7 && r9 && r9.brave && typeof r9.brave.isBrave == a7 && (e7[u6] = "Brave"), e7;
          }, this.getCPU = function() {
            var n9 = {};
            return n9[y7] = o7, J3.call(n9, i10, D5.cpu), n9;
          }, this.getDevice = function() {
            var n9 = {};
            return n9[N4] = o7, n9[l7] = o7, n9[I4] = o7, J3.call(n9, i10, D5.device), w7 && !n9[I4] && d7 && d7.mobile && (n9[I4] = j4), w7 && "Macintosh" == n9[l7] && r9 && typeof r9.standalone !== M4 && r9.maxTouchPoints && r9.maxTouchPoints > 2 && (n9[l7] = "iPad", n9[I4] = b5), n9;
          }, this.getEngine = function() {
            var n9 = {};
            return n9[u6] = o7, n9[g7] = o7, J3.call(n9, i10, D5.engine), n9;
          }, this.getOS = function() {
            var n9 = {};
            return n9[u6] = o7, n9[g7] = o7, J3.call(n9, i10, D5.os), w7 && !n9[u6] && d7 && "Unknown" != d7.platform && (n9[u6] = d7.platform.replace(/chrome os/i, W4).replace(/macos/i, G3)), n9;
          }, this.getResult = function() {
            return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
          }, this.getUA = function() {
            return i10;
          }, this.setUA = function(n9) {
            return i10 = typeof n9 === c8 && n9.length > 500 ? F4(n9, 500) : n9, this;
          }, this.setUA(i10), this;
        };
        q4.VERSION = "1.0.37", q4.BROWSER = H3([u6, g7, A5]), q4.CPU = H3([y7]), q4.DEVICE = H3([l7, N4, I4, d6, j4, D4, b5, w6, C5]), q4.ENGINE = q4.OS = H3([u6, g7]), typeof e5 !== M4 ? (n7.exports && (e5 = n7.exports = q4), e5.UAParser = q4) : r8.amdO ? (i9 = function() {
          return q4;
        }.call(e5, r8, e5, n7)) === o7 || (n7.exports = i9) : typeof t8 !== M4 && (t8.UAParser = q4);
        var $3 = typeof t8 !== M4 && (t8.jQuery || t8.Zepto);
        if ($3 && !$3.ua) {
          var nn = new q4();
          $3.ua = nn.getResult(), $3.ua.get = function() {
            return nn.getUA();
          }, $3.ua.set = function(n8) {
            nn.setUA(n8);
            var e6 = nn.getResult();
            for (var r9 in e6)
              $3.ua[r9] = e6[r9];
          };
        }
      }("object" == typeof window ? window : this);
    } };
    r4 = {};
    i5.amdO = {}, i5.n = (n7) => {
      var e5 = n7 && n7.__esModule ? () => n7.default : () => n7;
      return i5.d(e5, { a: e5 }), e5;
    }, i5.d = (n7, e5) => {
      for (var r8 in e5)
        i5.o(e5, r8) && !i5.o(n7, r8) && Object.defineProperty(n7, r8, { enumerable: true, get: e5[r8] });
    }, i5.o = (n7, e5) => Object.prototype.hasOwnProperty.call(n7, e5), (() => {
      var n7;
      if ("string" == typeof import.meta.url && (n7 = import.meta.url), !n7)
        throw new Error("Automatic publicPath is not supported in this browser");
      n7 = n7.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"), i5.p = n7;
    })(), i5.nc = void 0;
    t3 = {};
    (() => {
      i5.d(t3, { BN: () => Q3, c0: () => ge3, LK: () => on, MK: () => nn, $Y: () => rn, GV: () => tn, zC: () => en, d: () => R3, Ll: () => de3, mX: () => H3, HN: () => P4, O$: () => F4, KD: () => Y3, XF: () => v5, ag: () => ye3, yJ: () => U4, cM: () => G3, pA: () => W4, $Q: () => Mn, xi: () => an, n_: () => Z4, jL: () => J3 });
      var e5 = i5(62), r8 = i5.n(e5), o7 = i5(36), a7 = i5.n(o7), M4 = i5(793), s9 = i5.n(M4), c8 = i5(892), A5 = i5.n(c8), l7 = i5(173), u6 = i5.n(l7), I4 = i5(464), N4 = i5.n(I4), g7 = i5(74), y7 = {};
      y7.styleTagTransform = N4(), y7.setAttributes = A5(), y7.insert = s9().bind(null, "head"), y7.domAPI = a7(), y7.insertStyleElement = u6(), r8()(g7.Z, y7), g7.Z && g7.Z.locals && g7.Z.locals;
      var d6 = i5(502), j4 = {};
      j4.styleTagTransform = N4(), j4.setAttributes = A5(), j4.insert = s9().bind(null, "head"), j4.domAPI = a7(), j4.insertStyleElement = u6(), r8()(d6.Z, j4), d6.Z && d6.Z.locals && d6.Z.locals;
      var b5 = i5(57), D4 = {};
      D4.styleTagTransform = N4(), D4.setAttributes = A5(), D4.insert = s9().bind(null, "head"), D4.domAPI = a7(), D4.insertStyleElement = u6(), r8()(b5.Z, D4), b5.Z && b5.Z.locals && b5.Z.locals;
      var w6 = i5(415), C5 = {};
      C5.styleTagTransform = N4(), C5.setAttributes = A5(), C5.insert = s9().bind(null, "head"), C5.domAPI = a7(), C5.insertStyleElement = u6(), r8()(w6.Z, C5), w6.Z && w6.Z.locals && w6.Z.locals;
      const m5 = i5.p + "assets/cancel.svg", L5 = i5.p + "assets/delete.svg", E6 = i5.p + "assets/fingerprint.svg", z3 = i5.p + "assets/gmail.svg", p5 = i5.p + "assets/logo.svg", T2 = i5.p + "assets/outlook.svg", x4 = i5.p + "assets/passkey-default.svg", k4 = i5.p + "assets/yahoo.svg", h6 = JSON.parse('{"authentication":{"signup":{"start":{"header":"Erstellen Sie Ihr Konto","subheader":"Haben Sie bereits ein Konto? ","button_login":"Einloggen","button_submit":"Weiter mit E-Mail","textField_name":"Name","textField_email":"E-Mail-Adresse"},"emailOtp":{"header":"Einmalkennwort eingeben, um Konto zu erstellen","body_text1":"Wir haben gerade ein Einmalkennwort an ","body_text2":" gesendet. Das Einmalkennwort l\xE4uft bald ab, bitte geben Sie es bald ein.","button_verify":"Fortfahren","button_sendOtpAgain":"Einmalkennwort erneut senden","button_back":"Abbrechen"},"emailLinkSent":{"header":"Pr\xFCfen Sie Ihr Email Postfach","body_text1":"Wir haben ihnen eine E-Mail an ","body_text2":"gesendet. Bitte \xF6ffnen sie diese und klicken sie auf den Link, um ihre Anmeldung abzuschlie\xDFen.","button_sendLinkAgainWaitingText":"Link erneut senden ({{remainingTime}} sec)","button_sendLinkAgain":"Link erneut senden","button_back":"Abbrechen"},"emailLinkVerification":{"header":"Verifizierung l\xE4uft...","button_back":"Abbrechen"},"passkeyCreate":{"header":"Starten Sie mit ","headerButton_showPasskeyBenefits":"Passkeys","body":"Wir erstellen einen Account f\xFCr ","button_start":"Account erstellen","button_switchToAlternate":{"emailOtp":"E-Mail-Einmalkennwort senden","emailLink":"E-Mail-Link senden"},"button_back":"Zur\xFCck"},"passkeyError":{"header":"Starten Sie mit","body_errorMessage":"Ihr Konto konnte nicht erstellt werden mit ","button_showPasskeyBenefits":"Passkeys","body_tryAgainMessage":{"emailOtp":". Versuchen Sie es erneut oder melden Sie sich mit E-Mail-Einmalkennwort an.","emailLink":". Versuchen Sie es erneut oder melden Sie sich mit E-Mail-Links an."},"button_switchToAlternate":{"emailOtp":"E-Mail-Einmalkennwort senden","emailLink":"E-Mail-Link senden"},"button_retry":"Erneut versuchen","button_back":"Zur\xFCck","button_cancel":"Abbrechen"},"passkeySuccess":{"header":"Willkommen!","subheader":"Passkey wurde erstellt","body_text1":"Sie k\xF6nnen jetzt Ihre Identit\xE4t mit Ihrem ","body_text2":{"emailOtp":"Passkey oder per E-Mail-Einmalkennwort","emailLink":"Passkey oder per E-Mail-Link"},"body_text3":" beim Einloggen best\xE4tigen.","button":"Weiter"},"passkeyBenefits":{"header":"Passkeys","body_introduction":"Mit Passkeys m\xFCssen Sie sich keine komplexen Passw\xF6rter mehr merken. Melden Sie sich sicher mit ","body_loginMethods":"Face ID, Touch ID oder Sperrcode an.","button_start":"Passkey erstellen","button_skip":"Vielleicht sp\xE4ter"},"passkeyPrompt":{"header":"Schneller einloggen mit ","button_showPasskeyBenefits":"Passkeys","button_start":"Aktivieren","button_skip":"Vielleicht sp\xE4ter"}},"login":{"start":{"header":"Willkommen zur\xFCck!","subheader":"Noch kein Konto? ","button_signup":"Konto erstellen","button_submit":"Weiter","textField_email":"E-Mail-Adresse"},"emailOtp":{"header":"Einmalkennwort zum Login eingeben","body_text1":"Wir haben gerade ein Einmalkennwort an ","body_text2":" gesendet. Das Einmalkennwort l\xE4uft bald ab, bitte geben Sie es bald ein.","button_verify":"Weiter","button_sendOtpAgain":"Einmalkennwort erneut senden","button_back":"Abbrechen"},"emailLinkSent":{"header":"Pr\xFCfen Sie Ihr E-Mail Postfach","body_text1":"Wir haben ihnen eine E-Mail an ","body_text2":"gesendet. Bitte \xF6ffnen sie diese und klicken sie auf den Link, um ihre Anmeldung abzuschlie\xDFen.","button_sendLinkAgainWaitingText":"Link erneut senden ({{remainingTime}} sec)","button_sendLinkAgain":"Link erneut senden","button_back":"Abbrechen"},"emailLinkVerification":{"header":"Verifizierung l\xE4uft...","button_back":"Abbrechen"},"passkeyError":{"header":"Mit Passkeys anmelden","body":{"emailOtp":"Einloggen mit Passkeys nicht m\xF6glich. Versuchen Sie es erneut oder melden Sie sich per E-Mail-Einmalkennwort an.","emailLink":"Einloggen mit Passkeys nicht m\xF6glich. Versuchen Sie es erneut oder melden Sie sich per E-Mail-Link an."},"button_switchToAlternate":{"emailOtp":"Einmalkennwort senden","emailLink":"Link senden"},"button_retry":"Erneut versuchen","button_back":"Zur\xFCck","button_cancel":"Abbrechen"},"passkeyAppend":{"header":"Schneller einloggen mit ","button_showPasskeyBenefits":"Passkeys","button_start":"Aktivieren","button_skip":"Vielleicht sp\xE4ter"},"passkeyBenefits":{"header":"Passkeys","body_introduction":"Mit Passkeys m\xFCssen Sie sich keine komplexen Passw\xF6rter mehr merken. Melden Sie sich sicher mit ","body_loginMethods":"Face ID, Touch ID oder Sperrcode an.","button_start":"Passkey erstellen","button_skip":"Vielleicht sp\xE4ter"}},"unexpectedError":{"header":"Hier ist etwas schief gelaufen","subheader":"Dieser Service ist aktuell leider nicht verf\xFCgbar","body_withCustomerSupport":"Bitte versuchen Sie es sp\xE4ter noch einmal. Sollte das Problem bestehen bleiben, wenden Sie sich bitte an {{customerSupportEmail}}.","body_noCustomerSupport":"Bitte versuchen Sie es sp\xE4ter noch einmal.","button":"Seite neu laden"}},"errors":{"invalidName":"Bitte geben Sie eine g\xFCltige E-Mail-Adresse ein","invalidFullname":"Bitte geben Sie einen Namen ein","passkeyChallengeCancelled":"Passkey Challenge abgebrochen","userAlreadyExists":"E-Mail-Adresse wird bereits verwendet","passkeyAlreadyExists":"F\xFCr dieses Ger\xE4t wurde bereits ein Passkey erstellt","unknownUser":"Benutzer existiert nicht","noPasskeyAvailable":"Kein Passkey verf\xFCgbar","invalidPasskey":"Der bereitgestellte Passkey ist nicht mehr g\xFCltig","invalidOtp":"Der eingegebene Code ist nicht g\xFCltig","invalidToken":"Der bereitgestellte Token ist nicht mehr g\xFCltig","noConditionalUiSupport":"Conditional UI wird auf diesem Ger\xE4t nicht unterst\xFCtzt","conditionalUiUnconfirmedCredential":"Dieser Passkey kann noch nicht verwendet werden. Bitte best\xE4tigen Sie Ihr Konto, indem Sie sich mit Ihrer E-Mail-Adresse anmelden.","unknownError":"Etwas ist schiefgelaufen. Bitte versuchen Sie es sp\xE4ter noch einmal"},"passkeysList":{"warning_notLoggedIn":"Bitte loggen Sie sich ein, um Ihre Passkeys zu sehen.","message_noPasskeys":"Sie haben noch keine Passkeys.","button_createPasskey":"Passkey erstellen","badge_synced":"Synchronisiert","field_credentialId":"Anmelde-ID: ","field_created":"Erstellt: {{date}} mit {{browser}} am {{os}}","field_lastUsed":"Zuletzt verwendet: ","field_status":"Status: ","dialog_delete":{"header":"Passkey l\xF6schen","body":"Sind Sie sicher, dass Sie diesen Passkey l\xF6schen m\xF6chten?","button_cancel":"Abbrechen","button_delete":"Ja, l\xF6schen"},"dialog_passkeyAlreadyExists":{"header":"Passkey bereits vorhanden","body":"F\xFCr dieses Ger\xE4t wurde bereits ein Passkey erstellt. Sie k\xF6nnen diesen Passkey l\xF6schen und einen neuen erstellen.","button_confirm":"Ok"}}}'), f5 = JSON.parse(`{"authentication":{"signup":{"start":{"header":"Create your account","subheader":"You already have an account? ","button_login":"Log in","button_submit":"Continue","textField_name":"Name","textField_email":"Email address"},"emailOtp":{"header":"Enter one-time passcode to create account","body_text1":"We just sent a one-time passcode to ","body_text2":". The one-time passcode expires shortly, so please enter it soon.","button_verify":"Continue","button_sendOtpAgain":"Send one-time passcode again","button_back":"Cancel"},"emailLinkSent":{"header":"Check your inbox to create your account","body_text1":"We just sent you a magic link to ","body_text2":". Click on the link in the email to finish setting up your account.","button_sendLinkAgainWaitingText":"Send email again ({{remainingTime}} sec)","button_sendLinkAgain":"Send email again","button_back":"Cancel"},"emailLinkVerification":{"header":"Verifying your email address","button_back":"Cancel"},"passkeyCreate":{"header":"Let's get you set up with ","headerButton_showPasskeyBenefits":"Passkeys","body":"We'll create an account for ","button_start":"Create your account","button_switchToAlternate":{"emailOtp":"Send email one-time passcode","emailLink":"Send email magic link"},"button_back":"Back"},"passkeyError":{"header":"Let's get you set up","body_errorMessage":"Creating your account was not possible with ","button_showPasskeyBenefits":"passkeys","body_tryAgainMessage":{"emailOtp":". Try again or sign up with email one-time passcode.","emailLink":". Try again or sign up with email magic link."},"button_switchToAlternate":{"emailOtp":"Send email one-time passcode","emailLink":"Send email magic link"},"button_retry":"Try again","button_back":"Back","button_cancel":"Cancel"},"passkeySuccess":{"header":"Welcome!","subheader":"Passkey created","body_text1":"You can now confirm your identity using your ","body_text2":{"emailOtp":"passkey or via email one-time passcode","emailLink":"passkey or via email magic link"},"body_text3":" when you log in.","button":"Continue"},"passkeyBenefits":{"header":"Passkeys","body_introduction":"With passkeys, you don't need to remember complex passwords anymore. Log in securely by using ","body_loginMethods":"Face ID, Touch ID or screen lock code.","button_start":"Create passkey","button_skip":"Maybe later"},"passkeyAppend":{"header":"Log in even faster with ","button_showPasskeyBenefits":"Passkeys","button_start":"Activate","button_skip":"Maybe later"}},"login":{"start":{"header":"Welcome back!","subheader":"Don't have an account yet? ","button_signup":"Create account","button_submit":"Continue","textField_email":"Email address"},"emailOtp":{"header":"Enter one-time passcode to log in","body_text1":"We just sent a one-time passcode to ","body_text2":". The one-time passcode expires shortly, so please enter it soon.","button_verify":"Continue","button_sendOtpAgain":"Send one-time passcode again","button_back":"Cancel"},"emailLinkSent":{"header":"Check your inbox to login","body_text1":"We just sent you a magic link to ","body_text2":". Click on the link in the email to login to your account.","button_sendLinkAgainWaitingText":"Send email again ({{remainingTime}} sec)","button_sendLinkAgain":"Send email again","button_back":"Cancel"},"emailLinkVerification":{"header":"Verifying your email address","button_back":"Cancel"},"passkeyError":{"header":"Log in with Passkeys","body":{"emailOtp":"Log in with passkeys not possible. Try again or log in with email one-time passcode.","emailLink":"Log in with passkeys not possible. Try again or log in with email magic link."},"button_switchToAlternate":{"emailOtp":"Send email one-time passcode","emailLink":"Send email magic link"},"button_retry":"Try again","button_back":"Back","button_cancel":"Cancel"},"passkeyAppend":{"header":"Log in even faster with ","button_showPasskeyBenefits":"Passkeys","button_start":"Activate","button_skip":"Maybe later"},"passkeyBenefits":{"header":"Passkeys","body_introduction":"With passkeys, you don't need to remember complex passwords anymore. Log in securely by using ","body_loginMethods":"Face ID, Touch ID or screen lock code.","button_start":"Create passkey","button_skip":"Maybe later"}},"unexpectedError":{"header":"Something went wrong","subheader":"We\u2019re sorry that our service is currently not available.","body_withCustomerSupport":"Please try again in a few moments and if the issue persists, please contact {{customerSupportEmail}}.","body_noCustomerSupport":"Please try again in a few moments.","button":"Refresh Page"}},"errors":{"invalidName":"Please enter a valid email","invalidFullname":"Please enter a valid name","passkeyChallengeCancelled":"Passkey challenge cancelled","userAlreadyExists":"Email address is already in use. If this account is yours, please log in instead.","passkeyAlreadyExists":"Passkey for this device already exists","unknownUser":"User does not exist","noPasskeyAvailable":"No passkey available","invalidPasskey":"The provided passkey is no longer valid. Log in using your email address instead.","invalidOtp":"The provided one-time passcode is not valid","invalidToken":"The provided token is not valid for user verification","noConditionalUiSupport":"Conditional UI is not supported by your device","conditionalUiUnconfirmedCredential":"This passkey can not be used yet. Please confirm your identify first by logging in with your email address.","unknownError":"Something went wrong. Please try again later"},"passkeysList":{"warning_notLoggedIn":"Please log in to see your passkeys.","message_noPasskeys":"You don't have any passkeys yet.","button_createPasskey":"Create a Passkey","badge_synced":"Synced","field_credentialId":"Credential ID: ","field_created":"Created: {{date}} with {{browser}} on {{os}}","field_lastUsed":"Last used: ","field_status":"Status: ","dialog_delete":{"header":"Delete Passkey","body":"Are you sure you want to delete this passkey?","button_cancel":"Cancel","button_confirm":"Yes, delete"},"dialog_passkeyAlreadyExists":{"header":"Passkey already exists","body":"A passkey for this device already exists. If you are facing issues with your passkey, please delete it and create a new one.","button_confirm":"Ok"}}}`), S5 = (n7, e6) => {
        const r9 = document.body.classList, i9 = "string" == typeof n7 ? n7 : e6 ? n7.dark : n7.light;
        r9.contains(i9) && r9.remove(i9), r9.add(i9);
      }, v5 = () => document.body.classList.contains("cb-dark"), B3 = () => {
        v5() || document.body.classList.add("cb-dark");
      }, O3 = () => {
        document.body.classList.remove("cb-dark");
      }, Y3 = (n7, e6) => {
        let r9;
        switch (n7) {
          case "on":
            B3(), e6 && S5(e6, true);
            break;
          case "off":
            O3(), e6 && S5(e6, false);
            break;
          case "auto":
            r9 = ((n8) => {
              const e7 = window.matchMedia("(prefers-color-scheme: dark)"), r10 = (e8) => {
                e8.matches ? B3() : O3(), n8 && S5(n8, e8.matches);
              };
              return e7.addEventListener("change", r10), e7.matches ? B3() : O3(), n8 && S5(n8, e7.matches), () => {
                e7.removeEventListener("change", r10);
              };
            })(e6);
        }
        return () => {
          e6 && ((n8) => {
            const e7 = document.body.classList, r10 = "string" == typeof n8 ? n8 : n8.dark;
            e7.contains(r10) && e7.remove(r10);
          })(e6), "auto" === n7 && r9 && r9();
        };
      };
      var Q3;
      !function(n7) {
        n7.EmeraldFunk = "cb-emerald-funk-theme";
      }(Q3 || (Q3 = {}));
      const P4 = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, Z4 = /^\d{10}$/, U4 = /^[a-zA-Z]+(([',. -][a-zA-Z ])?[a-zA-Z]*)*$/, W4 = /^[0-9]$/, G3 = /^[^0-9]$/;
      async function H3() {
        return window.PublicKeyCredential && window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
      }
      const R3 = { "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4": { name: "Google Password Manager", iconDark: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE5MiAxOTIiIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDE5MiAxOTIiIHdpZHRoPSIyNHB4Ij48cmVjdCBmaWxsPSJub25lIiBoZWlnaHQ9IjE5MiIgd2lkdGg9IjE5MiIgeT0iMCIvPjxnPjxwYXRoIGQ9Ik02OS4yOSwxMDZjLTMuNDYsNS45Ny05LjkxLDEwLTE3LjI5LDEwYy0xMS4wMywwLTIwLTguOTctMjAtMjBzOC45Ny0yMCwyMC0yMCBjNy4zOCwwLDEzLjgzLDQuMDMsMTcuMjksMTBoMjUuNTVDOTAuMyw2Ni41NCw3Mi44Miw1Miw1Miw1MkMyNy43NCw1Miw4LDcxLjc0LDgsOTZzMTkuNzQsNDQsNDQsNDRjMjAuODIsMCwzOC4zLTE0LjU0LDQyLjg0LTM0IEg2OS4yOXoiIGZpbGw9IiM0Mjg1RjQiLz48cmVjdCBmaWxsPSIjRkJCQzA0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iNDQiIHg9Ijk0IiB5PSI4NCIvPjxwYXRoIGQ9Ik05NC4zMiw4NEg2OHYwLjA1YzIuNSwzLjM0LDQsNy40Nyw0LDExLjk1cy0xLjUsOC42MS00LDExLjk1VjEwOGgyNi4zMiBjMS4wOC0zLjgyLDEuNjgtNy44NCwxLjY4LTEyUzk1LjQxLDg3LjgyLDk0LjMyLDg0eiIgZmlsbD0iI0VBNDMzNSIvPjxwYXRoIGQ9Ik0xODQsMTA2djI2aC0xNnYtOGMwLTQuNDItMy41OC04LTgtOHMtOCwzLjU4LTgsOHY4aC0xNnYtMjZIMTg0eiIgZmlsbD0iIzM0QTg1MyIvPjxyZWN0IGZpbGw9IiMxODgwMzgiIGhlaWdodD0iMjQiIHdpZHRoPSI0OCIgeD0iMTM2IiB5PSI4NCIvPjwvZz48L3N2Zz4=", icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE5MiAxOTIiIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDE5MiAxOTIiIHdpZHRoPSIyNHB4Ij48cmVjdCBmaWxsPSJub25lIiBoZWlnaHQ9IjE5MiIgd2lkdGg9IjE5MiIgeT0iMCIvPjxnPjxwYXRoIGQ9Ik02OS4yOSwxMDZjLTMuNDYsNS45Ny05LjkxLDEwLTE3LjI5LDEwYy0xMS4wMywwLTIwLTguOTctMjAtMjBzOC45Ny0yMCwyMC0yMCBjNy4zOCwwLDEzLjgzLDQuMDMsMTcuMjksMTBoMjUuNTVDOTAuMyw2Ni41NCw3Mi44Miw1Miw1Miw1MkMyNy43NCw1Miw4LDcxLjc0LDgsOTZzMTkuNzQsNDQsNDQsNDRjMjAuODIsMCwzOC4zLTE0LjU0LDQyLjg0LTM0IEg2OS4yOXoiIGZpbGw9IiM0Mjg1RjQiLz48cmVjdCBmaWxsPSIjRkJCQzA0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iNDQiIHg9Ijk0IiB5PSI4NCIvPjxwYXRoIGQ9Ik05NC4zMiw4NEg2OHYwLjA1YzIuNSwzLjM0LDQsNy40Nyw0LDExLjk1cy0xLjUsOC42MS00LDExLjk1VjEwOGgyNi4zMiBjMS4wOC0zLjgyLDEuNjgtNy44NCwxLjY4LTEyUzk1LjQxLDg3LjgyLDk0LjMyLDg0eiIgZmlsbD0iI0VBNDMzNSIvPjxwYXRoIGQ9Ik0xODQsMTA2djI2aC0xNnYtOGMwLTQuNDItMy41OC04LTgtOHMtOCwzLjU4LTgsOHY4aC0xNnYtMjZIMTg0eiIgZmlsbD0iIzM0QTg1MyIvPjxyZWN0IGZpbGw9IiMxODgwMzgiIGhlaWdodD0iMjQiIHdpZHRoPSI0OCIgeD0iMTM2IiB5PSI4NCIvPjwvZz48L3N2Zz4=" }, "adce0002-35bc-c60a-648b-0b25f1f05503": { name: "Chrome on Mac", iconDark: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNDggNDgiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMy4yMTczIiB5MT0iMTUiIHgyPSI0NC43ODEyIiB5Mj0iMTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZDkzMDI1Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2VhNDMzNSIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjIwLjcyMTkiIHkxPSI0Ny42NzkxIiB4Mj0iNDEuNTAzOSIgeTI9IjExLjY4MzciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmNjOTM0Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2ZiYmMwNCIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjI2LjU5ODEiIHkxPSI0Ni41MDE1IiB4Mj0iNS44MTYxIiB5Mj0iMTAuNTA2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzFlOGUzZSIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNGE4NTMiLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAKICAgIDxwYXRoIGlkPSJwIiBkPSJNMTMuNjA4NiAzMC4wMDMxIDMuMjE4IDEyLjAwNkEyMy45OTQgMjMuOTk0IDAgMCAwIDI0LjAwMjUgNDhsMTAuMzkwNi0xNy45OTcxLS4wMDY3LS4wMDY4YTExLjk4NTIgMTEuOTg1MiAwIDAgMS0yMC43Nzc4LjAwN1oiLz4KICA8L2RlZnM+CiAgCiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNhKSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDI0IDI0KSIvPgogIDx1c2UgeGxpbms6aHJlZj0iI3AiIGZpbGw9InVybCgjYikiIHRyYW5zZm9ybT0icm90YXRlKC0xMjAgMjQgMjQpIi8+CiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNjKSIvPgogIAogIDxjaXJjbGUgY3g9IjI0IiBjeT0iMjQiIHI9IjEyIiBzdHlsZT0iZmlsbDojZmZmIi8+CiAgPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iOS41IiBzdHlsZT0iZmlsbDojMWE3M2U4Ii8+Cjwvc3ZnPg==", icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNDggNDgiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMy4yMTczIiB5MT0iMTUiIHgyPSI0NC43ODEyIiB5Mj0iMTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZDkzMDI1Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2VhNDMzNSIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjIwLjcyMTkiIHkxPSI0Ny42NzkxIiB4Mj0iNDEuNTAzOSIgeTI9IjExLjY4MzciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmNjOTM0Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2ZiYmMwNCIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjI2LjU5ODEiIHkxPSI0Ni41MDE1IiB4Mj0iNS44MTYxIiB5Mj0iMTAuNTA2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzFlOGUzZSIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNGE4NTMiLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAKICAgIDxwYXRoIGlkPSJwIiBkPSJNMTMuNjA4NiAzMC4wMDMxIDMuMjE4IDEyLjAwNkEyMy45OTQgMjMuOTk0IDAgMCAwIDI0LjAwMjUgNDhsMTAuMzkwNi0xNy45OTcxLS4wMDY3LS4wMDY4YTExLjk4NTIgMTEuOTg1MiAwIDAgMS0yMC43Nzc4LjAwN1oiLz4KICA8L2RlZnM+CiAgCiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNhKSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDI0IDI0KSIvPgogIDx1c2UgeGxpbms6aHJlZj0iI3AiIGZpbGw9InVybCgjYikiIHRyYW5zZm9ybT0icm90YXRlKC0xMjAgMjQgMjQpIi8+CiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNjKSIvPgogIAogIDxjaXJjbGUgY3g9IjI0IiBjeT0iMjQiIHI9IjEyIiBzdHlsZT0iZmlsbDojZmZmIi8+CiAgPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iOS41IiBzdHlsZT0iZmlsbDojMWE3M2U4Ii8+Cjwvc3ZnPg==" }, "08987058-cadc-4b81-b6e1-30de50dcbe96": { name: "Windows Hello", iconDark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==", icon: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==" }, "9ddd1817-af5a-4672-a2b9-3e3dd95000a9": { name: "Windows Hello", iconDark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==", icon: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==" }, "6028b017-b1d4-4c02-b4b3-afcdafc96bb2": { name: "Windows Hello", iconDark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==", icon: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==" }, "dd4ec289-e01d-41c9-bb89-70fa845d4bf2": { name: "Apple iCloud Keychain (Managed)" }, "531126d6-e717-415c-9320-3d9aa6981239": { name: "Dashlane", iconDark: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIGZpbGw9IiNGRkZGRkYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01NS45MzE1IDIwLjk0MDVDNTUuOTMxNSAyMC41NTYxIDU1LjU0NzEgMjAuMTcxNyA1NS4wMDc5IDIwLjAxNzlMNDguNTQ0NiAxNy42MzU4QzQ3LjQ2ODMgMTcuMTc0NSA0Ni4yMzcyIDE3LjcxMjcgNDYuMjM3MiAxOC40ODI1VjQ1LjU2MjRDNDYuMjM3MiA0NS45NDY4IDQ2LjYyMTUgNDYuNDA4MSA0Ny4wMDU5IDQ2LjU2MThMNTMuNjIzIDQ4Ljk0NEM1NC42MjM1IDQ5LjMyODQgNTUuOTMxNSA0OC43OTAyIDU1LjkzMTUgNDcuOTQzNVYyMC45NDA1Wk00My44NTE3IDExLjQ3NzlDNDMuODUxNyAxMS4wOTI0IDQzLjQ2NzMgMTAuNzA4IDQyLjkyODEgMTAuNTU0MkwzNi40NjU5IDguMTcyMDZDMzUuMzg4NSA3LjcxMDc4IDM0LjE1NzQgOC4yNDg5NCAzNC4xNTc0IDkuMDE4ODFWMjUuNDgwN0MzNC4xNTc0IDI1Ljg2NTEgMzQuNTQxOCAyNi4zMjY0IDM0LjkyNjIgMjYuNDgxMkw0MS41NDMyIDI4Ljg2MzRDNDIuNTQzNyAyOS4yNDg5IDQzLjg1MTcgMjguNzA5NiA0My44NTE3IDI3Ljg2NFYxMS40Nzc5Wk00My44NTE3IDQxLjA5OTFDNDMuODUxNyA0MC43MTQ3IDQzLjQ2NzMgNDAuMzMwMyA0Mi45MjgxIDQwLjE3NjVMMzYuNDY1OSAzNy43OTQ0QzM1LjM4ODUgMzcuMzMzMSAzNC4xNTc0IDM3Ljg3MTIgMzQuMTU3NCAzOC42NDExVjU1LjEwM0MzNC4xNTc0IDU1LjQ4NzQgMzQuNTQxOCA1NS45NDg3IDM0LjkyNjIgNTYuMTAyNEw0MS41NDMyIDU4LjQ4NDZDNDIuNTQzNyA1OC44NzAxIDQzLjg1MTcgNTguMzMwOCA0My44NTE3IDU3LjQ4NDFWNDEuMDk5MVpNMzEuNzcyIDQ0LjQwODFDMzEuNzcyIDQ0LjAyMzcgMzEuMzg3NiA0My42MzgzIDMwLjg0ODMgNDMuNDg0NUwyNC4zODYyIDQxLjEwMjNDMjMuMzAzMyA0MC42NDEgMjIuMDc3NiA0MS4xNzkyIDIyLjA3NzYgNDEuOTQ5MVY1OS40OTA1QzIyLjA3NzYgNTkuODc0OSAyMi40NjIgNjAuMzM3MyAyMi44NDY0IDYwLjQ5MUwyOS40NjM0IDYyLjg3MzJDMzAuNDYzOSA2My4yNTg3IDMxLjc3MiA2Mi43MTk0IDMxLjc3MiA2MS44NzM4VjQ0LjQwODFaTTMxLjc3MiA0LjQ3NTM2QzMxLjc3MiA0LjA5MDk3IDMxLjM4NzYgMy43MDY1NyAzMC44NDgzIDMuNTUyODFMMjQuMzg2MiAxLjE3MDY0QzIzLjMwMzMgMC43MDkzNjkgMjIuMDc3NiAxLjI0NzUyIDIyLjA3NzYgMi4wMTc0VjE5LjU1ODhDMjIuMDc3NiAxOS45NDQzIDIyLjQ2MiAyMC40MDU2IDIyLjg0NjQgMjAuNTU5M0wyOS40NjM0IDIyLjk0MTVDMzAuNDYzOSAyMy4zMjU5IDMxLjc3MiAyMi43ODc4IDMxLjc3MiAyMS45NDFWNC40NzUzNlpNMTkuNjk0NCA1LjE2ODM2QzE5LjY5NDQgNC43ODM5NiAxOS4zMSA0LjM5ODQ4IDE4Ljc3MDcgNC4yNDQ3M0wxMi4zMDg1IDEuODYyNTZDMTEuMjMxMiAxLjQwMTI4IDEwIDEuOTM5NDQgMTAgMi43MDkzMVY1OC44NzMzQzEwIDU5LjI1NzcgMTAuMzg0NCA1OS43MTkgMTAuNzY5OSA1OS44NzI3TDE3LjM4NTggNjIuMjU0OUMxOC4zODYzIDYyLjYzOTMgMTkuNjk0NCA2Mi4xMDEyIDE5LjY5NDQgNjEuMjU0NFY1LjE2ODM2WiIgLz4KPC9zdmc+Cg==", icon: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIGZpbGw9IiMwRTM1M0QiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01NS45MzE1IDIwLjk0MDVDNTUuOTMxNSAyMC41NTYxIDU1LjU0NzEgMjAuMTcxNyA1NS4wMDc5IDIwLjAxNzlMNDguNTQ0NiAxNy42MzU4QzQ3LjQ2ODMgMTcuMTc0NSA0Ni4yMzcyIDE3LjcxMjcgNDYuMjM3MiAxOC40ODI1VjQ1LjU2MjRDNDYuMjM3MiA0NS45NDY4IDQ2LjYyMTUgNDYuNDA4MSA0Ny4wMDU5IDQ2LjU2MThMNTMuNjIzIDQ4Ljk0NEM1NC42MjM1IDQ5LjMyODQgNTUuOTMxNSA0OC43OTAyIDU1LjkzMTUgNDcuOTQzNVYyMC45NDA1Wk00My44NTE3IDExLjQ3NzlDNDMuODUxNyAxMS4wOTI0IDQzLjQ2NzMgMTAuNzA4IDQyLjkyODEgMTAuNTU0MkwzNi40NjU5IDguMTcyMDZDMzUuMzg4NSA3LjcxMDc4IDM0LjE1NzQgOC4yNDg5NCAzNC4xNTc0IDkuMDE4ODFWMjUuNDgwN0MzNC4xNTc0IDI1Ljg2NTEgMzQuNTQxOCAyNi4zMjY0IDM0LjkyNjIgMjYuNDgxMkw0MS41NDMyIDI4Ljg2MzRDNDIuNTQzNyAyOS4yNDg5IDQzLjg1MTcgMjguNzA5NiA0My44NTE3IDI3Ljg2NFYxMS40Nzc5Wk00My44NTE3IDQxLjA5OTFDNDMuODUxNyA0MC43MTQ3IDQzLjQ2NzMgNDAuMzMwMyA0Mi45MjgxIDQwLjE3NjVMMzYuNDY1OSAzNy43OTQ0QzM1LjM4ODUgMzcuMzMzMSAzNC4xNTc0IDM3Ljg3MTIgMzQuMTU3NCAzOC42NDExVjU1LjEwM0MzNC4xNTc0IDU1LjQ4NzQgMzQuNTQxOCA1NS45NDg3IDM0LjkyNjIgNTYuMTAyNEw0MS41NDMyIDU4LjQ4NDZDNDIuNTQzNyA1OC44NzAxIDQzLjg1MTcgNTguMzMwOCA0My44NTE3IDU3LjQ4NDFWNDEuMDk5MVpNMzEuNzcyIDQ0LjQwODFDMzEuNzcyIDQ0LjAyMzcgMzEuMzg3NiA0My42MzgzIDMwLjg0ODMgNDMuNDg0NUwyNC4zODYyIDQxLjEwMjNDMjMuMzAzMyA0MC42NDEgMjIuMDc3NiA0MS4xNzkyIDIyLjA3NzYgNDEuOTQ5MVY1OS40OTA1QzIyLjA3NzYgNTkuODc0OSAyMi40NjIgNjAuMzM3MyAyMi44NDY0IDYwLjQ5MUwyOS40NjM0IDYyLjg3MzJDMzAuNDYzOSA2My4yNTg3IDMxLjc3MiA2Mi43MTk0IDMxLjc3MiA2MS44NzM4VjQ0LjQwODFaTTMxLjc3MiA0LjQ3NTM2QzMxLjc3MiA0LjA5MDk3IDMxLjM4NzYgMy43MDY1NyAzMC44NDgzIDMuNTUyODFMMjQuMzg2MiAxLjE3MDY0QzIzLjMwMzMgMC43MDkzNjkgMjIuMDc3NiAxLjI0NzUyIDIyLjA3NzYgMi4wMTc0VjE5LjU1ODhDMjIuMDc3NiAxOS45NDQzIDIyLjQ2MiAyMC40MDU2IDIyLjg0NjQgMjAuNTU5M0wyOS40NjM0IDIyLjk0MTVDMzAuNDYzOSAyMy4zMjU5IDMxLjc3MiAyMi43ODc4IDMxLjc3MiAyMS45NDFWNC40NzUzNlpNMTkuNjk0NCA1LjE2ODM2QzE5LjY5NDQgNC43ODM5NiAxOS4zMSA0LjM5ODQ4IDE4Ljc3MDcgNC4yNDQ3M0wxMi4zMDg1IDEuODYyNTZDMTEuMjMxMiAxLjQwMTI4IDEwIDEuOTM5NDQgMTAgMi43MDkzMVY1OC44NzMzQzEwIDU5LjI1NzcgMTAuMzg0NCA1OS43MTkgMTAuNzY5OSA1OS44NzI3TDE3LjM4NTggNjIuMjU0OUMxOC4zODYzIDYyLjYzOTMgMTkuNjk0NCA2Mi4xMDEyIDE5LjY5NDQgNjEuMjU0NFY1LjE2ODM2WiIgLz4KPC9zdmc+Cg==" }, "bada5566-a7aa-401f-bd96-45619a55120d": { name: "1Password", iconDark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQwIiBoZWlnaHQ9IjI0MCIgdmlld0JveD0iMCAwIDI0MCAyNDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjM5LjI1NyAxMjAuNDE3QzIzOS4yNTcgNTQuNDE5MyAxODUuNzU1IDAuOTE2NTA0IDExOS43NTcgMC45MTY1MDRDNTMuNzYwMSAwLjkxNjUwNCAwLjI1NzMyNCA1NC40MTkzIDAuMjU3MzI0IDEyMC40MTdDMC4yNTczMjQgMTg2LjQxNyA1My43NjAxIDIzOS45MTcgMTE5Ljc1NyAyMzkuOTE3QzE4NS43NTUgMjM5LjkxNyAyMzkuMjU3IDE4Ni40MTcgMjM5LjI1NyAxMjAuNDE3Wk05OC4wMDY5IDU0LjAyNzZDOTcuMDY3NCA1NS44NzE0IDk3LjA2NzQgNTguMjg1MSA5Ny4wNjc0IDYzLjExMjZWOTAuNDcyOUM5Ny4wNjc0IDkxLjY3ODggOTcuMDY3NCA5Mi4yODE3IDk3LjIxOTYgOTIuODM5MkM5Ny4zNTQ1IDkzLjMzMzEgOTcuNTc2MyA5My43OTkgOTcuODc0NiA5NC4yMTVDOTguMjExMyA5NC42ODQ3IDk4LjY3OTIgOTUuMDY0OCA5OS42MTUyIDk1LjgyNTFMMTA2LjUzNiAxMDEuNDQ3QzEwNy42NjQgMTAyLjM2NCAxMDguMjI4IDEwMi44MjIgMTA4LjQzMyAxMDMuMzc0QzEwOC42MTMgMTAzLjg1NyAxMDguNjEzIDEwNC4zOSAxMDguNDMzIDEwNC44NzNDMTA4LjIyOCAxMDUuNDI1IDEwNy42NjQgMTA1Ljg4MyAxMDYuNTM2IDEwNi44TDk5LjYxNTIgMTEyLjQyMkM5OC42NzkzIDExMy4xODIgOTguMjExMyAxMTMuNTYyIDk3Ljg3NDYgMTE0LjAzMkM5Ny41NzYzIDExNC40NDggOTcuMzU0NSAxMTQuOTE0IDk3LjIxOTYgMTE1LjQwOEM5Ny4wNjc0IDExNS45NjUgOTcuMDY3NCAxMTYuNTY4IDk3LjA2NzQgMTE3Ljc3NFYxNzcuNzE5Qzk3LjA2NzQgMTgyLjU0NyA5Ny4wNjc0IDE4NC45NjEgOTguMDA2OSAxODYuODA1Qzk4LjgzMzMgMTg4LjQyNiAxMDAuMTUyIDE4OS43NDUgMTAxLjc3NCAxOTAuNTcxQzEwMy42MTggMTkxLjUxMSAxMDYuMDMxIDE5MS41MTEgMTEwLjg1OSAxOTEuNTExSDEyOC42NTZDMTMzLjQ4MyAxOTEuNTExIDEzNS44OTcgMTkxLjUxMSAxMzcuNzQxIDE5MC41NzFDMTM5LjM2MyAxODkuNzQ1IDE0MC42ODEgMTg4LjQyNiAxNDEuNTA4IDE4Ni44MDVDMTQyLjQ0NyAxODQuOTYxIDE0Mi40NDcgMTgyLjU0NyAxNDIuNDQ3IDE3Ny43MTlWMTUwLjM1OUMxNDIuNDQ3IDE0OS4xNTMgMTQyLjQ0NyAxNDguNTUgMTQyLjI5NSAxNDcuOTkzQzE0Mi4xNiAxNDcuNDk5IDE0MS45MzggMTQ3LjAzMyAxNDEuNjQgMTQ2LjYxN0MxNDEuMzAzIDE0Ni4xNDcgMTQwLjgzNSAxNDUuNzY3IDEzOS44OTkgMTQ1LjAwN0wxMzIuOTc4IDEzOS4zODVDMTMxLjg1IDEzOC40NjggMTMxLjI4NiAxMzguMDEgMTMxLjA4MiAxMzcuNDU5QzEzMC45MDIgMTM2Ljk3NSAxMzAuOTAyIDEzNi40NDMgMTMxLjA4MiAxMzUuOTU5QzEzMS4yODYgMTM1LjQwNyAxMzEuODUgMTM0Ljk0OSAxMzIuOTc4IDEzNC4wMzNMMTM5Ljg5OSAxMjguNDFDMTQwLjgzNSAxMjcuNjUgMTQxLjMwMyAxMjcuMjcgMTQxLjY0IDEyNi44QzE0MS45MzggMTI2LjM4NCAxNDIuMTYgMTI1LjkxOCAxNDIuMjk1IDEyNS40MjRDMTQyLjQ0NyAxMjQuODY3IDE0Mi40NDcgMTI0LjI2NCAxNDIuNDQ3IDEyMy4wNThWNjMuMTEyNkMxNDIuNDQ3IDU4LjI4NTEgMTQyLjQ0NyA1NS44NzE0IDE0MS41MDggNTQuMDI3NkMxNDAuNjgxIDUyLjQwNTcgMTM5LjM2MyA1MS4wODcgMTM3Ljc0MSA1MC4yNjA2QzEzNS44OTcgNDkuMzIxMSAxMzMuNDgzIDQ5LjMyMTEgMTI4LjY1NiA0OS4zMjExSDExMC44NTlDMTA2LjAzMSA0OS4zMjExIDEwMy42MTggNDkuMzIxMSAxMDEuNzc0IDUwLjI2MDZDMTAwLjE1MiA1MS4wODcgOTguODMzMyA1Mi40MDU3IDk4LjAwNjkgNTQuMDI3NloiIGZpbGw9IiNGRkZFRkIiLz4KPC9zdmc+Cg==", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQwIiBoZWlnaHQ9IjI0MCIgdmlld0JveD0iMCAwIDI0MCAyNDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjM5LjExNiAxMjAuNDE3QzIzOS4xMTYgNTQuNDE5MyAxODUuNjEzIDAuOTE2NTA0IDExOS42MTYgMC45MTY1MDRDNTMuNjE5IDAuOTE2NTA0IDAuMTE2MjExIDU0LjQxOTMgMC4xMTYyMTEgMTIwLjQxN0MwLjExNjIxMSAxODYuNDE3IDUzLjYxOSAyMzkuOTE3IDExOS42MTYgMjM5LjkxN0MxODUuNjEzIDIzOS45MTcgMjM5LjExNiAxODYuNDE3IDIzOS4xMTYgMTIwLjQxN1pNOTcuODY1OCA1NC4wMjc2Qzk2LjkyNjMgNTUuODcxNCA5Ni45MjYzIDU4LjI4NTEgOTYuOTI2MyA2My4xMTI2VjkwLjQ3MjlDOTYuOTI2MyA5MS42Nzg4IDk2LjkyNjMgOTIuMjgxNyA5Ny4wNzg1IDkyLjgzOTJDOTcuMjEzNCA5My4zMzMxIDk3LjQzNTIgOTMuNzk5IDk3LjczMzUgOTQuMjE1Qzk4LjA3MDIgOTQuNjg0NyA5OC41MzgxIDk1LjA2NDggOTkuNDc0MSA5NS44MjUxTDEwNi4zOTUgMTAxLjQ0N0MxMDcuNTIzIDEwMi4zNjQgMTA4LjA4NyAxMDIuODIyIDEwOC4yOTIgMTAzLjM3NEMxMDguNDcxIDEwMy44NTcgMTA4LjQ3MSAxMDQuMzkgMTA4LjI5MiAxMDQuODczQzEwOC4wODcgMTA1LjQyNSAxMDcuNTIzIDEwNS44ODMgMTA2LjM5NSAxMDYuOEw5OS40NzQxIDExMi40MjJDOTguNTM4MiAxMTMuMTgyIDk4LjA3MDIgMTEzLjU2MiA5Ny43MzM1IDExNC4wMzJDOTcuNDM1MiAxMTQuNDQ4IDk3LjIxMzQgMTE0LjkxNCA5Ny4wNzg1IDExNS40MDhDOTYuOTI2MyAxMTUuOTY1IDk2LjkyNjMgMTE2LjU2OCA5Ni45MjYzIDExNy43NzRWMTc3LjcxOUM5Ni45MjYzIDE4Mi41NDcgOTYuOTI2MyAxODQuOTYxIDk3Ljg2NTggMTg2LjgwNUM5OC42OTIyIDE4OC40MjYgMTAwLjAxMSAxODkuNzQ1IDEwMS42MzMgMTkwLjU3MUMxMDMuNDc3IDE5MS41MTEgMTA1Ljg5IDE5MS41MTEgMTEwLjcxOCAxOTEuNTExSDEyOC41MTVDMTMzLjM0MiAxOTEuNTExIDEzNS43NTYgMTkxLjUxMSAxMzcuNiAxOTAuNTcxQzEzOS4yMjEgMTg5Ljc0NSAxNDAuNTQgMTg4LjQyNiAxNDEuMzY3IDE4Ni44MDVDMTQyLjMwNiAxODQuOTYxIDE0Mi4zMDYgMTgyLjU0NyAxNDIuMzA2IDE3Ny43MTlWMTUwLjM1OUMxNDIuMzA2IDE0OS4xNTMgMTQyLjMwNiAxNDguNTUgMTQyLjE1NCAxNDcuOTkzQzE0Mi4wMTkgMTQ3LjQ5OSAxNDEuNzk3IDE0Ny4wMzMgMTQxLjQ5OSAxNDYuNjE3QzE0MS4xNjIgMTQ2LjE0NyAxNDAuNjk0IDE0NS43NjcgMTM5Ljc1OCAxNDUuMDA3TDEzMi44MzcgMTM5LjM4NUMxMzEuNzA5IDEzOC40NjggMTMxLjE0NSAxMzguMDEgMTMwLjk0IDEzNy40NTlDMTMwLjc2MSAxMzYuOTc1IDEzMC43NjEgMTM2LjQ0MyAxMzAuOTQgMTM1Ljk1OUMxMzEuMTQ1IDEzNS40MDcgMTMxLjcwOSAxMzQuOTQ5IDEzMi44MzcgMTM0LjAzM0wxMzkuNzU4IDEyOC40MUMxNDAuNjk0IDEyNy42NSAxNDEuMTYyIDEyNy4yNyAxNDEuNDk5IDEyNi44QzE0MS43OTcgMTI2LjM4NCAxNDIuMDE5IDEyNS45MTggMTQyLjE1NCAxMjUuNDI0QzE0Mi4zMDYgMTI0Ljg2NyAxNDIuMzA2IDEyNC4yNjQgMTQyLjMwNiAxMjMuMDU4VjYzLjExMjZDMTQyLjMwNiA1OC4yODUxIDE0Mi4zMDYgNTUuODcxNCAxNDEuMzY3IDU0LjAyNzZDMTQwLjU0IDUyLjQwNTcgMTM5LjIyMSA1MS4wODcgMTM3LjYgNTAuMjYwNkMxMzUuNzU2IDQ5LjMyMTEgMTMzLjM0MiA0OS4zMjExIDEyOC41MTUgNDkuMzIxMUgxMTAuNzE4QzEwNS44OSA0OS4zMjExIDEwMy40NzcgNDkuMzIxMSAxMDEuNjMzIDUwLjI2MDZDMTAwLjAxMSA1MS4wODcgOTguNjkyMiA1Mi40MDU3IDk3Ljg2NTggNTQuMDI3NloiIGZpbGw9IiMxQTI4NUYiLz4KPC9zdmc+Cg==" }, "b84e4048-15dc-4dd0-8640-f4f60813c8af": { name: "NordPass", iconDark: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODAgODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03LjYxMzQgNzBDMi44MjQzNSA2My4zNTIgMCA1NS4xNzIyIDAgNDYuMzI3M0MwIDI0LjA1NTIgMTcuOTA4NiA2IDQwIDZDNjIuMDkxNCA2IDgwIDI0LjA1NTIgODAgNDYuMzI3M0M4MCA1NS4xNzIxIDc3LjE3NTcgNjMuMzUxOCA3Mi4zODY3IDY5Ljk5OTlMNTMuMTc0NyAzOC41NDY2TDUxLjMxOTUgNDEuNzA0Nkw1My4yMDE4IDUwLjQ4NzdMNDAgMjcuNzE0N0wzMS44MzM0IDQxLjYxNjFMMzMuNzM0NiA1MC40ODc3TDI2LjgxNDcgMzguNTY0Nkw3LjYxMzQgNzBaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K", icon: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODAgODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03LjYxMzQgNzBDMi44MjQzNSA2My4zNTIgMCA1NS4xNzIyIDAgNDYuMzI3M0MwIDI0LjA1NTIgMTcuOTA4NiA2IDQwIDZDNjIuMDkxNCA2IDgwIDI0LjA1NTIgODAgNDYuMzI3M0M4MCA1NS4xNzIxIDc3LjE3NTcgNjMuMzUxOCA3Mi4zODY3IDY5Ljk5OTlMNTMuMTc0NyAzOC41NDY2TDUxLjMxOTUgNDEuNzA0Nkw1My4yMDE4IDUwLjQ4NzdMNDAgMjcuNzE0N0wzMS44MzM0IDQxLjYxNjFMMzMuNzM0NiA1MC40ODc3TDI2LjgxNDcgMzguNTY0Nkw3LjYxMzQgNzBaIiBmaWxsPSIjMENBQUFCIi8+Cjwvc3ZnPgo=" }, "0ea242b4-43c4-4a1b-8b17-dd6d0b6baec6": { name: "Keeper", iconDark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzYwMzRfMzM2MjcpIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTIiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMiAxMkMyMiAxNy41MjI4IDE3LjUyMjggMjIgMTIgMjJDNi40NzcxNSAyMiAyIDE3LjUyMjggMiAxMkMyIDYuNDc3MTUgNi40NzcxNSAyIDEyIDJDMTcuNTIyOCAyIDIyIDYuNDc3MTUgMjIgMTJaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNMTAuMTIxOCAzLjI3MzI1SDExLjY2NjZWOS41MTUyN0gxNC44NTc1TDE4LjY5NiA2LjQ2MzE3TDE5LjY2MDcgNy42NjgyMUwxNS4zOTg5IDExLjA1NjRIMTAuMTIxOFYzLjI3MzI1WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTMuMTQzOCAzLjQ4MzY2TDE0LjY4ODcgMy44NzY5NFY2LjAzNDkyTDE2LjQxNzMgNC42MTgxMUwxNy43MDA4IDUuNTYwOTdMMTQuNDA3IDguMjYwMTNMMTMuMTQzOCA4LjI1MzQxVjMuNDgzNjZaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik00LjAzODcgMTUuMDg0OUw1LjU4MzU0IDE2LjM5NThWNy44MTQyN0w0LjAzODcgOS4yMjc3MlYxNS4wODQ5WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNOC42MTI1NyAxOC4yNDExTDcuMDY2MDQgMTkuNTgwNlY0LjQ5NDg1TDguNjEyNTcgNS44MzQzNFYxOC4yNDExWiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTQuNjg4NyAxOC4xMTc0TDE2LjQxNzMgMTkuNTM0MkwxNy43MDA4IDE4LjU4OTdMMTQuNDA3IDE1Ljg5MjJMMTMuMTQzOCAxNS44OTg5VjIwLjY2ODdMMTQuNjg4NyAyMC4yNzU0VjE4LjExNzRaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik0xOC42OTYgMTcuNDc4NkwxNC44NTc1IDE0LjQyNDhIMTEuNjY2NlYyMC42NjY4SDEwLjEyMThWMTIuODg1M0gxNS4zOTg5TDE5LjY2MDcgMTYuMjczNUwxOC42OTYgMTcuNDc4NloiIGZpbGw9IiNGRkM3MDAiLz4KPHBhdGggZD0iTTE2LjczNzYgMTEuOTcwNkwxOS44OTgxIDE0LjU3MDZMMjAuODgzIDEzLjM4MjNMMTkuMTY2MSAxMS45NzA2TDIwLjg4MyAxMC41NTg4TDE5Ljg5ODEgOS4zNzA1NkwxNi43Mzc2IDExLjk3MDZaIiBmaWxsPSIjRkZDNzAwIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfNjAzNF8zMzYyNyI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzYwMzRfMzM2MjcpIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTIiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMiAxMkMyMiAxNy41MjI4IDE3LjUyMjggMjIgMTIgMjJDNi40NzcxNSAyMiAyIDE3LjUyMjggMiAxMkMyIDYuNDc3MTUgNi40NzcxNSAyIDEyIDJDMTcuNTIyOCAyIDIyIDYuNDc3MTUgMjIgMTJaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNMTAuMTIxOCAzLjI3MzI1SDExLjY2NjZWOS41MTUyN0gxNC44NTc1TDE4LjY5NiA2LjQ2MzE3TDE5LjY2MDcgNy42NjgyMUwxNS4zOTg5IDExLjA1NjRIMTAuMTIxOFYzLjI3MzI1WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTMuMTQzOCAzLjQ4MzY2TDE0LjY4ODcgMy44NzY5NFY2LjAzNDkyTDE2LjQxNzMgNC42MTgxMUwxNy43MDA4IDUuNTYwOTdMMTQuNDA3IDguMjYwMTNMMTMuMTQzOCA4LjI1MzQxVjMuNDgzNjZaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik00LjAzODcgMTUuMDg0OUw1LjU4MzU0IDE2LjM5NThWNy44MTQyN0w0LjAzODcgOS4yMjc3MlYxNS4wODQ5WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNOC42MTI1NyAxOC4yNDExTDcuMDY2MDQgMTkuNTgwNlY0LjQ5NDg1TDguNjEyNTcgNS44MzQzNFYxOC4yNDExWiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTQuNjg4NyAxOC4xMTc0TDE2LjQxNzMgMTkuNTM0MkwxNy43MDA4IDE4LjU4OTdMMTQuNDA3IDE1Ljg5MjJMMTMuMTQzOCAxNS44OTg5VjIwLjY2ODdMMTQuNjg4NyAyMC4yNzU0VjE4LjExNzRaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik0xOC42OTYgMTcuNDc4NkwxNC44NTc1IDE0LjQyNDhIMTEuNjY2NlYyMC42NjY4SDEwLjEyMThWMTIuODg1M0gxNS4zOTg5TDE5LjY2MDcgMTYuMjczNUwxOC42OTYgMTcuNDc4NloiIGZpbGw9IiNGRkM3MDAiLz4KPHBhdGggZD0iTTE2LjczNzYgMTEuOTcwNkwxOS44OTgxIDE0LjU3MDZMMjAuODgzIDEzLjM4MjNMMTkuMTY2MSAxMS45NzA2TDIwLjg4MyAxMC41NTg4TDE5Ljg5ODEgOS4zNzA1NkwxNi43Mzc2IDExLjk3MDZaIiBmaWxsPSIjRkZDNzAwIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfNjAzNF8zMzYyNyI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K" }, "f3809540-7f14-49c1-a8b3-8f813b225541": { name: "Enpass", iconDark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNTYuNDgzIDI4LjA1NTRDMzEzLjg5OSAyOC4wNTU0IDM3MS4zMTUgMjcuODg1NiA0MjguNzQ1IDI4LjE0MDVDNDQwLjY4IDI3LjkwNzYgNDUyLjUyMSAzMC4yODg5IDQ2My40NDEgMzUuMTE3OUM0NzQuMzYyIDM5Ljk0NjkgNDg0LjA5OSA0Ny4xMDczIDQ5MS45NzEgNTYuMDk4NEM1MDQuMDYyIDY5LjY5NjIgNTExLjEzMiA4Ny4wMzg3IDUxMiAxMDUuMjNDNTEyLjAyOCAxMjEuOTMzIDUxMC4wMzUgMTM4LjU3OCA1MDYuMDYzIDE1NC44MDFDNDk4LjQ0NCAxOTguNzA2IDQ5MC41MTUgMjQyLjUyNyA0ODIuNzI2IDI4Ni4zNzZDNDc2LjAxMiAzMjQuMTM0IDQ2OS41ODEgMzYxLjk1IDQ2Mi41MTMgMzk5LjY4QzQ1Ny42NzIgNDIwLjk2OSA0NDYuNTQ1IDQ0MC4zMDMgNDMwLjU4IDQ1NS4xNjVDNDE0LjYxNiA0NzAuMDI3IDM5NC41NTUgNDc5LjcyNyAzNzMuMDExIDQ4My4wMDJDMzY3Ljc1MiA0ODMuNjI5IDM2Mi40NjIgNDgzLjk0NiAzNTcuMTY2IDQ4My45NUMyOTAuMDUzIDQ4NC4wMTcgMjIyLjk0IDQ4NC4wMTcgMTU1LjgyOCA0ODMuOTVDMTMwLjQ2NiA0ODMuOSAxMDUuOTMgNDc0LjkxNSA4Ni41MTMyIDQ1OC41NjZDNjcuMDk2NSA0NDIuMjE4IDU0LjAzNjIgNDE5LjU0OCA0OS42MTggMzk0LjUyNUMzNi4xODA0IDMxOS4xNzcgMjIuNjI5NyAyNDMuODUzIDguOTY1OTcgMTY4LjU1M0M2LjI4MDM0IDE1My42MzkgMy4zMTIgMTM4LjgxMSAxLjIwNTkgMTIzLjc4NEMtMi40NjEwNSAxMDIuNzI5IDIuMzEwOTMgODEuMDc0NCAxNC40ODUyIDYzLjUyNDRDMjYuNjU5NiA0NS45NzQ1IDQ1LjI1MjkgMzMuOTQ2MiA2Ni4yMjY2IDMwLjA1MjVDNzMuMDU1NyAyOC43NDUxIDc5Ljk5NTkgMjguMTA5NCA4Ni45NDg0IDI4LjE1NDZDMTQzLjQ2IDI3Ljk5NDEgMTk5Ljk3MSAyNy45NjEgMjU2LjQ4MyAyOC4wNTU0Wk0yMTAuOTI2IDMzOS42NDNDMjEwLjkyNiAzNTQuNjcgMjEwLjkyNiAzNjkuNjk3IDIxMC45MjYgMzg0LjczOEMyMTAuNzczIDM4OC4yMDUgMjExLjM0MyAzOTEuNjY1IDIxMi41OTcgMzk0Ljg5OUMyMTMuODUyIDM5OC4xMzQgMjE1Ljc2NCA0MDEuMDcxIDIxOC4yMTMgNDAzLjUyNUMyMjAuNjYyIDQwNS45NzkgMjIzLjU5MyA0MDcuODk1IDIyNi44MjEgNDA5LjE1MkMyMzAuMDQ5IDQxMC40MDkgMjMzLjUwMyA0MTAuOTc5IDIzNi45NjIgNDEwLjgyNkMyNDkuMzg3IDQxMC44MjYgMjYxLjgxMiA0MTAuODI2IDI3NC4yMzYgNDEwLjgyNkMyNzcuOTIyIDQxMS4xODMgMjgxLjY0MiA0MTAuNzE3IDI4NS4xMjcgNDA5LjQ2MkMyODguNjEyIDQwOC4yMDggMjkxLjc3NyA0MDYuMTk2IDI5NC4zOTQgNDAzLjU3QzI5Ny4wMTIgNDAwLjk0NSAyOTkuMDE3IDM5Ny43NzIgMzAwLjI2NSAzOTQuMjc4QzMwMS41MTQgMzkwLjc4NSAzMDEuOTc1IDM4Ny4wNTggMzAxLjYxNSAzODMuMzY0QzMwMS42MTUgMzUzLjkxOSAzMDEuNjE2IDMyNC40NiAzMDEuNDc0IDI5NS4wMTVDMzAxLjMxMSAyOTMuMzMxIDMwMS42NyAyOTEuNjM3IDMwMi41MDIgMjkwLjE2NUMzMDMuMzM0IDI4OC42OTIgMzA0LjU5OSAyODcuNTEyIDMwNi4xMjUgMjg2Ljc4NkMzMjMuNzkgMjc2LjI5OCAzMzcuNTUxIDI2MC4zMTQgMzQ1LjMxMyAyNDEuMjY2QzM1My4wNzUgMjIyLjIxOSAzNTQuNDEzIDIwMS4xNTEgMzQ5LjEyMyAxODEuMjcyQzM0Mi4zNTYgMTU2Ljg1MyAzMjYuMjg2IDEzNi4wNzUgMzA0LjM3NiAxMjMuNDE0QzI4Mi40NjYgMTEwLjc1NCAyNTYuNDY5IDEwNy4yMjUgMjMxLjk4NyAxMTMuNTg2QzIxNy42NjkgMTE2LjU0NCAyMDQuMjg5IDEyMi45NTkgMTkzLjAwNyAxMzIuMjc0QzE4MS43MjYgMTQxLjU4OCAxNzIuODg0IDE1My41MjIgMTY3LjI0OSAxNjcuMDM4QzE1OS4wMjcgMTg4LjY4NiAxNTguNTQ4IDIxMi41MjEgMTY1Ljg5MyAyMzQuNDg0QzE3My4yMzggMjU2LjQ0NyAxODcuOTU0IDI3NS4xODEgMjA3LjUzMyAyODcuNDk1QzIwOC42NyAyODguMDM4IDIwOS42MTMgMjg4LjkxNyAyMTAuMjM3IDI5MC4wMTNDMjEwLjg2MSAyOTEuMTA5IDIxMS4xMzYgMjkyLjM3IDIxMS4wMjUgMjkzLjYyN0MyMTAuODQxIDMwOS4wMDggMjEwLjkyNiAzMjQuMzMzIDIxMC45MjYgMzM5LjY3MVYzMzkuNjQzWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNTYuNDgzIDI4LjA1NTRDMzEzLjg5OSAyOC4wNTU0IDM3MS4zMTUgMjcuODg1NiA0MjguNzQ1IDI4LjE0MDVDNDQwLjY4IDI3LjkwNzYgNDUyLjUyMSAzMC4yODg5IDQ2My40NDEgMzUuMTE3OUM0NzQuMzYyIDM5Ljk0NjkgNDg0LjA5OSA0Ny4xMDczIDQ5MS45NzEgNTYuMDk4NEM1MDQuMDYyIDY5LjY5NjIgNTExLjEzMiA4Ny4wMzg3IDUxMiAxMDUuMjNDNTEyLjAyOCAxMjEuOTMzIDUxMC4wMzUgMTM4LjU3OCA1MDYuMDYzIDE1NC44MDFDNDk4LjQ0NCAxOTguNzA2IDQ5MC41MTUgMjQyLjUyNyA0ODIuNzI2IDI4Ni4zNzZDNDc2LjAxMiAzMjQuMTM0IDQ2OS41ODEgMzYxLjk1IDQ2Mi41MTMgMzk5LjY4QzQ1Ny42NzIgNDIwLjk2OSA0NDYuNTQ1IDQ0MC4zMDMgNDMwLjU4IDQ1NS4xNjVDNDE0LjYxNiA0NzAuMDI3IDM5NC41NTUgNDc5LjcyNyAzNzMuMDExIDQ4My4wMDJDMzY3Ljc1MiA0ODMuNjI5IDM2Mi40NjIgNDgzLjk0NiAzNTcuMTY2IDQ4My45NUMyOTAuMDUzIDQ4NC4wMTcgMjIyLjk0IDQ4NC4wMTcgMTU1LjgyOCA0ODMuOTVDMTMwLjQ2NiA0ODMuOSAxMDUuOTMgNDc0LjkxNSA4Ni41MTMyIDQ1OC41NjZDNjcuMDk2NSA0NDIuMjE4IDU0LjAzNjIgNDE5LjU0OCA0OS42MTggMzk0LjUyNUMzNi4xODA0IDMxOS4xNzcgMjIuNjI5NyAyNDMuODUzIDguOTY1OTcgMTY4LjU1M0M2LjI4MDM0IDE1My42MzkgMy4zMTIgMTM4LjgxMSAxLjIwNTkgMTIzLjc4NEMtMi40NjEwNSAxMDIuNzI5IDIuMzEwOTMgODEuMDc0NCAxNC40ODUyIDYzLjUyNDRDMjYuNjU5NiA0NS45NzQ1IDQ1LjI1MjkgMzMuOTQ2MiA2Ni4yMjY2IDMwLjA1MjVDNzMuMDU1NyAyOC43NDUxIDc5Ljk5NTkgMjguMTA5NCA4Ni45NDg0IDI4LjE1NDZDMTQzLjQ2IDI3Ljk5NDEgMTk5Ljk3MSAyNy45NjEgMjU2LjQ4MyAyOC4wNTU0Wk0yMTAuOTI2IDMzOS42NDNDMjEwLjkyNiAzNTQuNjcgMjEwLjkyNiAzNjkuNjk3IDIxMC45MjYgMzg0LjczOEMyMTAuNzczIDM4OC4yMDUgMjExLjM0MyAzOTEuNjY1IDIxMi41OTcgMzk0Ljg5OUMyMTMuODUyIDM5OC4xMzQgMjE1Ljc2NCA0MDEuMDcxIDIxOC4yMTMgNDAzLjUyNUMyMjAuNjYyIDQwNS45NzkgMjIzLjU5MyA0MDcuODk1IDIyNi44MjEgNDA5LjE1MkMyMzAuMDQ5IDQxMC40MDkgMjMzLjUwMyA0MTAuOTc5IDIzNi45NjIgNDEwLjgyNkMyNDkuMzg3IDQxMC44MjYgMjYxLjgxMiA0MTAuODI2IDI3NC4yMzYgNDEwLjgyNkMyNzcuOTIyIDQxMS4xODMgMjgxLjY0MiA0MTAuNzE3IDI4NS4xMjcgNDA5LjQ2MkMyODguNjEyIDQwOC4yMDggMjkxLjc3NyA0MDYuMTk2IDI5NC4zOTQgNDAzLjU3QzI5Ny4wMTIgNDAwLjk0NSAyOTkuMDE3IDM5Ny43NzIgMzAwLjI2NSAzOTQuMjc4QzMwMS41MTQgMzkwLjc4NSAzMDEuOTc1IDM4Ny4wNTggMzAxLjYxNSAzODMuMzY0QzMwMS42MTUgMzUzLjkxOSAzMDEuNjE2IDMyNC40NiAzMDEuNDc0IDI5NS4wMTVDMzAxLjMxMSAyOTMuMzMxIDMwMS42NyAyOTEuNjM3IDMwMi41MDIgMjkwLjE2NUMzMDMuMzM0IDI4OC42OTIgMzA0LjU5OSAyODcuNTEyIDMwNi4xMjUgMjg2Ljc4NkMzMjMuNzkgMjc2LjI5OCAzMzcuNTUxIDI2MC4zMTQgMzQ1LjMxMyAyNDEuMjY2QzM1My4wNzUgMjIyLjIxOSAzNTQuNDEzIDIwMS4xNTEgMzQ5LjEyMyAxODEuMjcyQzM0Mi4zNTYgMTU2Ljg1MyAzMjYuMjg2IDEzNi4wNzUgMzA0LjM3NiAxMjMuNDE0QzI4Mi40NjYgMTEwLjc1NCAyNTYuNDY5IDEwNy4yMjUgMjMxLjk4NyAxMTMuNTg2QzIxNy42NjkgMTE2LjU0NCAyMDQuMjg5IDEyMi45NTkgMTkzLjAwNyAxMzIuMjc0QzE4MS43MjYgMTQxLjU4OCAxNzIuODg0IDE1My41MjIgMTY3LjI0OSAxNjcuMDM4QzE1OS4wMjcgMTg4LjY4NiAxNTguNTQ4IDIxMi41MjEgMTY1Ljg5MyAyMzQuNDg0QzE3My4yMzggMjU2LjQ0NyAxODcuOTU0IDI3NS4xODEgMjA3LjUzMyAyODcuNDk1QzIwOC42NyAyODguMDM4IDIwOS42MTMgMjg4LjkxNyAyMTAuMjM3IDI5MC4wMTNDMjEwLjg2MSAyOTEuMTA5IDIxMS4xMzYgMjkyLjM3IDIxMS4wMjUgMjkzLjYyN0MyMTAuODQxIDMwOS4wMDggMjEwLjkyNiAzMjQuMzMzIDIxMC45MjYgMzM5LjY3MVYzMzkuNjQzWiIgZmlsbD0iIzBEMzM4RiIvPgo8L3N2Zz4K" }, "b5397666-4885-aa6b-cebf-e52262a439a2": { name: "Chromium Browser" }, "771b48fd-d3d4-4f74-9232-fc157ab0507a": { name: "Edge on Mac", iconDark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50KTt9LmNscy0ye29wYWNpdHk6MC4zNTtmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50KTt9LmNscy0yLC5jbHMtNHtpc29sYXRpb246aXNvbGF0ZTt9LmNscy0ze2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtMik7fS5jbHMtNHtvcGFjaXR5OjAuNDE7ZmlsbDp1cmwoI3JhZGlhbC1ncmFkaWVudC0yKTt9LmNscy01e2ZpbGw6dXJsKCNyYWRpYWwtZ3JhZGllbnQtMyk7fS5jbHMtNntmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50LTQpO308L3N0eWxlPjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50IiB4MT0iNjMuMzMiIHkxPSI4NC4wMyIgeDI9IjI0MS42NyIgeTI9Ijg0LjAzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMGM1OWE0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTE0YThiIi8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudCIgY3g9IjE2MS44MyIgY3k9IjY4LjkxIiByPSI5NS4zOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMC45NSwgMCwgMjQ4Ljg0KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMC43MiIgc3RvcC1vcGFjaXR5PSIwIi8+PHN0b3Agb2Zmc2V0PSIwLjk1IiBzdG9wLW9wYWNpdHk9IjAuNTMiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50LTIiIHgxPSIxNTcuMzUiIHkxPSIxNjEuMzkiIHgyPSI0NS45NiIgeTI9IjQwLjA2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMWI5ZGUyIi8+PHN0b3Agb2Zmc2V0PSIwLjE2IiBzdG9wLWNvbG9yPSIjMTU5NWRmIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMDY4MGQ3Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDA3OGQ0Ii8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC0yIiBjeD0iLTM0MC4yOSIgY3k9IjYyLjk5IiByPSIxNDMuMjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMC4xNSwgLTAuOTksIC0wLjgsIC0wLjEyLCAxNzYuNjQsIC0xMjUuNCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAuNzYiIHN0b3Atb3BhY2l0eT0iMCIvPjxzdG9wIG9mZnNldD0iMC45NSIgc3RvcC1vcGFjaXR5PSIwLjUiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0icmFkaWFsLWdyYWRpZW50LTMiIGN4PSIxMTMuMzciIGN5PSI1NzAuMjEiIHI9IjIwMi40MyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgtMC4wNCwgMSwgMi4xMywgMC4wOCwgLTExNzkuNTQsIC0xMDYuNjkpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMzVjMWYxIi8+PHN0b3Agb2Zmc2V0PSIwLjExIiBzdG9wLWNvbG9yPSIjMzRjMWVkIi8+PHN0b3Agb2Zmc2V0PSIwLjIzIiBzdG9wLWNvbG9yPSIjMmZjMmRmIi8+PHN0b3Agb2Zmc2V0PSIwLjMxIiBzdG9wLWNvbG9yPSIjMmJjM2QyIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMzZjNzUyIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC00IiBjeD0iMzc2LjUyIiBjeT0iNTY3Ljk3IiByPSI5Ny4zNCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgwLjI4LCAwLjk2LCAwLjc4LCAtMC4yMywgLTMwMy43NiwgLTE0OC41KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIgc3RvcC1vcGFjaXR5PSIwIi8+PC9yYWRpYWxHcmFkaWVudD48L2RlZnM+PHRpdGxlPkVkZ2VfTG9nb18yNjV4MjY1PC90aXRsZT48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0xMTAuMzQsMjQ2LjM0QTc5LjIsNzkuMiwwLDAsMSw4Ny42LDIyNSw4MC43Miw4MC43MiwwLDAsMSwxMTcuMTMsMTA1YzMuMTItMS40Nyw4LjQ1LTQuMTMsMTUuNTQtNGEzMi4zNSwzMi4zNSwwLDAsMSwyNS42OSwxMywzMS44OCwzMS44OCwwLDAsMSw2LjM2LDE4LjY2YzAtLjIxLDI0LjQ2LTc5LjYtODAtNzkuNi00My45LDAtODAsNDEuNjYtODAsNzguMjFhMTMwLjE1LDEzMC4xNSwwLDAsMCwxMi4xMSw1NiwxMjgsMTI4LDAsMCwwLDE1Ni4zOCw2Ny4xMSw3NS41NSw3NS41NSwwLDAsMS02Mi43OC04WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMTEwLjM0LDI0Ni4zNEE3OS4yLDc5LjIsMCwwLDEsODcuNiwyMjUsODAuNzIsODAuNzIsMCwwLDEsMTE3LjEzLDEwNWMzLjEyLTEuNDcsOC40NS00LjEzLDE1LjU0LTRhMzIuMzUsMzIuMzUsMCwwLDEsMjUuNjksMTMsMzEuODgsMzEuODgsMCwwLDEsNi4zNiwxOC42NmMwLS4yMSwyNC40Ni03OS42LTgwLTc5LjYtNDMuOSwwLTgwLDQxLjY2LTgwLDc4LjIxYTEzMC4xNSwxMzAuMTUsMCwwLDAsMTIuMTEsNTYsMTI4LDEyOCwwLDAsMCwxNTYuMzgsNjcuMTEsNzUuNTUsNzUuNTUsMCwwLDEtNjIuNzgtOFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjYzIC00LjkyKSIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTE1Ni45NCwxNTMuNzhjLS44MSwxLjA1LTMuMywyLjUtMy4zLDUuNjYsMCwyLjYxLDEuNyw1LjEyLDQuNzIsNy4yMywxNC4zOCwxMCw0MS40OSw4LjY4LDQxLjU2LDguNjhBNTkuNTYsNTkuNTYsMCwwLDAsMjMwLjE5LDE2N2E2MS4zOCw2MS4zOCwwLDAsMCwzMC40My01Mi44OGMuMjYtMjIuNDEtOC0zNy4zMS0xMS4zNC00My45MUMyMjguMDksMjguNzYsMTgyLjM1LDQuOTIsMTMyLjYxLDQuOTJhMTI4LDEyOCwwLDAsMC0xMjgsMTI2LjJjLjQ4LTM2LjU0LDM2LjgtNjYuMDUsODAtNjYuMDUsMy41LDAsMjMuNDYuMzQsNDIsMTAuMDcsMTYuMzQsOC41OCwyNC45LDE4Ljk0LDMwLjg1LDI5LjIxLDYuMTgsMTAuNjcsNy4yOCwyNC4xNSw3LjI4LDI5LjUyUzE2MiwxNDcuMiwxNTYuOTQsMTUzLjc4WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy02IiBkPSJNMTU2Ljk0LDE1My43OGMtLjgxLDEuMDUtMy4zLDIuNS0zLjMsNS42NiwwLDIuNjEsMS43LDUuMTIsNC43Miw3LjIzLDE0LjM4LDEwLDQxLjQ5LDguNjgsNDEuNTYsOC42OEE1OS41Niw1OS41NiwwLDAsMCwyMzAuMTksMTY3YTYxLjM4LDYxLjM4LDAsMCwwLDMwLjQzLTUyLjg4Yy4yNi0yMi40MS04LTM3LjMxLTExLjM0LTQzLjkxQzIyOC4wOSwyOC43NiwxODIuMzUsNC45MiwxMzIuNjEsNC45MmExMjgsMTI4LDAsMCwwLTEyOCwxMjYuMmMuNDgtMzYuNTQsMzYuOC02Ni4wNSw4MC02Ni4wNSwzLjUsMCwyMy40Ni4zNCw0MiwxMC4wNywxNi4zNCw4LjU4LDI0LjksMTguOTQsMzAuODUsMjkuMjEsNi4xOCwxMC42Nyw3LjI4LDI0LjE1LDcuMjgsMjkuNTJTMTYyLDE0Ny4yLDE1Ni45NCwxNTMuNzhaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48L3N2Zz4=", icon: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50KTt9LmNscy0ye29wYWNpdHk6MC4zNTtmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50KTt9LmNscy0yLC5jbHMtNHtpc29sYXRpb246aXNvbGF0ZTt9LmNscy0ze2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtMik7fS5jbHMtNHtvcGFjaXR5OjAuNDE7ZmlsbDp1cmwoI3JhZGlhbC1ncmFkaWVudC0yKTt9LmNscy01e2ZpbGw6dXJsKCNyYWRpYWwtZ3JhZGllbnQtMyk7fS5jbHMtNntmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50LTQpO308L3N0eWxlPjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50IiB4MT0iNjMuMzMiIHkxPSI4NC4wMyIgeDI9IjI0MS42NyIgeTI9Ijg0LjAzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMGM1OWE0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTE0YThiIi8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudCIgY3g9IjE2MS44MyIgY3k9IjY4LjkxIiByPSI5NS4zOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMC45NSwgMCwgMjQ4Ljg0KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMC43MiIgc3RvcC1vcGFjaXR5PSIwIi8+PHN0b3Agb2Zmc2V0PSIwLjk1IiBzdG9wLW9wYWNpdHk9IjAuNTMiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50LTIiIHgxPSIxNTcuMzUiIHkxPSIxNjEuMzkiIHgyPSI0NS45NiIgeTI9IjQwLjA2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMWI5ZGUyIi8+PHN0b3Agb2Zmc2V0PSIwLjE2IiBzdG9wLWNvbG9yPSIjMTU5NWRmIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMDY4MGQ3Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDA3OGQ0Ii8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC0yIiBjeD0iLTM0MC4yOSIgY3k9IjYyLjk5IiByPSIxNDMuMjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMC4xNSwgLTAuOTksIC0wLjgsIC0wLjEyLCAxNzYuNjQsIC0xMjUuNCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAuNzYiIHN0b3Atb3BhY2l0eT0iMCIvPjxzdG9wIG9mZnNldD0iMC45NSIgc3RvcC1vcGFjaXR5PSIwLjUiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0icmFkaWFsLWdyYWRpZW50LTMiIGN4PSIxMTMuMzciIGN5PSI1NzAuMjEiIHI9IjIwMi40MyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgtMC4wNCwgMSwgMi4xMywgMC4wOCwgLTExNzkuNTQsIC0xMDYuNjkpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMzVjMWYxIi8+PHN0b3Agb2Zmc2V0PSIwLjExIiBzdG9wLWNvbG9yPSIjMzRjMWVkIi8+PHN0b3Agb2Zmc2V0PSIwLjIzIiBzdG9wLWNvbG9yPSIjMmZjMmRmIi8+PHN0b3Agb2Zmc2V0PSIwLjMxIiBzdG9wLWNvbG9yPSIjMmJjM2QyIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMzZjNzUyIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC00IiBjeD0iMzc2LjUyIiBjeT0iNTY3Ljk3IiByPSI5Ny4zNCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgwLjI4LCAwLjk2LCAwLjc4LCAtMC4yMywgLTMwMy43NiwgLTE0OC41KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIgc3RvcC1vcGFjaXR5PSIwIi8+PC9yYWRpYWxHcmFkaWVudD48L2RlZnM+PHRpdGxlPkVkZ2VfTG9nb18yNjV4MjY1PC90aXRsZT48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0xMTAuMzQsMjQ2LjM0QTc5LjIsNzkuMiwwLDAsMSw4Ny42LDIyNSw4MC43Miw4MC43MiwwLDAsMSwxMTcuMTMsMTA1YzMuMTItMS40Nyw4LjQ1LTQuMTMsMTUuNTQtNGEzMi4zNSwzMi4zNSwwLDAsMSwyNS42OSwxMywzMS44OCwzMS44OCwwLDAsMSw2LjM2LDE4LjY2YzAtLjIxLDI0LjQ2LTc5LjYtODAtNzkuNi00My45LDAtODAsNDEuNjYtODAsNzguMjFhMTMwLjE1LDEzMC4xNSwwLDAsMCwxMi4xMSw1NiwxMjgsMTI4LDAsMCwwLDE1Ni4zOCw2Ny4xMSw3NS41NSw3NS41NSwwLDAsMS02Mi43OC04WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMTEwLjM0LDI0Ni4zNEE3OS4yLDc5LjIsMCwwLDEsODcuNiwyMjUsODAuNzIsODAuNzIsMCwwLDEsMTE3LjEzLDEwNWMzLjEyLTEuNDcsOC40NS00LjEzLDE1LjU0LTRhMzIuMzUsMzIuMzUsMCwwLDEsMjUuNjksMTMsMzEuODgsMzEuODgsMCwwLDEsNi4zNiwxOC42NmMwLS4yMSwyNC40Ni03OS42LTgwLTc5LjYtNDMuOSwwLTgwLDQxLjY2LTgwLDc4LjIxYTEzMC4xNSwxMzAuMTUsMCwwLDAsMTIuMTEsNTYsMTI4LDEyOCwwLDAsMCwxNTYuMzgsNjcuMTEsNzUuNTUsNzUuNTUsMCwwLDEtNjIuNzgtOFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjYzIC00LjkyKSIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTE1Ni45NCwxNTMuNzhjLS44MSwxLjA1LTMuMywyLjUtMy4zLDUuNjYsMCwyLjYxLDEuNyw1LjEyLDQuNzIsNy4yMywxNC4zOCwxMCw0MS40OSw4LjY4LDQxLjU2LDguNjhBNTkuNTYsNTkuNTYsMCwwLDAsMjMwLjE5LDE2N2E2MS4zOCw2MS4zOCwwLDAsMCwzMC40My01Mi44OGMuMjYtMjIuNDEtOC0zNy4zMS0xMS4zNC00My45MUMyMjguMDksMjguNzYsMTgyLjM1LDQuOTIsMTMyLjYxLDQuOTJhMTI4LDEyOCwwLDAsMC0xMjgsMTI2LjJjLjQ4LTM2LjU0LDM2LjgtNjYuMDUsODAtNjYuMDUsMy41LDAsMjMuNDYuMzQsNDIsMTAuMDcsMTYuMzQsOC41OCwyNC45LDE4Ljk0LDMwLjg1LDI5LjIxLDYuMTgsMTAuNjcsNy4yOCwyNC4xNSw3LjI4LDI5LjUyUzE2MiwxNDcuMiwxNTYuOTQsMTUzLjc4WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy02IiBkPSJNMTU2Ljk0LDE1My43OGMtLjgxLDEuMDUtMy4zLDIuNS0zLjMsNS42NiwwLDIuNjEsMS43LDUuMTIsNC43Miw3LjIzLDE0LjM4LDEwLDQxLjQ5LDguNjgsNDEuNTYsOC42OEE1OS41Niw1OS41NiwwLDAsMCwyMzAuMTksMTY3YTYxLjM4LDYxLjM4LDAsMCwwLDMwLjQzLTUyLjg4Yy4yNi0yMi40MS04LTM3LjMxLTExLjM0LTQzLjkxQzIyOC4wOSwyOC43NiwxODIuMzUsNC45MiwxMzIuNjEsNC45MmExMjgsMTI4LDAsMCwwLTEyOCwxMjYuMmMuNDgtMzYuNTQsMzYuOC02Ni4wNSw4MC02Ni4wNSwzLjUsMCwyMy40Ni4zNCw0MiwxMC4wNywxNi4zNCw4LjU4LDI0LjksMTguOTQsMzAuODUsMjkuMjEsNi4xOCwxMC42Nyw3LjI4LDI0LjE1LDcuMjgsMjkuNTJTMTYyLDE0Ny4yLDE1Ni45NCwxNTMuNzhaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48L3N2Zz4=" }, "39a5647e-1853-446c-a1f6-a79bae9f5bc7": { name: "IDmelon", iconDark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2YxNWI1Yzt9LmNscy0ye2ZpbGw6IzkyMWIxZDt9LmNscy0ze2ZpbGw6I2VlMzAyNTt9LmNscy00e2ZpbGw6I2JiMjAyNjt9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMzQxLjg3LDEwMC4ybC00LjI5LTEuNjRjLTMyLjMxLTExLjgxLTY1LjM2LTEzLjI3LTc2LjkyLTEzLjRsLS44OSwwSDEyMC4xMkEyMy40MywyMy40MywwLDAsMCwxMTEuNiw4N2MtLjQxLjIxLS44MS40Mi0xLjE3LjY0bC0xLjg1LDEuNzYsMTMzLjM1LDY1LjgsMTAzLjM4LTUyLjg5WiIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjI5NC41OCIgeTE9IjEzNy4wNyIgeDI9IjI5Ni45OSIgeTI9IjEzOC4yNyIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjIzOS41MyIgeTE9IjE1Mi4xMSIgeDI9IjI0MS45MyIgeTI9IjE1My4zMSIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTEwNi43NCw5MXEtMi42Miw0LjItMi4zNSwxMS4yNnQuMjYsMTMuMzdWNDIzLjIxcTAsNS43Ni0uMjYsMTQuNDF0MS4zMSwxMi44NGExNC41NSwxNC41NSwwLDAsMCwxLjE0LDIuMTlsMTM2LTI5OS41NkwxMTAuNDMsODcuNjVBMTEuMjQsMTEuMjQsMCwwLDAsMTA2Ljc0LDkxWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTM2MS44NiwxMTEuNTNjLTIuMzItMS41NS00LjctMy4xLTcuMTMtNC42OGE5My45Miw5My45MiwwLDAsMC0xMi02LjMyYy0uMjctLjExLS41NS0uMjMtLjgzLS4zM2wtOTksNTIuODlMMzg3LjYzLDQwMi4zMUExNjQuMDcsMTY0LjA3LDAsMCwwLDM5NywzODguMTJxMjkuODItNTEuMjEsMjkuODItMTI1YTI4NC44MywyODQuODMsMCwwLDAtNy4wOC02MS4yNSwxNjQuMTYsMTY0LjE2LDAsMCwwLTI2LjUzLTU5Ljc1LDEzNC45LDEzNC45LDAsMCwwLTkuMDUtMTEuMzhBMTUzLjIsMTUzLjIsMCwwLDAsMzYxLjg2LDExMS41M1oiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0xMDYuNjUsNDUyLjM0YTEwLjA3LDEwLjA3LDAsMCwwLDcuNjksNS4xOWwxLjc0LjJoMTU2YzUwLjI3LDAsODguNjQtMTguNjksMTE1LjUyLTU1LjQyTDI0Mi44OSwxNTMuMDlaIi8+PC9zdmc+", icon: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2YxNWI1Yzt9LmNscy0ye2ZpbGw6IzkyMWIxZDt9LmNscy0ze2ZpbGw6I2VlMzAyNTt9LmNscy00e2ZpbGw6I2JiMjAyNjt9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMzQxLjg3LDEwMC4ybC00LjI5LTEuNjRjLTMyLjMxLTExLjgxLTY1LjM2LTEzLjI3LTc2LjkyLTEzLjRsLS44OSwwSDEyMC4xMkEyMy40MywyMy40MywwLDAsMCwxMTEuNiw4N2MtLjQxLjIxLS44MS40Mi0xLjE3LjY0bC0xLjg1LDEuNzYsMTMzLjM1LDY1LjgsMTAzLjM4LTUyLjg5WiIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjI5NC41OCIgeTE9IjEzNy4wNyIgeDI9IjI5Ni45OSIgeTI9IjEzOC4yNyIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjIzOS41MyIgeTE9IjE1Mi4xMSIgeDI9IjI0MS45MyIgeTI9IjE1My4zMSIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTEwNi43NCw5MXEtMi42Miw0LjItMi4zNSwxMS4yNnQuMjYsMTMuMzdWNDIzLjIxcTAsNS43Ni0uMjYsMTQuNDF0MS4zMSwxMi44NGExNC41NSwxNC41NSwwLDAsMCwxLjE0LDIuMTlsMTM2LTI5OS41NkwxMTAuNDMsODcuNjVBMTEuMjQsMTEuMjQsMCwwLDAsMTA2Ljc0LDkxWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTM2MS44NiwxMTEuNTNjLTIuMzItMS41NS00LjctMy4xLTcuMTMtNC42OGE5My45Miw5My45MiwwLDAsMC0xMi02LjMyYy0uMjctLjExLS41NS0uMjMtLjgzLS4zM2wtOTksNTIuODlMMzg3LjYzLDQwMi4zMUExNjQuMDcsMTY0LjA3LDAsMCwwLDM5NywzODguMTJxMjkuODItNTEuMjEsMjkuODItMTI1YTI4NC44MywyODQuODMsMCwwLDAtNy4wOC02MS4yNSwxNjQuMTYsMTY0LjE2LDAsMCwwLTI2LjUzLTU5Ljc1LDEzNC45LDEzNC45LDAsMCwwLTkuMDUtMTEuMzhBMTUzLjIsMTUzLjIsMCwwLDAsMzYxLjg2LDExMS41M1oiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0xMDYuNjUsNDUyLjM0YTEwLjA3LDEwLjA3LDAsMCwwLDcuNjksNS4xOWwxLjc0LjJoMTU2YzUwLjI3LDAsODguNjQtMTguNjksMTE1LjUyLTU1LjQyTDI0Mi44OSwxNTMuMDlaIi8+PC9zdmc+" }, "6e8248d5-b479-40db-a3d8-11116f7e8349": { name: "Bitwarden", iconDark: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMywgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9Ikljb24iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiMxNzVEREM7fQoJLnN0MXtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8cmVjdCBpZD0iQmFja2dyb3VuZCIgY2xhc3M9InN0MCIgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIvPgo8cGF0aCBpZD0iSWRlbnRpdHkiIGNsYXNzPSJzdDEiIGQ9Ik04MjkuOCwxMjguNmMtNi41LTYuNS0xNC4yLTkuNy0yMy05LjdIMjE3LjJjLTguOSwwLTE2LjUsMy4yLTIzLDkuN3MtOS43LDE0LjItOS43LDIzdjM5My4xCgljMCwyOS4zLDUuNyw1OC40LDE3LjEsODcuM2MxMS40LDI4LjgsMjUuNiw1NC40LDQyLjUsNzYuOGMxNi45LDIyLjMsMzcsNDQuMSw2MC40LDY1LjNzNDUsMzguNyw2NC43LDUyLjcKCWMxOS44LDE0LDQwLjQsMjcuMiw2MS45LDM5LjdzMzYuOCwyMC45LDQ1LjgsMjUuM2M5LDQuNCwxNi4zLDcuOSwyMS43LDEwLjJjNC4xLDIsOC41LDMuMSwxMy4zLDMuMWM0LjgsMCw5LjItMSwxMy4zLTMuMQoJYzUuNS0yLjQsMTIuNy01LjgsMjEuOC0xMC4yYzktNC40LDI0LjMtMTIuOSw0NS44LTI1LjNjMjEuNS0xMi41LDQyLjEtMjUuNyw2MS45LTM5LjdjMTkuOC0xNCw0MS40LTMxLjYsNjQuOC01Mi43CgljMjMuNC0yMS4yLDQzLjUtNDIuOSw2MC40LTY1LjNjMTYuOS0yMi40LDMxLTQ3LjksNDIuNS03Ni44YzExLjQtMjguOCwxNy4xLTU3LjksMTcuMS04Ny4zdi0zOTMKCUM4MzkuNiwxNDIuOCw4MzYuMywxMzUuMSw4MjkuOCwxMjguNnogTTc1My44LDU0OC40YzAsMTQyLjMtMjQxLjgsMjY0LjktMjQxLjgsMjY0LjlWMjAzaDI0MS44Qzc1My44LDIwMyw3NTMuOCw0MDYuMSw3NTMuOCw1NDguNHoKCSIvPgo8L3N2Zz4K", icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMywgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9Ikljb24iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiMxNzVEREM7fQoJLnN0MXtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8cmVjdCBpZD0iQmFja2dyb3VuZCIgY2xhc3M9InN0MCIgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIvPgo8cGF0aCBpZD0iSWRlbnRpdHkiIGNsYXNzPSJzdDEiIGQ9Ik04MjkuOCwxMjguNmMtNi41LTYuNS0xNC4yLTkuNy0yMy05LjdIMjE3LjJjLTguOSwwLTE2LjUsMy4yLTIzLDkuN3MtOS43LDE0LjItOS43LDIzdjM5My4xCgljMCwyOS4zLDUuNyw1OC40LDE3LjEsODcuM2MxMS40LDI4LjgsMjUuNiw1NC40LDQyLjUsNzYuOGMxNi45LDIyLjMsMzcsNDQuMSw2MC40LDY1LjNzNDUsMzguNyw2NC43LDUyLjcKCWMxOS44LDE0LDQwLjQsMjcuMiw2MS45LDM5LjdzMzYuOCwyMC45LDQ1LjgsMjUuM2M5LDQuNCwxNi4zLDcuOSwyMS43LDEwLjJjNC4xLDIsOC41LDMuMSwxMy4zLDMuMWM0LjgsMCw5LjItMSwxMy4zLTMuMQoJYzUuNS0yLjQsMTIuNy01LjgsMjEuOC0xMC4yYzktNC40LDI0LjMtMTIuOSw0NS44LTI1LjNjMjEuNS0xMi41LDQyLjEtMjUuNyw2MS45LTM5LjdjMTkuOC0xNCw0MS40LTMxLjYsNjQuOC01Mi43CgljMjMuNC0yMS4yLDQzLjUtNDIuOSw2MC40LTY1LjNjMTYuOS0yMi40LDMxLTQ3LjksNDIuNS03Ni44YzExLjQtMjguOCwxNy4xLTU3LjksMTcuMS04Ny4zdi0zOTMKCUM4MzkuNiwxNDIuOCw4MzYuMywxMzUuMSw4MjkuOCwxMjguNnogTTc1My44LDU0OC40YzAsMTQyLjMtMjQxLjgsMjY0LjktMjQxLjgsMjY0LjlWMjAzaDI0MS44Qzc1My44LDIwMyw3NTMuOCw0MDYuMSw3NTMuOCw1NDguNHoKCSIvPgo8L3N2Zz4K" } };
      var V3 = i5(353);
      function F4(n7) {
        const { browser: e6, os: r9 } = (0, V3.UAParser)(n7);
        return { browser: e6, os: r9 };
      }
      const J3 = (n7, e6) => {
        const r9 = atob(n7.split(",")[1]), i9 = new DOMParser().parseFromString(r9, "image/svg+xml");
        i9.documentElement.style.setProperty("fill", e6);
        const t8 = new XMLSerializer().serializeToString(i9.documentElement);
        return `data:image/svg+xml;base64,${btoa(t8)}`;
      };
      function X4(n7, e6, r9, i9) {
        if ("a" === r9 && !i9)
          throw new TypeError("Private accessor was defined without a getter");
        if ("function" == typeof e6 ? n7 !== e6 || !i9 : !e6.has(n7))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return "m" === r9 ? i9 : "a" === r9 ? i9.call(n7) : i9 ? i9.value : e6.get(n7);
      }
      function _4(n7, e6, r9, i9, t8) {
        if ("m" === i9)
          throw new TypeError("Private method is not writable");
        if ("a" === i9 && !t8)
          throw new TypeError("Private accessor was defined without a setter");
        if ("function" == typeof e6 ? n7 !== e6 || !t8 : !e6.has(n7))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return "a" === i9 ? t8.call(n7, r9) : t8 ? t8.value = r9 : e6.set(n7, r9), r9;
      }
      Object.create, Object.create, "function" == typeof SuppressedError && SuppressedError;
      const K3 = (q4 = { ConditionalUiUnconfirmedCredential: () => i3, InvalidEmailError: () => u2, InvalidFullnameError: () => l3, InvalidOtpInputError: () => h2, InvalidPasskeyError: () => p2, InvalidTokenInputError: () => d2, NoPasskeyAvailableError: () => f2, NonRecoverableError: () => y3, PasskeyChallengeCancelledError: () => w3, UnknownError: () => v2, UnknownUserError: () => b, UserAlreadyExistsError: () => S2 }, $3 = {}, i5.d($3, q4), $3);
      var q4, $3, nn, en, rn, tn, on;
      !function(n7) {
        n7[n7.SignUp = 0] = "SignUp", n7[n7.Login = 1] = "Login";
      }(nn || (nn = {})), function(n7) {
        n7.PasskeySignupWithFallback = "PasskeySignupWithFallback", n7.SignupWithPasskeyAppend = "SignupWithPasskeyAppend";
      }(en || (en = {})), function(n7) {
        n7.PasskeyLoginWithFallback = "PasskeyLoginWithFallback";
      }(rn || (rn = {})), function(n7) {
        n7.Start = "start", n7.End = "end", n7.EmailOTPVerification = "email-otp-verification", n7.EmailLinkSent = "email-link-sent", n7.EmailLinkVerification = "email-link-verification", n7.PasskeyError = "passkey-error", n7.PasskeyAppend = "passkey-append", n7.PasskeyBenefits = "passkey-benefits", n7.PasskeySuccess = "passkey-success", n7.PasskeyCreate = "passkey-create";
      }(tn || (tn = {})), function(n7) {
        n7.ShowBenefits = "show-benefits", n7.CancelOTP = "cancel-otp", n7.CancelEmailLink = "cancel-email-link", n7.VerifyLink = "verify-link", n7.CancelPasskey = "cancel-passkey", n7.ChangeFlow = "change-flow", n7.PrimaryButton = "primary-button", n7.SecondaryButton = "secondary-button", n7.InitConditionalUI = "init-conditional-ui";
      }(on || (on = {}));
      const an = { "0d": 0, "1d": 1, "3d": 3, "1w": 7, "3w": 21, "1m": 30, "3m": 90 }, Mn = "corbado_passkeyAppendAskTS";
      var sn, cn2, An, ln, un, In, Nn, gn, yn, dn, jn, bn, Dn, wn, Cn, mn, Ln, En;
      class zn {
        constructor(n7, e6, r9 = nn.SignUp) {
          sn.add(this), cn2.set(this, void 0), An.set(this, void 0), ln.set(this, void 0), un.set(this, void 0), In.set(this, void 0), _4(this, cn2, n7, "f"), _4(this, In, r9, "f"), _4(this, un, e6, "f"), _4(this, ln, X4(this, sn, "m", Nn).call(this, e6), "f"), _4(this, An, X4(this, sn, "m", gn).call(this), "f");
        }
        get onLoggedIn() {
          return X4(this, cn2, "f");
        }
        get flowType() {
          return X4(this, In, "f");
        }
        get flowName() {
          return X4(this, ln, "f")[X4(this, In, "f")].name;
        }
        get flowOptions() {
          return X4(this, ln, "f")[X4(this, In, "f")].options;
        }
        get initialScreenName() {
          return X4(this, An, "f");
        }
        get verificationMethod() {
          var n7;
          return null !== (n7 = X4(this, ln, "f")[X4(this, In, "f")].options.verificationMethod) && void 0 !== n7 ? n7 : "emailOtp";
        }
        get userNameRequired() {
          return X4(this, un, "f").userFullNameRequired;
        }
        get allowUserRegistration() {
          return X4(this, un, "f").allowUserRegistration;
        }
        get passkeyAppendInterval() {
          var n7;
          return null !== (n7 = an[X4(this, un, "f").passkeyAppendInterval]) && void 0 !== n7 ? n7 : 0;
        }
        update(n7) {
          _4(this, In, n7, "f");
        }
      }
      cn2 = /* @__PURE__ */ new WeakMap(), An = /* @__PURE__ */ new WeakMap(), ln = /* @__PURE__ */ new WeakMap(), un = /* @__PURE__ */ new WeakMap(), In = /* @__PURE__ */ new WeakMap(), sn = /* @__PURE__ */ new WeakSet(), Nn = function(n7) {
        return { [nn.SignUp]: { name: "EmailOTPSignup" === n7.signupFlow ? en.SignupWithPasskeyAppend : en.PasskeySignupWithFallback, options: n7.signupFlowOptions }, [nn.Login]: { name: rn.PasskeyLoginWithFallback, options: n7.loginFlowOptions } };
      }, gn = function() {
        return new URLSearchParams(window.location.search).get("corbadoToken") ? (this.update(nn.Login), tn.EmailLinkVerification) : tn.Start;
      };
      const pn = { email: void 0, fullName: void 0, emailError: void 0 }, Tn = { emailError: void 0, userNameError: void 0, verificationError: void 0, lastPasskeyRetryTimeStamp: void 0 }, xn = { passkeyAppend: true, retryPasskeyOnError: true, verificationMethod: "emailOtp" };
      class kn {
        constructor(n7, e6, r9, i9, t8) {
          yn.add(this), dn.set(this, void 0), jn.set(this, void 0), bn.set(this, void 0), Dn.set(this, void 0), wn.set(this, void 0), Cn.set(this, void 0), mn.set(this, void 0), _4(this, wn, { ...xn, ...n7 }, "f"), _4(this, Cn, pn, "f"), _4(this, dn, e6, "f"), _4(this, jn, i9, "f"), _4(this, bn, t8, "f"), _4(this, Dn, X4(this, yn, "m", En).call(this, r9), "f"), i9.authService.userChanges.subscribe((n8) => {
            this.update({ user: n8 });
          });
        }
        get user() {
          return X4(this, mn, "f");
        }
        get userState() {
          return X4(this, Cn, "f");
        }
        get flowOptions() {
          return X4(this, wn, "f");
        }
        get passkeysSupported() {
          return X4(this, dn, "f");
        }
        get corbadoApp() {
          return X4(this, jn, "f");
        }
        get shouldAppendPasskey() {
          return X4(this, dn, "f") && X4(this, wn, "f").passkeyAppend && X4(this, Dn, "f");
        }
        update(n7) {
          const e6 = n7.userState || { ...X4(this, Cn, "f"), ...Tn };
          _4(this, Cn, X4(this, yn, "m", Ln).call(this, e6), "f"), _4(this, mn, n7.user || X4(this, mn, "f"), "f"), _4(this, wn, { ...X4(this, wn, "f"), ...n7.flowOptions }, "f");
        }
      }
      dn = /* @__PURE__ */ new WeakMap(), jn = /* @__PURE__ */ new WeakMap(), bn = /* @__PURE__ */ new WeakMap(), Dn = /* @__PURE__ */ new WeakMap(), wn = /* @__PURE__ */ new WeakMap(), Cn = /* @__PURE__ */ new WeakMap(), mn = /* @__PURE__ */ new WeakMap(), yn = /* @__PURE__ */ new WeakSet(), Ln = function(n7) {
        return n7.emailError && (n7.emailError.translatedMessage = X4(this, bn, "f").t(n7.emailError.name)), n7.userNameError && (n7.userNameError.translatedMessage = X4(this, bn, "f").t(n7.userNameError.name)), n7.verificationError && (n7.verificationError.translatedMessage = X4(this, bn, "f").t(n7.verificationError.name)), n7;
      }, En = function(n7) {
        const e6 = localStorage.getItem(Mn);
        if (!e6 || !n7)
          return true;
        const r9 = new Date(e6), i9 = (/* @__PURE__ */ new Date()).getTime() - r9.getTime();
        return Math.ceil(i9 / 864e5) > n7;
      };
      class hn {
        constructor(n7, e6, r9) {
          this.nextFlow = n7, this.nextScreen = e6, this.stateUpdate = r9;
        }
        static navigate(n7, e6) {
          return new hn(null, n7, null != e6 ? e6 : null);
        }
        static changeFlow(n7) {
          return new hn(n7, null, null);
        }
        static state(n7) {
          return new hn(null, null, n7);
        }
        static ignore() {
          return new hn(null, null, null);
        }
      }
      function fn(n7) {
        var e6 = String(n7);
        if ("[object Object]" === e6)
          try {
            e6 = JSON.stringify(n7);
          } catch (n8) {
          }
        return e6;
      }
      var Sn = new (function() {
        function n7() {
          this.some = false, this.none = true;
        }
        return n7.prototype[Symbol.iterator] = function() {
          return { next: function() {
            return { done: true, value: void 0 };
          } };
        }, n7.prototype.unwrapOr = function(n8) {
          return n8;
        }, n7.prototype.expect = function(n8) {
          throw new Error("" + n8);
        }, n7.prototype.unwrap = function() {
          throw new Error("Tried to unwrap None");
        }, n7.prototype.map = function(n8) {
          return this;
        }, n7.prototype.andThen = function(n8) {
          return this;
        }, n7.prototype.toResult = function(n8) {
          return Yn(n8);
        }, n7.prototype.toString = function() {
          return "None";
        }, n7;
      }())();
      Object.freeze(Sn);
      var vn, Bn = function() {
        function n7(e6) {
          if (!(this instanceof n7))
            return new n7(e6);
          this.some = true, this.none = false, this.val = e6;
        }
        return n7.prototype[Symbol.iterator] = function() {
          var n8 = Object(this.val);
          return Symbol.iterator in n8 ? n8[Symbol.iterator]() : { next: function() {
            return { done: true, value: void 0 };
          } };
        }, n7.prototype.unwrapOr = function(n8) {
          return this.val;
        }, n7.prototype.expect = function(n8) {
          return this.val;
        }, n7.prototype.unwrap = function() {
          return this.val;
        }, n7.prototype.map = function(n8) {
          return Bn(n8(this.val));
        }, n7.prototype.andThen = function(n8) {
          return n8(this.val);
        }, n7.prototype.toResult = function(n8) {
          return Qn(this.val);
        }, n7.prototype.safeUnwrap = function() {
          return this.val;
        }, n7.prototype.toString = function() {
          return "Some(" + fn(this.val) + ")";
        }, n7.EMPTY = new n7(void 0), n7;
      }();
      !function(n7) {
        n7.all = function() {
          for (var n8 = [], e6 = 0; e6 < arguments.length; e6++)
            n8[e6] = arguments[e6];
          for (var r9 = [], i9 = 0, t8 = n8; i9 < t8.length; i9++) {
            var o8 = t8[i9];
            if (!o8.some)
              return o8;
            r9.push(o8.val);
          }
          return Bn(r9);
        }, n7.any = function() {
          for (var n8 = [], e6 = 0; e6 < arguments.length; e6++)
            n8[e6] = arguments[e6];
          for (var r9 = 0, i9 = n8; r9 < i9.length; r9++) {
            var t8 = i9[r9];
            return t8.some, t8;
          }
          return Sn;
        }, n7.isOption = function(n8) {
          return n8 instanceof Bn || n8 === Sn;
        };
      }(vn || (vn = {}));
      var On, Yn = function() {
        function n7(e6) {
          if (!(this instanceof n7))
            return new n7(e6);
          this.ok = false, this.err = true, this.val = e6;
          var r9 = new Error().stack.split("\n").slice(2);
          r9 && r9.length > 0 && r9[0].includes("ErrImpl") && r9.shift(), this._stack = r9.join("\n");
        }
        return n7.prototype[Symbol.iterator] = function() {
          return { next: function() {
            return { done: true, value: void 0 };
          } };
        }, n7.prototype.else = function(n8) {
          return n8;
        }, n7.prototype.unwrapOr = function(n8) {
          return n8;
        }, n7.prototype.expect = function(n8) {
          throw new Error(n8 + " - Error: " + fn(this.val) + "\n" + this._stack);
        }, n7.prototype.unwrap = function() {
          throw new Error("Tried to unwrap Error: " + fn(this.val) + "\n" + this._stack);
        }, n7.prototype.map = function(n8) {
          return this;
        }, n7.prototype.andThen = function(n8) {
          return this;
        }, n7.prototype.mapErr = function(n8) {
          return new Yn(n8(this.val));
        }, n7.prototype.toOption = function() {
          return Sn;
        }, n7.prototype.toString = function() {
          return "Err(" + fn(this.val) + ")";
        }, Object.defineProperty(n7.prototype, "stack", { get: function() {
          return this + "\n" + this._stack;
        }, enumerable: false, configurable: true }), n7.EMPTY = new n7(void 0), n7;
      }(), Qn = function() {
        function n7(e6) {
          if (!(this instanceof n7))
            return new n7(e6);
          this.ok = true, this.err = false, this.val = e6;
        }
        return n7.prototype[Symbol.iterator] = function() {
          var n8 = Object(this.val);
          return Symbol.iterator in n8 ? n8[Symbol.iterator]() : { next: function() {
            return { done: true, value: void 0 };
          } };
        }, n7.prototype.else = function(n8) {
          return this.val;
        }, n7.prototype.unwrapOr = function(n8) {
          return this.val;
        }, n7.prototype.expect = function(n8) {
          return this.val;
        }, n7.prototype.unwrap = function() {
          return this.val;
        }, n7.prototype.map = function(n8) {
          return new Qn(n8(this.val));
        }, n7.prototype.andThen = function(n8) {
          return n8(this.val);
        }, n7.prototype.mapErr = function(n8) {
          return this;
        }, n7.prototype.toOption = function() {
          return Bn(this.val);
        }, n7.prototype.safeUnwrap = function() {
          return this.val;
        }, n7.prototype.toString = function() {
          return "Ok(" + fn(this.val) + ")";
        }, n7.EMPTY = new n7(void 0), n7;
      }();
      !function(n7) {
        n7.all = function() {
          for (var n8 = [], e6 = 0; e6 < arguments.length; e6++)
            n8[e6] = arguments[e6];
          for (var r9 = [], i9 = 0, t8 = n8; i9 < t8.length; i9++) {
            var o8 = t8[i9];
            if (!o8.ok)
              return o8;
            r9.push(o8.val);
          }
          return new Qn(r9);
        }, n7.any = function() {
          for (var n8 = [], e6 = 0; e6 < arguments.length; e6++)
            n8[e6] = arguments[e6];
          for (var r9 = [], i9 = 0, t8 = n8; i9 < t8.length; i9++) {
            var o8 = t8[i9];
            if (o8.ok)
              return o8;
            r9.push(o8.val);
          }
          return new Yn(r9);
        }, n7.wrap = function(n8) {
          try {
            return new Qn(n8());
          } catch (n9) {
            return new Yn(n9);
          }
        }, n7.wrapAsync = function(n8) {
          try {
            return n8().then(function(n9) {
              return new Qn(n9);
            }).catch(function(n9) {
              return new Yn(n9);
            });
          } catch (n9) {
            return Promise.resolve(new Yn(n9));
          }
        }, n7.isResult = function(n8) {
          return n8 instanceof Yn || n8 instanceof Qn;
        };
      }(On || (On = {}));
      const Pn = (n7, e6 = false) => {
        if (null == n7 ? void 0 : n7.email)
          return Qn(n7.email);
        const r9 = { emailError: new K3.InvalidEmailError(), email: null == n7 ? void 0 : n7.email };
        return Yn(e6 ? hn.state(r9) : hn.navigate(tn.Start, r9));
      }, Zn = (n7) => n7.user ? Qn(void 0) : Yn(hn.navigate(tn.Start, { emailError: new K3.UnknownError(), email: n7.userState.email })), Un = async (n7, e6) => {
        const r9 = await n7.initLoginWithEmailLink(e6);
        return r9.ok ? hn.navigate(tn.EmailLinkSent, { email: e6 }) : hn.state({ emailError: r9.val, email: e6 });
      }, Wn = async (n7, e6, r9) => "emailLink" === e6.verificationMethod ? await Un(n7, r9) : await (async (n8, e7) => {
        const r10 = await n8.initLoginWithEmailOTP(e7);
        return r10.ok ? hn.navigate(tn.EmailOTPVerification, { email: e7 }) : hn.state({ emailError: r10.val, email: e7 });
      })(n7, r9), Gn = async (n7, e6) => {
        if (!n7.shouldAppendPasskey)
          return hn.navigate(tn.End);
        const r9 = await n7.corbadoApp.authService.authMethods(e6);
        return r9.err ? void 0 : r9.val.selectedMethods.includes("webauthn") ? hn.navigate(tn.End, { email: e6 }) : (localStorage.setItem(Mn, Date.now().toString()), hn.navigate(tn.PasskeyAppend, { email: e6 }));
      }, Hn = async (n7, e6, r9) => {
        const i9 = { email: r9 }, t8 = await n7.loginWithPasskey(r9);
        return t8.ok ? hn.navigate(tn.End, i9) : t8.val instanceof K3.UnknownUserError ? hn.navigate(tn.Start, { ...i9, emailError: t8.val }) : t8.val instanceof K3.NoPasskeyAvailableError || t8.val instanceof K3.PasskeyChallengeCancelledError || !e6.retryPasskeyOnError ? Wn(n7, e6, r9) : hn.navigate(tn.PasskeyError, { ...i9, lastPasskeyRetryTimeStamp: Date.now() });
      }, Rn = async (n7, e6) => (await n7.appendPasskey()).ok || !e6 ? hn.navigate(tn.End) : hn.navigate(tn.PasskeyError, { lastPasskeyRetryTimeStamp: Date.now() }), Vn = { [tn.Start]: async (n7, e6, r9) => {
        switch (e6) {
          case on.ChangeFlow:
            return hn.changeFlow(nn.SignUp);
          case on.PrimaryButton: {
            const e7 = Pn(null == r9 ? void 0 : r9.userStateUpdate, true);
            if (e7.err)
              return e7.val;
            const i9 = e7.val;
            return n7.passkeysSupported ? Hn(n7.corbadoApp.authService, n7.flowOptions, i9) : await Wn(n7.corbadoApp.authService, n7.flowOptions, i9);
          }
          case on.InitConditionalUI:
            return (async (n8) => {
              if (!n8.passkeysSupported)
                return hn.ignore();
              const e7 = await n8.corbadoApp.authService.loginWithConditionalUI();
              return e7.ok ? hn.navigate(tn.End) : e7.val instanceof K3.PasskeyChallengeCancelledError ? hn.ignore() : e7.val instanceof K3.InvalidPasskeyError || e7.val instanceof K3.ConditionalUiUnconfirmedCredential ? hn.state({ emailError: e7.val }) : hn.ignore();
            })(n7);
        }
      }, [tn.EmailOTPVerification]: async (n7, e6, r9) => {
        const i9 = Pn(n7.userState);
        if (i9.err)
          return i9.val;
        const t8 = i9.val;
        switch (e6) {
          case on.PrimaryButton: {
            const e7 = await (async (n8, e8, r10) => {
              if (!r10 || 6 !== r10.length)
                return Yn(hn.state({ ...e8, verificationError: new K3.InvalidOtpInputError() }));
              const i10 = await n8.completeLoginWithEmailOTP(r10);
              return i10.ok ? Qn(void 0) : i10.val instanceof K3.InvalidOtpInputError ? Yn(hn.state({ ...e8, verificationError: i10.val })) : Yn(hn.state({ ...e8, verificationError: new K3.UnknownError() }));
            })(n7.corbadoApp.authService, n7.userState, null == r9 ? void 0 : r9.verificationCode);
            return e7.err ? e7.val : Gn(n7, t8);
          }
          case on.SecondaryButton:
            return;
          case on.CancelOTP:
            return hn.navigate(tn.Start, { email: t8 });
        }
        return hn.state({});
      }, [tn.EmailLinkSent]: (n7, e6) => {
        const r9 = Pn(n7.userState);
        if (r9.err)
          return r9.val;
        const i9 = r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return (async (n8, e7) => {
              const r10 = await Un(n8, e7);
              return null != r10 ? r10 : hn.navigate(tn.EmailLinkSent, { emailError: new K3.UnknownError(), email: e7 });
            })(n7.corbadoApp.authService, i9);
          case on.CancelEmailLink:
            return hn.navigate(tn.Start);
        }
      }, [tn.EmailLinkVerification]: async (n7, e6) => {
        var r9, i9;
        switch (e6) {
          case on.VerifyLink: {
            const e7 = await (async (n8, e8) => {
              const r10 = await n8.completeLoginWithEmailLink(), i10 = window.location.origin + window.location.pathname;
              return history.pushState({}, "", i10), r10.ok ? Qn(void 0) : r10.val instanceof K3.InvalidTokenInputError ? Yn(hn.state({ ...e8, verificationError: r10.val })) : Yn(hn.state({ ...e8, verificationError: new K3.UnknownError() }));
            })(n7.corbadoApp.authService, n7.userState);
            return e7.err ? e7.val : Gn(n7, null !== (i9 = null === (r9 = n7.user) || void 0 === r9 ? void 0 : r9.email) && void 0 !== i9 ? i9 : "");
          }
          case on.CancelEmailLink:
            return window.location.search = "", hn.navigate(tn.Start);
        }
        return hn.state({});
      }, [tn.PasskeyAppend]: async (n7, e6) => {
        const r9 = Zn(n7);
        if (r9.err)
          return r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return await Rn(n7.corbadoApp.authService, n7.flowOptions.retryPasskeyOnError);
          case on.SecondaryButton:
            return Promise.resolve(hn.navigate(tn.End));
          case on.ShowBenefits:
            return Promise.resolve(hn.navigate(tn.PasskeyBenefits));
        }
        return Promise.resolve(void 0);
      }, [tn.PasskeyError]: async (n7, e6) => {
        switch (e6) {
          case on.PrimaryButton: {
            if (n7.user)
              return await Rn(n7.corbadoApp.authService, n7.flowOptions.retryPasskeyOnError);
            const e7 = Pn(n7.userState);
            if (e7.err)
              return e7.val;
            const r9 = e7.val;
            return await Hn(n7.corbadoApp.authService, n7.flowOptions, r9);
          }
          case on.SecondaryButton: {
            if (n7.user)
              return hn.navigate(tn.End);
            const e7 = Pn(n7.userState);
            if (e7.err)
              return e7.val;
            const r9 = e7.val;
            return await Wn(n7.corbadoApp.authService, n7.flowOptions, r9);
          }
          case on.CancelPasskey:
            return hn.navigate(tn.End);
        }
        return hn.state({});
      }, [tn.PasskeyBenefits]: async (n7, e6) => {
        const r9 = Zn(n7);
        if (r9.err)
          return r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return await Rn(n7.corbadoApp.authService, n7.flowOptions.retryPasskeyOnError);
          case on.SecondaryButton:
            return hn.navigate(tn.End);
        }
      } }, Fn = (n7, e6 = false) => {
        let r9 = {};
        return (null == n7 ? void 0 : n7.email) || (r9 = { emailError: new K3.InvalidEmailError() }), (null == n7 ? void 0 : n7.fullName) || (r9 = { ...r9, userNameError: new K3.InvalidFullnameError() }), (null == n7 ? void 0 : n7.email) && n7.fullName ? Qn({ email: n7.email, fullName: n7.fullName }) : (r9 = { ...r9, email: null == n7 ? void 0 : n7.email, fullName: null == n7 ? void 0 : n7.fullName }, Yn(e6 ? hn.state(r9) : hn.navigate(tn.Start, r9)));
      }, Jn = (n7) => n7.user ? Qn(void 0) : Yn(hn.navigate(tn.Start, { emailError: new K3.UnknownError(), fullName: n7.userState.fullName, email: n7.userState.email })), Xn = async (n7, e6, r9) => {
        const i9 = await n7.authService.userExists(e6);
        return i9.err ? Yn(hn.state({ email: e6, fullName: r9, emailError: new K3.UnknownError() })) : i9.val ? Yn(hn.state({ email: e6, fullName: r9, emailError: new K3.UserAlreadyExistsError() })) : Qn(void 0);
      }, _n = async (n7, e6, r9) => {
        const i9 = await n7.authService.initLoginWithEmailLink(e6);
        return i9.ok ? hn.ignore() : hn.navigate(tn.Start, { email: e6, fullName: r9, emailError: i9.val });
      }, Kn = async (n7, e6, r9, i9, t8 = false) => {
        let o8;
        if (o8 = "emailLink" === e6.verificationMethod ? await (async (n8, e7, r10) => {
          const i10 = await n8.authService.initSignUpWithEmailLink(e7, r10);
          return i10.ok ? hn.navigate(tn.EmailLinkSent, { email: e7, fullName: r10 }) : hn.navigate(tn.Start, { email: e7, fullName: r10, emailError: i10.val });
        })(n7, r9, i9) : await (async (n8, e7, r10) => {
          const i10 = await n8.authService.initSignUpWithEmailOTP(e7, r10);
          return i10.ok ? hn.navigate(tn.EmailOTPVerification, { email: e7, fullName: r10 }) : hn.navigate(tn.Start, { email: e7, fullName: r10, emailError: i10.val });
        })(n7, r9, i9), o8)
          return o8;
        const a8 = { email: r9, fullName: i9, emailError: new K3.UnknownError() };
        return t8 ? hn.state(a8) : hn.navigate(tn.Start, a8);
      }, qn = async (n7, e6, r9) => {
        if (!r9 || 6 !== r9.length)
          return Yn(hn.state({ ...e6, verificationError: new K3.InvalidOtpInputError() }));
        const i9 = await n7.authService.completeSignupWithEmailOTP(r9);
        return i9.ok ? Qn(void 0) : i9.val instanceof K3.InvalidOtpInputError ? Yn(hn.state({ ...e6, verificationError: i9.val })) : Yn(hn.state({ ...e6, verificationError: new K3.UnknownError() }));
      }, $n = async (n7, e6, r9) => {
        const i9 = await n7.authService.signUpWithPasskey(e6, r9);
        return i9.ok ? Qn(hn.navigate(tn.PasskeySuccess)) : i9.val instanceof K3.UserAlreadyExistsError ? Qn(hn.navigate(tn.Start, { email: e6, fullName: r9, emailError: i9.val })) : i9;
      }, ne3 = (n7) => n7 ? (localStorage.setItem(Mn, Date.now().toString()), hn.navigate(tn.PasskeyAppend)) : hn.navigate(tn.End), ee3 = async (n7, e6) => (await n7.authService.appendPasskey()).ok ? hn.navigate(tn.PasskeySuccess) : e6 ? hn.navigate(tn.PasskeyError, { lastPasskeyRetryTimeStamp: Date.now() }) : hn.navigate(tn.End), re3 = { [tn.Start]: async (n7, e6, r9) => {
        switch (e6) {
          case on.ChangeFlow:
            return hn.changeFlow(nn.Login);
          case on.PrimaryButton: {
            const e7 = Fn(null == r9 ? void 0 : r9.userStateUpdate, true);
            if (e7.err)
              return e7.val;
            const { email: i9, fullName: t8 } = e7.val, o8 = await Xn(n7.corbadoApp, i9, t8);
            return o8.err ? o8.val : n7.passkeysSupported ? hn.navigate(tn.PasskeyCreate, { ...null == r9 ? void 0 : r9.userStateUpdate }) : await Kn(n7.corbadoApp, n7.flowOptions, i9, t8, true);
          }
        }
      }, [tn.PasskeyCreate]: async (n7, e6) => {
        const r9 = Fn(n7.userState);
        if (r9.err)
          return r9.val;
        const { email: i9, fullName: t8 } = r9.val;
        switch (e6) {
          case on.ShowBenefits:
            return hn.navigate(tn.PasskeyBenefits);
          case on.PrimaryButton: {
            const e7 = await $n(n7.corbadoApp, i9, t8);
            return e7.ok ? e7.val : n7.flowOptions.retryPasskeyOnError ? hn.navigate(tn.PasskeyError, { ...n7.userState, lastPasskeyRetryTimeStamp: Date.now() }) : await Kn(n7.corbadoApp, n7.flowOptions, i9, t8);
          }
          case on.SecondaryButton:
            return await Kn(n7.corbadoApp, n7.flowOptions, i9, t8);
        }
      }, [tn.EmailOTPVerification]: async (n7, e6, r9) => {
        const i9 = Fn(n7.userState);
        if (i9.err)
          return i9.val;
        switch (e6) {
          case on.PrimaryButton: {
            const e7 = await qn(n7.corbadoApp, n7.userState, null == r9 ? void 0 : r9.verificationCode);
            return e7.err ? e7.val : ne3(n7.shouldAppendPasskey);
          }
          case on.SecondaryButton:
            return;
          case on.CancelOTP:
            return hn.navigate(tn.Start);
        }
      }, [tn.EmailLinkSent]: (n7, e6) => {
        const r9 = Fn(n7.userState);
        if (r9.err)
          return r9.val;
        const { email: i9, fullName: t8 } = r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return _n(n7.corbadoApp, i9, t8);
          case on.CancelEmailLink:
            return hn.navigate(tn.Start);
        }
      }, [tn.EmailLinkVerification]: () => hn.state({}), [tn.PasskeyAppend]: async (n7, e6) => {
        const r9 = Jn(n7);
        if (r9.err)
          return r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return await ee3(n7.corbadoApp, n7.flowOptions.retryPasskeyOnError);
          case on.SecondaryButton:
            return hn.navigate(tn.End);
          case on.ShowBenefits:
            return hn.navigate(tn.PasskeyBenefits);
        }
      }, [tn.PasskeyBenefits]: async (n7, e6) => {
        const r9 = Fn(n7.userState);
        if (r9.err)
          return r9.val;
        const { email: i9, fullName: t8 } = r9.val;
        switch (e6) {
          case on.PrimaryButton: {
            if (n7.user)
              return await ee3(n7.corbadoApp, n7.flowOptions.retryPasskeyOnError);
            const e7 = await $n(n7.corbadoApp, i9, t8);
            return e7.ok ? e7.val : n7.flowOptions.retryPasskeyOnError ? hn.navigate(tn.PasskeyError, { ...n7.userState, lastPasskeyRetryTimeStamp: Date.now() }) : await Kn(n7.corbadoApp, n7.flowOptions, i9, t8);
          }
          case on.SecondaryButton:
            return n7.user ? hn.navigate(tn.End) : await Kn(n7.corbadoApp, n7.flowOptions, i9, t8);
        }
      }, [tn.PasskeySuccess]: (n7, e6) => e6 === on.PrimaryButton ? Promise.resolve(hn.navigate(tn.End)) : Promise.resolve(void 0), [tn.PasskeyError]: async (n7, e6) => {
        const r9 = Fn(n7.userState);
        if (r9.err)
          return r9.val;
        const { email: i9, fullName: t8 } = r9.val;
        switch (e6) {
          case on.ShowBenefits:
            return hn.navigate(tn.PasskeyBenefits);
          case on.PrimaryButton: {
            const e7 = await $n(n7.corbadoApp, i9, t8);
            return e7.ok ? e7.val : hn.state({ ...n7.userState, lastPasskeyRetryTimeStamp: Date.now() });
          }
          case on.SecondaryButton:
            return await Kn(n7.corbadoApp, n7.flowOptions, i9, t8);
          case on.CancelPasskey:
            return hn.navigate(tn.End);
        }
      } }, ie4 = { [tn.Start]: async (n7, e6, r9) => {
        switch (e6) {
          case on.ChangeFlow:
            return hn.changeFlow(nn.Login);
          case on.PrimaryButton: {
            const e7 = Fn(null == r9 ? void 0 : r9.userStateUpdate, true);
            if (e7.err)
              return e7.val;
            const { email: i9, fullName: t8 } = e7.val, o8 = await Xn(n7.corbadoApp, i9, t8);
            return o8.err ? o8.val : await Kn(n7.corbadoApp, n7.flowOptions, i9, t8, true);
          }
        }
      }, [tn.EmailOTPVerification]: async (n7, e6, r9) => {
        const i9 = Fn(n7.userState);
        if (i9.err)
          return i9.val;
        switch (e6) {
          case on.PrimaryButton: {
            const e7 = await qn(n7.corbadoApp, n7.userState, null == r9 ? void 0 : r9.verificationCode);
            return e7.err ? e7.val : ne3(n7.shouldAppendPasskey);
          }
          case on.CancelOTP:
            return hn.navigate(tn.Start);
        }
      }, [tn.EmailLinkSent]: (n7, e6) => {
        const r9 = Fn(n7.userState);
        if (r9.err)
          return r9.val;
        const { email: i9, fullName: t8 } = r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return _n(n7.corbadoApp, i9, t8);
          case on.CancelEmailLink:
            return hn.navigate(tn.Start);
        }
      }, [tn.EmailLinkVerification]: () => hn.state({}), [tn.PasskeyAppend]: async (n7, e6) => {
        const r9 = Jn(n7);
        if (r9.err)
          return r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return await ee3(n7.corbadoApp, n7.flowOptions.retryPasskeyOnError);
          case on.SecondaryButton:
            return hn.navigate(tn.End);
          case on.ShowBenefits:
            return hn.navigate(tn.PasskeyBenefits);
        }
      }, [tn.PasskeyBenefits]: async (n7, e6) => {
        const r9 = Jn(n7);
        if (r9.err)
          return r9.val;
        switch (e6) {
          case on.PrimaryButton:
            return await ee3(n7.corbadoApp, n7.flowOptions.retryPasskeyOnError);
          case on.SecondaryButton:
            return hn.navigate(tn.End);
        }
      }, [tn.PasskeySuccess]: (n7, e6) => e6 === on.PrimaryButton ? Promise.resolve(hn.navigate(tn.End)) : Promise.resolve(void 0), [tn.PasskeyError]: async (n7, e6) => {
        const r9 = Jn(n7);
        if (r9.err)
          return r9.val;
        switch (e6) {
          case on.ShowBenefits:
            return hn.navigate(tn.PasskeyBenefits);
          case on.PrimaryButton:
            return await ee3(n7.corbadoApp, n7.flowOptions.retryPasskeyOnError);
          case on.CancelPasskey:
            return hn.navigate(tn.End);
        }
      } }, te3 = { [en.PasskeySignupWithFallback]: re3, [en.SignupWithPasskeyAppend]: ie4, [rn.PasskeyLoginWithFallback]: Vn };
      var oe3, ae3, Me3, se4, ce3, Ae3, le3, ue3, Ie3, Ne3;
      class ge3 {
        constructor(n7) {
          if (oe3.add(this), ae3.set(this, void 0), Me3.set(this, void 0), se4.set(this, void 0), ce3.set(this, void 0), Ae3.set(this, void 0), le3.set(this, []), ue3.set(this, []), !n7)
            throw new Error("corbadoApp is undefined. This should not happen.");
          _4(this, Ae3, n7, "f"), _4(this, Me3, [], "f");
        }
        async init(n7, e6, r9) {
          let i9 = r9;
          const t8 = await X4(this, Ae3, "f").projectService.getProjectConfig();
          if (t8.err)
            return;
          const o8 = t8.val;
          o8.allowUserRegistration || (r9 === nn.SignUp ? X4(this, Ae3, "f").globalErrors.next(K3.NonRecoverableError.userRegistrationNotAllowed()) : i9 = nn.Login), _4(this, se4, new zn(e6, o8, i9), "f"), _4(this, ae3, X4(this, se4, "f").initialScreenName, "f");
          const a8 = await H3();
          _4(this, ce3, new kn(X4(this, se4, "f").flowOptions, a8, X4(this, se4, "f").passkeyAppendInterval, X4(this, Ae3, "f"), n7), "f"), X4(this, oe3, "m", Ie3).call(this);
        }
        dispose() {
          X4(this, Ae3, "f").dispose();
        }
        get currentScreenName() {
          return X4(this, ae3, "f");
        }
        get currentFlowName() {
          return X4(this, se4, "f").flowName;
        }
        get currentFlowTypeText() {
          return X4(this, se4, "f").flowType === nn.SignUp ? "signup" : "login";
        }
        get currentVerificationMethod() {
          return X4(this, se4, "f").verificationMethod;
        }
        get userNameRequired() {
          return X4(this, se4, "f").userNameRequired;
        }
        get allowUserRegistration() {
          return X4(this, se4, "f").allowUserRegistration;
        }
        onFlowChange(n7) {
          return X4(this, le3, "f").push(n7) - 1;
        }
        removeOnFlowChangeCallback(n7) {
          X4(this, le3, "f").splice(n7, 1);
        }
        onUserStateChange(n7) {
          return X4(this, ue3, "f").push(n7) - 1;
        }
        removeOnUserStateChange(n7) {
          X4(this, ue3, "f").splice(n7, 1);
        }
        async handleStateUpdate(n7, e6) {
          if (!X4(this, ce3, "f"))
            throw new Error("FlowHandler is not initialized");
          const r9 = te3[X4(this, se4, "f").flowName][X4(this, ae3, "f")];
          if (!r9)
            throw new Error("Invalid screen");
          const i9 = await r9(X4(this, ce3, "f"), n7, e6);
          if (i9 && null !== (null == i9 ? void 0 : i9.nextFlow) && X4(this, oe3, "m", Ie3).call(this, i9.nextFlow), (null == i9 ? void 0 : i9.stateUpdate) && X4(this, oe3, "m", Ne3).call(this, { userState: i9.stateUpdate }), null == i9 ? void 0 : i9.nextScreen) {
            if (i9.nextScreen === tn.End)
              return X4(this, ce3, "f").corbadoApp.clearGlobalErrors(), void X4(this, se4, "f").onLoggedIn();
            X4(this, Me3, "f").push(X4(this, ae3, "f")), _4(this, ae3, i9.nextScreen, "f"), X4(this, le3, "f").forEach((n8) => n8({ screenName: X4(this, ae3, "f") }));
          }
        }
        navigateBack() {
          return X4(this, Me3, "f").length ? (_4(this, ae3, X4(this, Me3, "f").pop() || tn.Start, "f"), X4(this, le3, "f").forEach((n7) => n7({ screenName: X4(this, ae3, "f") })), X4(this, ae3, "f")) : tn.Start;
        }
        update(n7) {
          X4(this, oe3, "m", Ne3).call(this, { user: n7 });
        }
      }
      ae3 = /* @__PURE__ */ new WeakMap(), Me3 = /* @__PURE__ */ new WeakMap(), se4 = /* @__PURE__ */ new WeakMap(), ce3 = /* @__PURE__ */ new WeakMap(), Ae3 = /* @__PURE__ */ new WeakMap(), le3 = /* @__PURE__ */ new WeakMap(), ue3 = /* @__PURE__ */ new WeakMap(), oe3 = /* @__PURE__ */ new WeakSet(), Ie3 = function(n7, e6) {
        void 0 !== n7 && X4(this, se4, "f").update(n7);
        const r9 = X4(this, se4, "f").flowName, i9 = X4(this, se4, "f").flowOptions, t8 = e6 || X4(this, se4, "f").initialScreenName;
        return X4(this, oe3, "m", Ne3).call(this, { flowOptions: i9 }), _4(this, ae3, t8, "f"), _4(this, Me3, [], "f"), X4(this, le3, "f").forEach((n8) => n8({ flowName: r9, flowType: this.currentFlowTypeText, verificationMethod: this.currentVerificationMethod, screenName: t8 })), t8;
      }, Ne3 = function(n7) {
        if (!X4(this, ce3, "f"))
          throw new Error("FlowHandler is not initialized");
        X4(this, ce3, "f").update(n7), X4(this, ue3, "f").forEach((n8) => n8(X4(this, ce3, "f").userState));
      };
      const ye3 = { en: f5, de: h6 }, de3 = { deleteIcon: L5, passkeyDefaultIcon: x4, yahooIcon: k4, gmailIcon: z3, outlookIcon: T2, fingerprintIcon: E6, cancelIcon: m5, logoIcon: p5 };
    })();
    o3 = t3.BN;
    a4 = t3.c0;
    M3 = t3.LK;
    s4 = t3.MK;
    c4 = t3.$Y;
    A3 = t3.GV;
    l5 = t3.zC;
    u4 = t3.d;
    I2 = t3.Ll;
    N3 = t3.mX;
    g5 = t3.HN;
    y5 = t3.O$;
    d4 = t3.KD;
    j2 = t3.XF;
    b3 = t3.ag;
    D2 = t3.yJ;
    w4 = t3.cM;
    C3 = t3.pA;
    m3 = t3.$Q;
    L3 = t3.xi;
    E4 = t3.n_;
    z = t3.jL;
  }
});

// node_modules/i18next/dist/esm/i18next.js
function defer2() {
  let res;
  let rej;
  const promise = new Promise((resolve2, reject) => {
    res = resolve2;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a7, s9, t8) {
  a7.forEach((m5) => {
    if (s9[m5])
      t8[m5] = s9[m5];
  });
}
function getLastOfPath(object, path2, Empty) {
  function cleanKey(key3) {
    return key3 && key3.indexOf("###") > -1 ? key3.replace(/###/g, ".") : key3;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  const stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    const key3 = cleanKey(stack.shift());
    if (!object[key3] && Empty)
      object[key3] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key3)) {
      object = object[key3];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path2, newValue) {
  const {
    obj,
    k: k4
  } = getLastOfPath(object, path2, Object);
  obj[k4] = newValue;
}
function pushPath(object, path2, newValue, concat4) {
  const {
    obj,
    k: k4
  } = getLastOfPath(object, path2, Object);
  obj[k4] = obj[k4] || [];
  if (concat4)
    obj[k4] = obj[k4].concat(newValue);
  if (!concat4)
    obj[k4].push(newValue);
}
function getPath(object, path2) {
  const {
    obj,
    k: k4
  } = getLastOfPath(object, path2);
  if (!obj)
    return void 0;
  return obj[k4];
}
function getPathWithDefaults(data, defaultData, key3) {
  const value = getPath(data, key3);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key3);
}
function deepExtend(target, source2, overwrite) {
  for (const prop in source2) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source2[prop] === "string" || source2[prop] instanceof String) {
          if (overwrite)
            target[prop] = source2[prop];
        } else {
          deepExtend(target[prop], source2[prop], overwrite);
        }
      } else {
        target[prop] = source2[prop];
      }
    }
  }
  return target;
}
function regexEscape(str2) {
  return str2.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function escape4(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, (s9) => _entityMap[s9]);
  }
  return data;
}
function looksLikeObjectPath(key3, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars3.filter((c8) => nsSeparator.indexOf(c8) < 0 && keySeparator.indexOf(c8) < 0);
  if (possibleChars.length === 0)
    return true;
  const r8 = new RegExp(`(${possibleChars.map((c8) => c8 === "?" ? "\\?" : c8).join("|")})`);
  let matched = !r8.test(key3);
  if (!matched) {
    const ki = key3.indexOf(keySeparator);
    if (ki > 0 && !r8.test(key3.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path2])
    return obj[path2];
  const paths = path2.split(keySeparator);
  let current = obj;
  for (let i9 = 0; i9 < paths.length; ++i9) {
    if (!current)
      return void 0;
    if (typeof current[paths[i9]] === "string" && i9 + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i9]] === void 0) {
      let j4 = 2;
      let p5 = paths.slice(i9, i9 + j4).join(keySeparator);
      let mix = current[p5];
      while (mix === void 0 && paths.length > i9 + j4) {
        j4++;
        p5 = paths.slice(i9, i9 + j4).join(keySeparator);
        mix = current[p5];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path2.endsWith(p5)) {
        if (typeof mix === "string")
          return mix;
        if (p5 && typeof mix[p5] === "string")
          return mix[p5];
      }
      const joinedPath = paths.slice(i9 + j4).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i9]];
  }
  return current;
}
function getCleanedCode(code) {
  if (code && code.indexOf("_") > 0)
    return code.replace("_", "-");
  return code;
}
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function createRules() {
  const rules2 = {};
  sets.forEach((set2) => {
    set2.lngs.forEach((l7) => {
      rules2[l7] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules2;
}
function deepFindWithDefaults(data, defaultData, key3) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key3);
  if (!path2 && ignoreJSONStructure && typeof key3 === "string") {
    path2 = deepFind(data, key3, keySeparator);
    if (path2 === void 0)
      path2 = deepFind(defaultData, key3, keySeparator);
  }
  return path2;
}
function parseFormatStr(formatStr) {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p5 = formatStr.split("(");
    formatName = p5[0].toLowerCase().trim();
    const optStr = p5[1].substring(0, p5[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (!opt)
          return;
        const [key3, ...rest] = opt.split(":");
        const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key3.trim()])
          formatOptions[key3.trim()] = val;
        if (val === "false")
          formatOptions[key3.trim()] = false;
        if (val === "true")
          formatOptions[key3.trim()] = true;
        if (!isNaN(val))
          formatOptions[key3.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  const cache = {};
  return function invokeFormatter(val, lng, options3) {
    const key3 = lng + JSON.stringify(options3);
    let formatter = cache[key3];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options3);
      cache[key3] = formatter;
    }
    return formatter(val);
  };
}
function removePending(q4, name2) {
  if (q4.pending[name2] !== void 0) {
    delete q4.pending[name2];
    q4.pendingCount--;
  }
}
function get3() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      let ret = {};
      if (typeof args[1] === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options3 = args[3] || args[2];
        Object.keys(options3).forEach((key3) => {
          ret[key3] = options3[key3];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value, format, lng, options3) => value,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options3) {
  if (typeof options3.ns === "string")
    options3.ns = [options3.ns];
  if (typeof options3.fallbackLng === "string")
    options3.fallbackLng = [options3.fallbackLng];
  if (typeof options3.fallbackNS === "string")
    options3.fallbackNS = [options3.fallbackNS];
  if (options3.supportedLngs && options3.supportedLngs.indexOf("cimode") < 0) {
    options3.supportedLngs = options3.supportedLngs.concat(["cimode"]);
  }
  return options3;
}
function noop3() {
}
function bindMemberFunctions(inst) {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var consoleLogger, Logger, baseLogger, EventEmitter, _entityMap, chars3, ResourceStore, postProcessor, checkedLoadedFor, Translator, LanguageUtil, sets, _rulesPluralsTypes, nonIntlVersions, intlVersions, suffixesOrder, PluralResolver, Interpolator, Formatter, Connector, I18n, instance, createInstance, dir, init2, loadResources, reloadResources, use2, changeLanguage, getFixedT, t4, exists, setDefaultNamespace, hasLoadedNamespace, loadNamespaces, loadLanguages;
var init_i18next = __esm({
  "node_modules/i18next/dist/esm/i18next.js"() {
    consoleLogger = {
      type: "logger",
      log(args) {
        this.output("log", args);
      },
      warn(args) {
        this.output("warn", args);
      },
      error(args) {
        this.output("error", args);
      },
      output(type, args) {
        if (console && console[type])
          console[type].apply(console, args);
      }
    };
    Logger = class _Logger {
      constructor(concreteLogger) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.init(concreteLogger, options3);
      }
      init(concreteLogger) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.prefix = options3.prefix || "i18next:";
        this.logger = concreteLogger || consoleLogger;
        this.options = options3;
        this.debug = options3.debug;
      }
      log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.forward(args, "log", "", true);
      }
      warn() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this.forward(args, "warn", "", true);
      }
      error() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this.forward(args, "error", "");
      }
      deprecate() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
      }
      forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug)
          return null;
        if (typeof args[0] === "string")
          args[0] = `${prefix}${this.prefix} ${args[0]}`;
        return this.logger[lvl](args);
      }
      create(moduleName) {
        return new _Logger(this.logger, {
          ...{
            prefix: `${this.prefix}:${moduleName}:`
          },
          ...this.options
        });
      }
      clone(options3) {
        options3 = options3 || this.options;
        options3.prefix = options3.prefix || this.prefix;
        return new _Logger(this.logger, options3);
      }
    };
    baseLogger = new Logger();
    EventEmitter = class {
      constructor() {
        this.observers = {};
      }
      on(events, listener) {
        events.split(" ").forEach((event) => {
          this.observers[event] = this.observers[event] || [];
          this.observers[event].push(listener);
        });
        return this;
      }
      off(event, listener) {
        if (!this.observers[event])
          return;
        if (!listener) {
          delete this.observers[event];
          return;
        }
        this.observers[event] = this.observers[event].filter((l7) => l7 !== listener);
      }
      emit(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (this.observers[event]) {
          const cloned = [].concat(this.observers[event]);
          cloned.forEach((observer) => {
            observer(...args);
          });
        }
        if (this.observers["*"]) {
          const cloned = [].concat(this.observers["*"]);
          cloned.forEach((observer) => {
            observer.apply(observer, [event, ...args]);
          });
        }
      }
    };
    _entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;"
    };
    chars3 = [" ", ",", "?", "!", ";"];
    ResourceStore = class extends EventEmitter {
      constructor(data) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          ns: ["translation"],
          defaultNS: "translation"
        };
        super();
        this.data = data || {};
        this.options = options3;
        if (this.options.keySeparator === void 0) {
          this.options.keySeparator = ".";
        }
        if (this.options.ignoreJSONStructure === void 0) {
          this.options.ignoreJSONStructure = true;
        }
      }
      addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
          this.options.ns.push(ns);
        }
      }
      removeNamespaces(ns) {
        const index7 = this.options.ns.indexOf(ns);
        if (index7 > -1) {
          this.options.ns.splice(index7, 1);
        }
      }
      getResource(lng, ns, key3) {
        let options3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const keySeparator = options3.keySeparator !== void 0 ? options3.keySeparator : this.options.keySeparator;
        const ignoreJSONStructure = options3.ignoreJSONStructure !== void 0 ? options3.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let path2 = [lng, ns];
        if (key3 && typeof key3 !== "string")
          path2 = path2.concat(key3);
        if (key3 && typeof key3 === "string")
          path2 = path2.concat(keySeparator ? key3.split(keySeparator) : key3);
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
        }
        const result = getPath(this.data, path2);
        if (result || !ignoreJSONStructure || typeof key3 !== "string")
          return result;
        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key3, keySeparator);
      }
      addResource(lng, ns, key3, value) {
        let options3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
          silent: false
        };
        const keySeparator = options3.keySeparator !== void 0 ? options3.keySeparator : this.options.keySeparator;
        let path2 = [lng, ns];
        if (key3)
          path2 = path2.concat(keySeparator ? key3.split(keySeparator) : key3);
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
          value = ns;
          ns = path2[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path2, value);
        if (!options3.silent)
          this.emit("added", lng, ns, key3, value);
      }
      addResources(lng, ns, resources) {
        let options3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
          silent: false
        };
        for (const m5 in resources) {
          if (typeof resources[m5] === "string" || Object.prototype.toString.apply(resources[m5]) === "[object Array]")
            this.addResource(lng, ns, m5, resources[m5], {
              silent: true
            });
        }
        if (!options3.silent)
          this.emit("added", lng, ns, resources);
      }
      addResourceBundle(lng, ns, resources, deep, overwrite) {
        let options3 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
          silent: false
        };
        let path2 = [lng, ns];
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
          deep = resources;
          resources = ns;
          ns = path2[1];
        }
        this.addNamespaces(ns);
        let pack = getPath(this.data, path2) || {};
        if (deep) {
          deepExtend(pack, resources, overwrite);
        } else {
          pack = {
            ...pack,
            ...resources
          };
        }
        setPath(this.data, path2, pack);
        if (!options3.silent)
          this.emit("added", lng, ns, resources);
      }
      removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
          delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit("removed", lng, ns);
      }
      hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== void 0;
      }
      getResourceBundle(lng, ns) {
        if (!ns)
          ns = this.options.defaultNS;
        if (this.options.compatibilityAPI === "v1")
          return {
            ...{},
            ...this.getResource(lng, ns)
          };
        return this.getResource(lng, ns);
      }
      getDataByLanguage(lng) {
        return this.data[lng];
      }
      hasLanguageSomeTranslations(lng) {
        const data = this.getDataByLanguage(lng);
        const n7 = data && Object.keys(data) || [];
        return !!n7.find((v5) => data[v5] && Object.keys(data[v5]).length > 0);
      }
      toJSON() {
        return this.data;
      }
    };
    postProcessor = {
      processors: {},
      addPostProcessor(module2) {
        this.processors[module2.name] = module2;
      },
      handle(processors, value, key3, options3, translator) {
        processors.forEach((processor) => {
          if (this.processors[processor])
            value = this.processors[processor].process(value, key3, options3, translator);
        });
        return value;
      }
    };
    checkedLoadedFor = {};
    Translator = class _Translator extends EventEmitter {
      constructor(services) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super();
        copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
        this.options = options3;
        if (this.options.keySeparator === void 0) {
          this.options.keySeparator = ".";
        }
        this.logger = baseLogger.create("translator");
      }
      changeLanguage(lng) {
        if (lng)
          this.language = lng;
      }
      exists(key3) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
        };
        if (key3 === void 0 || key3 === null) {
          return false;
        }
        const resolved = this.resolve(key3, options3);
        return resolved && resolved.res !== void 0;
      }
      extractFromKey(key3, options3) {
        let nsSeparator = options3.nsSeparator !== void 0 ? options3.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === void 0)
          nsSeparator = ":";
        const keySeparator = options3.keySeparator !== void 0 ? options3.keySeparator : this.options.keySeparator;
        let namespaces = options3.ns || this.options.defaultNS || [];
        const wouldCheckForNsInKey = nsSeparator && key3.indexOf(nsSeparator) > -1;
        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options3.keySeparator && !this.options.userDefinedNsSeparator && !options3.nsSeparator && !looksLikeObjectPath(key3, nsSeparator, keySeparator);
        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
          const m5 = key3.match(this.interpolator.nestingRegexp);
          if (m5 && m5.length > 0) {
            return {
              key: key3,
              namespaces
            };
          }
          const parts = key3.split(nsSeparator);
          if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
            namespaces = parts.shift();
          key3 = parts.join(keySeparator);
        }
        if (typeof namespaces === "string")
          namespaces = [namespaces];
        return {
          key: key3,
          namespaces
        };
      }
      translate(keys, options3, lastKey) {
        if (typeof options3 !== "object" && this.options.overloadTranslationOptionHandler) {
          options3 = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (typeof options3 === "object")
          options3 = {
            ...options3
          };
        if (!options3)
          options3 = {};
        if (keys === void 0 || keys === null)
          return "";
        if (!Array.isArray(keys))
          keys = [String(keys)];
        const returnDetails = options3.returnDetails !== void 0 ? options3.returnDetails : this.options.returnDetails;
        const keySeparator = options3.keySeparator !== void 0 ? options3.keySeparator : this.options.keySeparator;
        const {
          key: key3,
          namespaces
        } = this.extractFromKey(keys[keys.length - 1], options3);
        const namespace = namespaces[namespaces.length - 1];
        const lng = options3.lng || this.language;
        const appendNamespaceToCIMode = options3.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (lng && lng.toLowerCase() === "cimode") {
          if (appendNamespaceToCIMode) {
            const nsSeparator = options3.nsSeparator || this.options.nsSeparator;
            if (returnDetails) {
              return {
                res: `${namespace}${nsSeparator}${key3}`,
                usedKey: key3,
                exactUsedKey: key3,
                usedLng: lng,
                usedNS: namespace
              };
            }
            return `${namespace}${nsSeparator}${key3}`;
          }
          if (returnDetails) {
            return {
              res: key3,
              usedKey: key3,
              exactUsedKey: key3,
              usedLng: lng,
              usedNS: namespace
            };
          }
          return key3;
        }
        const resolved = this.resolve(keys, options3);
        let res = resolved && resolved.res;
        const resUsedKey = resolved && resolved.usedKey || key3;
        const resExactUsedKey = resolved && resolved.exactUsedKey || key3;
        const resType = Object.prototype.toString.apply(res);
        const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
        const joinArrays = options3.joinArrays !== void 0 ? options3.joinArrays : this.options.joinArrays;
        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
          if (!options3.returnObjects && !this.options.returnObjects) {
            if (!this.options.returnedObjectHandler) {
              this.logger.warn("accessing an object - but returnObjects options is not enabled!");
            }
            const r8 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
              ...options3,
              ns: namespaces
            }) : `key '${key3} (${this.language})' returned an object instead of string.`;
            if (returnDetails) {
              resolved.res = r8;
              return resolved;
            }
            return r8;
          }
          if (keySeparator) {
            const resTypeIsArray = resType === "[object Array]";
            const copy2 = resTypeIsArray ? [] : {};
            const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
            for (const m5 in res) {
              if (Object.prototype.hasOwnProperty.call(res, m5)) {
                const deepKey = `${newKeyToUse}${keySeparator}${m5}`;
                copy2[m5] = this.translate(deepKey, {
                  ...options3,
                  ...{
                    joinArrays: false,
                    ns: namespaces
                  }
                });
                if (copy2[m5] === deepKey)
                  copy2[m5] = res[m5];
              }
            }
            res = copy2;
          }
        } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
          res = res.join(joinArrays);
          if (res)
            res = this.extendTranslation(res, keys, options3, lastKey);
        } else {
          let usedDefault = false;
          let usedKey = false;
          const needsPluralHandling = options3.count !== void 0 && typeof options3.count !== "string";
          const hasDefaultValue = _Translator.hasDefaultValue(options3);
          const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options3.count, options3) : "";
          const defaultValueSuffixOrdinalFallback = options3.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options3.count, {
            ordinal: false
          }) : "";
          const defaultValue = options3[`defaultValue${defaultValueSuffix}`] || options3[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options3.defaultValue;
          if (!this.isValidLookup(res) && hasDefaultValue) {
            usedDefault = true;
            res = defaultValue;
          }
          if (!this.isValidLookup(res)) {
            usedKey = true;
            res = key3;
          }
          const missingKeyNoValueFallbackToKey = options3.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
          const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
          const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
          if (usedKey || usedDefault || updateMissing) {
            this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key3, updateMissing ? defaultValue : res);
            if (keySeparator) {
              const fk = this.resolve(key3, {
                ...options3,
                keySeparator: false
              });
              if (fk && fk.res)
                this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
            }
            let lngs = [];
            const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options3.lng || this.language);
            if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
              for (let i9 = 0; i9 < fallbackLngs.length; i9++) {
                lngs.push(fallbackLngs[i9]);
              }
            } else if (this.options.saveMissingTo === "all") {
              lngs = this.languageUtils.toResolveHierarchy(options3.lng || this.language);
            } else {
              lngs.push(options3.lng || this.language);
            }
            const send = (l7, k4, specificDefaultValue) => {
              const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
              if (this.options.missingKeyHandler) {
                this.options.missingKeyHandler(l7, namespace, k4, defaultForMissing, updateMissing, options3);
              } else if (this.backendConnector && this.backendConnector.saveMissing) {
                this.backendConnector.saveMissing(l7, namespace, k4, defaultForMissing, updateMissing, options3);
              }
              this.emit("missingKey", l7, namespace, k4, res);
            };
            if (this.options.saveMissing) {
              if (this.options.saveMissingPlurals && needsPluralHandling) {
                lngs.forEach((language) => {
                  this.pluralResolver.getSuffixes(language, options3).forEach((suffix) => {
                    send([language], key3 + suffix, options3[`defaultValue${suffix}`] || defaultValue);
                  });
                });
              } else {
                send(lngs, key3, defaultValue);
              }
            }
          }
          res = this.extendTranslation(res, keys, options3, resolved, lastKey);
          if (usedKey && res === key3 && this.options.appendNamespaceToMissingKey)
            res = `${namespace}:${key3}`;
          if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
            if (this.options.compatibilityAPI !== "v1") {
              res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key3}` : key3, usedDefault ? res : void 0);
            } else {
              res = this.options.parseMissingKeyHandler(res);
            }
          }
        }
        if (returnDetails) {
          resolved.res = res;
          return resolved;
        }
        return res;
      }
      extendTranslation(res, key3, options3, resolved, lastKey) {
        var _this = this;
        if (this.i18nFormat && this.i18nFormat.parse) {
          res = this.i18nFormat.parse(res, {
            ...this.options.interpolation.defaultVariables,
            ...options3
          }, options3.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
            resolved
          });
        } else if (!options3.skipInterpolation) {
          if (options3.interpolation)
            this.interpolator.init({
              ...options3,
              ...{
                interpolation: {
                  ...this.options.interpolation,
                  ...options3.interpolation
                }
              }
            });
          const skipOnVariables = typeof res === "string" && (options3 && options3.interpolation && options3.interpolation.skipOnVariables !== void 0 ? options3.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
          let nestBef;
          if (skipOnVariables) {
            const nb = res.match(this.interpolator.nestingRegexp);
            nestBef = nb && nb.length;
          }
          let data = options3.replace && typeof options3.replace !== "string" ? options3.replace : options3;
          if (this.options.interpolation.defaultVariables)
            data = {
              ...this.options.interpolation.defaultVariables,
              ...data
            };
          res = this.interpolator.interpolate(res, data, options3.lng || this.language, options3);
          if (skipOnVariables) {
            const na = res.match(this.interpolator.nestingRegexp);
            const nestAft = na && na.length;
            if (nestBef < nestAft)
              options3.nest = false;
          }
          if (!options3.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
            options3.lng = resolved.usedLng;
          if (options3.nest !== false)
            res = this.interpolator.nest(res, function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (lastKey && lastKey[0] === args[0] && !options3.context) {
                _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key3[0]}`);
                return null;
              }
              return _this.translate(...args, key3);
            }, options3);
          if (options3.interpolation)
            this.interpolator.reset();
        }
        const postProcess2 = options3.postProcess || this.options.postProcess;
        const postProcessorNames = typeof postProcess2 === "string" ? [postProcess2] : postProcess2;
        if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options3.applyPostProcessor !== false) {
          res = postProcessor.handle(postProcessorNames, res, key3, this.options && this.options.postProcessPassResolved ? {
            i18nResolved: resolved,
            ...options3
          } : options3, this);
        }
        return res;
      }
      resolve(keys) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let found;
        let usedKey;
        let exactUsedKey;
        let usedLng;
        let usedNS;
        if (typeof keys === "string")
          keys = [keys];
        keys.forEach((k4) => {
          if (this.isValidLookup(found))
            return;
          const extracted = this.extractFromKey(k4, options3);
          const key3 = extracted.key;
          usedKey = key3;
          let namespaces = extracted.namespaces;
          if (this.options.fallbackNS)
            namespaces = namespaces.concat(this.options.fallbackNS);
          const needsPluralHandling = options3.count !== void 0 && typeof options3.count !== "string";
          const needsZeroSuffixLookup = needsPluralHandling && !options3.ordinal && options3.count === 0 && this.pluralResolver.shouldUseIntlApi();
          const needsContextHandling = options3.context !== void 0 && (typeof options3.context === "string" || typeof options3.context === "number") && options3.context !== "";
          const codes = options3.lngs ? options3.lngs : this.languageUtils.toResolveHierarchy(options3.lng || this.language, options3.fallbackLng);
          namespaces.forEach((ns) => {
            if (this.isValidLookup(found))
              return;
            usedNS = ns;
            if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
              checkedLoadedFor[`${codes[0]}-${ns}`] = true;
              this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            }
            codes.forEach((code) => {
              if (this.isValidLookup(found))
                return;
              usedLng = code;
              const finalKeys = [key3];
              if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
                this.i18nFormat.addLookupKeys(finalKeys, key3, code, ns, options3);
              } else {
                let pluralSuffix;
                if (needsPluralHandling)
                  pluralSuffix = this.pluralResolver.getSuffix(code, options3.count, options3);
                const zeroSuffix = `${this.options.pluralSeparator}zero`;
                const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                if (needsPluralHandling) {
                  finalKeys.push(key3 + pluralSuffix);
                  if (options3.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                    finalKeys.push(key3 + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                  }
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(key3 + zeroSuffix);
                  }
                }
                if (needsContextHandling) {
                  const contextKey = `${key3}${this.options.contextSeparator}${options3.context}`;
                  finalKeys.push(contextKey);
                  if (needsPluralHandling) {
                    finalKeys.push(contextKey + pluralSuffix);
                    if (options3.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                      finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                    }
                    if (needsZeroSuffixLookup) {
                      finalKeys.push(contextKey + zeroSuffix);
                    }
                  }
                }
              }
              let possibleKey;
              while (possibleKey = finalKeys.pop()) {
                if (!this.isValidLookup(found)) {
                  exactUsedKey = possibleKey;
                  found = this.getResource(code, ns, possibleKey, options3);
                }
              }
            });
          });
        });
        return {
          res: found,
          usedKey,
          exactUsedKey,
          usedLng,
          usedNS
        };
      }
      isValidLookup(res) {
        return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
      }
      getResource(code, ns, key3) {
        let options3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        if (this.i18nFormat && this.i18nFormat.getResource)
          return this.i18nFormat.getResource(code, ns, key3, options3);
        return this.resourceStore.getResource(code, ns, key3, options3);
      }
      static hasDefaultValue(options3) {
        const prefix = "defaultValue";
        for (const option in options3) {
          if (Object.prototype.hasOwnProperty.call(options3, option) && prefix === option.substring(0, prefix.length) && void 0 !== options3[option]) {
            return true;
          }
        }
        return false;
      }
    };
    LanguageUtil = class {
      constructor(options3) {
        this.options = options3;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = baseLogger.create("languageUtils");
      }
      getScriptPartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf("-") < 0)
          return null;
        const p5 = code.split("-");
        if (p5.length === 2)
          return null;
        p5.pop();
        if (p5[p5.length - 1].toLowerCase() === "x")
          return null;
        return this.formatLanguageCode(p5.join("-"));
      }
      getLanguagePartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf("-") < 0)
          return code;
        const p5 = code.split("-");
        return this.formatLanguageCode(p5[0]);
      }
      formatLanguageCode(code) {
        if (typeof code === "string" && code.indexOf("-") > -1) {
          const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
          let p5 = code.split("-");
          if (this.options.lowerCaseLng) {
            p5 = p5.map((part) => part.toLowerCase());
          } else if (p5.length === 2) {
            p5[0] = p5[0].toLowerCase();
            p5[1] = p5[1].toUpperCase();
            if (specialCases.indexOf(p5[1].toLowerCase()) > -1)
              p5[1] = capitalize(p5[1].toLowerCase());
          } else if (p5.length === 3) {
            p5[0] = p5[0].toLowerCase();
            if (p5[1].length === 2)
              p5[1] = p5[1].toUpperCase();
            if (p5[0] !== "sgn" && p5[2].length === 2)
              p5[2] = p5[2].toUpperCase();
            if (specialCases.indexOf(p5[1].toLowerCase()) > -1)
              p5[1] = capitalize(p5[1].toLowerCase());
            if (specialCases.indexOf(p5[2].toLowerCase()) > -1)
              p5[2] = capitalize(p5[2].toLowerCase());
          }
          return p5.join("-");
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
      }
      isSupportedCode(code) {
        if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
          code = this.getLanguagePartFromCode(code);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
      }
      getBestMatchFromCodes(codes) {
        if (!codes)
          return null;
        let found;
        codes.forEach((code) => {
          if (found)
            return;
          const cleanedLng = this.formatLanguageCode(code);
          if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
            found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
          codes.forEach((code) => {
            if (found)
              return;
            const lngOnly = this.getLanguagePartFromCode(code);
            if (this.isSupportedCode(lngOnly))
              return found = lngOnly;
            found = this.options.supportedLngs.find((supportedLng) => {
              if (supportedLng === lngOnly)
                return supportedLng;
              if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
                return;
              if (supportedLng.indexOf(lngOnly) === 0)
                return supportedLng;
            });
          });
        }
        if (!found)
          found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
      }
      getFallbackCodes(fallbacks, code) {
        if (!fallbacks)
          return [];
        if (typeof fallbacks === "function")
          fallbacks = fallbacks(code);
        if (typeof fallbacks === "string")
          fallbacks = [fallbacks];
        if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
          return fallbacks;
        if (!code)
          return fallbacks.default || [];
        let found = fallbacks[code];
        if (!found)
          found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found)
          found = fallbacks[this.formatLanguageCode(code)];
        if (!found)
          found = fallbacks[this.getLanguagePartFromCode(code)];
        if (!found)
          found = fallbacks.default;
        return found || [];
      }
      toResolveHierarchy(code, fallbackCode) {
        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        const codes = [];
        const addCode = (c8) => {
          if (!c8)
            return;
          if (this.isSupportedCode(c8)) {
            codes.push(c8);
          } else {
            this.logger.warn(`rejecting language code not found in supportedLngs: ${c8}`);
          }
        };
        if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
          if (this.options.load !== "languageOnly")
            addCode(this.formatLanguageCode(code));
          if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
            addCode(this.getScriptPartFromCode(code));
          if (this.options.load !== "currentOnly")
            addCode(this.getLanguagePartFromCode(code));
        } else if (typeof code === "string") {
          addCode(this.formatLanguageCode(code));
        }
        fallbackCodes.forEach((fc) => {
          if (codes.indexOf(fc) < 0)
            addCode(this.formatLanguageCode(fc));
        });
        return codes;
      }
    };
    sets = [{
      lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
      nr: [1, 2],
      fc: 1
    }, {
      lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
      nr: [1, 2],
      fc: 2
    }, {
      lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
      nr: [1],
      fc: 3
    }, {
      lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
      nr: [1, 2, 5],
      fc: 4
    }, {
      lngs: ["ar"],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5
    }, {
      lngs: ["cs", "sk"],
      nr: [1, 2, 5],
      fc: 6
    }, {
      lngs: ["csb", "pl"],
      nr: [1, 2, 5],
      fc: 7
    }, {
      lngs: ["cy"],
      nr: [1, 2, 3, 8],
      fc: 8
    }, {
      lngs: ["fr"],
      nr: [1, 2],
      fc: 9
    }, {
      lngs: ["ga"],
      nr: [1, 2, 3, 7, 11],
      fc: 10
    }, {
      lngs: ["gd"],
      nr: [1, 2, 3, 20],
      fc: 11
    }, {
      lngs: ["is"],
      nr: [1, 2],
      fc: 12
    }, {
      lngs: ["jv"],
      nr: [0, 1],
      fc: 13
    }, {
      lngs: ["kw"],
      nr: [1, 2, 3, 4],
      fc: 14
    }, {
      lngs: ["lt"],
      nr: [1, 2, 10],
      fc: 15
    }, {
      lngs: ["lv"],
      nr: [1, 2, 0],
      fc: 16
    }, {
      lngs: ["mk"],
      nr: [1, 2],
      fc: 17
    }, {
      lngs: ["mnk"],
      nr: [0, 1, 2],
      fc: 18
    }, {
      lngs: ["mt"],
      nr: [1, 2, 11, 20],
      fc: 19
    }, {
      lngs: ["or"],
      nr: [2, 1],
      fc: 2
    }, {
      lngs: ["ro"],
      nr: [1, 2, 20],
      fc: 20
    }, {
      lngs: ["sl"],
      nr: [5, 1, 2, 3],
      fc: 21
    }, {
      lngs: ["he", "iw"],
      nr: [1, 2, 20, 21],
      fc: 22
    }];
    _rulesPluralsTypes = {
      1: function(n7) {
        return Number(n7 > 1);
      },
      2: function(n7) {
        return Number(n7 != 1);
      },
      3: function(n7) {
        return 0;
      },
      4: function(n7) {
        return Number(n7 % 10 == 1 && n7 % 100 != 11 ? 0 : n7 % 10 >= 2 && n7 % 10 <= 4 && (n7 % 100 < 10 || n7 % 100 >= 20) ? 1 : 2);
      },
      5: function(n7) {
        return Number(n7 == 0 ? 0 : n7 == 1 ? 1 : n7 == 2 ? 2 : n7 % 100 >= 3 && n7 % 100 <= 10 ? 3 : n7 % 100 >= 11 ? 4 : 5);
      },
      6: function(n7) {
        return Number(n7 == 1 ? 0 : n7 >= 2 && n7 <= 4 ? 1 : 2);
      },
      7: function(n7) {
        return Number(n7 == 1 ? 0 : n7 % 10 >= 2 && n7 % 10 <= 4 && (n7 % 100 < 10 || n7 % 100 >= 20) ? 1 : 2);
      },
      8: function(n7) {
        return Number(n7 == 1 ? 0 : n7 == 2 ? 1 : n7 != 8 && n7 != 11 ? 2 : 3);
      },
      9: function(n7) {
        return Number(n7 >= 2);
      },
      10: function(n7) {
        return Number(n7 == 1 ? 0 : n7 == 2 ? 1 : n7 < 7 ? 2 : n7 < 11 ? 3 : 4);
      },
      11: function(n7) {
        return Number(n7 == 1 || n7 == 11 ? 0 : n7 == 2 || n7 == 12 ? 1 : n7 > 2 && n7 < 20 ? 2 : 3);
      },
      12: function(n7) {
        return Number(n7 % 10 != 1 || n7 % 100 == 11);
      },
      13: function(n7) {
        return Number(n7 !== 0);
      },
      14: function(n7) {
        return Number(n7 == 1 ? 0 : n7 == 2 ? 1 : n7 == 3 ? 2 : 3);
      },
      15: function(n7) {
        return Number(n7 % 10 == 1 && n7 % 100 != 11 ? 0 : n7 % 10 >= 2 && (n7 % 100 < 10 || n7 % 100 >= 20) ? 1 : 2);
      },
      16: function(n7) {
        return Number(n7 % 10 == 1 && n7 % 100 != 11 ? 0 : n7 !== 0 ? 1 : 2);
      },
      17: function(n7) {
        return Number(n7 == 1 || n7 % 10 == 1 && n7 % 100 != 11 ? 0 : 1);
      },
      18: function(n7) {
        return Number(n7 == 0 ? 0 : n7 == 1 ? 1 : 2);
      },
      19: function(n7) {
        return Number(n7 == 1 ? 0 : n7 == 0 || n7 % 100 > 1 && n7 % 100 < 11 ? 1 : n7 % 100 > 10 && n7 % 100 < 20 ? 2 : 3);
      },
      20: function(n7) {
        return Number(n7 == 1 ? 0 : n7 == 0 || n7 % 100 > 0 && n7 % 100 < 20 ? 1 : 2);
      },
      21: function(n7) {
        return Number(n7 % 100 == 1 ? 1 : n7 % 100 == 2 ? 2 : n7 % 100 == 3 || n7 % 100 == 4 ? 3 : 0);
      },
      22: function(n7) {
        return Number(n7 == 1 ? 0 : n7 == 2 ? 1 : (n7 < 0 || n7 > 10) && n7 % 10 == 0 ? 2 : 3);
      }
    };
    nonIntlVersions = ["v1", "v2", "v3"];
    intlVersions = ["v4"];
    suffixesOrder = {
      zero: 0,
      one: 1,
      two: 2,
      few: 3,
      many: 4,
      other: 5
    };
    PluralResolver = class {
      constructor(languageUtils) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.languageUtils = languageUtils;
        this.options = options3;
        this.logger = baseLogger.create("pluralResolver");
        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
          this.options.compatibilityJSON = "v3";
          this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
        }
        this.rules = createRules();
      }
      addRule(lng, obj) {
        this.rules[lng] = obj;
      }
      getRule(code) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.shouldUseIntlApi()) {
          try {
            return new Intl.PluralRules(getCleanedCode(code), {
              type: options3.ordinal ? "ordinal" : "cardinal"
            });
          } catch {
            return;
          }
        }
        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
      }
      needsPlural(code) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const rule = this.getRule(code, options3);
        if (this.shouldUseIntlApi()) {
          return rule && rule.resolvedOptions().pluralCategories.length > 1;
        }
        return rule && rule.numbers.length > 1;
      }
      getPluralFormsOfKey(code, key3) {
        let options3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.getSuffixes(code, options3).map((suffix) => `${key3}${suffix}`);
      }
      getSuffixes(code) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const rule = this.getRule(code, options3);
        if (!rule) {
          return [];
        }
        if (this.shouldUseIntlApi()) {
          return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options3.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
        }
        return rule.numbers.map((number) => this.getSuffix(code, number, options3));
      }
      getSuffix(code, count) {
        let options3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const rule = this.getRule(code, options3);
        if (rule) {
          if (this.shouldUseIntlApi()) {
            return `${this.options.prepend}${options3.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
          }
          return this.getSuffixRetroCompatible(rule, count);
        }
        this.logger.warn(`no plural rule found for: ${code}`);
        return "";
      }
      getSuffixRetroCompatible(rule, count) {
        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        let suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = "plural";
          } else if (suffix === 1) {
            suffix = "";
          }
        }
        const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
        if (this.options.compatibilityJSON === "v1") {
          if (suffix === 1)
            return "";
          if (typeof suffix === "number")
            return `_plural_${suffix.toString()}`;
          return returnSuffix();
        } else if (this.options.compatibilityJSON === "v2") {
          return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }
      shouldUseIntlApi() {
        return !nonIntlVersions.includes(this.options.compatibilityJSON);
      }
    };
    Interpolator = class {
      constructor() {
        let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("interpolator");
        this.options = options3;
        this.format = options3.interpolation && options3.interpolation.format || ((value) => value);
        this.init(options3);
      }
      init() {
        let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!options3.interpolation)
          options3.interpolation = {
            escapeValue: true
          };
        const iOpts = options3.interpolation;
        this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape4;
        this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
        this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
        this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
        this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
        this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
        this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
        this.resetRegExp();
      }
      reset() {
        if (this.options)
          this.init(this.options);
      }
      resetRegExp() {
        const regexpStr = `${this.prefix}(.+?)${this.suffix}`;
        this.regexp = new RegExp(regexpStr, "g");
        const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
        this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
        const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
        this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
      }
      interpolate(str2, data, lng, options3) {
        let match;
        let value;
        let replaces;
        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
        function regexSafe(val) {
          return val.replace(/\$/g, "$$$$");
        }
        const handleFormat = (key3) => {
          if (key3.indexOf(this.formatSeparator) < 0) {
            const path2 = deepFindWithDefaults(data, defaultData, key3, this.options.keySeparator, this.options.ignoreJSONStructure);
            return this.alwaysFormat ? this.format(path2, void 0, lng, {
              ...options3,
              ...data,
              interpolationkey: key3
            }) : path2;
          }
          const p5 = key3.split(this.formatSeparator);
          const k4 = p5.shift().trim();
          const f5 = p5.join(this.formatSeparator).trim();
          return this.format(deepFindWithDefaults(data, defaultData, k4, this.options.keySeparator, this.options.ignoreJSONStructure), f5, lng, {
            ...options3,
            ...data,
            interpolationkey: k4
          });
        };
        this.resetRegExp();
        const missingInterpolationHandler = options3 && options3.missingInterpolationHandler || this.options.missingInterpolationHandler;
        const skipOnVariables = options3 && options3.interpolation && options3.interpolation.skipOnVariables !== void 0 ? options3.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        const todos = [{
          regex: this.regexpUnescape,
          safeValue: (val) => regexSafe(val)
        }, {
          regex: this.regexp,
          safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
        }];
        todos.forEach((todo) => {
          replaces = 0;
          while (match = todo.regex.exec(str2)) {
            const matchedVar = match[1].trim();
            value = handleFormat(matchedVar);
            if (value === void 0) {
              if (typeof missingInterpolationHandler === "function") {
                const temp = missingInterpolationHandler(str2, match, options3);
                value = typeof temp === "string" ? temp : "";
              } else if (options3 && Object.prototype.hasOwnProperty.call(options3, matchedVar)) {
                value = "";
              } else if (skipOnVariables) {
                value = match[0];
                continue;
              } else {
                this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str2}`);
                value = "";
              }
            } else if (typeof value !== "string" && !this.useRawValueToEscape) {
              value = makeString(value);
            }
            const safeValue = todo.safeValue(value);
            str2 = str2.replace(match[0], safeValue);
            if (skipOnVariables) {
              todo.regex.lastIndex += value.length;
              todo.regex.lastIndex -= match[0].length;
            } else {
              todo.regex.lastIndex = 0;
            }
            replaces++;
            if (replaces >= this.maxReplaces) {
              break;
            }
          }
        });
        return str2;
      }
      nest(str2, fc) {
        let options3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        let match;
        let value;
        let clonedOptions;
        function handleHasOptions(key3, inheritedOptions) {
          const sep = this.nestingOptionsSeparator;
          if (key3.indexOf(sep) < 0)
            return key3;
          const c8 = key3.split(new RegExp(`${sep}[ ]*{`));
          let optionsString = `{${c8[1]}`;
          key3 = c8[0];
          optionsString = this.interpolate(optionsString, clonedOptions);
          const matchedSingleQuotes = optionsString.match(/'/g);
          const matchedDoubleQuotes = optionsString.match(/"/g);
          if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
            optionsString = optionsString.replace(/'/g, '"');
          }
          try {
            clonedOptions = JSON.parse(optionsString);
            if (inheritedOptions)
              clonedOptions = {
                ...inheritedOptions,
                ...clonedOptions
              };
          } catch (e5) {
            this.logger.warn(`failed parsing options string in nesting for key ${key3}`, e5);
            return `${key3}${sep}${optionsString}`;
          }
          delete clonedOptions.defaultValue;
          return key3;
        }
        while (match = this.nestingRegexp.exec(str2)) {
          let formatters = [];
          clonedOptions = {
            ...options3
          };
          clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
          clonedOptions.applyPostProcessor = false;
          delete clonedOptions.defaultValue;
          let doReduce = false;
          if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
            const r8 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
            match[1] = r8.shift();
            formatters = r8;
            doReduce = true;
          }
          value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
          if (value && match[0] === str2 && typeof value !== "string")
            return value;
          if (typeof value !== "string")
            value = makeString(value);
          if (!value) {
            this.logger.warn(`missed to resolve ${match[1]} for nesting ${str2}`);
            value = "";
          }
          if (doReduce) {
            value = formatters.reduce((v5, f5) => this.format(v5, f5, options3.lng, {
              ...options3,
              interpolationkey: match[1].trim()
            }), value.trim());
          }
          str2 = str2.replace(match[0], value);
          this.regexp.lastIndex = 0;
        }
        return str2;
      }
    };
    Formatter = class {
      constructor() {
        let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("formatter");
        this.options = options3;
        this.formats = {
          number: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.NumberFormat(lng, {
              ...opt
            });
            return (val) => formatter.format(val);
          }),
          currency: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.NumberFormat(lng, {
              ...opt,
              style: "currency"
            });
            return (val) => formatter.format(val);
          }),
          datetime: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.DateTimeFormat(lng, {
              ...opt
            });
            return (val) => formatter.format(val);
          }),
          relativetime: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.RelativeTimeFormat(lng, {
              ...opt
            });
            return (val) => formatter.format(val, opt.range || "day");
          }),
          list: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.ListFormat(lng, {
              ...opt
            });
            return (val) => formatter.format(val);
          })
        };
        this.init(options3);
      }
      init(services) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
        };
        const iOpts = options3.interpolation;
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      }
      add(name2, fc) {
        this.formats[name2.toLowerCase().trim()] = fc;
      }
      addCached(name2, fc) {
        this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc);
      }
      format(value, format, lng) {
        let options3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const formats = format.split(this.formatSeparator);
        const result = formats.reduce((mem, f5) => {
          const {
            formatName,
            formatOptions
          } = parseFormatStr(f5);
          if (this.formats[formatName]) {
            let formatted = mem;
            try {
              const valOptions = options3 && options3.formatParams && options3.formatParams[options3.interpolationkey] || {};
              const l7 = valOptions.locale || valOptions.lng || options3.locale || options3.lng || lng;
              formatted = this.formats[formatName](mem, l7, {
                ...formatOptions,
                ...options3,
                ...valOptions
              });
            } catch (error2) {
              this.logger.warn(error2);
            }
            return formatted;
          } else {
            this.logger.warn(`there was no format function for ${formatName}`);
          }
          return mem;
        }, value);
        return result;
      }
    };
    Connector = class extends EventEmitter {
      constructor(backend, store, services) {
        let options3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        super();
        this.backend = backend;
        this.store = store;
        this.services = services;
        this.languageUtils = services.languageUtils;
        this.options = options3;
        this.logger = baseLogger.create("backendConnector");
        this.waitingReads = [];
        this.maxParallelReads = options3.maxParallelReads || 10;
        this.readingCalls = 0;
        this.maxRetries = options3.maxRetries >= 0 ? options3.maxRetries : 5;
        this.retryTimeout = options3.retryTimeout >= 1 ? options3.retryTimeout : 350;
        this.state = {};
        this.queue = [];
        if (this.backend && this.backend.init) {
          this.backend.init(services, options3.backend, options3);
        }
      }
      queueLoad(languages, namespaces, options3, callback) {
        const toLoad = {};
        const pending = {};
        const toLoadLanguages = {};
        const toLoadNamespaces = {};
        languages.forEach((lng) => {
          let hasAllNamespaces = true;
          namespaces.forEach((ns) => {
            const name2 = `${lng}|${ns}`;
            if (!options3.reload && this.store.hasResourceBundle(lng, ns)) {
              this.state[name2] = 2;
            } else if (this.state[name2] < 0)
              ;
            else if (this.state[name2] === 1) {
              if (pending[name2] === void 0)
                pending[name2] = true;
            } else {
              this.state[name2] = 1;
              hasAllNamespaces = false;
              if (pending[name2] === void 0)
                pending[name2] = true;
              if (toLoad[name2] === void 0)
                toLoad[name2] = true;
              if (toLoadNamespaces[ns] === void 0)
                toLoadNamespaces[ns] = true;
            }
          });
          if (!hasAllNamespaces)
            toLoadLanguages[lng] = true;
        });
        if (Object.keys(toLoad).length || Object.keys(pending).length) {
          this.queue.push({
            pending,
            pendingCount: Object.keys(pending).length,
            loaded: {},
            errors: [],
            callback
          });
        }
        return {
          toLoad: Object.keys(toLoad),
          pending: Object.keys(pending),
          toLoadLanguages: Object.keys(toLoadLanguages),
          toLoadNamespaces: Object.keys(toLoadNamespaces)
        };
      }
      loaded(name2, err, data) {
        const s9 = name2.split("|");
        const lng = s9[0];
        const ns = s9[1];
        if (err)
          this.emit("failedLoading", lng, ns, err);
        if (data) {
          this.store.addResourceBundle(lng, ns, data);
        }
        this.state[name2] = err ? -1 : 2;
        const loaded = {};
        this.queue.forEach((q4) => {
          pushPath(q4.loaded, [lng], ns);
          removePending(q4, name2);
          if (err)
            q4.errors.push(err);
          if (q4.pendingCount === 0 && !q4.done) {
            Object.keys(q4.loaded).forEach((l7) => {
              if (!loaded[l7])
                loaded[l7] = {};
              const loadedKeys = q4.loaded[l7];
              if (loadedKeys.length) {
                loadedKeys.forEach((n7) => {
                  if (loaded[l7][n7] === void 0)
                    loaded[l7][n7] = true;
                });
              }
            });
            q4.done = true;
            if (q4.errors.length) {
              q4.callback(q4.errors);
            } else {
              q4.callback();
            }
          }
        });
        this.emit("loaded", loaded);
        this.queue = this.queue.filter((q4) => !q4.done);
      }
      read(lng, ns, fcName) {
        let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
        let callback = arguments.length > 5 ? arguments[5] : void 0;
        if (!lng.length)
          return callback(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
          this.waitingReads.push({
            lng,
            ns,
            fcName,
            tried,
            wait,
            callback
          });
          return;
        }
        this.readingCalls++;
        const resolver = (err, data) => {
          this.readingCalls--;
          if (this.waitingReads.length > 0) {
            const next2 = this.waitingReads.shift();
            this.read(next2.lng, next2.ns, next2.fcName, next2.tried, next2.wait, next2.callback);
          }
          if (err && data && tried < this.maxRetries) {
            setTimeout(() => {
              this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
            }, wait);
            return;
          }
          callback(err, data);
        };
        const fc = this.backend[fcName].bind(this.backend);
        if (fc.length === 2) {
          try {
            const r8 = fc(lng, ns);
            if (r8 && typeof r8.then === "function") {
              r8.then((data) => resolver(null, data)).catch(resolver);
            } else {
              resolver(null, r8);
            }
          } catch (err) {
            resolver(err);
          }
          return;
        }
        return fc(lng, ns, resolver);
      }
      prepareLoading(languages, namespaces) {
        let options3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        let callback = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend) {
          this.logger.warn("No backend was added via i18next.use. Will not load resources.");
          return callback && callback();
        }
        if (typeof languages === "string")
          languages = this.languageUtils.toResolveHierarchy(languages);
        if (typeof namespaces === "string")
          namespaces = [namespaces];
        const toLoad = this.queueLoad(languages, namespaces, options3, callback);
        if (!toLoad.toLoad.length) {
          if (!toLoad.pending.length)
            callback();
          return null;
        }
        toLoad.toLoad.forEach((name2) => {
          this.loadOne(name2);
        });
      }
      load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {}, callback);
      }
      reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
          reload: true
        }, callback);
      }
      loadOne(name2) {
        let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const s9 = name2.split("|");
        const lng = s9[0];
        const ns = s9[1];
        this.read(lng, ns, "read", void 0, void 0, (err, data) => {
          if (err)
            this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
          if (!err && data)
            this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
          this.loaded(name2, err, data);
        });
      }
      saveMissing(languages, namespace, key3, fallbackValue, isUpdate) {
        let options3 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
        let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
        };
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
          this.logger.warn(`did not save key "${key3}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          return;
        }
        if (key3 === void 0 || key3 === null || key3 === "")
          return;
        if (this.backend && this.backend.create) {
          const opts = {
            ...options3,
            isUpdate
          };
          const fc = this.backend.create.bind(this.backend);
          if (fc.length < 6) {
            try {
              let r8;
              if (fc.length === 5) {
                r8 = fc(languages, namespace, key3, fallbackValue, opts);
              } else {
                r8 = fc(languages, namespace, key3, fallbackValue);
              }
              if (r8 && typeof r8.then === "function") {
                r8.then((data) => clb(null, data)).catch(clb);
              } else {
                clb(null, r8);
              }
            } catch (err) {
              clb(err);
            }
          } else {
            fc(languages, namespace, key3, fallbackValue, clb, opts);
          }
        }
        if (!languages || !languages[0])
          return;
        this.store.addResource(languages[0], namespace, key3, fallbackValue);
      }
    };
    I18n = class _I18n extends EventEmitter {
      constructor() {
        let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        super();
        this.options = transformOptions(options3);
        this.services = {};
        this.logger = baseLogger;
        this.modules = {
          external: []
        };
        bindMemberFunctions(this);
        if (callback && !this.isInitialized && !options3.isClone) {
          if (!this.options.initImmediate) {
            this.init(options3, callback);
            return this;
          }
          setTimeout(() => {
            this.init(options3, callback);
          }, 0);
        }
      }
      init() {
        var _this = this;
        let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options3 === "function") {
          callback = options3;
          options3 = {};
        }
        if (!options3.defaultNS && options3.defaultNS !== false && options3.ns) {
          if (typeof options3.ns === "string") {
            options3.defaultNS = options3.ns;
          } else if (options3.ns.indexOf("translation") < 0) {
            options3.defaultNS = options3.ns[0];
          }
        }
        const defOpts = get3();
        this.options = {
          ...defOpts,
          ...this.options,
          ...transformOptions(options3)
        };
        if (this.options.compatibilityAPI !== "v1") {
          this.options.interpolation = {
            ...defOpts.interpolation,
            ...this.options.interpolation
          };
        }
        if (options3.keySeparator !== void 0) {
          this.options.userDefinedKeySeparator = options3.keySeparator;
        }
        if (options3.nsSeparator !== void 0) {
          this.options.userDefinedNsSeparator = options3.nsSeparator;
        }
        function createClassOnDemand(ClassOrObject) {
          if (!ClassOrObject)
            return null;
          if (typeof ClassOrObject === "function")
            return new ClassOrObject();
          return ClassOrObject;
        }
        if (!this.options.isClone) {
          if (this.modules.logger) {
            baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
          } else {
            baseLogger.init(null, this.options);
          }
          let formatter;
          if (this.modules.formatter) {
            formatter = this.modules.formatter;
          } else if (typeof Intl !== "undefined") {
            formatter = Formatter;
          }
          const lu = new LanguageUtil(this.options);
          this.store = new ResourceStore(this.options.resources, this.options);
          const s9 = this.services;
          s9.logger = baseLogger;
          s9.resourceStore = this.store;
          s9.languageUtils = lu;
          s9.pluralResolver = new PluralResolver(lu, {
            prepend: this.options.pluralSeparator,
            compatibilityJSON: this.options.compatibilityJSON,
            simplifyPluralSuffix: this.options.simplifyPluralSuffix
          });
          if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
            s9.formatter = createClassOnDemand(formatter);
            s9.formatter.init(s9, this.options);
            this.options.interpolation.format = s9.formatter.format.bind(s9.formatter);
          }
          s9.interpolator = new Interpolator(this.options);
          s9.utils = {
            hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
          };
          s9.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s9.resourceStore, s9, this.options);
          s9.backendConnector.on("*", function(event) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            _this.emit(event, ...args);
          });
          if (this.modules.languageDetector) {
            s9.languageDetector = createClassOnDemand(this.modules.languageDetector);
            if (s9.languageDetector.init)
              s9.languageDetector.init(s9, this.options.detection, this.options);
          }
          if (this.modules.i18nFormat) {
            s9.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
            if (s9.i18nFormat.init)
              s9.i18nFormat.init(this);
          }
          this.translator = new Translator(this.services, this.options);
          this.translator.on("*", function(event) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            _this.emit(event, ...args);
          });
          this.modules.external.forEach((m5) => {
            if (m5.init)
              m5.init(this);
          });
        }
        this.format = this.options.interpolation.format;
        if (!callback)
          callback = noop3;
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
          const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          if (codes.length > 0 && codes[0] !== "dev")
            this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
          this.logger.warn("init: no languageDetector is used and no lng is defined");
        }
        const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
        storeApi.forEach((fcName) => {
          this[fcName] = function() {
            return _this.store[fcName](...arguments);
          };
        });
        const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
        storeApiChained.forEach((fcName) => {
          this[fcName] = function() {
            _this.store[fcName](...arguments);
            return _this;
          };
        });
        const deferred = defer2();
        const load2 = () => {
          const finish = (err, t8) => {
            if (this.isInitialized && !this.initializedStoreOnce)
              this.logger.warn("init: i18next is already initialized. You should call init just once!");
            this.isInitialized = true;
            if (!this.options.isClone)
              this.logger.log("initialized", this.options);
            this.emit("initialized", this.options);
            deferred.resolve(t8);
            callback(err, t8);
          };
          if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
            return finish(null, this.t.bind(this));
          this.changeLanguage(this.options.lng, finish);
        };
        if (this.options.resources || !this.options.initImmediate) {
          load2();
        } else {
          setTimeout(load2, 0);
        }
        return deferred;
      }
      loadResources(language) {
        let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop3;
        let usedCallback = callback;
        const usedLng = typeof language === "string" ? language : this.language;
        if (typeof language === "function")
          usedCallback = language;
        if (!this.options.resources || this.options.partialBundledLanguages) {
          if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
            return usedCallback();
          const toLoad = [];
          const append = (lng) => {
            if (!lng)
              return;
            if (lng === "cimode")
              return;
            const lngs = this.services.languageUtils.toResolveHierarchy(lng);
            lngs.forEach((l7) => {
              if (l7 === "cimode")
                return;
              if (toLoad.indexOf(l7) < 0)
                toLoad.push(l7);
            });
          };
          if (!usedLng) {
            const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            fallbacks.forEach((l7) => append(l7));
          } else {
            append(usedLng);
          }
          if (this.options.preload) {
            this.options.preload.forEach((l7) => append(l7));
          }
          this.services.backendConnector.load(toLoad, this.options.ns, (e5) => {
            if (!e5 && !this.resolvedLanguage && this.language)
              this.setResolvedLanguage(this.language);
            usedCallback(e5);
          });
        } else {
          usedCallback(null);
        }
      }
      reloadResources(lngs, ns, callback) {
        const deferred = defer2();
        if (!lngs)
          lngs = this.languages;
        if (!ns)
          ns = this.options.ns;
        if (!callback)
          callback = noop3;
        this.services.backendConnector.reload(lngs, ns, (err) => {
          deferred.resolve();
          callback(err);
        });
        return deferred;
      }
      use(module2) {
        if (!module2)
          throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!module2.type)
          throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        if (module2.type === "backend") {
          this.modules.backend = module2;
        }
        if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
          this.modules.logger = module2;
        }
        if (module2.type === "languageDetector") {
          this.modules.languageDetector = module2;
        }
        if (module2.type === "i18nFormat") {
          this.modules.i18nFormat = module2;
        }
        if (module2.type === "postProcessor") {
          postProcessor.addPostProcessor(module2);
        }
        if (module2.type === "formatter") {
          this.modules.formatter = module2;
        }
        if (module2.type === "3rdParty") {
          this.modules.external.push(module2);
        }
        return this;
      }
      setResolvedLanguage(l7) {
        if (!l7 || !this.languages)
          return;
        if (["cimode", "dev"].indexOf(l7) > -1)
          return;
        for (let li = 0; li < this.languages.length; li++) {
          const lngInLngs = this.languages[li];
          if (["cimode", "dev"].indexOf(lngInLngs) > -1)
            continue;
          if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
            this.resolvedLanguage = lngInLngs;
            break;
          }
        }
      }
      changeLanguage(lng, callback) {
        var _this2 = this;
        this.isLanguageChangingTo = lng;
        const deferred = defer2();
        this.emit("languageChanging", lng);
        const setLngProps = (l7) => {
          this.language = l7;
          this.languages = this.services.languageUtils.toResolveHierarchy(l7);
          this.resolvedLanguage = void 0;
          this.setResolvedLanguage(l7);
        };
        const done = (err, l7) => {
          if (l7) {
            setLngProps(l7);
            this.translator.changeLanguage(l7);
            this.isLanguageChangingTo = void 0;
            this.emit("languageChanged", l7);
            this.logger.log("languageChanged", l7);
          } else {
            this.isLanguageChangingTo = void 0;
          }
          deferred.resolve(function() {
            return _this2.t(...arguments);
          });
          if (callback)
            callback(err, function() {
              return _this2.t(...arguments);
            });
        };
        const setLng = (lngs) => {
          if (!lng && !lngs && this.services.languageDetector)
            lngs = [];
          const l7 = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
          if (l7) {
            if (!this.language) {
              setLngProps(l7);
            }
            if (!this.translator.language)
              this.translator.changeLanguage(l7);
            if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
              this.services.languageDetector.cacheUserLanguage(l7);
          }
          this.loadResources(l7, (err) => {
            done(err, l7);
          });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
          setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
          if (this.services.languageDetector.detect.length === 0) {
            this.services.languageDetector.detect().then(setLng);
          } else {
            this.services.languageDetector.detect(setLng);
          }
        } else {
          setLng(lng);
        }
        return deferred;
      }
      getFixedT(lng, ns, keyPrefix) {
        var _this3 = this;
        const fixedT = function(key3, opts) {
          let options3;
          if (typeof opts !== "object") {
            for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
              rest[_key3 - 2] = arguments[_key3];
            }
            options3 = _this3.options.overloadTranslationOptionHandler([key3, opts].concat(rest));
          } else {
            options3 = {
              ...opts
            };
          }
          options3.lng = options3.lng || fixedT.lng;
          options3.lngs = options3.lngs || fixedT.lngs;
          options3.ns = options3.ns || fixedT.ns;
          options3.keyPrefix = options3.keyPrefix || keyPrefix || fixedT.keyPrefix;
          const keySeparator = _this3.options.keySeparator || ".";
          let resultKey;
          if (options3.keyPrefix && Array.isArray(key3)) {
            resultKey = key3.map((k4) => `${options3.keyPrefix}${keySeparator}${k4}`);
          } else {
            resultKey = options3.keyPrefix ? `${options3.keyPrefix}${keySeparator}${key3}` : key3;
          }
          return _this3.t(resultKey, options3);
        };
        if (typeof lng === "string") {
          fixedT.lng = lng;
        } else {
          fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        fixedT.keyPrefix = keyPrefix;
        return fixedT;
      }
      t() {
        return this.translator && this.translator.translate(...arguments);
      }
      exists() {
        return this.translator && this.translator.exists(...arguments);
      }
      setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
      }
      hasLoadedNamespace(ns) {
        let options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!this.isInitialized) {
          this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
          return false;
        }
        if (!this.languages || !this.languages.length) {
          this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
          return false;
        }
        const lng = options3.lng || this.resolvedLanguage || this.languages[0];
        const fallbackLng = this.options ? this.options.fallbackLng : false;
        const lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === "cimode")
          return true;
        const loadNotPending = (l7, n7) => {
          const loadState = this.services.backendConnector.state[`${l7}|${n7}`];
          return loadState === -1 || loadState === 2;
        };
        if (options3.precheck) {
          const preResult = options3.precheck(this, loadNotPending);
          if (preResult !== void 0)
            return preResult;
        }
        if (this.hasResourceBundle(lng, ns))
          return true;
        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
          return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
          return true;
        return false;
      }
      loadNamespaces(ns, callback) {
        const deferred = defer2();
        if (!this.options.ns) {
          if (callback)
            callback();
          return Promise.resolve();
        }
        if (typeof ns === "string")
          ns = [ns];
        ns.forEach((n7) => {
          if (this.options.ns.indexOf(n7) < 0)
            this.options.ns.push(n7);
        });
        this.loadResources((err) => {
          deferred.resolve();
          if (callback)
            callback(err);
        });
        return deferred;
      }
      loadLanguages(lngs, callback) {
        const deferred = defer2();
        if (typeof lngs === "string")
          lngs = [lngs];
        const preloaded = this.options.preload || [];
        const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0);
        if (!newLngs.length) {
          if (callback)
            callback();
          return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources((err) => {
          deferred.resolve();
          if (callback)
            callback(err);
        });
        return deferred;
      }
      dir(lng) {
        if (!lng)
          lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
        if (!lng)
          return "rtl";
        const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get3());
        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
      }
      static createInstance() {
        let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        return new _I18n(options3, callback);
      }
      cloneInstance() {
        let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop3;
        const forkResourceStore = options3.forkResourceStore;
        if (forkResourceStore)
          delete options3.forkResourceStore;
        const mergedOptions = {
          ...this.options,
          ...options3,
          ...{
            isClone: true
          }
        };
        const clone2 = new _I18n(mergedOptions);
        if (options3.debug !== void 0 || options3.prefix !== void 0) {
          clone2.logger = clone2.logger.clone(options3);
        }
        const membersToCopy = ["store", "services", "language"];
        membersToCopy.forEach((m5) => {
          clone2[m5] = this[m5];
        });
        clone2.services = {
          ...this.services
        };
        clone2.services.utils = {
          hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
        };
        if (forkResourceStore) {
          clone2.store = new ResourceStore(this.store.data, mergedOptions);
          clone2.services.resourceStore = clone2.store;
        }
        clone2.translator = new Translator(clone2.services, mergedOptions);
        clone2.translator.on("*", function(event) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }
          clone2.emit(event, ...args);
        });
        clone2.init(mergedOptions, callback);
        clone2.translator.options = mergedOptions;
        clone2.translator.backendConnector.services.utils = {
          hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
        };
        return clone2;
      }
      toJSON() {
        return {
          options: this.options,
          store: this.store,
          language: this.language,
          languages: this.languages,
          resolvedLanguage: this.resolvedLanguage
        };
      }
    };
    instance = I18n.createInstance();
    instance.createInstance = I18n.createInstance;
    createInstance = instance.createInstance;
    dir = instance.dir;
    init2 = instance.init;
    loadResources = instance.loadResources;
    reloadResources = instance.reloadResources;
    use2 = instance.use;
    changeLanguage = instance.changeLanguage;
    getFixedT = instance.getFixedT;
    t4 = instance.t;
    exists = instance.exists;
    setDefaultNamespace = instance.setDefaultNamespace;
    hasLoadedNamespace = instance.hasLoadedNamespace;
    loadNamespaces = instance.loadNamespaces;
    loadLanguages = instance.loadLanguages;
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o7) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o8) {
    return typeof o8;
  } : function(o8) {
    return o8 && "function" == typeof Symbol && o8.constructor === Symbol && o8 !== Symbol.prototype ? "symbol" : typeof o8;
  }, _typeof(o7);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t8, r8) {
  if ("object" != _typeof(t8) || !t8)
    return t8;
  var e5 = t8[Symbol.toPrimitive];
  if (void 0 !== e5) {
    var i9 = e5.call(t8, r8 || "default");
    if ("object" != _typeof(i9))
      return i9;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r8 ? String : Number)(t8);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t8) {
  var i9 = toPrimitive(t8, "string");
  return "symbol" == _typeof(i9) ? i9 : String(i9);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i9 = 0; i9 < props.length; i9++) {
    var descriptor = props[i9];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js
function defaults2(obj) {
  each.call(slice.call(arguments, 1), function(source2) {
    if (source2) {
      for (var prop in source2) {
        if (obj[prop] === void 0)
          obj[prop] = source2[prop];
      }
    }
  });
  return obj;
}
function getDefaults2() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
    convertDetectedLanguage: function convertDetectedLanguage(l7) {
      return l7;
    }
  };
}
var arr, each, slice, fieldContentRegExp, serializeCookie, cookie, cookie$1, querystring, hasLocalStorageSupport, localStorageAvailable, localStorage2, hasSessionStorageSupport, sessionStorageAvailable, sessionStorage2, navigator$1, htmlTag, path, subdomain, Browser;
var init_i18nextBrowserLanguageDetector = __esm({
  "node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js"() {
    init_classCallCheck();
    init_createClass();
    arr = [];
    each = arr.forEach;
    slice = arr.slice;
    fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    serializeCookie = function serializeCookie2(name2, val, options3) {
      var opt = options3 || {};
      opt.path = opt.path || "/";
      var value = encodeURIComponent(val);
      var str2 = "".concat(name2, "=").concat(value);
      if (opt.maxAge > 0) {
        var maxAge = opt.maxAge - 0;
        if (Number.isNaN(maxAge))
          throw new Error("maxAge should be a Number");
        str2 += "; Max-Age=".concat(Math.floor(maxAge));
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str2 += "; Domain=".concat(opt.domain);
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str2 += "; Path=".concat(opt.path);
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str2 += "; Expires=".concat(opt.expires.toUTCString());
      }
      if (opt.httpOnly)
        str2 += "; HttpOnly";
      if (opt.secure)
        str2 += "; Secure";
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str2 += "; SameSite=Strict";
            break;
          case "lax":
            str2 += "; SameSite=Lax";
            break;
          case "strict":
            str2 += "; SameSite=Strict";
            break;
          case "none":
            str2 += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str2;
    };
    cookie = {
      create: function create(name2, value, minutes, domain2) {
        var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
          path: "/",
          sameSite: "strict"
        };
        if (minutes) {
          cookieOptions.expires = /* @__PURE__ */ new Date();
          cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
        }
        if (domain2)
          cookieOptions.domain = domain2;
        document.cookie = serializeCookie(name2, encodeURIComponent(value), cookieOptions);
      },
      read: function read(name2) {
        var nameEQ = "".concat(name2, "=");
        var ca = document.cookie.split(";");
        for (var i9 = 0; i9 < ca.length; i9++) {
          var c8 = ca[i9];
          while (c8.charAt(0) === " ") {
            c8 = c8.substring(1, c8.length);
          }
          if (c8.indexOf(nameEQ) === 0)
            return c8.substring(nameEQ.length, c8.length);
        }
        return null;
      },
      remove: function remove(name2) {
        this.create(name2, "", -1);
      }
    };
    cookie$1 = {
      name: "cookie",
      lookup: function lookup(options3) {
        var found;
        if (options3.lookupCookie && typeof document !== "undefined") {
          var c8 = cookie.read(options3.lookupCookie);
          if (c8)
            found = c8;
        }
        return found;
      },
      cacheUserLanguage: function cacheUserLanguage(lng, options3) {
        if (options3.lookupCookie && typeof document !== "undefined") {
          cookie.create(options3.lookupCookie, lng, options3.cookieMinutes, options3.cookieDomain, options3.cookieOptions);
        }
      }
    };
    querystring = {
      name: "querystring",
      lookup: function lookup2(options3) {
        var found;
        if (typeof window !== "undefined") {
          var search = window.location.search;
          if (!window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1) {
            search = window.location.hash.substring(window.location.hash.indexOf("?"));
          }
          var query = search.substring(1);
          var params = query.split("&");
          for (var i9 = 0; i9 < params.length; i9++) {
            var pos = params[i9].indexOf("=");
            if (pos > 0) {
              var key3 = params[i9].substring(0, pos);
              if (key3 === options3.lookupQuerystring) {
                found = params[i9].substring(pos + 1);
              }
            }
          }
        }
        return found;
      }
    };
    hasLocalStorageSupport = null;
    localStorageAvailable = function localStorageAvailable2() {
      if (hasLocalStorageSupport !== null)
        return hasLocalStorageSupport;
      try {
        hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
        var testKey = "i18next.translate.boo";
        window.localStorage.setItem(testKey, "foo");
        window.localStorage.removeItem(testKey);
      } catch (e5) {
        hasLocalStorageSupport = false;
      }
      return hasLocalStorageSupport;
    };
    localStorage2 = {
      name: "localStorage",
      lookup: function lookup3(options3) {
        var found;
        if (options3.lookupLocalStorage && localStorageAvailable()) {
          var lng = window.localStorage.getItem(options3.lookupLocalStorage);
          if (lng)
            found = lng;
        }
        return found;
      },
      cacheUserLanguage: function cacheUserLanguage2(lng, options3) {
        if (options3.lookupLocalStorage && localStorageAvailable()) {
          window.localStorage.setItem(options3.lookupLocalStorage, lng);
        }
      }
    };
    hasSessionStorageSupport = null;
    sessionStorageAvailable = function sessionStorageAvailable2() {
      if (hasSessionStorageSupport !== null)
        return hasSessionStorageSupport;
      try {
        hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
        var testKey = "i18next.translate.boo";
        window.sessionStorage.setItem(testKey, "foo");
        window.sessionStorage.removeItem(testKey);
      } catch (e5) {
        hasSessionStorageSupport = false;
      }
      return hasSessionStorageSupport;
    };
    sessionStorage2 = {
      name: "sessionStorage",
      lookup: function lookup4(options3) {
        var found;
        if (options3.lookupSessionStorage && sessionStorageAvailable()) {
          var lng = window.sessionStorage.getItem(options3.lookupSessionStorage);
          if (lng)
            found = lng;
        }
        return found;
      },
      cacheUserLanguage: function cacheUserLanguage3(lng, options3) {
        if (options3.lookupSessionStorage && sessionStorageAvailable()) {
          window.sessionStorage.setItem(options3.lookupSessionStorage, lng);
        }
      }
    };
    navigator$1 = {
      name: "navigator",
      lookup: function lookup5(options3) {
        var found = [];
        if (typeof navigator !== "undefined") {
          if (navigator.languages) {
            for (var i9 = 0; i9 < navigator.languages.length; i9++) {
              found.push(navigator.languages[i9]);
            }
          }
          if (navigator.userLanguage) {
            found.push(navigator.userLanguage);
          }
          if (navigator.language) {
            found.push(navigator.language);
          }
        }
        return found.length > 0 ? found : void 0;
      }
    };
    htmlTag = {
      name: "htmlTag",
      lookup: function lookup6(options3) {
        var found;
        var htmlTag2 = options3.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
        if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
          found = htmlTag2.getAttribute("lang");
        }
        return found;
      }
    };
    path = {
      name: "path",
      lookup: function lookup7(options3) {
        var found;
        if (typeof window !== "undefined") {
          var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
          if (language instanceof Array) {
            if (typeof options3.lookupFromPathIndex === "number") {
              if (typeof language[options3.lookupFromPathIndex] !== "string") {
                return void 0;
              }
              found = language[options3.lookupFromPathIndex].replace("/", "");
            } else {
              found = language[0].replace("/", "");
            }
          }
        }
        return found;
      }
    };
    subdomain = {
      name: "subdomain",
      lookup: function lookup8(options3) {
        var lookupFromSubdomainIndex = typeof options3.lookupFromSubdomainIndex === "number" ? options3.lookupFromSubdomainIndex + 1 : 1;
        var language = typeof window !== "undefined" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
        if (!language)
          return void 0;
        return language[lookupFromSubdomainIndex];
      }
    };
    Browser = /* @__PURE__ */ function() {
      function Browser2(services) {
        var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Browser2);
        this.type = "languageDetector";
        this.detectors = {};
        this.init(services, options3);
      }
      _createClass(Browser2, [{
        key: "init",
        value: function init3(services) {
          var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this.services = services || {
            languageUtils: {}
          };
          this.options = defaults2(options3, this.options || {}, getDefaults2());
          if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
            this.options.convertDetectedLanguage = function(l7) {
              return l7.replace("-", "_");
            };
          }
          if (this.options.lookupFromUrlIndex)
            this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
          this.i18nOptions = i18nOptions;
          this.addDetector(cookie$1);
          this.addDetector(querystring);
          this.addDetector(localStorage2);
          this.addDetector(sessionStorage2);
          this.addDetector(navigator$1);
          this.addDetector(htmlTag);
          this.addDetector(path);
          this.addDetector(subdomain);
        }
      }, {
        key: "addDetector",
        value: function addDetector(detector) {
          this.detectors[detector.name] = detector;
        }
      }, {
        key: "detect",
        value: function detect(detectionOrder) {
          var _this = this;
          if (!detectionOrder)
            detectionOrder = this.options.order;
          var detected = [];
          detectionOrder.forEach(function(detectorName) {
            if (_this.detectors[detectorName]) {
              var lookup10 = _this.detectors[detectorName].lookup(_this.options);
              if (lookup10 && typeof lookup10 === "string")
                lookup10 = [lookup10];
              if (lookup10)
                detected = detected.concat(lookup10);
            }
          });
          detected = detected.map(function(d6) {
            return _this.options.convertDetectedLanguage(d6);
          });
          if (this.services.languageUtils.getBestMatchFromCodes)
            return detected;
          return detected.length > 0 ? detected[0] : null;
        }
      }, {
        key: "cacheUserLanguage",
        value: function cacheUserLanguage4(lng, caches2) {
          var _this2 = this;
          if (!caches2)
            caches2 = this.options.caches;
          if (!caches2)
            return;
          if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1)
            return;
          caches2.forEach(function(cacheName) {
            if (_this2.detectors[cacheName])
              _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
          });
        }
      }]);
      return Browser2;
    }();
    Browser.type = "languageDetector";
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i9 = 1; i9 < arguments.length; i9++) {
      var source2 = arguments[i9];
      for (var key3 in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key3)) {
          target[key3] = source2[key3];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var init_extends = __esm({
  "node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "node_modules/void-elements/index.js"(exports, module2) {
    module2.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
  }
});

// node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
function n3(n7) {
  var r8 = { type: "tag", name: "", voidElement: false, attrs: {}, children: [] }, i9 = n7.match(/<\/?([^\s]+?)[/\s>]/);
  if (i9 && (r8.name = i9[1], (import_void_elements.default[i9[1]] || "/" === n7.charAt(n7.length - 2)) && (r8.voidElement = true), r8.name.startsWith("!--"))) {
    var s9 = n7.indexOf("-->");
    return { type: "comment", comment: -1 !== s9 ? n7.slice(4, s9) : "" };
  }
  for (var a7 = new RegExp(t5), c8 = null; null !== (c8 = a7.exec(n7)); )
    if (c8[0].trim())
      if (c8[1]) {
        var o7 = c8[1].trim(), l7 = [o7, ""];
        o7.indexOf("=") > -1 && (l7 = o7.split("=")), r8.attrs[l7[0]] = l7[1], a7.lastIndex--;
      } else
        c8[2] && (r8.attrs[c8[2]] = c8[3].trim().substring(1, c8[3].length - 1));
  return r8;
}
function a5(e5, t8) {
  switch (t8.type) {
    case "text":
      return e5 + t8.content;
    case "tag":
      return e5 += "<" + t8.name + (t8.attrs ? function(e6) {
        var t9 = [];
        for (var n7 in e6)
          t9.push(n7 + '="' + e6[n7] + '"');
        return t9.length ? " " + t9.join(" ") : "";
      }(t8.attrs) : "") + (t8.voidElement ? "/>" : ">"), t8.voidElement ? e5 : e5 + t8.children.reduce(a5, "") + "</" + t8.name + ">";
    case "comment":
      return e5 + "<!--" + t8.comment + "-->";
  }
}
var import_void_elements, t5, r5, i6, s5, c5, html_parse_stringify_module_default;
var init_html_parse_stringify_module = __esm({
  "node_modules/html-parse-stringify/dist/html-parse-stringify.module.js"() {
    import_void_elements = __toESM(require_void_elements());
    t5 = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
    r5 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g;
    i6 = /^\s*$/;
    s5 = /* @__PURE__ */ Object.create(null);
    c5 = { parse: function(e5, t8) {
      t8 || (t8 = {}), t8.components || (t8.components = s5);
      var a7, c8 = [], o7 = [], l7 = -1, m5 = false;
      if (0 !== e5.indexOf("<")) {
        var u6 = e5.indexOf("<");
        c8.push({ type: "text", content: -1 === u6 ? e5 : e5.substring(0, u6) });
      }
      return e5.replace(r5, function(r8, s9) {
        if (m5) {
          if (r8 !== "</" + a7.name + ">")
            return;
          m5 = false;
        }
        var u7, f5 = "/" !== r8.charAt(1), h6 = r8.startsWith("<!--"), p5 = s9 + r8.length, d6 = e5.charAt(p5);
        if (h6) {
          var v5 = n3(r8);
          return l7 < 0 ? (c8.push(v5), c8) : ((u7 = o7[l7]).children.push(v5), c8);
        }
        if (f5 && (l7++, "tag" === (a7 = n3(r8)).type && t8.components[a7.name] && (a7.type = "component", m5 = true), a7.voidElement || m5 || !d6 || "<" === d6 || a7.children.push({ type: "text", content: e5.slice(p5, e5.indexOf("<", p5)) }), 0 === l7 && c8.push(a7), (u7 = o7[l7 - 1]) && u7.children.push(a7), o7[l7] = a7), (!f5 || a7.voidElement) && (l7 > -1 && (a7.voidElement || a7.name === r8.slice(2, -1)) && (l7--, a7 = -1 === l7 ? c8 : o7[l7]), !m5 && "<" !== d6 && d6)) {
          u7 = -1 === l7 ? c8 : o7[l7].children;
          var x4 = e5.indexOf("<", p5), g7 = e5.slice(p5, -1 === x4 ? void 0 : x4);
          i6.test(g7) && (g7 = " "), (x4 > -1 && l7 + u7.length >= 0 || " " !== g7) && u7.push({ type: "text", content: g7 });
        }
      }), c8;
    }, stringify: function(e5) {
      return e5.reduce(function(e6, t8) {
        return e6 + a5("", t8);
      }, "");
    } };
    html_parse_stringify_module_default = c5;
  }
});

// node_modules/react-i18next/dist/es/utils.js
function warn() {
  if (console && console.warn) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = `react-i18next:: ${args[0]}`;
    console.warn(...args);
  }
}
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn(...args);
}
function loadNamespaces2(i18n, ns, cb) {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb));
}
function loadLanguages2(i18n, lng, ns, cb) {
  if (typeof ns === "string")
    ns = [ns];
  ns.forEach((n7) => {
    if (i18n.options.ns.indexOf(n7) < 0)
      i18n.options.ns.push(n7);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  let options3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const lng = i18n.languages[0];
  const fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  const lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  const loadNotPending = (l7, n7) => {
    const loadState = i18n.services.backendConnector.state[`${l7}|${n7}`];
    return loadState === -1 || loadState === 2;
  };
  if (options3.bindI18n && options3.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
    return false;
  if (i18n.hasResourceBundle(lng, ns))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
    return true;
  return false;
}
function hasLoadedNamespace2(ns, i18n) {
  let options3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  const isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns, i18n, options3);
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options3.lng,
    precheck: (i18nInstance2, loadNotPending) => {
      if (options3.bindI18n && options3.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
        return false;
    }
  });
}
var alreadyWarned, loadedClb;
var init_utils3 = __esm({
  "node_modules/react-i18next/dist/es/utils.js"() {
    alreadyWarned = {};
    loadedClb = (i18n, cb) => () => {
      if (i18n.isInitialized) {
        cb();
      } else {
        const initialized = () => {
          setTimeout(() => {
            i18n.off("initialized", initialized);
          }, 0);
          cb();
        };
        i18n.on("initialized", initialized);
      }
    };
  }
});

// node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity, htmlEntities, unescapeHtmlEntity, unescape3;
var init_unescape = __esm({
  "node_modules/react-i18next/dist/es/unescape.js"() {
    matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
    htmlEntities = {
      "&amp;": "&",
      "&#38;": "&",
      "&lt;": "<",
      "&#60;": "<",
      "&gt;": ">",
      "&#62;": ">",
      "&apos;": "'",
      "&#39;": "'",
      "&quot;": '"',
      "&#34;": '"',
      "&nbsp;": " ",
      "&#160;": " ",
      "&copy;": "\xA9",
      "&#169;": "\xA9",
      "&reg;": "\xAE",
      "&#174;": "\xAE",
      "&hellip;": "\u2026",
      "&#8230;": "\u2026",
      "&#x2F;": "/",
      "&#47;": "/"
    };
    unescapeHtmlEntity = (m5) => htmlEntities[m5];
    unescape3 = (text2) => text2.replace(matchHtmlEntity, unescapeHtmlEntity);
  }
});

// node_modules/react-i18next/dist/es/defaults.js
function setDefaults() {
  let options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions2 = {
    ...defaultOptions2,
    ...options3
  };
}
function getDefaults3() {
  return defaultOptions2;
}
var defaultOptions2;
var init_defaults = __esm({
  "node_modules/react-i18next/dist/es/defaults.js"() {
    init_unescape();
    defaultOptions2 = {
      bindI18n: "languageChanged",
      bindI18nStore: "",
      transEmptyNodeValue: "",
      transSupportBasicHtmlNodes: true,
      transWrapTextNodes: "",
      transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
      useSuspense: true,
      unescape: unescape3
    };
  }
});

// node_modules/react-i18next/dist/es/i18nInstance.js
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}
var i18nInstance;
var init_i18nInstance = __esm({
  "node_modules/react-i18next/dist/es/i18nInstance.js"() {
  }
});

// node_modules/react-i18next/dist/es/TransWithoutContext.js
function hasChildren(node, checkLength) {
  if (!node)
    return false;
  const base2 = node.props ? node.props.children : node.children;
  if (checkLength)
    return base2.length > 0;
  return !!base2;
}
function getChildren(node) {
  if (!node)
    return [];
  const children = node.props ? node.props.children : node.children;
  return node.props && node.props.i18nIsDynamicList ? getAsArray(children) : children;
}
function hasValidReactChildren(children) {
  if (Object.prototype.toString.call(children) !== "[object Array]")
    return false;
  return children.every((child) => (0, import_react.isValidElement)(child));
}
function getAsArray(data) {
  return Array.isArray(data) ? data : [data];
}
function mergeProps(source2, target) {
  const newTarget = {
    ...target
  };
  newTarget.props = Object.assign(source2.props, target.props);
  return newTarget;
}
function nodesToString(children, i18nOptions) {
  if (!children)
    return "";
  let stringNode = "";
  const childrenArray = getAsArray(children);
  const keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
  childrenArray.forEach((child, childIndex) => {
    if (typeof child === "string") {
      stringNode += `${child}`;
    } else if ((0, import_react.isValidElement)(child)) {
      const childPropsCount = Object.keys(child.props).length;
      const shouldKeepChild = keepArray.indexOf(child.type) > -1;
      const childChildren = child.props.children;
      if (!childChildren && shouldKeepChild && childPropsCount === 0) {
        stringNode += `<${child.type}/>`;
      } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
        stringNode += `<${childIndex}></${childIndex}>`;
      } else if (child.props.i18nIsDynamicList) {
        stringNode += `<${childIndex}></${childIndex}>`;
      } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") {
        stringNode += `<${child.type}>${childChildren}</${child.type}>`;
      } else {
        const content = nodesToString(childChildren, i18nOptions);
        stringNode += `<${childIndex}>${content}</${childIndex}>`;
      }
    } else if (child === null) {
      warn(`Trans: the passed in value is invalid - seems you passed in a null child.`);
    } else if (typeof child === "object") {
      const {
        format,
        ...clone2
      } = child;
      const keys = Object.keys(clone2);
      if (keys.length === 1) {
        const value = format ? `${keys[0]}, ${format}` : keys[0];
        stringNode += `{{${value}}}`;
      } else {
        warn(`react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`, child);
      }
    } else {
      warn(`Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.`, child);
    }
  });
  return stringNode;
}
function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
  if (targetString === "")
    return [];
  const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map((keep) => `<${keep}`).join("|")).test(targetString);
  if (!children && !emptyChildrenButNeedsHandling && !shouldUnescape)
    return [targetString];
  const data = {};
  function getData(childs) {
    const childrenArray = getAsArray(childs);
    childrenArray.forEach((child) => {
      if (typeof child === "string")
        return;
      if (hasChildren(child))
        getData(getChildren(child));
      else if (typeof child === "object" && !(0, import_react.isValidElement)(child))
        Object.assign(data, child);
    });
  }
  getData(children);
  const ast = html_parse_stringify_module_default.parse(`<0>${targetString}</0>`);
  const opts = {
    ...data,
    ...combinedTOpts
  };
  function renderInner(child, node, rootReactNode) {
    const childs = getChildren(child);
    const mappedChildren = mapAST(childs, node.children, rootReactNode);
    return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props && child.props.i18nIsDynamicList ? childs : mappedChildren;
  }
  function pushTranslatedJSX(child, inner, mem, i9, isVoid2) {
    if (child.dummy) {
      child.children = inner;
      mem.push((0, import_react.cloneElement)(child, {
        key: i9
      }, isVoid2 ? void 0 : inner));
    } else {
      mem.push(...import_react.Children.map([child], (c8) => {
        const props = {
          ...c8.props
        };
        delete props.i18nIsDynamicList;
        return import_react.default.createElement(c8.type, _extends({}, props, {
          key: i9,
          ref: c8.ref
        }, isVoid2 ? {} : {
          children: inner
        }));
      }));
    }
  }
  function mapAST(reactNode, astNode, rootReactNode) {
    const reactNodes = getAsArray(reactNode);
    const astNodes = getAsArray(astNode);
    return astNodes.reduce((mem, node, i9) => {
      const translationContent = node.children && node.children[0] && node.children[0].content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
      if (node.type === "tag") {
        let tmp = reactNodes[parseInt(node.name, 10)];
        if (rootReactNode.length === 1 && !tmp)
          tmp = rootReactNode[0][node.name];
        if (!tmp)
          tmp = {};
        const child = Object.keys(node.attrs).length !== 0 ? mergeProps({
          props: node.attrs
        }, tmp) : tmp;
        const isElement2 = (0, import_react.isValidElement)(child);
        const isValidTranslationWithChildren = isElement2 && hasChildren(node, true) && !node.voidElement;
        const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && typeof child === "object" && child.dummy && !isElement2;
        const isKnownComponent = typeof children === "object" && children !== null && Object.hasOwnProperty.call(children, node.name);
        if (typeof child === "string") {
          const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
          mem.push(value);
        } else if (hasChildren(child) || isValidTranslationWithChildren) {
          const inner = renderInner(child, node, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i9);
        } else if (isEmptyTransWithHTML) {
          const inner = mapAST(reactNodes, node.children, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i9);
        } else if (Number.isNaN(parseFloat(node.name))) {
          if (isKnownComponent) {
            const inner = renderInner(child, node, rootReactNode);
            pushTranslatedJSX(child, inner, mem, i9, node.voidElement);
          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {
            if (node.voidElement) {
              mem.push((0, import_react.createElement)(node.name, {
                key: `${node.name}-${i9}`
              }));
            } else {
              const inner = mapAST(reactNodes, node.children, rootReactNode);
              mem.push((0, import_react.createElement)(node.name, {
                key: `${node.name}-${i9}`
              }, inner));
            }
          } else if (node.voidElement) {
            mem.push(`<${node.name} />`);
          } else {
            const inner = mapAST(reactNodes, node.children, rootReactNode);
            mem.push(`<${node.name}>${inner}</${node.name}>`);
          }
        } else if (typeof child === "object" && !isElement2) {
          const content = node.children[0] ? translationContent : null;
          if (content)
            mem.push(content);
        } else {
          pushTranslatedJSX(child, translationContent, mem, i9, node.children.length !== 1 || !translationContent);
        }
      } else if (node.type === "text") {
        const wrapTextNodes = i18nOptions.transWrapTextNodes;
        const content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
        if (wrapTextNodes) {
          mem.push((0, import_react.createElement)(wrapTextNodes, {
            key: `${node.name}-${i9}`
          }, content));
        } else {
          mem.push(content);
        }
      }
      return mem;
    }, []);
  }
  const result = mapAST([{
    dummy: true,
    children: children || []
  }], ast, getAsArray(children || []));
  return getChildren(result[0]);
}
function Trans(_ref) {
  let {
    children,
    count,
    parent,
    i18nKey,
    context,
    tOptions = {},
    values,
    defaults: defaults4,
    components,
    ns,
    i18n: i18nFromProps,
    t: tFromProps,
    shouldUnescape,
    ...additionalProps
  } = _ref;
  const i18n = i18nFromProps || getI18n();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
    return children;
  }
  const t8 = tFromProps || i18n.t.bind(i18n) || ((k4) => k4);
  if (context)
    tOptions.context = context;
  const reactI18nextOptions = {
    ...getDefaults3(),
    ...i18n.options && i18n.options.react
  };
  let namespaces = ns || t8.ns || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  const nodeAsString = nodesToString(children, reactI18nextOptions);
  const defaultValue = defaults4 || nodeAsString || reactI18nextOptions.transEmptyNodeValue || i18nKey;
  const {
    hashTransKey
  } = reactI18nextOptions;
  const key3 = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);
  const interpolationOverride = values ? tOptions.interpolation : {
    interpolation: {
      ...tOptions.interpolation,
      prefix: "#$?",
      suffix: "?$#"
    }
  };
  const combinedTOpts = {
    ...tOptions,
    count,
    ...values,
    ...interpolationOverride,
    defaultValue,
    ns: namespaces
  };
  const translation = key3 ? t8(key3, combinedTOpts) : defaultValue;
  const content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
  const useAsParent = parent !== void 0 ? parent : reactI18nextOptions.defaultTransParent;
  return useAsParent ? (0, import_react.createElement)(useAsParent, additionalProps, content) : content;
}
var import_react;
var init_TransWithoutContext = __esm({
  "node_modules/react-i18next/dist/es/TransWithoutContext.js"() {
    init_extends();
    import_react = __toESM(require_react(), 1);
    init_html_parse_stringify_module();
    init_utils3();
    init_defaults();
    init_i18nInstance();
  }
});

// node_modules/react-i18next/dist/es/initReactI18next.js
var initReactI18next;
var init_initReactI18next = __esm({
  "node_modules/react-i18next/dist/es/initReactI18next.js"() {
    init_defaults();
    init_i18nInstance();
    initReactI18next = {
      type: "3rdParty",
      init(instance2) {
        setDefaults(instance2.options.react);
        setI18n(instance2);
      }
    };
  }
});

// node_modules/react-i18next/dist/es/context.js
var import_react2, I18nContext, ReportNamespaces;
var init_context = __esm({
  "node_modules/react-i18next/dist/es/context.js"() {
    import_react2 = __toESM(require_react(), 1);
    init_defaults();
    init_i18nInstance();
    init_initReactI18next();
    I18nContext = (0, import_react2.createContext)();
    ReportNamespaces = class {
      constructor() {
        this.usedNamespaces = {};
      }
      addUsedNamespaces(namespaces) {
        namespaces.forEach((ns) => {
          if (!this.usedNamespaces[ns])
            this.usedNamespaces[ns] = true;
        });
      }
      getUsedNamespaces() {
        return Object.keys(this.usedNamespaces);
      }
    };
  }
});

// node_modules/react-i18next/dist/es/Trans.js
function Trans2(_ref) {
  let {
    children,
    count,
    parent,
    i18nKey,
    context,
    tOptions = {},
    values,
    defaults: defaults4,
    components,
    ns,
    i18n: i18nFromProps,
    t: tFromProps,
    shouldUnescape,
    ...additionalProps
  } = _ref;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = (0, import_react3.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  const t8 = tFromProps || i18n && i18n.t.bind(i18n);
  return Trans({
    children,
    count,
    parent,
    i18nKey,
    context,
    tOptions,
    values,
    defaults: defaults4,
    components,
    ns: ns || t8 && t8.ns || defaultNSFromContext || i18n && i18n.options && i18n.options.defaultNS,
    i18n,
    t: tFromProps,
    shouldUnescape,
    ...additionalProps
  });
}
var import_react3;
var init_Trans = __esm({
  "node_modules/react-i18next/dist/es/Trans.js"() {
    import_react3 = __toESM(require_react(), 1);
    init_TransWithoutContext();
    init_context();
  }
});

// node_modules/react-i18next/dist/es/useTranslation.js
function useTranslation(ns) {
  let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = (0, import_react4.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k4, optsOrDefaultValue) => {
      if (typeof optsOrDefaultValue === "string")
        return optsOrDefaultValue;
      if (optsOrDefaultValue && typeof optsOrDefaultValue === "object" && typeof optsOrDefaultValue.defaultValue === "string")
        return optsOrDefaultValue.defaultValue;
      return Array.isArray(k4) ? k4[k4.length - 1] : k4;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults3(),
    ...i18n.options.react,
    ...props
  };
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n7) => hasLoadedNamespace2(n7, i18n, i18nOptions));
  function getT() {
    return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  const [t8, setT] = (0, import_react4.useState)(getT);
  let joinedNS = namespaces.join();
  if (props.lng)
    joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious(joinedNS);
  const isMounted = (0, import_react4.useRef)(true);
  (0, import_react4.useEffect)(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages2(i18n, props.lng, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      } else {
        loadNamespaces2(i18n, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getT);
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach((e5) => i18n.off(e5, boundReset));
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach((e5) => i18n.store.off(e5, boundReset));
    };
  }, [i18n, joinedNS]);
  const isInitial = (0, import_react4.useRef)(true);
  (0, import_react4.useEffect)(() => {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n, keyPrefix]);
  const ret = [t8, i18n, ready];
  ret.t = t8;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise((resolve2) => {
    if (props.lng) {
      loadLanguages2(i18n, props.lng, namespaces, () => resolve2());
    } else {
      loadNamespaces2(i18n, namespaces, () => resolve2());
    }
  });
}
var import_react4, usePrevious;
var init_useTranslation = __esm({
  "node_modules/react-i18next/dist/es/useTranslation.js"() {
    import_react4 = __toESM(require_react(), 1);
    init_context();
    init_utils3();
    usePrevious = (value, ignore) => {
      const ref = (0, import_react4.useRef)();
      (0, import_react4.useEffect)(() => {
        ref.current = ignore ? ref.current : value;
      }, [value, ignore]);
      return ref.current;
    };
  }
});

// node_modules/react-i18next/dist/es/withTranslation.js
var import_react5;
var init_withTranslation = __esm({
  "node_modules/react-i18next/dist/es/withTranslation.js"() {
    import_react5 = __toESM(require_react(), 1);
    init_useTranslation();
    init_utils3();
  }
});

// node_modules/react-i18next/dist/es/Translation.js
var init_Translation = __esm({
  "node_modules/react-i18next/dist/es/Translation.js"() {
    init_useTranslation();
  }
});

// node_modules/react-i18next/dist/es/I18nextProvider.js
var import_react6;
var init_I18nextProvider = __esm({
  "node_modules/react-i18next/dist/es/I18nextProvider.js"() {
    import_react6 = __toESM(require_react(), 1);
    init_context();
  }
});

// node_modules/react-i18next/dist/es/useSSR.js
var import_react7;
var init_useSSR = __esm({
  "node_modules/react-i18next/dist/es/useSSR.js"() {
    import_react7 = __toESM(require_react(), 1);
    init_context();
  }
});

// node_modules/react-i18next/dist/es/withSSR.js
var import_react8;
var init_withSSR = __esm({
  "node_modules/react-i18next/dist/es/withSSR.js"() {
    import_react8 = __toESM(require_react(), 1);
    init_useSSR();
    init_context();
    init_utils3();
  }
});

// node_modules/react-i18next/dist/es/index.js
var init_es = __esm({
  "node_modules/react-i18next/dist/es/index.js"() {
    init_Trans();
    init_TransWithoutContext();
    init_useTranslation();
    init_withTranslation();
    init_Translation();
    init_I18nextProvider();
    init_withSSR();
    init_useSSR();
    init_initReactI18next();
    init_defaults();
    init_i18nInstance();
    init_context();
  }
});

// node_modules/@corbado/react/dist/index.js
var u5, D3, r6, l6, n4, j3, i7, c6, s6, g6, I3, T, o4, z2, L4, y6, d5, E5, A4, x3, O2, m4, C4, w5, S4, k3, Q2, Y2, U3, f4, b4, v4, p4, h4, B2, P3, F3, Z3, G2, R2, H2, W3, V2, J2, _3, X2, K2, $2, q3, ee2, Me2, te2, ae2, Ne2, ue2, De2, re2, le2, ne2, je2, ie3, ce2, se3, ge2, Ie2, Te2, oe2, ze2, Le2, ye2, de2, Ee2, Ae2, xe2, Oe, me2, Ce2, we2, Se2, ke2, Qe2, Ye2, Ue2, fe2, be2, ve2, pe2, he2, Be2;
var init_dist6 = __esm({
  "node_modules/@corbado/react/dist/index.js"() {
    init_dist4();
    init_dist5();
    init_i18next();
    init_i18nextBrowserLanguageDetector();
    init_es();
    u5 = __toESM(require_react());
    D3 = { d: (e5, M4) => {
      for (var t8 in M4)
        D3.o(M4, t8) && !D3.o(e5, t8) && Object.defineProperty(e5, t8, { enumerable: true, get: M4[t8] });
    }, o: (e5, M4) => Object.prototype.hasOwnProperty.call(e5, M4) };
    r6 = {};
    D3.d(r6, { rX: () => we2, Hg: () => A4, BN: () => i7.CorbadoThemes, m3: () => Se2, XZ: () => ke2, Mo: () => Qe2, km: () => l6.useCorbado, Ye: () => l6.useCorbadoSession });
    l6 = (n4 = { CorbadoProvider: () => b2, useCorbado: () => L2, useCorbadoSession: () => f3 }, j3 = {}, D3.d(j3, n4), j3);
    i7 = ((e5) => {
      var M4 = {};
      return D3.d(M4, e5), M4;
    })({ CorbadoThemes: () => o3, FlowHandler: () => a4, FlowHandlerEvents: () => M3, FlowType: () => s4, LoginFlowNames: () => c4, ScreenNames: () => A3, SignUpFlowNames: () => l5, aaguidMappings: () => u4, getParsedUA: () => y5, handleTheming: () => d4, hasDarkMode: () => j2, i18n: () => b3, notANumberRegex: () => w4, numberRegex: () => C3, updateSvgFillColor: () => z });
    c6 = ((e5) => {
      var M4 = {};
      return D3.d(M4, e5), M4;
    })({ default: () => instance });
    s6 = ((e5) => {
      var M4 = {};
      return D3.d(M4, e5), M4;
    })({ default: () => Browser });
    g6 = ((e5) => {
      var M4 = {};
      return D3.d(M4, e5), M4;
    })({ Trans: () => Trans2, initReactI18next: () => initReactI18next, useTranslation: () => useTranslation });
    I3 = "en";
    c6.default.use(g6.initReactI18next).use(s6.default).init({ resources: { en: { translation: i7.i18n.en }, de: { translation: i7.i18n.de } }, keySeparator: ".", fallbackLng: I3 });
    T = (e5) => {
      var M4;
      null === (M4 = null === document || void 0 === document ? void 0 : document.querySelector("html")) || void 0 === M4 || M4.setAttribute("lang", e5);
    };
    o4 = (e5 = true, M4 = I3, t8 = null) => {
      const a7 = window.navigator.language;
      if (e5 && M4 === I3 && a7 === I3 && !t8)
        return;
      for (const [e6, M5] of Object.entries(null != t8 ? t8 : {}))
        c6.default.addResourceBundle(e6, "translation", M5, true, true);
      const N4 = e5 ? ((e6) => e6.split("-")[0])(a7) : M4;
      try {
        c6.default.changeLanguage(N4), T(N4);
      } catch {
        c6.default.changeLanguage(M4), T(M4);
      }
    };
    z2 = ((e5) => {
      var M4 = {};
      return D3.d(M4, e5), M4;
    })({ createContext: () => u5.createContext, default: () => u5.default, forwardRef: () => u5.forwardRef, memo: () => u5.memo, useCallback: () => u5.useCallback, useContext: () => u5.useContext, useEffect: () => u5.useEffect, useMemo: () => u5.useMemo, useRef: () => u5.useRef, useState: () => u5.useState });
    L4 = (0, z2.createContext)({ customerSupportEmail: "", isDevMode: false });
    y6 = ({ children: e5, customerSupportEmail: M4, isDevMode: t8 }) => {
      const a7 = (0, z2.useMemo)(() => ({ customerSupportEmail: M4, isDevMode: t8 }), [M4, t8]);
      return z2.default.createElement(L4.Provider, { value: a7 }, e5);
    };
    d5 = (0, z2.createContext)({ theme: "", darkMode: "auto", themeUpdateTS: 0, updateTheme: () => {
    } });
    E5 = ({ children: e5, theme: M4, darkMode: t8 }) => {
      const [a7, N4] = (0, z2.useState)(M4), [u6, D4] = (0, z2.useState)(t8), [r8, l7] = (0, z2.useState)(0);
      (0, z2.useEffect)(() => {
        const e6 = new MutationObserver(() => {
          l7(Date.now());
        });
        return e6.observe(document.body, { attributes: true, attributeFilter: ["class"], childList: false, subtree: false }), () => {
          e6.disconnect();
        };
      }, []), (0, z2.useEffect)(() => {
        n7(null != M4 ? M4 : "", null != t8 ? t8 : "auto");
      }, [M4, t8]);
      const n7 = (e6, M5) => {
        N4(e6), D4(M5), l7(Date.now());
      };
      return z2.default.createElement(d5.Provider, { value: { theme: a7, darkMode: u6, themeUpdateTS: r8, updateTheme: n7 } }, e5);
    };
    A4 = ({ children: e5, ...M4 }) => {
      var t8, a7;
      const { defaultLanguage: N4, autoDetectLanguage: u6, customTranslations: D4, darkMode: r8, theme: n7, ...j4 } = M4;
      return (0, z2.useEffect)(() => {
        o4(u6, N4, D4);
      }, [u6, N4, D4]), (0, z2.useEffect)(() => (0, i7.handleTheming)(null != r8 ? r8 : "auto", n7), [r8, n7]), z2.default.createElement(l6.CorbadoProvider, { ...j4 }, z2.default.createElement(y6, { customerSupportEmail: null !== (t8 = M4.customerSupportEmail) && void 0 !== t8 ? t8 : "", isDevMode: null !== (a7 = M4.isDevMode) && void 0 !== a7 && a7 }, z2.default.createElement(E5, { theme: n7, darkMode: r8 }, e5)));
    };
    x3 = (0, z2.memo)(({ variant: e5 = "primary", className: M4 = "" }) => {
      const t8 = `${"primary" === e5 ? "cb-spinner-primary" : "cb-spinner-secondary"} ${M4}`;
      return z2.default.createElement("div", { className: t8 });
    }, (e5, M4) => e5.variant === M4.variant && e5.className === M4.className);
    O2 = (0, z2.forwardRef)(({ isLoading: e5 = false, disabled: M4, children: t8, ...a7 }, N4) => z2.default.createElement("button", { disabled: e5 || M4, ref: N4, ...a7 }, e5 ? z2.default.createElement(x3, null) : t8));
    m4 = (0, z2.forwardRef)(({ isLoading: e5, disabled: M4, className: t8, children: a7, ...N4 }, u6) => z2.default.createElement(O2, { className: `${t8} cb-button-primary`, isLoading: e5, disabled: M4, ref: u6, children: a7, ...N4 }));
    C4 = (0, z2.forwardRef)(({ isLoading: e5, disabled: M4, className: t8, children: a7, ...N4 }, u6) => z2.default.createElement(O2, { className: `${t8} cb-button-secondary`, isLoading: e5, disabled: M4, ref: u6, children: a7, ...N4 }));
    w5 = (0, z2.forwardRef)(({ isLoading: e5, disabled: M4, className: t8, children: a7, ...N4 }, u6) => z2.default.createElement(O2, { className: `${t8} cb-button-tertiary`, isLoading: e5, disabled: M4, ref: u6, children: a7, ...N4 }));
    S4 = ({ children: e5, className: M4 = "" }) => z2.default.createElement("div", { className: `cb-horizontal-divider ${M4}` }, e5);
    k3 = (0, z2.forwardRef)(({ src: e5, style: M4, alt: t8 = "", onClick: a7, className: N4 = "" }, u6) => z2.default.createElement("img", { src: e5, ref: u6, alt: t8, onClick: a7, style: M4, className: `cb-icon ${a7 ? "cb-pointer" : ""} ${N4}` }));
    Q2 = z2.default.forwardRef(({ id: e5, className: M4 = "", error: t8, ...a7 }, N4) => {
      const u6 = `cb-input ${M4} ${t8 ? "cb-error" : ""}`;
      return z2.default.createElement("input", { id: e5, ...a7, className: u6, autoComplete: a7.autoComplete ? a7.autoComplete : "off", ref: N4 });
    });
    Y2 = z2.default.forwardRef(({ label: e5, type: M4, id: t8, name: a7, value: N4, onChange: u6, onFocus: D4, onBlur: r8, error: l7, ...n7 }, j4) => {
      const [i9, c8] = z2.default.useState(false), [s9, g7] = z2.default.useState(false), I4 = `cb-form-input ${i9 ? "cb-has-focus" : ""} ${s9 ? "cb-has-content" : ""} ${l7 ? "cb-has-error" : ""}`;
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement("div", { className: I4 }, z2.default.createElement(Q2, { ref: j4, type: M4, id: t8 || a7, name: a7, value: N4, placeholder: e5, onChange: (e6) => {
        g7(!!e6.target.value), u6 && u6(e6);
      }, onFocus: (e6) => {
        c8(true), D4 && D4(e6);
      }, onBlur: (e6) => {
        c8(false), r8 && r8(e6);
      }, error: l7, ...n7 }), z2.default.createElement("label", { htmlFor: t8 || a7 }, e5), l7 ? z2.default.createElement("div", { className: "cb-form-input-error" }, z2.default.createElement("p", { className: "cb-error" }, l7)) : null));
    });
    U3 = ({ target: e5 = "_blank", icon: M4, label: t8, href: a7 }) => z2.default.createElement("a", { target: e5, className: "cb-link-icon", href: a7 }, M4, " ", z2.default.createElement("p", null, t8));
    f4 = (0, z2.forwardRef)(({ index: e5, value: M4, disabled: t8, error: a7, handleOtpChange: N4, handleKeyDown: u6, handlePaste: D4 }, r8) => z2.default.createElement(Q2, { ref: r8, id: `otp-${e5}`, value: M4, type: "tel", inputMode: "numeric", pattern: "[0-9]*", maxLength: 1, onChange: (M5) => N4(M5.target, e5), onKeyDown: (M5) => u6(M5, e5), onPaste: D4, disabled: t8, className: "cb-email-otp-input", autoFocus: 0 === e5, error: a7 }));
    b4 = (0, z2.memo)(({ emittedOTP: e5, numberOfDigits: M4 = 6, loading: t8 = false, error: a7 }) => {
      const [N4, u6] = (0, z2.useState)(new Array(M4).fill("")), D4 = (0, z2.useRef)([]), r8 = (0, z2.useRef)(new Array(M4).fill("")), l7 = (0, z2.useCallback)((M5) => {
        r8.current = M5, e5(M5), u6(M5);
      }, [e5]), n7 = (0, z2.useCallback)((e6, M5) => {
        const t9 = e6.value;
        if (i7.notANumberRegex.test(t9))
          return;
        const a8 = M5 + 1, N5 = r8.current;
        if (N5[M5]) {
          if (a8 >= N5.length)
            return;
          l7(N5.map((e7, M6) => M6 === a8 ? t9 : e7)), a8 + 1 < N5.length && D4.current[a8 + 1].focus();
        } else
          l7(N5.map((e7, a9) => a9 === M5 ? t9 : e7)), a8 < N5.length && t9 && D4.current[a8].focus();
      }, [l7]), j4 = (0, z2.useCallback)((e6, M5) => {
        const t9 = r8.current;
        switch (e6.key) {
          case "ArrowLeft":
            M5 > 0 && D4.current[M5 - 1].focus();
            break;
          case "ArrowRight":
            M5 < t9.length - 1 && D4.current[M5 + 1].focus();
            break;
          case "Backspace":
            t9[M5] ? l7(t9.map((e7, t10) => t10 === M5 ? "" : e7)) : M5 > 0 && (D4.current[M5 - 1].focus(), l7(t9.map((e7, t10) => t10 === M5 - 1 ? "" : e7)));
        }
      }, [l7]), c8 = (0, z2.useCallback)((e6) => {
        e6.preventDefault();
        const M5 = e6.clipboardData.getData("text").slice(0, 6).split("");
        M5.every((e7) => i7.numberRegex.test(e7)) && (l7(M5.concat(new Array(6 - M5.length).fill(""))), D4.current[M5.length - 1].focus());
      }, [l7]);
      return z2.default.createElement("div", { className: "cb-email-otp-input-container" }, N4.map((e6, M5) => z2.default.createElement(f4, { key: M5, index: M5, value: e6, handleOtpChange: n7, handleKeyDown: j4, handlePaste: c8, ref: (e7) => e7 && (D4.current[M5] = e7), disabled: t8, error: a7 })));
    });
    v4 = ({ children: e5, className: M4 = "" }) => z2.default.createElement("h1", { className: `cb-header ${M4}` }, e5);
    p4 = ({ children: e5, className: M4 = "" }) => z2.default.createElement("h2", { className: `cb-subheader ${M4}` }, e5);
    h4 = ({ children: e5, className: M4 = "" }) => z2.default.createElement("p", { className: `cb-body text-center ${M4}` }, e5);
    B2 = (e5) => z2.default.createElement(k3, { src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij4NCiAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPg0KICA8cGF0aCBkPSJNNiAxOWMwIDEuMS45IDIgMiAyaDhjMS4xIDAgMi0uOSAyLTJWN0g2djEyek0xOSA0aC0zLjVsLTEtMWgtNWwtMSAxSDV2MmgxNFY0eiIvPg0KPC9zdmc+DQo=", alt: "delete", ...e5 });
    P3 = (e5) => z2.default.createElement(k3, { src: "data:image/svg+xml;base64,PHN2Zw0KICAgICAgICB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnDQogICAgICAgIHZpZXdCb3g9JzAgLTk2MCA5NjAgOTYwJw0KPg0KICAgIDxwYXRoIGQ9J00xMjAtMTYwdi0xMTJxMC0zNCAxNy41LTYyLjVUMTg0LTM3OHE2Mi0zMSAxMjYtNDYuNVQ0NDAtNDQwcTIwIDAgNDAgMS41dDQwIDQuNXEtNCA1OCAyMSAxMDkuNXQ3MyA4NC41djgwSDEyMFpNNzYwLTQwbC02MC02MHYtMTg2cS00NC0xMy03Mi00OS41VDYwMC00MjBxMC01OCA0MS05OXQ5OS00MXE1OCAwIDk5IDQxdDQxIDk5cTAgNDUtMjUuNSA4MFQ3OTAtMjkwbDUwIDUwLTYwIDYwIDYwIDYwLTgwIDgwWk00NDAtNDgwcS02NiAwLTExMy00N3QtNDctMTEzcTAtNjYgNDctMTEzdDExMy00N3E2NiAwIDExMyA0N3Q0NyAxMTNxMCA2Ni00NyAxMTN0LTExMyA0N1ptMzAwIDgwcTE3IDAgMjguNS0xMS41VDc4MC00NDBxMC0xNy0xMS41LTI4LjVUNzQwLTQ4MHEtMTcgMC0yOC41IDExLjVUNzAwLTQ0MHEwIDE3IDExLjUgMjguNVQ3NDAtNDAwWicgLz4NCjwvc3ZnPg0K", alt: "passkey-default", ...e5 });
    F3 = (e5) => z2.default.createElement(k3, { src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGZpbGw9IiM1YzZiYzAiIGQ9Ik00MiwzN2MwLDIuNzYyLTIuMjM4LDUtNSw1SDExYy0yLjc2MSwwLTUtMi4yMzgtNS01VjExYzAtMi43NjIsMi4yMzktNSw1LTVoMjZjMi43NjIsMCw1LDIuMjM4LDUsNQlWMzd6Ii8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTM0LDEzSDE0Yy0wLjU1MiwwLTEsMC40NDgtMSwxdjEyYzAsMC41NTIsMC40NDgsMSwxLDFoMjBjMC41NTIsMCwxLTAuNDQ4LDEtMVYxNAlDMzUsMTMuNDQ4LDM0LjU1MiwxMywzNCwxM3ogTTMzLDE3bC05LDRsLTktNHYtMmgxOFYxN3oiLz48ZyB0cmFuc2Zvcm09Im1hdHJpeCguNjMwNzIgMCAwIC42MzA3MiAtNzIuMDYzIDEyNy44NjYpIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMTMyLjI2Ni0xNTAuNDkxaDIuMzg1bDEuMzg5LDMuNTUybDEuNDA3LTMuNTUyaDIuMzIybC0zLjQ5Niw4LjQxaC0yLjMzNyBsMC45NTctMi4yMjhMMTMyLjI2Ni0xNTAuNDkxeiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0xNDIuMTg2LTE1MC42MzNjLTEuNzkyLDAtMi45MjQsMS42MDctMi45MjQsMy4yMDdjMCwxLjgwMSwxLjI0MiwzLjIyOCwyLjg5LDMuMjI4IGMxLjIzLDAsMS42OTMtMC43NDksMS42OTMtMC43NDl2MC41ODRoMi4wOHYtNi4xMjhoLTIuMDh2MC41NTdDMTQzLjg0Ni0xNDkuOTM0LDE0My4zMjgtMTUwLjYzMywxNDIuMTg2LTE1MC42MzN6IE0xNDIuNjI5LTE0OC42NjNjMC44MjcsMCwxLjI1MywwLjY1NCwxLjI1MywxLjI0NGMwLDAuNjM2LTAuNDU3LDEuMjU5LTEuMjUzLDEuMjU5Yy0wLjY2LDAtMS4yNTYtMC41MzktMS4yNTYtMS4yMzIgQzE0MS4zNzItMTQ4LjA5NSwxNDEuODUyLTE0OC42NjMsMTQyLjYyOS0xNDguNjYzeiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0xNDYuNjQyLTE0NC4zNjN2LTguODM0aDIuMTc1djMuMjg0YzAsMCwwLjUxNy0wLjcxOSwxLjU5OS0wLjcxOSBjMS4zMjQsMCwyLjA5OSwwLjk4NiwyLjA5OSwyLjM5NnYzLjg3M2gtMi4xNTl2LTMuMzQzYzAtMC40NzctMC4yMjctMC45MzgtMC43NDItMC45MzhjLTAuNTI0LDAtMC43OTcsMC40NjgtMC43OTcsMC45Mzh2My4zNDMgSDE0Ni42NDJ6Ii8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTE1Ni4yMjQtMTUwLjYzMmMtMi4wNTIsMC0zLjI3NCwxLjU2LTMuMjc0LDMuMjMyYzAsMS45MDIsMS40NzksMy4yMDMsMy4yODEsMy4yMDMgYzEuNzQ3LDAsMy4yNzUtMS4yNDEsMy4yNzUtMy4xNzFDMTU5LjUwNy0xNDkuNDc5LDE1Ny45MDctMTUwLjYzMiwxNTYuMjI0LTE1MC42MzJ6IE0xNTYuMjQ0LTE0OC42NDUgYzAuNzI1LDAsMS4yMjYsMC42MDQsMS4yMjYsMS4yNDdjMCwwLjU0OS0wLjQ2NywxLjIyNi0xLjIyNiwxLjIyNmMtMC42OTUsMC0xLjIxNy0wLjU1OC0xLjIxNy0xLjIzMiBDMTU1LjAyNy0xNDguMDUzLDE1NS40Ni0xNDguNjQ1LDE1Ni4yNDQtMTQ4LjY0NXoiLz48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMTYzLjEzMS0xNTAuNjMyYy0yLjA1MiwwLTMuMjc0LDEuNTYtMy4yNzQsMy4yMzJjMCwxLjkwMiwxLjQ3OSwzLjIwMywzLjI4MSwzLjIwMyBjMS43NDcsMCwzLjI3NS0xLjI0MSwzLjI3NS0zLjE3MUMxNjYuNDE0LTE0OS40NzksMTY0LjgxNC0xNTAuNjMyLDE2My4xMzEtMTUwLjYzMnogTTE2My4xNTEtMTQ4LjY0NSBjMC43MjUsMCwxLjIyNiwwLjYwNCwxLjIyNiwxLjI0N2MwLDAuNTQ5LTAuNDY3LDEuMjI2LTEuMjI2LDEuMjI2Yy0wLjY5NSwwLTEuMjE3LTAuNTU4LTEuMjE3LTEuMjMyIEMxNjEuOTMzLTE0OC4wNTMsMTYyLjM2Ny0xNDguNjQ1LDE2My4xNTEtMTQ4LjY0NXoiLz48Y2lyY2xlIGN4PSIxNjguMTMxIiBjeT0iLTE0NS42NzciIHI9IjEuNDQ1IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTE3MC4wNS0xNDcuNjUzaC0yLjYwMWwyLjMwOC01LjU0NWgyLjU5MUwxNzAuMDUtMTQ3LjY1M3oiLz48L2c+PC9zdmc+", alt: "yahoo", ...e5 });
    Z3 = (e5) => z2.default.createElement(k3, { src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGZpbGw9IiM0Y2FmNTAiIGQ9Ik00NSwxNi4ybC01LDIuNzVsLTUsNC43NUwzNSw0MGg3YzEuNjU3LDAsMy0xLjM0MywzLTNWMTYuMnoiLz48cGF0aCBmaWxsPSIjMWU4OGU1IiBkPSJNMywxNi4ybDMuNjE0LDEuNzFMMTMsMjMuN1Y0MEg2Yy0xLjY1NywwLTMtMS4zNDMtMy0zVjE2LjJ6Ii8+PHBvbHlnb24gZmlsbD0iI2U1MzkzNSIgcG9pbnRzPSIzNSwxMS4yIDI0LDE5LjQ1IDEzLDExLjIgMTIsMTcgMTMsMjMuNyAyNCwzMS45NSAzNSwyMy43IDM2LDE3Ii8+PHBhdGggZmlsbD0iI2M2MjgyOCIgZD0iTTMsMTIuMjk4VjE2LjJsMTAsNy41VjExLjJMOS44NzYsOC44NTlDOS4xMzIsOC4zMDEsOC4yMjgsOCw3LjI5OCw4aDBDNC45MjQsOCwzLDkuOTI0LDMsMTIuMjk4eiIvPjxwYXRoIGZpbGw9IiNmYmMwMmQiIGQ9Ik00NSwxMi4yOThWMTYuMmwtMTAsNy41VjExLjJsMy4xMjQtMi4zNDFDMzguODY4LDguMzAxLDM5Ljc3Miw4LDQwLjcwMiw4aDAgQzQzLjA3Niw4LDQ1LDkuOTI0LDQ1LDEyLjI5OHoiLz48L3N2Zz4=", alt: "gmail", ...e5 });
    G2 = (e5) => z2.default.createElement(k3, { src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIGlkPSJMaXZlbGxvXzEiIHg9IjBweCINCiAgICAgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTgzMS4wODUgMTcwMy4zMzUiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE4MzEuMDg1IDE3MDMuMzM1IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCiAgICA8cGF0aCBmaWxsPSIjMEEyNzY3Ig0KICAgICAgICAgIGQ9Ik0xODMxLjA4Myw4OTQuMjVjMC4xLTE0LjMxOC03LjI5OC0yNy42NDQtMTkuNTAzLTM1LjEzMWgtMC4yMTNsLTAuNzY3LTAuNDI2bC02MzQuNDkyLTM3NS41ODUgIGMtMi43NC0xLjg1MS01LjU4My0zLjU0My04LjUxNy01LjA2N2MtMjQuNDk4LTEyLjYzOS01My41OTktMTIuNjM5LTc4LjA5OCwwYy0yLjkzNCwxLjUyNS01Ljc3NywzLjIxNi04LjUxNyw1LjA2N0w0NDYuNDg2LDg1OC42OTMgIGwtMC43NjYsMC40MjZjLTE5LjM5MiwxMi4wNTktMjUuMzM3LDM3LjU1Ni0xMy4yNzgsNTYuOTQ4YzMuNTUzLDUuNzE0LDguNDQ3LDEwLjQ3NCwxNC4yNTcsMTMuODY4bDYzNC40OTIsMzc1LjU4NSAgYzIuNzQ5LDEuODM1LDUuNTkyLDMuNTI3LDguNTE3LDUuMDY4YzI0LjQ5OCwxMi42MzksNTMuNTk5LDEyLjYzOSw3OC4wOTgsMGMyLjkyNS0xLjU0MSw1Ljc2Ny0zLjIzMiw4LjUxNy01LjA2OGw2MzQuNDkyLTM3NS41ODUgIEMxODIzLjQ5LDkyMi41NDUsMTgzMS4yMjgsOTA4LjkyMywxODMxLjA4Myw4OTQuMjV6Ii8+DQogIDxwYXRoIGZpbGw9IiMwMzY0QjgiDQogICAgICAgIGQ9Ik01MjAuNDUzLDY0My40NzdoNDE2LjM4djM4MS42NzRoLTQxNi4zOFY2NDMuNDc3eiBNMTc0NS45MTcsMjU1LjVWODAuOTA4ICBjMS00My42NTItMzMuNTUyLTc5Ljg2Mi03Ny4yMDMtODAuOTA4SDU4OC4yMDRDNTQ0LjU1MiwxLjA0Niw1MTAsMzcuMjU2LDUxMSw4MC45MDhWMjU1LjVsNjM4Ljc1LDE3MC4zMzNMMTc0NS45MTcsMjU1LjV6Ii8+DQogIDxwYXRoIGZpbGw9IiMwMDc4RDQiIGQ9Ik01MTEsMjU1LjVoNDI1LjgzM3YzODMuMjVINTExVjI1NS41eiIvPg0KICA8cGF0aCBmaWxsPSIjMjhBOEVBIiBkPSJNMTM2Mi42NjcsMjU1LjVIOTM2LjgzM3YzODMuMjVMMTM2Mi42NjcsMTAyMmgzODMuMjVWNjM4Ljc1TDEzNjIuNjY3LDI1NS41eiIvPg0KICA8cGF0aCBmaWxsPSIjMDA3OEQ0IiBkPSJNOTM2LjgzMyw2MzguNzVoNDI1LjgzM1YxMDIySDkzNi44MzNWNjM4Ljc1eiIvPg0KICA8cGF0aCBmaWxsPSIjMDM2NEI4IiBkPSJNOTM2LjgzMywxMDIyaDQyNS44MzN2MzgzLjI1SDkzNi44MzNWMTAyMnoiLz4NCiAgPHBhdGggZmlsbD0iIzE0NDQ3RCIgZD0iTTUyMC40NTMsMTAyNS4xNTFoNDE2LjM4djM0Ni45NjloLTQxNi4zOFYxMDI1LjE1MXoiLz4NCiAgPHBhdGggZmlsbD0iIzAwNzhENCIgZD0iTTEzNjIuNjY3LDEwMjJoMzgzLjI1djM4My4yNWgtMzgzLjI1VjEwMjJ6Ii8+DQogIDxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTEyOC40NTg0IiB5MT0iODExLjA4MzMiIHgyPSIxMTI4LjQ1ODQiIHkyPSIxLjk5ODIiDQogICAgICAgICAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMTcwNS4zMzM0KSI+DQogICAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzM1QjhGMSIvPg0KICAgIDxzdG9wIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzI4QThFQSIvPg0KICAgIDwvbGluZWFyR3JhZGllbnQ+DQogIDxwYXRoIGZpbGw9InVybCgjU1ZHSURfMV8pIg0KICAgICAgICBkPSJNMTgxMS41OCw5MjcuNTkzbC0wLjgwOSwwLjQyNmwtNjM0LjQ5MiwzNTYuODQ4Yy0yLjc2OCwxLjcwMy01LjU3OCwzLjMyMS04LjUxNyw0Ljc2OSAgYy0xMC43NzcsNS4xMzItMjIuNDgxLDguMDI5LTM0LjQwNyw4LjUxN2wtMzQuNjYzLTIwLjI3Yy0yLjkyOS0xLjQ3LTUuNzczLTMuMTA1LTguNTE3LTQuODk3TDQ0Ny4xNjcsOTA2LjAwM2gtMC4yOTggIGwtMjEuMDM2LTExLjc1M3Y3MjIuMzg0YzAuMzI4LDQ4LjE5NiwzOS42NTMsODcuMDA2LDg3Ljg0OSw4Ni43aDEyMzAuOTE0YzAuNzI0LDAsMS4zNjMtMC4zNDEsMi4xMjktMC4zNDEgIGMxMC4xOC0wLjY1MSwyMC4yMTYtMi43NDUsMjkuODA4LTYuMjE3YzQuMTQ1LTEuNzU2LDguMTQ2LTMuODM1LDExLjk2Ni02LjIxN2MyLjg1My0xLjYxOCw3Ljc1LTUuMTUyLDcuNzUtNS4xNTIgIGMyMS44MTQtMTYuMTQyLDM0LjcyNi00MS42MzUsMzQuODMzLTY4Ljc3MlY4OTQuMjVDMTgzMS4wNjgsOTA4LjA2NywxODIzLjYxNiw5MjAuODA3LDE4MTEuNTgsOTI3LjU5M3oiLz4NCiAgPHBhdGggb3BhY2l0eT0iMC41IiBmaWxsPSIjMEEyNzY3IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3ICAgICINCiAgICAgICAgZD0iTTE3OTcuMDE3LDg5MS4zOTd2NDQuMjg3bC02NjMuNDQ4LDQ1Ni43OTFMNDQ2LjY5OSw5MDYuMzAxICBjMC0wLjIzNS0wLjE5MS0wLjQyNi0wLjQyNi0wLjQyNmwwLDBsLTYzLjAyMy0zNy44OTl2LTMxLjkzOGwyNS45NzYtMC40MjZsNTQuOTMyLDMxLjUxMmwxLjI3NywwLjQyNmw0LjY4NCwyLjk4MSAgYzAsMCw2NDUuNTYzLDM2OC4zNDYsNjQ3LjI2NywzNjkuMTk3bDI0LjY5OCwxNC40NzhjMi4xMjktMC44NTIsNC4yNTgtMS43MDMsNi44MTMtMi41NTUgIGMxLjI3OC0wLjg1Miw2NDAuODc5LTM2MC42ODEsNjQwLjg3OS0zNjAuNjgxTDE3OTcuMDE3LDg5MS4zOTd6Ii8+DQogIDxwYXRoIGZpbGw9IiMxNDkwREYiDQogICAgICAgIGQ9Ik0xODExLjU4LDkyNy41OTNsLTAuODA5LDAuNDY4bC02MzQuNDkyLDM1Ni44NDhjLTIuNzY4LDEuNzAzLTUuNTc4LDMuMzIxLTguNTE3LDQuNzY5ICBjLTI0LjY0MSwxMi4wMzgtNTMuNDU3LDEyLjAzOC03OC4wOTgsMGMtMi45MTgtMS40NDUtNS43Ni0zLjAzNy04LjUxNy00Ljc2OUw0NDYuNjU3LDkyOC4wNjFsLTAuNzY2LTAuNDY4ICBjLTEyLjI1LTYuNjQyLTE5LjkzLTE5LjQwOS0yMC4wNTctMzMuMzQzdjcyMi4zODRjMC4zMDUsNDguMTg4LDM5LjYxNiw4Ny4wMDQsODcuODAzLDg2LjdjMC4wMDEsMCwwLjAwMiwwLDAuMDA0LDBoMTIyOS42MzYgIGM0OC4xODgsMC4zMDcsODcuNS0zOC41MDksODcuODA3LTg2LjY5NmMwLTAuMDAxLDAtMC4wMDIsMC0wLjAwNFY4OTQuMjVDMTgzMS4wNjgsOTA4LjA2NywxODIzLjYxNiw5MjAuODA3LDE4MTEuNTgsOTI3LjU5M3oiLz4NCiAgPHBhdGggb3BhY2l0eT0iMC4xIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3ICAgICINCiAgICAgICAgZD0iTTExODUuNTIsMTI3OS42MjlsLTkuNDk2LDUuMzIzYy0yLjc1MiwxLjc1Mi01LjU5NSwzLjM1OS04LjUxNyw0LjgxMiAgYy0xMC40NjIsNS4xMzUtMjEuODM4LDguMTQ2LTMzLjQ3LDguODU3bDI0MS40MDUsMjg1LjQ3OWw0MjEuMTA3LDEwMS40NzZjMTEuNTM5LTguNzE2LDIwLjcxNy0yMC4xNzgsMjYuNy0zMy4zNDNMMTE4NS41MiwxMjc5LjYyOSAgeiIvPg0KICA8cGF0aCBvcGFjaXR5PSIwLjA1IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3ICAgICINCiAgICAgICAgZD0iTTEyMjguNTI5LDEyNTUuNDQybC01Mi41MDUsMjkuNTFjLTIuNzUyLDEuNzUyLTUuNTk1LDMuMzU5LTguNTE3LDQuODEyICBjLTEwLjQ2Miw1LjEzNS0yMS44MzgsOC4xNDYtMzMuNDcsOC44NTdsMTEzLjEwMSwzMTEuODM4bDU0OS41MzgsNzQuOTg5YzIxLjY0OS0xNi4yNTQsMzQuMzk0LTQxLjc0MywzNC40MDctNjguODE1di05LjMyNiAgTDEyMjguNTI5LDEyNTUuNDQyeiIvPg0KICA8cGF0aCBmaWxsPSIjMjhBOEVBIg0KICAgICAgICBkPSJNNTE0LjgzMywxNzAzLjMzM2gxMjI4LjMxNmMxOC45MDEsMC4wOTYsMzcuMzM1LTUuODc0LDUyLjU5LTE3LjAzM2wtNjk3LjA4OS00MDguMzMxICBjLTIuOTI5LTEuNDctNS43NzMtMy4xMDUtOC41MTctNC44OTdMNDQ3LjEyNSw5MDYuMDg4aC0wLjI5OGwtMjAuOTkzLTExLjgzOHY3MTkuOTE0ICBDNDI1Ljc4NiwxNjYzLjM2NCw0NjUuNjMyLDE3MDMuMjg2LDUxNC44MzMsMTcwMy4zMzNDNTE0LjgzMiwxNzAzLjMzMyw1MTQuODMyLDE3MDMuMzMzLDUxNC44MzMsMTcwMy4zMzN6Ii8+DQogIDxwYXRoIG9wYWNpdHk9IjAuMSIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAgICAiDQogICAgICAgIGQ9Ik0xMDIyLDQxOC43MjJ2OTA4LjMwM2MtMC4wNzYsMzEuODQ2LTE5LjQ0LDYwLjQ3MS00OC45NzEsNzIuMzkyICBjLTkuMTQ4LDMuOTMxLTE5LDUuOTYtMjguOTU3LDUuOTYySDQyNS44MzNWMzgzLjI1SDUxMXYtNDIuNTgzaDQzMy4wNzNDOTg3LjA5MiwzNDAuODMsMTAyMS45MDcsMzc1LjcwMiwxMDIyLDQxOC43MjJ6Ii8+DQogIDxwYXRoIG9wYWNpdHk9IjAuMiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAgICAiDQogICAgICAgIGQ9Ik05NzkuNDE3LDQ2MS4zMDV2OTA4LjMwMmMwLjEwNywxMC4yODctMi4wNzQsMjAuNDY5LTYuMzg4LDI5LjgwOCAgYy0xMS44MjYsMjkuMTQ5LTQwLjA4Myw0OC4yNzMtNzEuNTQsNDguNDE3SDQyNS44MzNWMzgzLjI1aDQ3NS42NTZjMTIuMzU2LTAuMTI0LDI0LjUzMywyLjk1OCwzNS4zNDQsOC45NDMgIEM5NjIuOTM3LDQwNS4zNDQsOTc5LjQwNyw0MzIuMDc2LDk3OS40MTcsNDYxLjMwNXoiLz4NCiAgPHBhdGggb3BhY2l0eT0iMC4yIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3ICAgICINCiAgICAgICAgZD0iTTk3OS40MTcsNDYxLjMwNXY4MjMuMTM2Yy0wLjIwOCw0My0zNC45MjgsNzcuODUzLTc3LjkyNyw3OC4yMjVINDI1LjgzM1YzODMuMjUgIGg0NzUuNjU2YzEyLjM1Ni0wLjEyNCwyNC41MzMsMi45NTgsMzUuMzQ0LDguOTQzQzk2Mi45MzcsNDA1LjM0NCw5NzkuNDA3LDQzMi4wNzYsOTc5LjQxNyw0NjEuMzA1eiIvPg0KICA8cGF0aCBvcGFjaXR5PSIwLjIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgICAgIg0KICAgICAgICBkPSJNOTM2LjgzMyw0NjEuMzA1djgyMy4xMzZjLTAuMDQ2LDQzLjA2Ny0zNC44NjEsNzguMDE1LTc3LjkyNyw3OC4yMjVINDI1LjgzMyAgVjM4My4yNWg0MzMuMDcyYzQzLjA2MiwwLjAyMyw3Ny45NTEsMzQuOTUxLDc3LjkyNyw3OC4wMTNDOTM2LjgzMyw0NjEuMjc3LDkzNi44MzMsNDYxLjI5MSw5MzYuODMzLDQ2MS4zMDV6Ii8+DQogIDxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTYyLjc0NjkiIHkxPSIxMzgzLjA3NDEiIHgyPSI3NzQuMDg2NCIgeTI9IjMyNC4yNTkyIg0KICAgICAgICAgICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDE3MDUuMzMzNCkiPg0KICAgICAgICA8c3RvcCBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMxNzg0RDkiLz4NCiAgICA8c3RvcCBvZmZzZXQ9IjAuNSIgc3R5bGU9InN0b3AtY29sb3I6IzEwN0FENSIvPg0KICAgIDxzdG9wIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzBBNjNDOSIvPg0KICAgIDwvbGluZWFyR3JhZGllbnQ+DQogIDxwYXRoIGZpbGw9InVybCgjU1ZHSURfMl8pIg0KICAgICAgICBkPSJNNzguMDU1LDM4My4yNWg3ODAuNzIzYzQzLjEwOSwwLDc4LjA1NSwzNC45NDcsNzguMDU1LDc4LjA1NXY3ODAuNzIzICBjMCw0My4xMDktMzQuOTQ2LDc4LjA1NS03OC4wNTUsNzguMDU1SDc4LjA1NWMtNDMuMTA5LDAtNzguMDU1LTM0Ljk0Ny03OC4wNTUtNzguMDU1VjQ2MS4zMDUgIEMwLDQxOC4xOTcsMzQuOTQ3LDM4My4yNSw3OC4wNTUsMzgzLjI1eiIvPg0KICA8cGF0aCBmaWxsPSIjRkZGRkZGIg0KICAgICAgICBkPSJNMjQzLjk2LDcxMC42MzFjMTkuMjM4LTQwLjk4OCw1MC4yOS03NS4yODksODkuMTctOTguNDk1YzQzLjA1Ny0yNC42NTEsOTIuMDgxLTM2Ljk0LDE0MS42NzUtMzUuNTE1ICBjNDUuOTY1LTAuOTk3LDkxLjMyMSwxMC42NTUsMTMxLjExNCwzMy42ODNjMzcuNDE0LDIyLjMxMiw2Ny41NDcsNTUuMDA0LDg2Ljc0Miw5NC4xMDljMjAuOTA0LDQzLjA5LDMxLjMyMiw5MC41MTIsMzAuNDA1LDEzOC4zOTYgIGMxLjAxMyw1MC4wNDMtOS43MDYsOTkuNjI4LTMxLjI5OSwxNDQuNzgzYy0xOS42NTIsNDAuNTAzLTUwLjc0MSw3NC4zNi04OS40MjUsOTcuMzg4Yy00MS4zMjcsMjMuNzM0LTg4LjM2NywzNS42OTItMTM2LjAxMSwzNC41NzggIGMtNDYuOTQ3LDEuMTMzLTkzLjMwMy0xMC42NTEtMTM0LjAxLTM0LjA2N2MtMzcuNzM4LTIyLjM0MS02OC4yNDktNTUuMDctODcuODkyLTk0LjI4Yy0yMS4wMjgtNDIuNDY3LTMxLjU3LTg5LjM1NS0zMC43NDUtMTM2LjczNSAgQzIxMi44MDgsODA0Ljg1OSwyMjMuMTU4LDc1NS42ODYsMjQzLjk2LDcxMC42MzF6IE0zMzkuMDA2LDk0MS44NThjMTAuMjU3LDI1LjkxMiwyNy42NTEsNDguMzg1LDUwLjE2Myw2NC44MTIgIGMyMi45MywxNi4wMjYsNTAuMzg3LDI0LjI5NCw3OC4zNTMsMjMuNTkxYzI5Ljc4MywxLjE3OCw1OS4xNC03LjM3Miw4My42MzQtMjQuMzU4YzIyLjIyNy0xNi4zNzUsMzkuMTY0LTM4LjkwOSw0OC43MTUtNjQuODEyICBjMTAuNjc3LTI4LjkyOCwxNS45NDYtNTkuNTcyLDE1LjU0My05MC40MDRjMC4zMy0zMS4xMjctNC42MjMtNjIuMDg0LTE0LjY0OS05MS41NTRjLTguODU1LTI2LjYwNy0yNS4yNDYtNTAuMDY5LTQ3LjE4Mi02Ny41MzcgIGMtMjMuODgtMTcuNzktNTMuMTU4LTI2LjgxMy04Mi45MS0yNS41NWMtMjguNTcyLTAuNzQtNTYuNjQ0LDcuNTkzLTgwLjE4NCwyMy44MDRjLTIyLjg5MywxNi40OTYtNDAuNjE3LDM5LjE2OC01MS4xLDY1LjM2NSAgYy0yMy4yNTUsNjAuMDQ5LTIzLjM3NiwxMjYuNTk1LTAuMzQxLDE4Ni43MjhMMzM5LjAwNiw5NDEuODU4eiIvPg0KICA8cGF0aCBmaWxsPSIjNTBEOUZGIiBkPSJNMTM2Mi42NjcsMjU1LjVoMzgzLjI1djM4My4yNWgtMzgzLjI1VjI1NS41eiIvPg0KICAgIDwvc3ZnPg0K", alt: "outlook", ...e5 });
    R2 = (e5) => z2.default.createElement(k3, { src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xMy4xNDI3IDIwLjk5OTlDMTAuODA3NyAxOS41NDM4IDkuMjUyNTQgMTYuOTUyMiA5LjI1MjU0IDEzLjk5NjhDOS4yNTI1NCAxMi40NzgzIDEwLjQ4MzMgMTEuMjQ3NiAxMi4wMDA4IDExLjI0NzZDMTMuNTE4NCAxMS4yNDc2IDE0Ljc0OTEgMTIuNDc4MyAxNC43NDkxIDEzLjk5NjhDMTQuNzQ5MSAxNS41MTUzIDE1Ljk3OTggMTYuNzQ2IDE3LjQ5NzQgMTYuNzQ2QzE5LjAxNDkgMTYuNzQ2IDIwLjI0NTcgMTUuNTE1MyAyMC4yNDU3IDEzLjk5NjhDMjAuMjQ1NyA5LjQ0MTM5IDE2LjU1NDQgNS43NDkyMiAxMi4wMDE3IDUuNzQ5MjJDNy40NDkwNyA1Ljc0OTIyIDMuNzU3ODEgOS40NDEzOSAzLjc1NzgxIDEzLjk5NjhDMy43NTc4MSAxNS4wMTIyIDMuODcxNDUgMTYuMDAxIDQuMDgwMzggMTYuOTU0TTguNDkwMjcgMjAuMjk4OUM3LjIzOTM4IDE4LjUxMzggNi41MDM1MSAxNi4zNDE5IDYuNTAzNTEgMTMuOTk2OEM2LjUwMzUxIDEwLjk1OTkgOC45NjQwNSA4LjQ5ODQ0IDExLjk5OTIgOC40OTg0NEMxNS4wMzQzIDguNDk4NDQgMTcuNDk0OCAxMC45NTk5IDE3LjQ5NDggMTMuOTk2OE0xNy43OTI3IDE5LjQ4MDZDMTcuNjkzNyAxOS40ODYxIDE3LjU5NjYgMTkuNDk1MyAxNy40OTY3IDE5LjQ5NTNDMTQuNDYxNiAxOS40OTUzIDEyLjAwMTEgMTcuMDMzOCAxMi4wMDExIDEzLjk5NjlNMTkuNjczNCA2LjQ3NjgyQzE3Ljc5OTMgNC4zNDgwMiAxNS4wNTkzIDMgMTIuMDAwNCAzQzguOTQxNDEgMyA2LjIwMTM4IDQuMzQ4MDIgNC4zMjczNCA2LjQ3NjgyIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8L3N2Zz4=", alt: "fingerprint", ...e5 });
    H2 = (e5) => z2.default.createElement(k3, { src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgLTk2MCA5NjAgOTYwIiB3aWR0aD0iMjQiPjxwYXRoIGQ9Im0yNTYtMjAwLTU2LTU2IDIyNC0yMjQtMjI0LTIyNCA1Ni01NiAyMjQgMjI0IDIyNC0yMjQgNTYgNTYtMjI0IDIyNCAyMjQgMjI0LTU2IDU2LTIyNC0yMjQtMjI0IDIyNFoiLz48L3N2Zz4=", alt: "cancel", ...e5 });
    W3 = ({ isOpen: e5, header: M4, body: t8, confirmText: a7 = "Yes", cancelText: N4, onClose: u6, onConfirm: D4 }) => {
      const [r8, l7] = z2.default.useState(false), [n7, j4] = z2.default.useState(false);
      if (!e5)
        return null;
      const i9 = async () => {
        u6 && (l7(true), await u6(), l7(false));
      };
      return z2.default.createElement("div", { className: "cb-dialog", onClick: () => {
        i9();
      } }, z2.default.createElement("div", { className: "cb-dialog-content", onClick: (e6) => e6.stopPropagation() }, z2.default.createElement("div", { className: "cb-dialog-header" }, M4, z2.default.createElement(H2, { className: "cb-dialog-x-button", onClick: () => {
        i9();
      } })), t8 ? z2.default.createElement("div", { className: "cb-dialog-body" }, t8) : null, z2.default.createElement("div", { className: "cb-dialog-footer" }, z2.default.createElement(m4, { className: "cb-dialog-button", isLoading: n7, disabled: r8, onClick: () => {
        (async () => {
          D4 && (j4(true), await D4(), j4(false));
        })();
      } }, a7), N4 ? z2.default.createElement(C4, { className: "cb-dialog-button", isLoading: r8, disabled: r8, onClick: () => {
        i9();
      } }, N4) : null)));
    };
    V2 = () => z2.default.createElement("div", { className: "cb-email-links" }, z2.default.createElement(U3, { icon: z2.default.createElement(Z3, null), label: "Google", href: "https://mail.google.com/mail/u/0/#search/from%3A%40corbado+in%3Aanywhere" }), z2.default.createElement(U3, { icon: z2.default.createElement(F3, null), label: "Yahoo", href: "https://mail.yahoo.com/d/search/keyword=corbado.com" }), z2.default.createElement(U3, { icon: z2.default.createElement(G2, null), label: "Outlook", href: "https://outlook.office.com/mail/0/inbox" }));
    J2 = "data:image/svg+xml;base64,PHN2Zw0KICAgIHdpZHRoPSc4NCcNCiAgICBoZWlnaHQ9JzIxJw0KICAgIHZpZXdCb3g9JzAgMCA4NCAyMScNCiAgICB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnDQogICAgPg0KICAgIDxwYXRoIGQ9J00zMS4zMDEyIDE3LjI5MzRDMzAuNDc2NyAxNy4yOTM0IDI5Ljc4OTUgMTcuMTU2OSAyOS4xMDI0IDE2Ljg4MzlDMjguNDE1MyAxNi42MDA2IDI3Ljc5NjggMTYuMjExNyAyNy4yNDcxIDE1LjcxNkMyNi43NjYyIDE1LjIyMDQgMjYuMzU0NSAxNC42NDQgMjYuMDc5NiAxMy45ODdDMjUuODA0OCAxMy4zMTk2IDI1LjY2NyAxMi42MDE5IDI1LjY2NyAxMS44MzMyQzI1LjY2NyAxMS4wNTQ4IDI1LjgwNDggMTAuMzM2NSAyNi4wNzk2IDkuNjc5NDZDMjYuMzU0NSA5LjAxMjEgMjYuNzY2NiA4LjQzMDg5IDI3LjMxNjMgNy45MzUxOUMyNy43OTcyIDcuNDM5NSAyOC40MTUzIDcuMDU1NDkgMjkuMTAyNCA2Ljc4MjQ4QzI5Ljc4OTUgNi40OTkxMiAzMC40NzY3IDYuMzU3NzcgMzEuMzAxMiA2LjM1Nzc3QzMxLjg1MDggNi4zNTc3NyAzMi40MDA4IDYuNDM4NDcgMzIuOTUwNCA2LjYwMDQ5QzMzLjUwMDEgNi43NjI1IDM0LjA0OTIgNi45OSAzNC40NjE1IDcuMjgzMDFDMzQuOTQyNCA3LjU3NjAxIDM1LjM1NTIgNy45MzAzNiAzNS42OTg4IDguMzQ0NzFMMzQuMTg3IDkuODE1OTZDMzMuODQzNSA5LjM0MDk1IDMzLjM2MjMgOC45ODE3NSAzMi44ODEzIDguNzM5MDdDMzIuNDAwNCA4LjQ5NjQgMzEuODUwOCA4LjM3NTA1IDMxLjMwMTIgOC4zNzUwNUMzMC44MjAyIDguMzc1MDUgMzAuMzM5MyA4LjQ2NjA1IDI5LjkyNyA4LjY0ODA2QzI5LjUxNDggOC44MTk3MiAyOS4xNzEyIDkuMDYyNDIgMjguODk2NCA5LjM3NjExQzI4LjU1MjkgOS42Nzk0NiAyOC4zNDcgMTAuMDQzNSAyOC4xNDA5IDEwLjQ2ODFDMjguMDAzNSAxMC44ODI1IDI3LjkzNDIgMTEuMzM3NSAyNy45MzQyIDExLjgzMzJDMjcuOTM0MiAxMi4zMTg1IDI4LjAwMzUgMTIuNzczNiAyOC4xNDA5IDEzLjE5ODNDMjguMzQ3IDEzLjYxMjYgMjguNTUyOSAxMy45NzY2IDI4Ljg5NjQgMTQuMjkwM0MyOS4yMzk5IDE0LjU5MzcgMjkuNTgzMiAxNC44MzE1IDI5Ljk5NTUgMTUuMDAzMkMzMC40MDc3IDE1LjE3NDkgMzAuODg4NyAxNS4yNjEgMzEuMzY5NiAxNS4yNjFDMzEuOTE5MyAxNS4yNjEgMzIuNDAwOCAxNS4xNDQ1IDMyLjk1MDQgMTQuOTEyMkMzMy40MzE0IDE0LjY3OTggMzMuODQzNSAxNC4zNDYyIDM0LjE4NyAxMy45MTExTDM1LjYyOTYgMTUuMzM2OUMzNS4yODYxIDE1Ljc0MTYgMzQuODczNyAxNi4wOTA0IDM0LjQ2MTUgMTYuMzgzNEMzMy45ODA1IDE2LjY3NjQgMzMuNTAwMSAxNi45MDM5IDMyLjk1MDQgMTcuMDY1OUMzMi40MDA4IDE3LjIxNzYgMzEuODUwOCAxNy4yOTM0IDMxLjMwMTIgMTcuMjkzNFpNMzkuODIxMiAxNy4yOTM0QzM4Ljk5NjcgMTcuMjkzNCAzOC4zMDkzIDE3LjExMTQgMzcuNjkwOSAxNi43NDc0QzM3LjAwMzggMTYuMzgzNCAzNi41MjI3IDE1Ljg5MzIgMzYuMTc5MiAxNS4yNzYyQzM1Ljc2NjkgMTQuNjU5MiAzNS41NjEyIDEzLjk2NyAzNS41NjEyIDEzLjE5ODNDMzUuNTYxMiAxMi40Mjk2IDM1Ljc2NzIgMTEuNzM3NCAzNi4xMTA3IDExLjEyMDNDMzYuNTIzIDEwLjQ5MzYgMzcuMDA0MSA5Ljk5Nzk0IDM3LjYyMjQgOS42MzM5M0MzOC4zMDk1IDkuMjY5OTEgMzguOTk2NyA5LjA4NzkxIDM5LjgyMTIgOS4wODc5MUM0MC41NzcgOS4wODc5MSA0MS4yNjM4IDkuMjY5OTEgNDEuOTUwOSA5LjYzMzkzQzQyLjU2OTMgOS45OTc5NCA0My4wNTA0IDEwLjQ5MzYgNDMuNDYyNiAxMS4xMjAzQzQzLjgwNjIgMTEuNzM3NCA0NC4wMTIyIDEyLjQyOTYgNDQuMDEyMiAxMy4xOTgzQzQ0LjAxMjIgMTMuOTY3IDQzLjgwNjIgMTQuNjU5MiA0My40NjI2IDE1LjI3NjJDNDMuMDUwNCAxNS44OTMyIDQyLjU2OTMgMTYuMzgzNCA0MS45NTA5IDE2Ljc0NzRDNDEuMzMyNSAxNy4xMTE0IDQwLjU3NyAxNy4yOTM0IDM5LjgyMTIgMTcuMjkzNFpNMzkuODIxMiAxNS40ODg1QzQwLjIzMzUgMTUuNDg4NSA0MC41NzY4IDE1LjM4NzIgNDAuOTIwMyAxNS4xODUyQzQxLjI2MzggMTQuOTgzMiA0MS40Njk3IDE0LjcxMDIgNDEuNjc1OCAxNC4zNjYxQzQxLjg4MTkgMTQuMDEyNSA0Mi4wMTk0IDEzLjYyMyA0Mi4wMTk0IDEzLjE5ODNDNDIuMDE5NCAxMi43NjMzIDQxLjg4MTkgMTIuMzc0NCA0MS42NzU4IDEyLjAzMDRDNDEuNDY5NyAxMS42ODY0IDQxLjI2MzggMTEuNDEzNCA0MC45MjAzIDExLjIxMTNDNDAuNTc2OCAxMC45OTkgNDAuMjMzNSAxMC44OTI4IDM5LjgyMTIgMTAuODkyOEMzOS40MDkgMTAuODkyOCAzOC45OTYzIDEwLjk5OSAzOC43MjE1IDExLjIxMTNDMzguMzc4IDExLjQxMzQgMzguMTAzIDExLjY4NjQgMzcuODk2OSAxMi4wMzA0QzM3LjY5MDggMTIuMzc0NCAzNy42MjI0IDEyLjc2MzMgMzcuNjIyNCAxMy4xOTgzQzM3LjYyMjQgMTMuNjIzIDM3LjY5MDggMTQuMDEyNSAzNy44OTY5IDE0LjM2NjFDMzguMTAzIDE0LjcxMDIgMzguMzc4IDE0Ljk4MzIgMzguNzIxNSAxNS4xODUyQzM4Ljk5NjMgMTUuMzg3MiAzOS40MDkgMTUuNDg4NSAzOS44MjEyIDE1LjQ4ODVaTTQ0LjY5OTIgMTcuMTQxOFY5LjIzOTYxSDQ2Ljc2MDVWMTAuMTE5M0M0Ni45NjY2IDkuNzc1MjkgNDcuMzEgOS41MTI1OSA0Ny42NTM1IDkuMzMwNThDNDcuOTk3MSA5LjE0ODU3IDQ4LjQwOTUgOS4wNTc1NyA0OC44MjE3IDkuMDU3NTdDNDkuMjM0IDkuMDY3OTEgNDkuNTA4NyA5LjEyODYxIDQ5LjcxNDggOS4yMzk2MVYxMS4wNTk3QzQ5LjU3NzQgMTAuOTg4NiA0OS4zNzExIDEwLjkzODMgNDkuMjMzNyAxMC45MDhDNDkuMDI3NiAxMC44NjczIDQ4LjgyMTggMTAuODQ3MyA0OC42MTU3IDEwLjg0NzNDNDguMjcyMiAxMC44NDczIDQ3Ljg1OTUgMTAuOTQ4NyA0Ny41MTYgMTEuMTUwN0M0Ny4xNzI1IDExLjM1MjcgNDYuOTY2NiAxMS42NDA5IDQ2Ljc2MDUgMTIuMDE1MlYxNy4xNDE4SDQ0LjY5OTJaTTUwLjI2NDMgMTcuMTQxOFY2LjUyNDYyTDUyLjMyNTYgNi4xNzU3OFY5Ljg3NjZDNTIuOTQzOSA5LjM4MDkgNTMuNjMxMSA5LjEzMzQgNTQuNTI0MyA5LjEzMzRDNTUuMjgwMSA5LjEzMzQgNTUuODk4OCA5LjMxNTQ0IDU2LjUxNzEgOS42Nzk0NkM1Ny4xMzU1IDEwLjA0MzUgNTcuNjE2MiAxMC41MzM2IDU3Ljk1OTcgMTEuMTUwN0M1OC4zMDMzIDExLjc1NzQgNTguNTA5MyAxMi40Mzk5IDU4LjUwOTMgMTMuMTk4M0M1OC41MDkzIDEzLjk1NjcgNTguMzAzMyAxNC42NDQgNTcuOTU5NyAxNS4yNjFDNTcuNjE2MiAxNS44Njc3IDU3LjEzNTUgMTYuMzUzMSA1Ni41MTcxIDE2LjcxNzFDNTUuODk4OCAxNy4wNzA3IDU1LjIxMTcgMTcuMjQ3OSA1NC40NTU5IDE3LjI0NzlDNTQuMDQzNyAxNy4yNDc5IDUzLjcgMTcuMTkyMSA1My4yODc3IDE3LjA4MTFDNTIuOTQ0MiAxNi45NzAxIDUyLjYwMDcgMTYuODA4MSA1Mi4yNTcxIDE2LjU5NThWMTcuMTQxOEg1MC4yNjQzWk01NC4xODA4IDE1LjQ4ODVDNTQuNTkzIDE1LjQ4ODUgNTUuMDA1NCAxNS4zODcyIDU1LjM0OSAxNS4xODUyQzU1LjY5MjUgMTQuOTgzMiA1NS45Njc1IDE0LjcxMDIgNTYuMTczNiAxNC4zNjYxQzU2LjM3OTcgMTQuMDIyMSA1Ni40NDggMTMuNjMzMyA1Ni40NDggMTMuMTk4M0M1Ni40NDggMTIuNzYzMyA1Ni4zNzk3IDEyLjM3NDQgNTYuMTczNiAxMi4wMzA0QzU1Ljk2NzUgMTEuNjc2NyA1NS42OTI1IDExLjQwMzcgNTUuMzQ5IDExLjIxMTNDNTUuMDA1NCAxMS4wMDkzIDU0LjU5MyAxMC45MDggNTQuMTgwOCAxMC45MDhDNTMuNzY4NiAxMC45MDggNTMuNDI1IDEwLjk3MzUgNTMuMTUwMiAxMS4xMDUyQzUyLjgwNjYgMTEuMjI2NSA1Mi41MzE3IDExLjQxMzMgNTIuMzI1NiAxMS42NjY0VjE0Ljc0NTNDNTIuNTMxNyAxNC45Nzc3IDUyLjgwNjYgMTUuMTU5NyA1My4xNTAyIDE1LjI5MTNDNTMuNDI1IDE1LjQyMyA1My44MzczIDE1LjQ4ODUgNTQuMTgwOCAxNS40ODg1Wk02MS43Mzg3IDE3LjI3ODNDNjEuMTg5IDE3LjI3ODMgNjAuNzA3OSAxNy4xNzY5IDYwLjIyNyAxNi45NzQ5QzU5LjgxNDcgMTYuNzYyNiA1OS40NzE2IDE2LjQ3NDQgNTkuMjY1NSAxNi4xMTA0QzU4Ljk5MDYgMTUuNzQ2NCA1OC44NTI4IDE1LjMyNjUgNTguODUyOCAxNC44NTE1QzU4Ljg1MjggMTQuMDkzMSA1OS4xMjgyIDEzLjUwNjQgNTkuNzQ2NSAxMy4wOTIxQzYwLjI5NjIgMTIuNjY3NCA2MS4wNTE2IDEyLjQ1NTEgNjIuMDgyMiAxMi40NTUxQzYyLjc2OTMgMTIuNDU1MSA2My4zODc1IDEyLjU2MTIgNjQuMDA1OSAxMi43NzM2VjEyLjE5NzJDNjQuMDA1OSAxMS43NDIyIDYzLjg2ODggMTEuMzk4MiA2My41OTM5IDExLjE2NThDNjMuMzE5MSAxMC45MzM1IDYyLjkwNyAxMC44MTcgNjIuMzU3MyAxMC44MTdDNjIuMDEzOCAxMC44MTcgNjEuNjY5OCAxMC44NzI4IDYxLjI1NzYgMTAuOTgzOEM2MC45MTQgMTEuMDg1MiA2MC40MzM1IDExLjI0NjUgNTkuOTUyNSAxMS40NjkyTDU5LjE5NjMgOS45MzcyOEM1OS44MTQ3IDkuNjUzOTIgNjAuNDMzNSA5LjQ0MTU3IDYwLjk4MzIgOS4zMDAyNEM2MS41MzI4IDkuMTU4OTEgNjIuMTUxMiA5LjA4NzkxIDYyLjcwMDkgOS4wODc5MUM2My43MzE1IDkuMDg3OTEgNjQuNTU1NyA5LjM0NTc2IDY1LjE3NDEgOS44NjE0NUM2NS43MjM3IDEwLjM2NjggNjYuMDY3MSAxMS4wODUyIDY2LjA2NzEgMTIuMDE1MlYxNy4xNDE4SDY0LjAwNTlWMTYuNTgwNkM2My42NjI0IDE2LjgyMzIgNjMuMzE4OCAxNy4wMDA0IDYyLjk3NTMgMTcuMTExNEM2Mi42MzE3IDE3LjIyMjQgNjIuMjE5NiAxNy4yNzgzIDYxLjczODcgMTcuMjc4M1pNNjAuODQ1NiAxNC44MDZDNjAuODQ1NiAxNS4xMDkzIDYwLjk4MjggMTUuMzUyIDYxLjI1NzYgMTUuNTM0MUM2MS40NjM3IDE1LjcwNTcgNjEuODc2IDE1Ljc5MTkgNjIuMjg4MiAxNS43OTE5QzYyLjYzMTcgMTUuNzkxOSA2Mi45MDY4IDE1Ljc1MTIgNjMuMjUwNCAxNS42NzA2QzYzLjUyNTIgMTUuNTc5NiA2My43OTk4IDE1LjQ0NzkgNjQuMDA1OSAxNS4yNzYyVjE0LjEyMzVDNjMuNzMxMSAxNC4wMjIxIDYzLjUyNTIgMTMuOTQ2MyA2My4yNTA0IDEzLjg5NkM2Mi45NzU2IDEzLjg0NTYgNjIuNjMyMSAxMy44MjAxIDYyLjM1NzMgMTMuODIwMUM2MS44NzY0IDEzLjgyMDEgNjEuNTMyNCAxMy45MTExIDYxLjI1NzYgMTQuMDkzMUM2MC45ODI4IDE0LjI2NDggNjAuODQ1NiAxNC41MDI3IDYwLjg0NTYgMTQuODA2Wk03MC42NzA3IDE3LjI0NzlDNjkuOTE0OSAxNy4yNDc5IDY5LjIyNzggMTcuMDY1OSA2OC42MDk1IDE2LjcwMTlDNjguMDU5OCAxNi4zMzc5IDY3LjU3OTEgMTUuODUyNSA2Ny4xNjY5IDE1LjI0NTlDNjYuODIzMyAxNC42Mjg4IDY2LjY4NTggMTMuOTQxNSA2Ni42ODU4IDEzLjE4MzFDNjYuNjg1OCAxMi40MjQ3IDY2LjgyMzMgMTEuNzQyMiA2Ny4xNjY5IDExLjEzNTVDNjcuNTc5MSAxMC41MTg1IDY4LjA2MDIgMTAuMDMzMSA2OC42Nzg2IDkuNjc5NDZDNjkuMjk3IDkuMzE1NDQgNjkuOTg0IDkuMTMzNCA3MC43Mzk4IDkuMTMzNEM3MS4wODM0IDkuMTMzNCA3MS40OTUzIDkuMTg5MjQgNzEuODM4OSA5LjMwMDI0QzcyLjI1MTEgOS40MDE1OSA3Mi41MjYgOS41NTMyOCA3Mi44Njk1IDkuNzU1MjlWNi41MjQ2Mkw3NC45MzA3IDYuMTc1NzhWMTcuMTQxOEg3Mi44Njk1VjE2LjQ4OTZDNzIuMjUxMSAxNi45OTQ5IDcxLjQ5NTIgMTcuMjQ3OSA3MC42NzA3IDE3LjI0NzlaTTcxLjAxNDMgMTUuNDczNEM3MS4zNTc4IDE1LjQ3MzQgNzEuNzAxMyAxNS40MTI3IDcyLjA0NDkgMTUuMjkxM0M3Mi4zODg0IDE1LjE1OTcgNzIuNjYzNCAxNC45NjggNzIuODY5NSAxNC43MTVWMTEuNjM2QzcyLjY2MzQgMTEuNDAzNyA3Mi4zODg0IDExLjIyMTcgNzIuMDQ0OSAxMS4wOUM3MS43MDEzIDEwLjk1ODMgNzEuMzU3OCAxMC44OTI4IDcxLjAxNDMgMTAuODkyOEM3MC41MzMzIDEwLjg5MjggNzAuMTg5NiAxMC45OTQyIDY5Ljg0NjEgMTEuMTk2MkM2OS41MDI1IDExLjM4ODUgNjkuMjI4MyAxMS42NjE2IDY5LjAyMjEgMTIuMDE1MkM2OC44MTYgMTIuMzU5MyA2OC42Nzg2IDEyLjc0ODEgNjguNjc4NiAxMy4xODMxQzY4LjY3ODYgMTMuNjE4MSA2OC44MTYgMTQuMDA3IDY5LjAyMjEgMTQuMzUxQzY5LjIyODMgMTQuNjk1IDY5LjUwMjUgMTQuOTY4IDY5Ljg0NjEgMTUuMTdDNzAuMTg5NiAxNS4zNzIgNzAuNTMzMyAxNS40NzM0IDcxLjAxNDMgMTUuNDczNFpNNzkuODA4NyAxNy4yOTM0Qzc4Ljk4NDIgMTcuMjkzNCA3OC4yOTc0IDE3LjExMTQgNzcuNjc5MSAxNi43NDc0Qzc2Ljk5MiAxNi4zODM0IDc2LjUxMDkgMTUuODkzMiA3Ni4xNjc0IDE1LjI3NjJDNzUuNzU1MSAxNC42NTkyIDc1LjYxNzggMTMuOTY3IDc1LjYxNzggMTMuMTk4M0M3NS42MTc4IDEyLjQyOTYgNzUuNzU1NCAxMS43Mzc0IDc2LjA5ODkgMTEuMTIwM0M3Ni41MTEyIDEwLjQ5MzYgNzYuOTkyMiA5Ljk5Nzk0IDc3LjYxMDYgOS42MzM5M0M3OC4yOTc3IDkuMjY5OTEgNzguOTg0MiA5LjA4NzkxIDc5LjgwODcgOS4wODc5MUM4MC41NjQ1IDkuMDg3OTEgODEuMjUyIDkuMjY5OTEgODEuOTM5MSA5LjYzMzkzQzgyLjU1NzUgOS45OTc5NCA4My4wMzg1IDEwLjQ5MzYgODMuNDUwOCAxMS4xMjAzQzgzLjc5NDMgMTEuNzM3NCA4NC4wMDAzIDEyLjQyOTYgODQuMDAwMyAxMy4xOTgzQzg0LjAwMDMgMTMuOTY3IDgzLjc5NDMgMTQuNjU5MiA4My40NTA4IDE1LjI3NjJDODMuMDM4NSAxNS44OTMyIDgyLjU1NzUgMTYuMzgzNCA4MS45MzkxIDE2Ljc0NzRDODEuMzIwNyAxNy4xMTE0IDgwLjU2NDUgMTcuMjkzNCA3OS44MDg3IDE3LjI5MzRaTTc5LjgwODcgMTUuNDg4NUM4MC4yMjEgMTUuNDg4NSA4MC41NjQ5IDE1LjM4NzIgODAuOTA4NSAxNS4xODUyQzgxLjI1MiAxNC45ODMyIDgxLjQ1NzkgMTQuNzEwMiA4MS42NjQgMTQuMzY2MUM4MS44NzAxIDE0LjAxMjUgODIuMDA3NSAxMy42MjMgODIuMDA3NSAxMy4xOTgzQzgyLjAwNzUgMTIuNzYzMyA4MS44NzAxIDEyLjM3NDQgODEuNjY0IDEyLjAzMDRDODEuNDU3OSAxMS42ODY0IDgxLjI1MiAxMS40MTM0IDgwLjkwODUgMTEuMjExM0M4MC41NjQ5IDEwLjk5OSA4MC4yMjEgMTAuODkyOCA3OS44MDg3IDEwLjg5MjhDNzkuMzk2NSAxMC44OTI4IDc4Ljk4NDUgMTAuOTk5IDc4LjcwOTcgMTEuMjExM0M3OC4zNjYxIDExLjQxMzQgNzguMDkxMiAxMS42ODY0IDc3Ljg4NSAxMi4wMzA0Qzc3LjY3ODkgMTIuMzc0NCA3Ny42MTA2IDEyLjc2MzMgNzcuNjEwNiAxMy4xOTgzQzc3LjYxMDYgMTMuNjIzIDc3LjY3ODkgMTQuMDEyNSA3Ny44ODUgMTQuMzY2MUM3OC4wOTEyIDE0LjcxMDIgNzguMzY2MSAxNC45ODMyIDc4LjcwOTcgMTUuMTg1MkM3OC45ODQ1IDE1LjM4NzIgNzkuMzk2NSAxNS40ODg1IDc5LjgwODcgMTUuNDg4NVonIC8+DQogICAgPGc+DQogICAgICAgIDxwYXRoIGQ9J00xOS4yMzAzIDE0LjExNkMxOS4yMzAzIDE0LjEyNzQgMTkuMjMwMyAxNC4xMzk0IDE5LjIzMDMgMTQuMTUwOEMxOS4yMzAzIDE0LjE1NDMgMTkuMjMwMyAxNC4xNTc5IDE5LjIzMDMgMTQuMTYyMUMxOC45NjIyIDE0LjkwNjQgMTguNjI3MiAxNS42MTY1IDE4LjIyNTIgMTYuMjc5MVYxNi4yODI3QzE4LjE1ODIgMTYuMjk4MyAxOC4xNTc4IDE2LjMxMDMgMTguMTU3OCAxNi4zMTk2QzE4LjE1NzggMTYuMzI4MSAxOC4wOTExIDE2LjMzMjMgMTguMDkxMSAxNi4zMzIzSDkuOTE2MzhDNi45MDExNyAxNi4zMzIzIDQuNDIxODggMTMuNzIwOCA0LjQyMTg4IDEwLjQ5OTJDNC40MjE4OCA3LjI3NzUzIDYuOTAxMTcgNC42NjYwMiA5LjkxNjM4IDQuNjY2MDJIMTguMDkxMUMxOC4wOTExIDQuNjY2MDIgMTguMTU3OCA0LjY3MDI4IDE4LjE1NzggNC42Nzg3OUMxOC4xNTc4IDQuNjg4MDEgMTguMTU4MiA0LjcwMDA3IDE4LjIyNTIgNC43MTU2OFY0LjcxOTIzQzE4LjYyNzIgNS4zODExNiAxOC45NjIyIDYuMDkyMDIgMTkuMjMwMyA2LjgzNTUzQzE5LjIzMDMgNi44Mzk3OSAxOS4yMzAzIDYuODQzMzYgMTkuMjMwMyA2Ljg0NzYxQzE5LjIzMDMgNi44NTgyNSAxOS4yMzAzIDYuODcwMyAxOS4yMzAzIDYuODgxNjVDMTkuMjMwMyA2LjkxMjg2IDE5LjIyOTkgNi45NDI2NiAxOS4xNjI5IDYuOTY0NjZDMTkuMTYyOSA2Ljk4NTk0IDE5LjE2MzEgNi45OTg2OSAxOS4wOTYxIDYuOTk4NjlIOS45MTYzOEM5LjA0NTMyIDYuOTk4NjkgOC4xNzQyNiA3LjM2NjkxIDcuNTcxMjIgOC4wMjM4N0M2Ljk2ODE4IDguNjgwMTIgNi42MzI4OSA5LjU3MDUyIDYuNjMyODkgMTAuNDk4NUM2LjYzMjg5IDExLjQyNjUgNi45NjgxOCAxMi4zMTY4IDcuNTcxMjIgMTIuOTczMUM4LjE3NDI2IDEzLjYzIDkuMDQ1MzIgMTMuOTk4MiA5LjkxNjM4IDEzLjk5ODJIMTkuMDk2MUMxOS4wOTYxIDEzLjk5ODIgMTkuMTYyOSAxNC4wMDE4IDE5LjE2MjkgMTQuMDA3NUMxOS4xNjI5IDE0LjAxMzEgMTkuMTYyOSAxNC4wMjI0IDE5LjE2MjkgMTQuMDMzQzE5LjIyOTkgMTQuMDQzNyAxOS4yMzAzIDE0LjA1NzEgMTkuMjMwMyAxNC4wNzEzQzE5LjIzMDMgMTQuMDg1NSAxOS4yMzAzIDE0LjEwMDQgMTkuMjMwMyAxNC4xMTZaJyAvPg0KICAgICAgICA8cGF0aCBkPSdNMTkuODMyMSAxMC40OTkxQzE5LjgzMjEgMTAuODUxNyAxOS44MzI0IDExLjIwNSAxOS43NjU0IDExLjU1NjJDMTkuNzY1NCAxMS41NTkgMTkuNzY1NCAxMS41NjI2IDE5Ljc2NTQgMTEuNTY2MkMxOS43NjU0IDExLjU5MzggMTkuNzY1NCAxMS42MTkzIDE5Ljc2NTQgMTEuNjM3MUMxOS42OTgzIDExLjY1NTUgMTkuNjk4IDExLjY2NTQgMTkuNjk4IDExLjY2NTRIOS45MTU1NkM5LjY0NzU0IDExLjY2NTQgOS4zMTIzOSAxMS41NDI3IDkuMTExMzggMTEuMzI0MkM4LjkxMDM2IDExLjEwNSA4Ljg0Mzc1IDEwLjgwODQgOC44NDM3NSAxMC40OTkxQzguODQzNzUgMTAuMTg5OCA4LjkxMDM2IDkuODkzMjEgOS4xMTEzOCA5LjY3Mzk5QzkuMzEyMzkgOS40NTU0NyA5LjY0NzU0IDkuMzMyMDMgOS45MTU1NiA5LjMzMjAzSDE5LjY5OEMxOS42OTggOS4zMzIwMyAxOS42OTgzIDkuMzQyNjggMTkuNzY1NCA5LjM2MTEzQzE5Ljc2NTQgOS4zNzg4NyAxOS43NjU0IDkuNDA0MzkgMTkuNzY1NCA5LjQzMjA2QzE5Ljc2NTQgOS40MzU2MSAxOS43NjU0IDkuNDM4NDcgMTkuNzY1NCA5LjQ0MjAyQzE5LjgzMjQgOS43OTMyIDE5LjgzMjEgMTAuMTQ1OCAxOS44MzIxIDEwLjQ5OTFaJyAvPg0KICAgICAgICA8cGF0aCBkPSdNMTUuOTQ2NyAxOC43ODM3QzE1Ljk0NjcgMTguODAwNyAxNS45NDY3IDE4LjgxNyAxNS45NDY3IDE4LjgzMjZDMTUuOTQ2NyAxOC44NDgyIDE1Ljk0NyAxOC44NjE3IDE1Ljg4IDE4Ljg3M0MxNS44OCAxOC44NzUyIDE1Ljg4IDE4Ljg3OCAxNS44OCAxOC44ODAxQzE0LjMzODkgMjAuMTM4IDEyLjQ2MjQgMjAuODcwOSAxMC40NTIyIDIwLjk4MzdDNC42MjI4MyAyMS4zMjU2IC0wLjI2ODI0MiAxNi4yMDc2IC0wLjAwMDIyNDIxOSAxMC4wMDY5QzAuMjY3Nzk0IDQuNDM2MjUgNC42MjI5NiAxLjI2MjI2ZS0wNSA5LjkxNjMxIDEuMjYyMjZlLTA1QzEyLjA2MDUgLTAuMDAzNTM0NjcgMTQuMjA0OSAwLjc0MDY3MSAxNS44OCAyLjExOTg2QzE1Ljg4IDIuMTIxOTkgMTUuODggMi4xMjQxMiAxNS44OCAyLjEyNjk2QzE1Ljk0NyAyLjE0MjU3IDE1Ljk0NjcgMi4xNjMxMyAxNS45NDY3IDIuMTg2NTVDMTUuOTQ2NyAyLjIwOTI1IDE1Ljk0NjcgMi4yMzQwOCAxNS45NDY3IDIuMjU2NzhDMTUuOTQ2NyAyLjI3ODc3IDE1Ljg4IDIuMjk4NjQgMTUuODggMi4zMTIxMkMxNS44OCAyLjMyNTYgMTUuODc5NiAyLjMzMzQzIDE1LjgxMjYgMi4zMzM0M0g5LjkxNjMxQzcuODM5MTcgMi4zMzM0MyA1Ljg5NjMgMy4xOTM5OCA0LjQ4OTIxIDQuNzI0OTlDMy4wMTUxMSA2LjI1NjcyIDIuMjEwNzkgOC4zMzQwMiAyLjIxMDc5IDEwLjVDMi4yMTA3OSAxMi42NjYgMy4wMTUxMSAxNC43NDMzIDQuNDg5MjEgMTYuMjc1QzUuODk2MyAxNy44MDYgNy44MzkxNyAxOC42NjY2IDkuOTE2MzEgMTguNjY2NkgxNS44MTI2QzE1Ljg3OTYgMTguNjY2NiAxNS44OCAxOC42Nzg3IDE1Ljg4IDE4LjcwMDdDMTUuOTQ3IDE4LjcyMjcgMTUuOTQ2NyAxOC43NTI1IDE1Ljk0NjcgMTguNzgzN1onIC8+DQogICAgPC9nPg0KPC9zdmc+";
    _3 = ({ style: e5, className: M4, onClick: t8 }) => {
      const { themeUpdateTS: a7 } = ((e6 = d5) => (0, z2.useContext)(e6))(), [N4, u6] = (0, z2.useState)(J2), D4 = (0, z2.useRef)(null);
      return (0, z2.useEffect)(() => {
        if (null === D4.current)
          return;
        const e6 = getComputedStyle(D4.current).getPropertyValue("--cb-secondary-text-color").trim(), M5 = (0, i7.updateSvgFillColor)(J2, e6);
        u6(M5);
      }, [a7]), z2.default.createElement(k3, { src: N4, ref: D4, style: e5, className: M4, onClick: t8 });
    };
    X2 = () => z2.default.createElement("div", { style: { backgroundColor: "var(--cb-primary-color)", borderRadius: " 0 0 1.5rem 1.5rem", height: "2rem", width: "11rem", display: "flex", flexDirection: "row", alignItems: "center", justifyContent: "center" } }, z2.default.createElement("div", { style: { color: "var(--cb-secondary-text-color)", fontFamily: "var(--cb-primary-font)", fontSize: "0.6rem", fontWeight: 700, letterSpacing: "0.03rem" } }, "Secured by"), z2.default.createElement("a", { href: "https://www.corbado.com", target: "_blank", rel: "noreferrer" }, z2.default.createElement(_3, { style: { height: "1.1rem", paddingLeft: "0.4rem" } })));
    K2 = ({ header: e5, subHeader: M4, secondaryHeader: t8, body: a7, primaryButton: N4, secondaryButton: u6, tertiaryButton: D4, showHorizontalRule: r8 = false, onClick: l7, primaryLoading: n7 = false, secondaryLoading: j4 = false, hideFingerPrintIcon: i9 = false }) => z2.default.createElement("div", { className: "cb-layout-passkey" }, z2.default.createElement(v4, null, e5), M4 && z2.default.createElement(p4, { className: "cb-subheader-spacing" }, M4), !i9 && z2.default.createElement(R2, { className: "cb-finger-print-icon" }), t8 && z2.default.createElement(v4, { className: "cb-secondary-header-spacing" }, t8), a7 && z2.default.createElement(h4, { className: "cb-body-spacing" }, a7), N4 && z2.default.createElement(m4, { onClick: () => l7("primary"), isLoading: n7, disabled: j4 }, N4), r8 && z2.default.createElement(S4, null, "or"), u6 && z2.default.createElement(C4, { onClick: () => l7("secondary"), isLoading: j4, disabled: n7 }, u6), D4 && z2.default.createElement(w5, { onClick: () => l7("tertiary"), disabled: n7 || j4 }, D4));
    $2 = { currentFlowType: void 0, currentFlow: void 0, currentScreen: void 0, currentUserState: {}, currentVerificationMethod: void 0, initialized: false, userNameRequired: true, allowUserRegistration: true, navigateBack: () => i7.ScreenNames.Start, emitEvent: () => Promise.reject(), changeFlow: () => {
    } };
    q3 = (0, z2.createContext)($2);
    ee2 = (e5 = q3) => {
      const M4 = (0, z2.useContext)(e5);
      if (!M4)
        throw new Error("Please make sure that your components are wrapped inside <FlowHandlerProvider />");
      return M4;
    };
    Me2 = (0, z2.memo)(({ children: e5, headerText: M4, subHeaderText: t8, flowChangeButtonText: a7, submitButtonText: N4, loading: u6, onSubmit: D4 }) => {
      const { changeFlow: r8 } = ee2();
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(v4, null, M4), a7 ? z2.default.createElement(p4, null, t8, z2.default.createElement("span", { className: "cb-link-secondary", onClick: r8 }, a7)) : null, z2.default.createElement("form", { className: "cb-form", onSubmit: (e6) => {
        e6.preventDefault(), D4();
      } }, z2.default.createElement("div", { className: "cb-form-body" }, e5), z2.default.createElement(m4, { disabled: u6, isLoading: u6 }, N4)));
    });
    te2 = (0, z2.memo)(({ header: e5, body: M4, children: t8 }) => {
      const { currentUserState: a7 } = ee2();
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(v4, null, e5), z2.default.createElement(h4, null, M4), z2.default.createElement(V2, null), t8, a7.verificationError && z2.default.createElement("p", { className: "cb-error" }, a7.verificationError.translatedMessage));
    });
    ae2 = ({ header: e5, body: M4, verificationButtonText: t8, backButtonText: a7, onVerificationButtonClick: N4, onBackButtonClick: u6 }) => {
      var D4;
      const { currentUserState: r8 } = ee2(), [l7, n7] = (0, z2.useState)(false), j4 = (0, z2.useRef)("");
      (0, z2.useEffect)(() => {
        n7(false);
      }, [r8]);
      const i9 = (0, z2.useCallback)((e6) => {
        const M5 = e6.join("");
        j4.current = M5, 6 === M5.length && N4(M5, n7);
      }, [N4]);
      return z2.default.createElement("form", { className: "cb-email-screen", onSubmit: (e6) => {
        e6.preventDefault(), N4(j4.current, n7);
      } }, z2.default.createElement(te2, { header: e5, body: M4 }, z2.default.createElement(b4, { emittedOTP: i9, error: null === (D4 = r8.verificationError) || void 0 === D4 ? void 0 : D4.translatedMessage })), z2.default.createElement(m4, { isLoading: l7 }, t8), z2.default.createElement(w5, { onClick: u6, disabled: l7 }, a7));
    };
    Ne2 = () => {
      const { emitEvent: e5, currentUserState: M4, currentFlowType: t8 } = ee2(), { t: a7 } = (0, g6.useTranslation)("translation", { keyPrefix: `authentication.${t8}.emailLinkSent` }), [N4, u6] = (0, z2.useState)(30), [D4, r8] = (0, z2.useState)(false), l7 = (0, z2.useRef)();
      function n7() {
        return l7.current = setInterval(() => u6((e6) => e6 - 1), 1e3), l7.current;
      }
      (0, z2.useEffect)(() => {
        const e6 = n7();
        return () => clearInterval(e6);
      }, []);
      const j4 = a7("header"), c8 = (0, z2.useMemo)(() => z2.default.createElement(z2.default.Fragment, null, a7("body_text1"), z2.default.createElement("span", { className: "cb-text-secondary cb-text-bold" }, M4.email), a7("body_text2")), [a7, M4]), s9 = (0, z2.useMemo)(() => N4 < 1 ? (l7.current && clearInterval(l7.current), a7("button_sendLinkAgain")) : z2.default.createElement(g6.Trans, { i18nKey: "button_sendLinkAgainWaitingText", t: a7, values: { remainingTime: N4 } }), [N4]), I4 = a7("button_back"), T2 = (0, z2.useCallback)(() => {
        e5(i7.FlowHandlerEvents.CancelEmailLink);
      }, []), o7 = (0, z2.useCallback)(async () => {
        r8(true), await e5(i7.FlowHandlerEvents.PrimaryButton), u6(60), n7(), r8(false);
      }, []);
      return z2.default.createElement("div", { className: "cb-email-screen" }, z2.default.createElement(te2, { header: j4, body: c8 }), z2.default.createElement(m4, { onClick: () => {
        o7();
      }, isLoading: D4, disabled: N4 > 0 }, s9), z2.default.createElement(w5, { onClick: T2, disabled: D4 }, I4));
    };
    ue2 = () => {
      const { emitEvent: e5, currentUserState: M4, currentFlowType: t8 } = ee2(), { t: a7 } = (0, g6.useTranslation)("translation", { keyPrefix: `authentication.${t8}.emailLinkVerification` }), [N4, u6] = (0, z2.useState)(true);
      (0, z2.useEffect)(() => {
        e5(i7.FlowHandlerEvents.VerifyLink);
      }, []), (0, z2.useEffect)(() => {
        M4.verificationError && u6(false);
      }, [M4]);
      const D4 = a7("header"), r8 = a7("button_back"), l7 = (0, z2.useCallback)(() => {
        e5(i7.FlowHandlerEvents.CancelEmailLink);
      }, []);
      return z2.default.createElement("div", { className: "cb-email-screen" }, z2.default.createElement(v4, null, D4), z2.default.createElement(h4, null, M4.verificationError && M4.verificationError.translatedMessage), N4 ? z2.default.createElement(x3, null) : null, z2.default.createElement(w5, { onClick: l7, disabled: N4 }, r8));
    };
    De2 = () => {
      const { emitEvent: e5, currentUserState: M4, currentFlowType: t8 } = ee2(), { t: a7 } = (0, g6.useTranslation)("translation", { keyPrefix: `authentication.${t8}.emailOtp` }), N4 = a7("header"), u6 = z2.default.createElement(z2.default.Fragment, null, a7("body_text1"), z2.default.createElement("span", { className: "cb-text-secondary cb-text-bold" }, M4.email), a7("body_text2")), D4 = a7("button_verify"), r8 = a7("button_back"), l7 = (0, z2.useCallback)(() => e5(i7.FlowHandlerEvents.CancelOTP), []), n7 = (0, z2.useCallback)(async (M5, t9) => {
        t9(true), await e5(i7.FlowHandlerEvents.PrimaryButton, { verificationCode: M5 });
      }, []), j4 = (0, z2.useMemo)(() => ({ header: N4, body: u6, verificationButtonText: D4, backButtonText: r8, onVerificationButtonClick: n7, onBackButtonClick: l7 }), [a7, M4.email, n7, l7, N4, u6, D4, r8]);
      return z2.default.createElement(ae2, { ...j4 });
    };
    re2 = () => {
      const { emitEvent: e5, currentFlowType: M4 } = ee2(), { t: t8 } = (0, g6.useTranslation)("translation", { keyPrefix: `authentication.${M4}.passkeyAppend` }), [a7, N4] = (0, z2.useState)(false), u6 = (0, z2.useMemo)(() => z2.default.createElement("span", null, t8("header"), z2.default.createElement("span", { className: "cb-link-primary", onClick: () => {
        e5(i7.FlowHandlerEvents.ShowBenefits);
      } }, t8("button_showPasskeyBenefits"))), [t8]), D4 = (0, z2.useMemo)(() => t8("button_start"), [t8]), r8 = (0, z2.useMemo)(() => t8("button_skip"), [t8]), l7 = (0, z2.useCallback)((M5) => "primary" === M5 ? (N4(true), e5(i7.FlowHandlerEvents.PrimaryButton)) : e5(i7.FlowHandlerEvents.SecondaryButton), [e5]), n7 = (0, z2.useMemo)(() => ({ header: u6, primaryButton: D4, secondaryButton: r8, primaryLoading: a7, onClick: l7 }), [u6, D4, r8, a7, l7]);
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(K2, { ...n7 }));
    };
    le2 = () => {
      const { emitEvent: e5, currentFlowType: M4 } = ee2(), { t: t8 } = (0, g6.useTranslation)("translation", { keyPrefix: `authentication.${M4}.passkeyBenefits` }), [a7, N4] = (0, z2.useState)(false), u6 = (0, z2.useMemo)(() => t8("header"), [t8]), D4 = (0, z2.useMemo)(() => z2.default.createElement(z2.default.Fragment, null, t8("body_introduction"), " ", z2.default.createElement("strong", null, t8("body_loginMethods"))), [t8]), r8 = (0, z2.useMemo)(() => t8("button_start"), [t8]), l7 = (0, z2.useMemo)(() => t8("button_skip"), [t8]), n7 = (0, z2.useCallback)(async (M5) => "primary" === M5 ? (N4(true), e5(i7.FlowHandlerEvents.PrimaryButton)) : e5(i7.FlowHandlerEvents.SecondaryButton), [e5, N4]), j4 = (0, z2.useMemo)(() => ({ header: u6, body: D4, primaryButton: r8, secondaryButton: l7, primaryLoading: a7, onClick: n7 }), [D4, u6, r8, l7, a7, n7]);
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(K2, { ...j4 }));
    };
    ne2 = { [i7.ScreenNames.Start]: () => {
      var e5;
      const { emitEvent: M4, currentUserState: t8, allowUserRegistration: a7 } = ee2(), { t: N4 } = (0, g6.useTranslation)("translation", { keyPrefix: "authentication.login.start" }), [u6, D4] = (0, z2.useState)(false), r8 = (0, z2.useRef)(false), l7 = (0, z2.useRef)();
      (0, z2.useEffect)(() => {
        r8.current || (r8.current = true, M4(i7.FlowHandlerEvents.InitConditionalUI));
      }, []), (0, z2.useEffect)(() => {
        D4(false);
      }, [t8]);
      const n7 = (0, z2.useMemo)(() => N4("header"), [N4]), j4 = (0, z2.useMemo)(() => N4("subheader"), [N4]), c8 = (0, z2.useMemo)(() => a7 ? N4("button_signup") : void 0, [N4]), s9 = (0, z2.useMemo)(() => N4("textField_email"), [N4]), I4 = (0, z2.useMemo)(() => N4("button_submit"), [N4]), T2 = (0, z2.useCallback)(() => {
        var e6;
        D4(true), M4(i7.FlowHandlerEvents.PrimaryButton, { userStateUpdate: { email: null === (e6 = l7.current) || void 0 === e6 ? void 0 : e6.value } });
      }, [M4]);
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(Me2, { headerText: n7, subHeaderText: j4, flowChangeButtonText: c8, onSubmit: T2, submitButtonText: I4, loading: u6 }, z2.default.createElement(Y2, { name: "username", type: "email", autoComplete: "email webauthn", label: s9, ref: (e6) => e6 && (l7.current = e6), error: null === (e5 = t8.emailError) || void 0 === e5 ? void 0 : e5.translatedMessage })));
    }, [i7.ScreenNames.EmailOTPVerification]: De2, [i7.ScreenNames.EmailLinkSent]: Ne2, [i7.ScreenNames.EmailLinkVerification]: ue2, [i7.ScreenNames.PasskeyAppend]: re2, [i7.ScreenNames.PasskeyError]: () => {
      const { isAuthenticated: e5 } = (0, l6.useCorbado)();
      return z2.default.createElement(ye2, { showSecondaryButton: !e5, navigateBackOnCancel: !e5 });
    }, [i7.ScreenNames.PasskeyBenefits]: le2 };
    je2 = () => {
      const { emitEvent: e5, currentVerificationMethod: M4 } = ee2(), { t: t8 } = (0, g6.useTranslation)("translation", { keyPrefix: "authentication.signup.passkeySuccess" }), a7 = (0, z2.useMemo)(() => t8("header"), [t8]), N4 = (0, z2.useMemo)(() => t8("subheader"), [t8]), u6 = (0, z2.useMemo)(() => z2.default.createElement("span", null, t8("body_text1"), " ", z2.default.createElement("strong", null, t8(`body_text2.${M4}`)), " ", t8("body_text3")), [t8]), D4 = (0, z2.useMemo)(() => t8("button"), [t8]), r8 = (0, z2.useCallback)(() => {
        e5(i7.FlowHandlerEvents.PrimaryButton);
      }, [e5]), l7 = (0, z2.useMemo)(() => ({ header: a7, secondaryHeader: N4, body: u6, primaryButton: D4, onClick: r8 }), [a7, N4, u6, D4, r8]);
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(K2, { ...l7 }));
    };
    ie3 = () => {
      const { currentUserState: e5, userNameRequired: M4, emitEvent: t8 } = ee2(), { t: a7 } = (0, g6.useTranslation)("translation", { keyPrefix: "authentication.signup.start" }), [N4, u6] = (0, z2.useState)(null), [D4, r8] = (0, z2.useState)(null), [l7, n7] = (0, z2.useState)(false), j4 = (0, z2.useRef)(), c8 = (0, z2.useRef)();
      (0, z2.useEffect)(() => {
        var M5, t9;
        n7(false), u6(null !== (M5 = e5.emailError) && void 0 !== M5 ? M5 : null), r8(null !== (t9 = e5.userNameError) && void 0 !== t9 ? t9 : null);
      }, [e5]);
      const s9 = (0, z2.useMemo)(() => a7("header"), [a7]), I4 = (0, z2.useMemo)(() => a7("subheader"), [a7]), T2 = (0, z2.useMemo)(() => a7("button_login"), [a7]), o7 = (0, z2.useMemo)(() => a7("button_submit"), [a7]), L5 = (0, z2.useMemo)(() => a7("textField_name"), [a7]), y7 = (0, z2.useMemo)(() => a7("textField_email"), [a7]), d6 = (0, z2.useCallback)(() => {
        var e6, a8, N5;
        n7(true);
        const u7 = M4 ? null === (e6 = c8.current) || void 0 === e6 ? void 0 : e6.value : null === (a8 = j4.current) || void 0 === a8 ? void 0 : a8.value;
        t8(i7.FlowHandlerEvents.PrimaryButton, { userStateUpdate: { email: null === (N5 = j4.current) || void 0 === N5 ? void 0 : N5.value, fullName: u7 } });
      }, [t8]);
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(Me2, { headerText: s9, subHeaderText: I4, flowChangeButtonText: T2, onSubmit: d6, submitButtonText: o7, loading: l7 }, M4 && z2.default.createElement(Y2, { name: "fullName", label: L5, error: null == D4 ? void 0 : D4.translatedMessage, ref: (e6) => e6 && (c8.current = e6) }), z2.default.createElement(Y2, { name: "name", type: "email", autoComplete: "email", label: y7, error: null == N4 ? void 0 : N4.translatedMessage, ref: (e6) => e6 && (j4.current = e6) })));
    };
    ce2 = { [i7.ScreenNames.Start]: ie3, [i7.ScreenNames.PasskeyCreate]: () => {
      const { navigateBack: e5, currentUserState: M4, emitEvent: t8, currentVerificationMethod: a7 } = ee2(), { t: N4 } = (0, g6.useTranslation)("translation", { keyPrefix: "authentication.signup.passkeyCreate" }), [u6, D4] = (0, z2.useState)(false), [r8, l7] = (0, z2.useState)(false);
      (0, z2.useEffect)(() => {
        D4(false), l7(false);
      }, [M4]);
      const n7 = (0, z2.useMemo)(() => z2.default.createElement("span", null, N4("header"), z2.default.createElement("span", { className: "cb-link-primary", onClick: () => {
        t8(i7.FlowHandlerEvents.ShowBenefits);
      } }, N4("headerButton_showPasskeyBenefits"))), [N4]), j4 = (0, z2.useMemo)(() => z2.default.createElement("span", null, N4("body"), " ", z2.default.createElement("span", { className: "cb-text-secondary" }, M4.email), "."), [N4]), c8 = (0, z2.useMemo)(() => N4("button_start"), [N4]), s9 = (0, z2.useMemo)(() => N4(`button_switchToAlternate.${a7}`), [N4]), I4 = (0, z2.useMemo)(() => N4("button_back"), [N4]), T2 = (0, z2.useCallback)(() => e5(), [e5]), o7 = (0, z2.useCallback)((M5) => {
        switch (M5) {
          case "primary":
            return D4(true), t8(i7.FlowHandlerEvents.PrimaryButton);
          case "secondary":
            return l7(true), t8(i7.FlowHandlerEvents.SecondaryButton);
          case "tertiary":
            return e5();
        }
      }, [T2]), L5 = (0, z2.useMemo)(() => ({ header: n7, subHeader: j4, primaryButton: c8, showHorizontalRule: true, secondaryButton: s9, tertiaryButton: I4, primaryLoading: u6, secondaryLoading: r8, onClick: o7 }), [n7, j4, c8, s9, I4, u6, r8, o7]);
      return z2.default.createElement(z2.default.Fragment, null, z2.default.createElement(K2, { ...L5 }));
    }, [i7.ScreenNames.EmailOTPVerification]: De2, [i7.ScreenNames.EmailLinkSent]: Ne2, [i7.ScreenNames.EmailLinkVerification]: ue2, [i7.ScreenNames.PasskeyAppend]: re2, [i7.ScreenNames.PasskeyBenefits]: le2, [i7.ScreenNames.PasskeySuccess]: je2, [i7.ScreenNames.PasskeyError]: () => {
      const { isAuthenticated: e5 } = (0, l6.useCorbado)();
      return z2.default.createElement(ye2, { showSecondaryButton: !e5, navigateBackOnCancel: !e5 });
    } };
    se3 = { [i7.ScreenNames.Start]: ie3, [i7.ScreenNames.EmailOTPVerification]: De2, [i7.ScreenNames.EmailLinkSent]: Ne2, [i7.ScreenNames.EmailLinkVerification]: ue2, [i7.ScreenNames.PasskeyAppend]: re2, [i7.ScreenNames.PasskeyBenefits]: le2, [i7.ScreenNames.PasskeySuccess]: je2, [i7.ScreenNames.PasskeyError]: () => z2.default.createElement(ye2, { showSecondaryButton: false, navigateBackOnCancel: false }) };
    ge2 = { [i7.SignUpFlowNames.PasskeySignupWithFallback]: ce2, [i7.SignUpFlowNames.SignupWithPasskeyAppend]: se3, [i7.LoginFlowNames.PasskeyLoginWithFallback]: ne2 };
    Ie2 = () => z2.default.createElement("div", { className: "cb-loading" }, z2.default.createElement(x3, null));
    Te2 = ({ error: e5 }) => z2.default.createElement("div", { className: "container" }, z2.default.createElement("div", { className: "title" }, e5.name, " ", z2.default.createElement("br", null), "(", "client" === e5.type ? "client side" : "server side", ")"), z2.default.createElement("div", { className: "error-details" }, z2.default.createElement("div", { className: "error-detail-row" }, z2.default.createElement("div", { className: "error-detail-title" }, ":Message"), z2.default.createElement("div", { className: "error-detail-value" }, e5.message)), z2.default.createElement("div", { className: "error-detail-row" }, z2.default.createElement("div", { className: "error-detail-title" }, ":Type"), z2.default.createElement("div", { className: "error-detail-value" }, e5.detailedType)), z2.default.createElement("div", { className: "error-detail-row" }, z2.default.createElement("div", { className: "error-detail-title" }, ":Link"), z2.default.createElement("a", { className: "error-detail-value", href: e5.link }, e5.link))), z2.default.createElement("div", { className: "error-detail-row" }, z2.default.createElement("div", { className: "error-detail-title" }, ":RequestID"), z2.default.createElement("div", { className: "error-detail-value" }, e5.requestId)), e5.details && z2.default.createElement(m4, { className: "error-button", onClick: () => {
      window.open(e5.details, "_blank");
    } }, "See browser console for more details"));
    oe2 = (e5) => {
      const { t: M4 } = (0, g6.useTranslation)("translation", { keyPrefix: "authentication.unexpectedError" });
      return z2.default.createElement("div", { className: "error-page" }, z2.default.createElement("div", { className: "prod-error-container" }, z2.default.createElement("div", { className: "prod-error-title" }, M4("header")), z2.default.createElement("div", { className: "prod-error-details" }, z2.default.createElement("div", { className: "prod-error-apology" }, M4("subheader")), z2.default.createElement("div", null, e5 ? M4("body_withCustomerSupport", e5) : M4("body_noCustomerSupport"))), z2.default.createElement(m4, { onClick: () => window.location.reload() }, M4("button"))));
    };
    ze2 = class extends z2.default.Component {
      constructor(e5) {
        super(e5), this.state = { error: void 0 };
      }
      static getDerivedStateFromError(e5) {
        return console.error(e5), { hasError: true };
      }
      componentDidCatch(e5, M4) {
        console.error(e5, M4);
      }
      render() {
        return !this.props.globalError && !this.state.error || this.props.isDevMode ? this.props.globalError ? z2.default.createElement("div", { className: "error-page" }, z2.default.createElement(Te2, { error: this.props.globalError })) : this.props.children : z2.default.createElement(oe2, { customerSupportEmail: this.props.customerSupportEmail });
      }
    };
    Le2 = () => {
      const { isDevMode: e5, customerSupportEmail: M4 } = ((e6 = L4) => (0, z2.useContext)(e6))(), { currentFlow: t8, currentScreen: a7, initialized: N4 } = ee2(), { globalError: u6 } = (0, l6.useCorbado)(), [D4, r8] = (0, z2.useState)({});
      (0, z2.useEffect)(() => {
        if (!t8)
          return;
        const e6 = ge2[t8];
        r8(null != e6 ? e6 : {});
      }, [t8]);
      const n7 = (0, z2.useMemo)(() => a7 ? D4[a7] : null, [D4, a7]), j4 = (0, z2.useCallback)(() => {
        const e6 = D4[i7.ScreenNames.End];
        return e6 ? z2.default.createElement(e6, null) : null;
      }, [D4]);
      return z2.default.createElement(ze2, { globalError: u6, isDevMode: e5, customerSupportEmail: M4 }, N4 ? n7 ? z2.default.createElement(n7, null) : z2.default.createElement(j4, null) : z2.default.createElement(Ie2, null));
    };
    ye2 = ({ showSecondaryButton: e5, navigateBackOnCancel: M4 }) => {
      const { navigateBack: t8, emitEvent: a7, currentFlowType: N4, currentVerificationMethod: u6, currentUserState: D4 } = ee2(), { t: r8 } = (0, g6.useTranslation)("translation", { keyPrefix: `authentication.${N4}.passkeyError` }), { isAuthenticated: n7 } = (0, l6.useCorbado)(), [j4, c8] = (0, z2.useState)(false), [s9, I4] = (0, z2.useState)(false);
      (0, z2.useEffect)(() => {
        c8(false);
      }, [D4.lastPasskeyRetryTimeStamp]);
      const T2 = (0, z2.useMemo)(() => r8("header"), [r8]), o7 = (0, z2.useMemo)(() => "login" === N4 ? r8(`body.${u6}`) : z2.default.createElement("span", null, r8("body_errorMessage"), z2.default.createElement("span", { className: "cb-link-primary", onClick: () => {
        a7(i7.FlowHandlerEvents.ShowBenefits);
      } }, r8("button_showPasskeyBenefits")), r8(`body_tryAgainMessage.${u6}`)), [r8]), L5 = (0, z2.useMemo)(() => r8("button_retry"), [r8]), y7 = (0, z2.useMemo)(() => e5 ? r8(`button_switchToAlternate.${u6}`) : "", [r8]), d6 = (0, z2.useMemo)(() => r8(M4 ? "button_back" : "button_cancel"), [r8, n7]), E6 = (0, z2.useCallback)((e6) => {
        switch (e6) {
          case "primary":
            return c8(true), void a7(i7.FlowHandlerEvents.PrimaryButton);
          case "secondary":
            return I4(true), void a7(i7.FlowHandlerEvents.SecondaryButton);
          case "tertiary":
            return M4 ? t8() : void a7(i7.FlowHandlerEvents.CancelPasskey);
        }
      }, [t8, a7]);
      return (0, z2.useMemo)(() => z2.default.createElement(K2, { header: T2, body: o7, primaryButton: L5, secondaryButton: y7, tertiaryButton: d6, onClick: E6, primaryLoading: j4, secondaryLoading: s9 }), [o7, E6, T2, L5, y7, j4, y7, d6]);
    };
    de2 = class extends z2.default.Component {
      constructor(e5) {
        super(e5), this.state = { error: void 0 };
      }
      static getDerivedStateFromError(e5) {
        return console.error(e5), { hasError: true };
      }
      componentDidCatch(e5, M4) {
        console.error(e5, M4);
      }
      render() {
        return this.props.globalError ? z2.default.createElement("div", { className: "error-page" }, z2.default.createElement("div", null, "Something went wrong. Please try again in a few moments.")) : this.props.children;
      }
    };
    Ee2 = ({ aaguid: e5 }) => {
      var M4, t8;
      const a7 = i7.aaguidMappings[e5], N4 = (0, i7.hasDarkMode)() && null !== (M4 = null == a7 ? void 0 : a7.iconDark) && void 0 !== M4 ? M4 : null == a7 ? void 0 : a7.icon;
      return z2.default.createElement("div", { className: "cb-passkey-list-icon" }, N4 ? z2.default.createElement("img", { src: N4, alt: null !== (t8 = null == a7 ? void 0 : a7.name) && void 0 !== t8 ? t8 : "Passkey" }) : z2.default.createElement(P3, null));
    };
    Ae2 = (0, z2.memo)(({ fetchPasskeys: e5 }) => {
      const { t: M4 } = (0, g6.useTranslation)("translation", { keyPrefix: "passkeysList" }), { appendPasskey: t8 } = (0, l6.useCorbado)(), [a7, N4] = (0, z2.useState)(false), [u6, D4] = (0, z2.useState)(false), r8 = (0, z2.useMemo)(() => ({ buttonText: M4("button_createPasskey"), dialogHeader: M4("dialog_passkeyAlreadyExists.header"), dialogBody: M4("dialog_passkeyAlreadyExists.body"), dialogConfirmText: M4("dialog_passkeyAlreadyExists.button_confirm") }), [M4]), n7 = () => {
        N4(false);
      };
      return z2.default.createElement("div", null, z2.default.createElement(m4, { className: "cb-passkey-list-primary-button", isLoading: u6, onClick: () => {
        (async () => {
          var M5;
          D4(true);
          const a8 = await t8();
          a8.ok ? await e5() : "errors.passkeyAlreadyExists" === (null === (M5 = a8.val) || void 0 === M5 ? void 0 : M5.name) && N4(true), D4(false);
        })();
      } }, r8.buttonText), z2.default.createElement(W3, { isOpen: a7, header: r8.dialogHeader, body: r8.dialogBody, confirmText: r8.dialogConfirmText, onClose: n7, onConfirm: n7 }));
    });
    xe2 = ({ passkeyId: e5, onPasskeyDelete: M4 }) => {
      const { t: t8 } = (0, g6.useTranslation)("translation", { keyPrefix: "passkeysList.dialog_delete" }), [a7, N4] = (0, z2.useState)(false), u6 = () => {
        N4(false);
      };
      return z2.default.createElement("div", { className: "cb-passkey-list-icon" }, z2.default.createElement(B2, { onClick: () => {
        N4(true);
      } }), z2.default.createElement(W3, { isOpen: a7, header: t8("header"), body: t8("body"), confirmText: t8("button_confirm"), cancelText: t8("button_cancel"), onClose: u6, onConfirm: async () => {
        await M4(e5), u6();
      } }));
    };
    Oe = ({ passkey: e5 }) => {
      var M4, t8;
      const { t: a7 } = (0, g6.useTranslation)("translation", { keyPrefix: "passkeysList" }), N4 = (0, i7.getParsedUA)(e5.userAgent), u6 = null !== (t8 = null === (M4 = i7.aaguidMappings[e5.aaguid]) || void 0 === M4 ? void 0 : M4.name) && void 0 !== t8 ? t8 : "Passkey";
      return z2.default.createElement("div", { className: "cb-passkey-list-details" }, z2.default.createElement("div", { className: "cb-passkey-list-header" }, z2.default.createElement("div", { className: "cb-passkey-list-header-title" }, u6), e5.backupState ? z2.default.createElement("div", { className: "cb-passkey-list-header-badge" }, a7("badge_synced")) : null), z2.default.createElement("div", null, a7("field_credentialId"), e5.id), z2.default.createElement("div", null, z2.default.createElement(g6.Trans, { i18nKey: "field_created", t: a7, values: { date: e5.created, browser: N4.browser.name, os: N4.os.name } })), z2.default.createElement("div", null, a7("field_lastUsed"), e5.lastUsed), z2.default.createElement("div", null, a7("field_status"), e5.status));
    };
    me2 = (0, z2.memo)(({ passkey: e5, fetchPasskeys: M4 }) => {
      const { deletePasskey: t8 } = (0, l6.useCorbado)();
      return z2.default.createElement("div", { key: e5.id, className: "cb-passkey-list-card" }, z2.default.createElement(Ee2, { aaguid: e5.aaguid }), z2.default.createElement(Oe, { passkey: e5 }), z2.default.createElement(xe2, { passkeyId: e5.id, onPasskeyDelete: async (e6) => {
        await t8(e6), await M4();
      } }));
    });
    Ce2 = ({ children: e5, initialFlowType: M4, onLoggedIn: t8, onChangeFlow: a7 }) => {
      const { corbadoApp: N4 } = (0, l6.useCorbado)(), [u6, D4] = (0, z2.useState)(), [r8, n7] = (0, z2.useState)(), [j4, s9] = (0, z2.useState)({}), [g7, I4] = (0, z2.useState)(), [T2, o7] = (0, z2.useState)(false), [L5, y7] = (0, z2.useState)(true), [d6, E6] = (0, z2.useState)(true), A5 = (0, z2.useRef)(), x4 = (0, z2.useRef)(), O3 = (0, z2.useRef)(0), m5 = (0, z2.useRef)(0);
      (0, z2.useEffect)(() => {
        const e6 = new i7.FlowHandler(N4);
        return D4(e6), O3.current = e6.onFlowChange((e7) => {
          e7.flowName && I4(e7.flowName), e7.screenName && n7(e7.screenName), e7.flowType && (A5.current = e7.flowType), e7.verificationMethod && (x4.current = e7.verificationMethod);
        }), m5.current = e6.onUserStateChange((e7) => {
          s9(e7);
        }), (async () => {
          await e6.init(c6.default, t8, M4), y7(e6.userNameRequired), E6(e6.allowUserRegistration), o7(true);
        })(), () => {
          e6.dispose(), e6.removeOnFlowChangeCallback(O3.current), e6.removeOnUserStateChange(m5.current);
        };
      }, []);
      const C5 = (0, z2.useCallback)(() => {
        var e6;
        return null !== (e6 = null == u6 ? void 0 : u6.navigateBack()) && void 0 !== e6 ? e6 : i7.ScreenNames.Start;
      }, [u6]), w6 = (0, z2.useCallback)((e6, M5) => null == u6 ? void 0 : u6.handleStateUpdate(e6, M5), [u6]), S5 = (0, z2.useCallback)(() => {
        void 0 === a7 && w6(i7.FlowHandlerEvents.ChangeFlow), null == a7 || a7();
      }, [M4, a7, w6]), k4 = (0, z2.useMemo)(() => ({ currentFlowType: A5.current, currentFlow: g7, currentScreen: r8, currentUserState: j4, currentVerificationMethod: x4.current, initialized: T2, userNameRequired: L5, allowUserRegistration: d6, changeFlow: S5, navigateBack: C5, emitEvent: w6 }), [A5.current, x4.current, g7, r8, j4, T2, C5]);
      return z2.default.createElement(q3.Provider, { value: k4 }, e5);
    };
    we2 = ({ onLoggedIn: e5 }) => z2.default.createElement("div", { style: { display: "flex", flexDirection: "column", alignItems: "center" } }, z2.default.createElement("div", { className: "cb-container" }, z2.default.createElement(Ce2, { onLoggedIn: e5 }, z2.default.createElement(Le2, null))), z2.default.createElement(X2, null));
    Se2 = ({ onLoggedIn: e5, navigateToSignUp: M4 }) => z2.default.createElement("div", { className: "cb-container" }, z2.default.createElement(Ce2, { onLoggedIn: e5, onChangeFlow: M4, initialFlowType: i7.FlowType.Login }, z2.default.createElement(Le2, null)));
    ke2 = () => {
      var e5;
      const { getPasskeys: M4, globalError: t8, isAuthenticated: a7 } = (0, l6.useCorbado)(), { t: N4 } = (0, g6.useTranslation)("translation", { keyPrefix: "passkeysList" }), [u6, D4] = (0, z2.useState)(), [r8, n7] = (0, z2.useState)(false);
      (0, z2.useEffect)(() => {
        a7 && j4();
      }, [a7]);
      const j4 = (0, z2.useCallback)(async () => {
        n7(true);
        const e6 = await M4();
        if (e6.err)
          throw new Error(e6.val.name);
        D4(e6.val), n7(false);
      }, [M4]);
      return a7 ? r8 ? z2.default.createElement(x3, null) : z2.default.createElement(de2, { globalError: t8 }, null !== (e5 = null == u6 ? void 0 : u6.passkeys.map((e6) => z2.default.createElement(me2, { key: e6.id, passkey: e6, fetchPasskeys: j4 }))) && void 0 !== e5 ? e5 : z2.default.createElement("div", null, N4("message_noPasskeys")), z2.default.createElement(Ae2, { fetchPasskeys: j4 })) : z2.default.createElement("div", null, N4("warning_notLoggedIn"));
    };
    Qe2 = ({ onSignedUp: e5, navigateToLogin: M4 }) => z2.default.createElement("div", { className: "cb-container" }, z2.default.createElement(Ce2, { onLoggedIn: e5, onChangeFlow: M4, initialFlowType: i7.FlowType.SignUp }, z2.default.createElement(Le2, null)));
    Ye2 = r6.rX;
    Ue2 = r6.Hg;
    fe2 = r6.BN;
    be2 = r6.m3;
    ve2 = r6.XZ;
    pe2 = r6.Mo;
    he2 = r6.km;
    Be2 = r6.Ye;
  }
});

// node_modules/@corbado/web-js/dist/index.js
var dist_exports4 = {};
__export(dist_exports4, {
  default: () => h5
});
function i8(t8) {
  var e5 = a6[t8];
  if (void 0 !== e5)
    return e5.exports;
  var r8 = a6[t8] = { exports: {} };
  return s7[t8](r8, r8.exports, i8), r8.exports;
}
var t6, o5, s7, a6, n5, h5;
var init_dist7 = __esm({
  "node_modules/@corbado/web-js/dist/index.js"() {
    t6 = __toESM(require_react_dom());
    init_dist6();
    init_dist3();
    o5 = __toESM(require_react());
    s7 = { 29: (t8, e5, r8) => {
      var o7 = r8(362);
      e5.s = o7.createRoot, o7.hydrateRoot;
    }, 362: (e5) => {
      e5.exports = t6;
    } };
    a6 = {};
    i8.d = (t8, e5) => {
      for (var r8 in e5)
        i8.o(e5, r8) && !i8.o(t8, r8) && Object.defineProperty(t8, r8, { enumerable: true, get: e5[r8] });
    }, i8.o = (t8, e5) => Object.prototype.hasOwnProperty.call(t8, e5);
    n5 = {};
    (() => {
      function t8(t9, e5, r8, o7) {
        if ("a" === r8 && !o7)
          throw new TypeError("Private accessor was defined without a getter");
        if ("function" == typeof e5 ? t9 !== e5 || !o7 : !e5.has(t9))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return "m" === r8 ? o7 : "a" === r8 ? o7.call(t9) : o7 ? o7.value : e5.get(t9);
      }
      function s9(t9, e5, r8, o7, s10) {
        if ("m" === o7)
          throw new TypeError("Private method is not writable");
        if ("a" === o7 && !s10)
          throw new TypeError("Private accessor was defined without a setter");
        if ("function" == typeof e5 ? t9 !== e5 || !s10 : !e5.has(t9))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return "a" === o7 ? s10.call(t9, r8) : s10 ? s10.value = r8 : e5.set(t9, r8), r8;
      }
      i8.d(n5, { Z: () => y7 }), Object.create, Object.create, "function" == typeof SuppressedError && SuppressedError;
      const a7 = (h6 = { CorbadoAuth: () => Ye2, CorbadoProvider: () => Ue2, Login: () => be2, PasskeyList: () => ve2, SignUp: () => pe2 }, c8 = {}, i8.d(c8, h6), c8);
      var h6, c8;
      const u6 = ((t9) => {
        var e5 = {};
        return i8.d(e5, t9), e5;
      })({ CorbadoApp: () => a2 });
      var l7, f5, p5, d6, g7, b5;
      class w6 {
        constructor(t9) {
          l7.set(this, void 0), f5.set(this, void 0), p5.set(this, void 0), d6.set(this, void 0), g7.set(this, void 0), b5.set(this, void 0);
          const e5 = new u6.CorbadoApp(t9);
          e5.authService.shortSessionChanges.subscribe((t10) => {
            s9(this, p5, t10, "f");
          }), e5.authService.userChanges.subscribe((t10) => {
            s9(this, g7, t10, "f");
          }), e5.globalErrors.subscribe((e6) => {
            s9(this, b5, e6, "f"), t9.onError && e6 && t9.onError(e6);
          }), e5.authService.authStateChanges.subscribe((t10) => {
            s9(this, d6, !!t10, "f");
          }), s9(this, l7, e5, "f"), s9(this, f5, t9, "f");
        }
        async init() {
          await t8(this, l7, "f").init();
        }
        get corbadoApp() {
          return t8(this, l7, "f");
        }
        get corbadoAppProps() {
          return t8(this, f5, "f");
        }
        get shortSession() {
          return t8(this, p5, "f");
        }
        get shortSessionChanges() {
          return t8(this, l7, "f").authService.shortSessionChanges;
        }
        get isAuthenticated() {
          return t8(this, d6, "f");
        }
        get authStateChanges() {
          return t8(this, l7, "f").authService.authStateChanges;
        }
        get userChanges() {
          return t8(this, l7, "f").authService.userChanges;
        }
        get user() {
          return t8(this, g7, "f");
        }
        get globalError() {
          return t8(this, b5, "f");
        }
        logout() {
          if (!this.corbadoApp)
            throw new Error("Please call load() before logging out");
          this.corbadoApp.authService.logout();
        }
      }
      l7 = /* @__PURE__ */ new WeakMap(), f5 = /* @__PURE__ */ new WeakMap(), p5 = /* @__PURE__ */ new WeakMap(), d6 = /* @__PURE__ */ new WeakMap(), g7 = /* @__PURE__ */ new WeakMap(), b5 = /* @__PURE__ */ new WeakMap();
      const v5 = ((t9) => {
        var e5 = {};
        return i8.d(e5, t9), e5;
      })({ default: () => o5.default });
      var m5, C5, S5, P4 = i8(29);
      m5 = /* @__PURE__ */ new WeakMap(), C5 = /* @__PURE__ */ new WeakMap(), S5 = /* @__PURE__ */ new WeakMap();
      const y7 = new class {
        constructor() {
          m5.set(this, void 0), C5.set(this, (e5, r8, o7) => {
            if (!t8(this, m5, "f"))
              throw new Error("Please call load() before mounting components");
            !function(t9, e6, r9, o8) {
              const s10 = (0, P4.s)(e6), i9 = { corbadoAppInstance: t9.corbadoApp, ...t9.corbadoAppProps };
              s10.render(v5.default.createElement(({ providerProps: t10, componentProps: e7 }) => v5.default.createElement(a7.CorbadoProvider, { ...t10 }, v5.default.createElement(r9, { ...e7 })), { providerProps: i9, componentProps: o8 }));
            }(t8(this, m5, "f"), e5, r8, o7);
          }), S5.set(this, () => {
            if (!t8(this, m5, "f"))
              throw new Error("Please call load() before using this library");
            return t8(this, m5, "f");
          });
        }
        get user() {
          return t8(this, S5, "f").call(this).user;
        }
        get shortSession() {
          return t8(this, S5, "f").call(this).shortSession;
        }
        get shortSessionChanges() {
          return t8(this, S5, "f").call(this).shortSessionChanges;
        }
        get userChanges() {
          return t8(this, S5, "f").call(this).userChanges;
        }
        get isAuthenticated() {
          return t8(this, S5, "f").call(this).isAuthenticated;
        }
        get authStateChanges() {
          return t8(this, S5, "f").call(this).authStateChanges;
        }
        async load(t9) {
          const e5 = new w6(t9);
          await e5.init(), s9(this, m5, e5, "f");
        }
        mountAuthUI(e5, r8) {
          t8(this, C5, "f").call(this, e5, a7.CorbadoAuth, r8);
        }
        mountSignUpUI(e5, r8) {
          t8(this, C5, "f").call(this, e5, a7.SignUp, r8);
        }
        mountLoginUI(e5, r8) {
          t8(this, C5, "f").call(this, e5, a7.Login, r8);
        }
        mountPasskeyListUI(e5) {
          t8(this, C5, "f").call(this, e5, a7.PasskeyList, {});
        }
        logout() {
          if (!t8(this, m5, "f"))
            throw new Error("Please call load() before logging out");
          t8(this, m5, "f").logout();
        }
      }();
    })();
    h5 = n5.Z;
  }
});

// .svelte-kit/output/server/chunks/index2.js
var FAUNA, PUBLIC_CORBADO_PROJECT_ID, authVerify, faunaReady, initializeSession, __tla2;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_index4();
    init_browser();
    init_browser2();
    __tla2 = (async () => {
      const JWKS = createLocalJWKSet({
        keys: [
          {
            alg: "RS256",
            e: "AQAB",
            kid: "pki-6009621403329666133",
            kty: "RSA",
            n: "r8MTlck5bV0vhy8vjIU8vZLPMtt-gYZy125nal-dzVE-Fm_cWVqsEh-4Lej1YoB24Gep8DUwhR8oNCX26N63wLL9VIke8xUCK05VooBg8UzWYyM3-RKi7mfk1xJREgoKSJJcJRVmQL5aLxQjRibtkQHiGbohX4J8GewDLkt17ebcWXdJcfEHf9vZxupOxjM3tr87WqS7uzSvgY4WtLcE12LnIuRdN25SOgx49yWADGYv1IvD9eHj_GlQDQj_xYHqaeJpA1euTXfWO99QDrCe09cpNCY3wJgiURvTxpOyhtDQGGfKmk8xIWdTWB9pl1sM2NhNxHxe9bTpHHLHeeGMQQ",
            use: "sig"
          }
        ]
      });
      const jwtVerify2 = async (jwt) => {
        return await jwtVerify(jwt, JWKS);
      };
      const parseCookies = (cookie2) => {
        return Object.fromEntries(cookie2.split(";").map((c8) => {
          const [key3, ...v5] = c8.split("=");
          return [
            key3.trim(),
            v5.join("=")
          ];
        }));
      };
      authVerify = async (cookies) => {
        let cbo_session;
        if (typeof cookies === "string") {
          cookies = parseCookies(cookies);
          cbo_session = cookies["cbo_short_session"];
        } else {
          cbo_session = cookies.get("cbo_short_session");
        }
        try {
          if (!cbo_session) {
            throw new Error("No session");
          }
          return await jwtVerify2(cbo_session);
        } catch (e5) {
          throw new Error(e5);
        }
      };
      PUBLIC_CORBADO_PROJECT_ID = "pro-1694494494712887582";
      const USER = writable({
        session: false
      });
      let SESSION = writable();
      FAUNA = writable();
      faunaReady = writable();
      let Corbado2 = writable();
      faunaReady.subscribe((value) => {
        console.log("faunaReady value updated:", value);
      });
      initializeSession = async () => {
        if (get_store_value(SESSION)) {
          console.log(get_store_value(SESSION));
          return get_store_value(SESSION);
        }
        {
          let imp = await Promise.resolve().then(() => (init_dist7(), dist_exports4)).then(async (m5) => {
            await m5.__tla;
            return m5;
          });
          Corbado2.set(imp.default);
          await get_store_value(Corbado2).load({
            projectId: PUBLIC_CORBADO_PROJECT_ID
          });
          if (get_store_value(Corbado2).isAuthenticated) {
            USER.set({
              email: get_store_value(Corbado2).user.email,
              name: get_store_value(Corbado2).user.name,
              session: true
            });
            setFaunaClient(get_store_value(Corbado2).shortSession).then((client) => {
              client.query(qe`createOrGetUser()`);
            });
          }
          return get_store_value(Corbado2);
        }
      };
      const setFaunaClient = async (jwt) => {
        const client = new he({
          secret: jwt
        });
        FAUNA.set(client);
        faunaReady.set(true);
        return client;
      };
    })();
  }
});

// node_modules/@corbado/webcomponent/pkg/package.js
var require_package = __commonJS({
  "node_modules/@corbado/webcomponent/pkg/package.js"(exports, module2) {
    !function(e5, t8) {
      "object" == typeof exports && "object" == typeof module2 ? module2.exports = t8() : "function" == typeof define && define.amd ? define([], t8) : "object" == typeof exports ? exports.webcomponent = t8() : e5.webcomponent = t8();
    }(exports, () => (() => {
      var e5 = { 230: (e6) => {
        e6.exports = "object" == typeof self ? self.FormData : window.FormData;
      }, 238: function(e6, t9, n8) {
        var i10;
        !function(r8, o7) {
          "use strict";
          var s9 = "function", a7 = "undefined", l7 = "object", c8 = "string", u6 = "major", d6 = "model", A5 = "name", g7 = "type", p5 = "vendor", M4 = "version", f5 = "architecture", m5 = "console", h6 = "mobile", y7 = "tablet", I4 = "smarttv", w6 = "wearable", N4 = "embedded", j4 = "Amazon", b5 = "Apple", D4 = "ASUS", x4 = "BlackBerry", L5 = "Browser", v5 = "Chrome", T2 = "Firefox", z3 = "Google", C5 = "Huawei", S5 = "LG", E6 = "Microsoft", k4 = "Motorola", O3 = "Opera", P4 = "Samsung", U4 = "Sharp", Q3 = "Sony", R3 = "Xiaomi", Y3 = "Zebra", Z4 = "Facebook", B3 = "Chromium OS", W4 = "Mac OS", G3 = function(e7) {
            for (var t10 = {}, n9 = 0; n9 < e7.length; n9++)
              t10[e7[n9].toUpperCase()] = e7[n9];
            return t10;
          }, H3 = function(e7, t10) {
            return typeof e7 === c8 && -1 !== _4(t10).indexOf(_4(e7));
          }, _4 = function(e7) {
            return e7.toLowerCase();
          }, V3 = function(e7, t10) {
            if (typeof e7 === c8)
              return e7 = e7.replace(/^\s\s*/, ""), typeof t10 === a7 ? e7 : e7.substring(0, 350);
          }, F4 = function(e7, t10) {
            for (var n9, i11, r9, a8, c9, u7, d7 = 0; d7 < t10.length && !c9; ) {
              var A6 = t10[d7], g8 = t10[d7 + 1];
              for (n9 = i11 = 0; n9 < A6.length && !c9 && A6[n9]; )
                if (c9 = A6[n9++].exec(e7))
                  for (r9 = 0; r9 < g8.length; r9++)
                    u7 = c9[++i11], typeof (a8 = g8[r9]) === l7 && a8.length > 0 ? 2 === a8.length ? typeof a8[1] == s9 ? this[a8[0]] = a8[1].call(this, u7) : this[a8[0]] = a8[1] : 3 === a8.length ? typeof a8[1] !== s9 || a8[1].exec && a8[1].test ? this[a8[0]] = u7 ? u7.replace(a8[1], a8[2]) : o7 : this[a8[0]] = u7 ? a8[1].call(this, u7, a8[2]) : o7 : 4 === a8.length && (this[a8[0]] = u7 ? a8[3].call(this, u7.replace(a8[1], a8[2])) : o7) : this[a8] = u7 || o7;
              d7 += 2;
            }
          }, J3 = function(e7, t10) {
            for (var n9 in t10)
              if (typeof t10[n9] === l7 && t10[n9].length > 0) {
                for (var i11 = 0; i11 < t10[n9].length; i11++)
                  if (H3(t10[n9][i11], e7))
                    return "?" === n9 ? o7 : n9;
              } else if (H3(t10[n9], e7))
                return "?" === n9 ? o7 : n9;
            return e7;
          }, X4 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, K3 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [M4, [A5, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [M4, [A5, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [A5, M4], [/opios[\/ ]+([\w\.]+)/i], [M4, [A5, O3 + " Mini"]], [/\bopr\/([\w\.]+)/i], [M4, [A5, O3]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [A5, M4], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [M4, [A5, "UC" + L5]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [M4, [A5, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [M4, [A5, "WeChat"]], [/konqueror\/([\w\.]+)/i], [M4, [A5, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [M4, [A5, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [M4, [A5, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[A5, /(.+)/, "$1 Secure " + L5], M4], [/\bfocus\/([\w\.]+)/i], [M4, [A5, T2 + " Focus"]], [/\bopt\/([\w\.]+)/i], [M4, [A5, O3 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [M4, [A5, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [M4, [A5, "Dolphin"]], [/coast\/([\w\.]+)/i], [M4, [A5, O3 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [M4, [A5, "MIUI " + L5]], [/fxios\/([-\w\.]+)/i], [M4, [A5, T2]], [/\bqihu|(qi?ho?o?|360)browser/i], [[A5, "360 " + L5]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[A5, /(.+)/, "$1 " + L5], M4], [/(comodo_dragon)\/([\w\.]+)/i], [[A5, /_/g, " "], M4], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [A5, M4], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [A5], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[A5, Z4], M4], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [A5, M4], [/\bgsa\/([\w\.]+) .*safari\//i], [M4, [A5, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [M4, [A5, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [M4, [A5, v5 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[A5, v5 + " WebView"], M4], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [M4, [A5, "Android " + L5]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [A5, M4], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [M4, [A5, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [M4, A5], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [A5, [M4, J3, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [A5, M4], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[A5, "Netscape"], M4], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [M4, [A5, T2 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [A5, M4], [/(cobalt)\/([\w\.]+)/i], [A5, [M4, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[f5, "amd64"]], [/(ia32(?=;))/i], [[f5, _4]], [/((?:i[346]|x)86)[;\)]/i], [[f5, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[f5, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[f5, "armhf"]], [/windows (ce|mobile); ppc;/i], [[f5, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[f5, /ower/, "", _4]], [/(sun4\w)[;\)]/i], [[f5, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[f5, _4]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d6, [p5, P4], [g7, y7]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [d6, [p5, P4], [g7, h6]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [d6, [p5, b5], [g7, h6]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d6, [p5, b5], [g7, y7]], [/(macintosh);/i], [d6, [p5, b5]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d6, [p5, U4], [g7, h6]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d6, [p5, C5], [g7, y7]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d6, [p5, C5], [g7, h6]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[d6, /_/g, " "], [p5, R3], [g7, h6]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d6, /_/g, " "], [p5, R3], [g7, y7]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d6, [p5, "OPPO"], [g7, h6]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d6, [p5, "Vivo"], [g7, h6]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [d6, [p5, "Realme"], [g7, h6]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d6, [p5, k4], [g7, h6]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d6, [p5, k4], [g7, y7]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d6, [p5, S5], [g7, y7]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d6, [p5, S5], [g7, h6]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d6, [p5, "Lenovo"], [g7, y7]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d6, /_/g, " "], [p5, "Nokia"], [g7, h6]], [/(pixel c)\b/i], [d6, [p5, z3], [g7, y7]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d6, [p5, z3], [g7, h6]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d6, [p5, Q3], [g7, h6]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d6, "Xperia Tablet"], [p5, Q3], [g7, y7]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d6, [p5, "OnePlus"], [g7, h6]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d6, [p5, j4], [g7, y7]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d6, /(.+)/g, "Fire Phone $1"], [p5, j4], [g7, h6]], [/(playbook);[-\w\),; ]+(rim)/i], [d6, p5, [g7, y7]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d6, [p5, x4], [g7, h6]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d6, [p5, D4], [g7, y7]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d6, [p5, D4], [g7, h6]], [/(nexus 9)/i], [d6, [p5, "HTC"], [g7, y7]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [p5, [d6, /_/g, " "], [g7, h6]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d6, [p5, "Acer"], [g7, y7]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d6, [p5, "Meizu"], [g7, h6]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [p5, d6, [g7, h6]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [p5, d6, [g7, y7]], [/(surface duo)/i], [d6, [p5, E6], [g7, y7]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d6, [p5, "Fairphone"], [g7, h6]], [/(u304aa)/i], [d6, [p5, "AT&T"], [g7, h6]], [/\bsie-(\w*)/i], [d6, [p5, "Siemens"], [g7, h6]], [/\b(rct\w+) b/i], [d6, [p5, "RCA"], [g7, y7]], [/\b(venue[\d ]{2,7}) b/i], [d6, [p5, "Dell"], [g7, y7]], [/\b(q(?:mv|ta)\w+) b/i], [d6, [p5, "Verizon"], [g7, y7]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d6, [p5, "Barnes & Noble"], [g7, y7]], [/\b(tm\d{3}\w+) b/i], [d6, [p5, "NuVision"], [g7, y7]], [/\b(k88) b/i], [d6, [p5, "ZTE"], [g7, y7]], [/\b(nx\d{3}j) b/i], [d6, [p5, "ZTE"], [g7, h6]], [/\b(gen\d{3}) b.+49h/i], [d6, [p5, "Swiss"], [g7, h6]], [/\b(zur\d{3}) b/i], [d6, [p5, "Swiss"], [g7, y7]], [/\b((zeki)?tb.*\b) b/i], [d6, [p5, "Zeki"], [g7, y7]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[p5, "Dragon Touch"], d6, [g7, y7]], [/\b(ns-?\w{0,9}) b/i], [d6, [p5, "Insignia"], [g7, y7]], [/\b((nxa|next)-?\w{0,9}) b/i], [d6, [p5, "NextBook"], [g7, y7]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[p5, "Voice"], d6, [g7, h6]], [/\b(lvtel\-)?(v1[12]) b/i], [[p5, "LvTel"], d6, [g7, h6]], [/\b(ph-1) /i], [d6, [p5, "Essential"], [g7, h6]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d6, [p5, "Envizen"], [g7, y7]], [/\b(trio[-\w\. ]+) b/i], [d6, [p5, "MachSpeed"], [g7, y7]], [/\btu_(1491) b/i], [d6, [p5, "Rotor"], [g7, y7]], [/(shield[\w ]+) b/i], [d6, [p5, "Nvidia"], [g7, y7]], [/(sprint) (\w+)/i], [p5, d6, [g7, h6]], [/(kin\.[onetw]{3})/i], [[d6, /\./g, " "], [p5, E6], [g7, h6]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d6, [p5, Y3], [g7, y7]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d6, [p5, Y3], [g7, h6]], [/smart-tv.+(samsung)/i], [p5, [g7, I4]], [/hbbtv.+maple;(\d+)/i], [[d6, /^/, "SmartTV"], [p5, P4], [g7, I4]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[p5, S5], [g7, I4]], [/(apple) ?tv/i], [p5, [d6, b5 + " TV"], [g7, I4]], [/crkey/i], [[d6, v5 + "cast"], [p5, z3], [g7, I4]], [/droid.+aft(\w)( bui|\))/i], [d6, [p5, j4], [g7, I4]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d6, [p5, U4], [g7, I4]], [/(bravia[\w ]+)( bui|\))/i], [d6, [p5, Q3], [g7, I4]], [/(mitv-\w{5}) bui/i], [d6, [p5, R3], [g7, I4]], [/Hbbtv.*(technisat) (.*);/i], [p5, d6, [g7, I4]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[p5, V3], [d6, V3], [g7, I4]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[g7, I4]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [p5, d6, [g7, m5]], [/droid.+; (shield) bui/i], [d6, [p5, "Nvidia"], [g7, m5]], [/(playstation [345portablevi]+)/i], [d6, [p5, Q3], [g7, m5]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d6, [p5, E6], [g7, m5]], [/((pebble))app/i], [p5, d6, [g7, w6]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d6, [p5, b5], [g7, w6]], [/droid.+; (glass) \d/i], [d6, [p5, z3], [g7, w6]], [/droid.+; (wt63?0{2,3})\)/i], [d6, [p5, Y3], [g7, w6]], [/(quest( 2| pro)?)/i], [d6, [p5, Z4], [g7, w6]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [p5, [g7, N4]], [/(aeobc)\b/i], [d6, [p5, j4], [g7, N4]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [d6, [g7, h6]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d6, [g7, y7]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[g7, y7]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[g7, h6]], [/(android[-\w\. ]{0,9});.+buil/i], [d6, [p5, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [M4, [A5, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [M4, [A5, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [A5, M4], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [M4, A5]], os: [[/microsoft (windows) (vista|xp)/i], [A5, M4], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [A5, [M4, J3, X4]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[A5, "Windows"], [M4, J3, X4]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /ios;fbsv\/([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[M4, /_/g, "."], [A5, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[A5, W4], [M4, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [M4, A5], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [A5, M4], [/\(bb(10);/i], [M4, [A5, x4]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [M4, [A5, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [M4, [A5, T2 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [M4, [A5, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [M4, [A5, "watchOS"]], [/crkey\/([\d\.]+)/i], [M4, [A5, v5 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[A5, B3], M4], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [A5, M4], [/(sunos) ?([\w\.\d]*)/i], [[A5, "Solaris"], M4], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [A5, M4]] }, q4 = function(e7, t10) {
            if (typeof e7 === l7 && (t10 = e7, e7 = o7), !(this instanceof q4))
              return new q4(e7, t10).getResult();
            var n9 = typeof r8 !== a7 && r8.navigator ? r8.navigator : o7, i11 = e7 || (n9 && n9.userAgent ? n9.userAgent : ""), m6 = n9 && n9.userAgentData ? n9.userAgentData : o7, I5 = t10 ? function(e8, t11) {
              var n10 = {};
              for (var i12 in e8)
                t11[i12] && t11[i12].length % 2 == 0 ? n10[i12] = t11[i12].concat(e8[i12]) : n10[i12] = e8[i12];
              return n10;
            }(K3, t10) : K3, w7 = n9 && n9.userAgent == i11;
            return this.getBrowser = function() {
              var e8, t11 = {};
              return t11[A5] = o7, t11[M4] = o7, F4.call(t11, i11, I5.browser), t11[u6] = typeof (e8 = t11[M4]) === c8 ? e8.replace(/[^\d\.]/g, "").split(".")[0] : o7, w7 && n9 && n9.brave && typeof n9.brave.isBrave == s9 && (t11[A5] = "Brave"), t11;
            }, this.getCPU = function() {
              var e8 = {};
              return e8[f5] = o7, F4.call(e8, i11, I5.cpu), e8;
            }, this.getDevice = function() {
              var e8 = {};
              return e8[p5] = o7, e8[d6] = o7, e8[g7] = o7, F4.call(e8, i11, I5.device), w7 && !e8[g7] && m6 && m6.mobile && (e8[g7] = h6), w7 && "Macintosh" == e8[d6] && n9 && typeof n9.standalone !== a7 && n9.maxTouchPoints && n9.maxTouchPoints > 2 && (e8[d6] = "iPad", e8[g7] = y7), e8;
            }, this.getEngine = function() {
              var e8 = {};
              return e8[A5] = o7, e8[M4] = o7, F4.call(e8, i11, I5.engine), e8;
            }, this.getOS = function() {
              var e8 = {};
              return e8[A5] = o7, e8[M4] = o7, F4.call(e8, i11, I5.os), w7 && !e8[A5] && m6 && "Unknown" != m6.platform && (e8[A5] = m6.platform.replace(/chrome os/i, B3).replace(/macos/i, W4)), e8;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return i11;
            }, this.setUA = function(e8) {
              return i11 = typeof e8 === c8 && e8.length > 350 ? V3(e8, 350) : e8, this;
            }, this.setUA(i11), this;
          };
          q4.VERSION = "1.0.35", q4.BROWSER = G3([A5, M4, u6]), q4.CPU = G3([f5]), q4.DEVICE = G3([d6, p5, g7, m5, h6, I4, y7, w6, N4]), q4.ENGINE = q4.OS = G3([A5, M4]), typeof t9 !== a7 ? (e6.exports && (t9 = e6.exports = q4), t9.UAParser = q4) : n8.amdO ? (i10 = function() {
            return q4;
          }.call(t9, n8, t9, e6)) === o7 || (e6.exports = i10) : typeof r8 !== a7 && (r8.UAParser = q4);
          var $3 = typeof r8 !== a7 && (r8.jQuery || r8.Zepto);
          if ($3 && !$3.ua) {
            var ee3 = new q4();
            $3.ua = ee3.getResult(), $3.ua.get = function() {
              return ee3.getUA();
            }, $3.ua.set = function(e7) {
              ee3.setUA(e7);
              var t10 = ee3.getResult();
              for (var n9 in t10)
                $3.ua[n9] = t10[n9];
            };
          }
        }("object" == typeof window ? window : this);
      }, 744: (e6, t9) => {
        "use strict";
        t9.Z = (e7, t10) => {
          const n8 = e7.__vccOpts || e7;
          for (const [e8, i10] of t10)
            n8[e8] = i10;
          return n8;
        };
      } }, t8 = {};
      function n7(i10) {
        var r8 = t8[i10];
        if (void 0 !== r8)
          return r8.exports;
        var o7 = t8[i10] = { exports: {} };
        return e5[i10].call(o7.exports, o7, o7.exports, n7), o7.exports;
      }
      n7.amdO = {}, n7.d = (e6, t9) => {
        for (var i10 in t9)
          n7.o(t9, i10) && !n7.o(e6, i10) && Object.defineProperty(e6, i10, { enumerable: true, get: t9[i10] });
      }, n7.g = function() {
        if ("object" == typeof globalThis)
          return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e6) {
          if ("object" == typeof window)
            return window;
        }
      }(), n7.o = (e6, t9) => Object.prototype.hasOwnProperty.call(e6, t9), n7.r = (e6) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e6, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e6, "__esModule", { value: true });
      };
      var i9 = {};
      return (() => {
        "use strict";
        function e6(e7, t10) {
          const n8 = /* @__PURE__ */ Object.create(null), i10 = e7.split(",");
          for (let e8 = 0; e8 < i10.length; e8++)
            n8[i10[e8]] = true;
          return t10 ? (e8) => !!n8[e8.toLowerCase()] : (e8) => !!n8[e8];
        }
        n7.r(i9), n7.d(i9, { default: () => Tg });
        const t9 = e6("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
        function r8(e7) {
          return !!e7 || "" === e7;
        }
        function o7(e7) {
          if (D4(e7)) {
            const t10 = {};
            for (let n8 = 0; n8 < e7.length; n8++) {
              const i10 = e7[n8], r9 = z3(i10) ? l7(i10) : o7(i10);
              if (r9)
                for (const e8 in r9)
                  t10[e8] = r9[e8];
            }
            return t10;
          }
          return z3(e7) || S5(e7) ? e7 : void 0;
        }
        const s9 = /;(?![^(]*\))/g, a7 = /:(.+)/;
        function l7(e7) {
          const t10 = {};
          return e7.split(s9).forEach((e8) => {
            if (e8) {
              const n8 = e8.split(a7);
              n8.length > 1 && (t10[n8[0].trim()] = n8[1].trim());
            }
          }), t10;
        }
        function c8(e7) {
          let t10 = "";
          if (z3(e7))
            t10 = e7;
          else if (D4(e7))
            for (let n8 = 0; n8 < e7.length; n8++) {
              const i10 = c8(e7[n8]);
              i10 && (t10 += i10 + " ");
            }
          else if (S5(e7))
            for (const n8 in e7)
              e7[n8] && (t10 += n8 + " ");
          return t10.trim();
        }
        function u6(e7, t10) {
          if (e7 === t10)
            return true;
          let n8 = v5(e7), i10 = v5(t10);
          if (n8 || i10)
            return !(!n8 || !i10) && e7.getTime() === t10.getTime();
          if (n8 = C5(e7), i10 = C5(t10), n8 || i10)
            return e7 === t10;
          if (n8 = D4(e7), i10 = D4(t10), n8 || i10)
            return !(!n8 || !i10) && function(e8, t11) {
              if (e8.length !== t11.length)
                return false;
              let n9 = true;
              for (let i11 = 0; n9 && i11 < e8.length; i11++)
                n9 = u6(e8[i11], t11[i11]);
              return n9;
            }(e7, t10);
          if (n8 = S5(e7), i10 = S5(t10), n8 || i10) {
            if (!n8 || !i10)
              return false;
            if (Object.keys(e7).length !== Object.keys(t10).length)
              return false;
            for (const n9 in e7) {
              const i11 = e7.hasOwnProperty(n9), r9 = t10.hasOwnProperty(n9);
              if (i11 && !r9 || !i11 && r9 || !u6(e7[n9], t10[n9]))
                return false;
            }
          }
          return String(e7) === String(t10);
        }
        function d6(e7, t10) {
          return e7.findIndex((e8) => u6(e8, t10));
        }
        const A5 = (e7) => z3(e7) ? e7 : null == e7 ? "" : D4(e7) || S5(e7) && (e7.toString === k4 || !T2(e7.toString)) ? JSON.stringify(e7, g7, 2) : String(e7), g7 = (e7, t10) => t10 && t10.__v_isRef ? g7(e7, t10.value) : x4(t10) ? { [`Map(${t10.size})`]: [...t10.entries()].reduce((e8, [t11, n8]) => (e8[`${t11} =>`] = n8, e8), {}) } : L5(t10) ? { [`Set(${t10.size})`]: [...t10.values()] } : !S5(t10) || D4(t10) || U4(t10) ? t10 : String(t10), p5 = {}, M4 = [], f5 = () => {
        }, m5 = () => false, h6 = /^on[^a-z]/, y7 = (e7) => h6.test(e7), I4 = (e7) => e7.startsWith("onUpdate:"), w6 = Object.assign, N4 = (e7, t10) => {
          const n8 = e7.indexOf(t10);
          n8 > -1 && e7.splice(n8, 1);
        }, j4 = Object.prototype.hasOwnProperty, b5 = (e7, t10) => j4.call(e7, t10), D4 = Array.isArray, x4 = (e7) => "[object Map]" === O3(e7), L5 = (e7) => "[object Set]" === O3(e7), v5 = (e7) => "[object Date]" === O3(e7), T2 = (e7) => "function" == typeof e7, z3 = (e7) => "string" == typeof e7, C5 = (e7) => "symbol" == typeof e7, S5 = (e7) => null !== e7 && "object" == typeof e7, E6 = (e7) => S5(e7) && T2(e7.then) && T2(e7.catch), k4 = Object.prototype.toString, O3 = (e7) => k4.call(e7), P4 = (e7) => O3(e7).slice(8, -1), U4 = (e7) => "[object Object]" === O3(e7), Q3 = (e7) => z3(e7) && "NaN" !== e7 && "-" !== e7[0] && "" + parseInt(e7, 10) === e7, R3 = e6(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Y3 = (e7) => {
          const t10 = /* @__PURE__ */ Object.create(null);
          return (n8) => t10[n8] || (t10[n8] = e7(n8));
        }, Z4 = /-(\w)/g, B3 = Y3((e7) => e7.replace(Z4, (e8, t10) => t10 ? t10.toUpperCase() : "")), W4 = /\B([A-Z])/g, G3 = Y3((e7) => e7.replace(W4, "-$1").toLowerCase()), H3 = Y3((e7) => e7.charAt(0).toUpperCase() + e7.slice(1)), _4 = Y3((e7) => e7 ? `on${H3(e7)}` : ""), V3 = (e7, t10) => !Object.is(e7, t10), F4 = (e7, t10) => {
          for (let n8 = 0; n8 < e7.length; n8++)
            e7[n8](t10);
        }, J3 = (e7, t10, n8) => {
          Object.defineProperty(e7, t10, { configurable: true, enumerable: false, value: n8 });
        }, X4 = (e7) => {
          const t10 = parseFloat(e7);
          return isNaN(t10) ? e7 : t10;
        };
        let K3;
        const q4 = () => K3 || (K3 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n7.g ? n7.g : {});
        let $3;
        class ee3 {
          constructor(e7 = false) {
            this.detached = e7, this.active = true, this.effects = [], this.cleanups = [], this.parent = $3, !e7 && $3 && (this.index = ($3.scopes || ($3.scopes = [])).push(this) - 1);
          }
          run(e7) {
            if (this.active) {
              const t10 = $3;
              try {
                return $3 = this, e7();
              } finally {
                $3 = t10;
              }
            }
          }
          on() {
            $3 = this;
          }
          off() {
            $3 = this.parent;
          }
          stop(e7) {
            if (this.active) {
              let t10, n8;
              for (t10 = 0, n8 = this.effects.length; t10 < n8; t10++)
                this.effects[t10].stop();
              for (t10 = 0, n8 = this.cleanups.length; t10 < n8; t10++)
                this.cleanups[t10]();
              if (this.scopes)
                for (t10 = 0, n8 = this.scopes.length; t10 < n8; t10++)
                  this.scopes[t10].stop(true);
              if (!this.detached && this.parent && !e7) {
                const e8 = this.parent.scopes.pop();
                e8 && e8 !== this && (this.parent.scopes[this.index] = e8, e8.index = this.index);
              }
              this.parent = void 0, this.active = false;
            }
          }
        }
        const te3 = (e7) => {
          const t10 = new Set(e7);
          return t10.w = 0, t10.n = 0, t10;
        }, ne3 = (e7) => (e7.w & se4) > 0, ie4 = (e7) => (e7.n & se4) > 0, re3 = /* @__PURE__ */ new WeakMap();
        let oe3 = 0, se4 = 1;
        const ae3 = 30;
        let le3;
        const ce3 = Symbol(""), ue3 = Symbol("");
        class de3 {
          constructor(e7, t10 = null, n8) {
            this.fn = e7, this.scheduler = t10, this.active = true, this.deps = [], this.parent = void 0, function(e8, t11 = $3) {
              t11 && t11.active && t11.effects.push(e8);
            }(this, n8);
          }
          run() {
            if (!this.active)
              return this.fn();
            let e7 = le3, t10 = ge3;
            for (; e7; ) {
              if (e7 === this)
                return;
              e7 = e7.parent;
            }
            try {
              return this.parent = le3, le3 = this, ge3 = true, se4 = 1 << ++oe3, oe3 <= ae3 ? (({ deps: e8 }) => {
                if (e8.length)
                  for (let t11 = 0; t11 < e8.length; t11++)
                    e8[t11].w |= se4;
              })(this) : Ae3(this), this.fn();
            } finally {
              oe3 <= ae3 && ((e8) => {
                const { deps: t11 } = e8;
                if (t11.length) {
                  let n8 = 0;
                  for (let i10 = 0; i10 < t11.length; i10++) {
                    const r9 = t11[i10];
                    ne3(r9) && !ie4(r9) ? r9.delete(e8) : t11[n8++] = r9, r9.w &= ~se4, r9.n &= ~se4;
                  }
                  t11.length = n8;
                }
              })(this), se4 = 1 << --oe3, le3 = this.parent, ge3 = t10, this.parent = void 0, this.deferStop && this.stop();
            }
          }
          stop() {
            le3 === this ? this.deferStop = true : this.active && (Ae3(this), this.onStop && this.onStop(), this.active = false);
          }
        }
        function Ae3(e7) {
          const { deps: t10 } = e7;
          if (t10.length) {
            for (let n8 = 0; n8 < t10.length; n8++)
              t10[n8].delete(e7);
            t10.length = 0;
          }
        }
        let ge3 = true;
        const pe3 = [];
        function Me3() {
          pe3.push(ge3), ge3 = false;
        }
        function fe3() {
          const e7 = pe3.pop();
          ge3 = void 0 === e7 || e7;
        }
        function me3(e7, t10, n8) {
          if (ge3 && le3) {
            let t11 = re3.get(e7);
            t11 || re3.set(e7, t11 = /* @__PURE__ */ new Map());
            let i10 = t11.get(n8);
            i10 || t11.set(n8, i10 = te3()), he3(i10);
          }
        }
        function he3(e7, t10) {
          let n8 = false;
          oe3 <= ae3 ? ie4(e7) || (e7.n |= se4, n8 = !ne3(e7)) : n8 = !e7.has(le3), n8 && (e7.add(le3), le3.deps.push(e7));
        }
        function ye3(e7, t10, n8, i10, r9, o8) {
          const s10 = re3.get(e7);
          if (!s10)
            return;
          let a8 = [];
          if ("clear" === t10)
            a8 = [...s10.values()];
          else if ("length" === n8 && D4(e7))
            s10.forEach((e8, t11) => {
              ("length" === t11 || t11 >= i10) && a8.push(e8);
            });
          else
            switch (void 0 !== n8 && a8.push(s10.get(n8)), t10) {
              case "add":
                D4(e7) ? Q3(n8) && a8.push(s10.get("length")) : (a8.push(s10.get(ce3)), x4(e7) && a8.push(s10.get(ue3)));
                break;
              case "delete":
                D4(e7) || (a8.push(s10.get(ce3)), x4(e7) && a8.push(s10.get(ue3)));
                break;
              case "set":
                x4(e7) && a8.push(s10.get(ce3));
            }
          if (1 === a8.length)
            a8[0] && Ie3(a8[0]);
          else {
            const e8 = [];
            for (const t11 of a8)
              t11 && e8.push(...t11);
            Ie3(te3(e8));
          }
        }
        function Ie3(e7, t10) {
          const n8 = D4(e7) ? e7 : [...e7];
          for (const e8 of n8)
            e8.computed && we3(e8);
          for (const e8 of n8)
            e8.computed || we3(e8);
        }
        function we3(e7, t10) {
          (e7 !== le3 || e7.allowRecurse) && (e7.scheduler ? e7.scheduler() : e7.run());
        }
        const Ne3 = e6("__proto__,__v_isRef,__isVue"), je3 = new Set(Object.getOwnPropertyNames(Symbol).filter((e7) => "arguments" !== e7 && "caller" !== e7).map((e7) => Symbol[e7]).filter(C5)), be3 = Te3(), De3 = Te3(false, true), xe3 = Te3(true), Le3 = ve3();
        function ve3() {
          const e7 = {};
          return ["includes", "indexOf", "lastIndexOf"].forEach((t10) => {
            e7[t10] = function(...e8) {
              const n8 = At(this);
              for (let e9 = 0, t11 = this.length; e9 < t11; e9++)
                me3(n8, 0, e9 + "");
              const i10 = n8[t10](...e8);
              return -1 === i10 || false === i10 ? n8[t10](...e8.map(At)) : i10;
            };
          }), ["push", "pop", "shift", "unshift", "splice"].forEach((t10) => {
            e7[t10] = function(...e8) {
              Me3();
              const n8 = At(this)[t10].apply(this, e8);
              return fe3(), n8;
            };
          }), e7;
        }
        function Te3(e7 = false, t10 = false) {
          return function(n8, i10, r9) {
            if ("__v_isReactive" === i10)
              return !e7;
            if ("__v_isReadonly" === i10)
              return e7;
            if ("__v_isShallow" === i10)
              return t10;
            if ("__v_raw" === i10 && r9 === (e7 ? t10 ? rt2 : it2 : t10 ? nt2 : tt2).get(n8))
              return n8;
            const o8 = D4(n8);
            if (!e7 && o8 && b5(Le3, i10))
              return Reflect.get(Le3, i10, r9);
            const s10 = Reflect.get(n8, i10, r9);
            return (C5(i10) ? je3.has(i10) : Ne3(i10)) ? s10 : (e7 || me3(n8, 0, i10), t10 ? s10 : ht2(s10) ? o8 && Q3(i10) ? s10 : s10.value : S5(s10) ? e7 ? st2(s10) : ot2(s10) : s10);
          };
        }
        function ze3(e7 = false) {
          return function(t10, n8, i10, r9) {
            let o8 = t10[n8];
            if (ct2(o8) && ht2(o8) && !ht2(i10))
              return false;
            if (!e7 && (ut2(i10) || ct2(i10) || (o8 = At(o8), i10 = At(i10)), !D4(t10) && ht2(o8) && !ht2(i10)))
              return o8.value = i10, true;
            const s10 = D4(t10) && Q3(n8) ? Number(n8) < t10.length : b5(t10, n8), a8 = Reflect.set(t10, n8, i10, r9);
            return t10 === At(r9) && (s10 ? V3(i10, o8) && ye3(t10, "set", n8, i10) : ye3(t10, "add", n8, i10)), a8;
          };
        }
        const Ce3 = { get: be3, set: ze3(), deleteProperty: function(e7, t10) {
          const n8 = b5(e7, t10), i10 = (e7[t10], Reflect.deleteProperty(e7, t10));
          return i10 && n8 && ye3(e7, "delete", t10, void 0), i10;
        }, has: function(e7, t10) {
          const n8 = Reflect.has(e7, t10);
          return C5(t10) && je3.has(t10) || me3(e7, 0, t10), n8;
        }, ownKeys: function(e7) {
          return me3(e7, 0, D4(e7) ? "length" : ce3), Reflect.ownKeys(e7);
        } }, Se3 = { get: xe3, set: (e7, t10) => true, deleteProperty: (e7, t10) => true }, Ee3 = w6({}, Ce3, { get: De3, set: ze3(true) }), ke3 = (e7) => e7, Oe2 = (e7) => Reflect.getPrototypeOf(e7);
        function Pe2(e7, t10, n8 = false, i10 = false) {
          const r9 = At(e7 = e7.__v_raw), o8 = At(t10);
          n8 || (t10 !== o8 && me3(r9, 0, t10), me3(r9, 0, o8));
          const { has: s10 } = Oe2(r9), a8 = i10 ? ke3 : n8 ? Mt : pt3;
          return s10.call(r9, t10) ? a8(e7.get(t10)) : s10.call(r9, o8) ? a8(e7.get(o8)) : void (e7 !== r9 && e7.get(t10));
        }
        function Ue3(e7, t10 = false) {
          const n8 = this.__v_raw, i10 = At(n8), r9 = At(e7);
          return t10 || (e7 !== r9 && me3(i10, 0, e7), me3(i10, 0, r9)), e7 === r9 ? n8.has(e7) : n8.has(e7) || n8.has(r9);
        }
        function Qe3(e7, t10 = false) {
          return e7 = e7.__v_raw, !t10 && me3(At(e7), 0, ce3), Reflect.get(e7, "size", e7);
        }
        function Re(e7) {
          e7 = At(e7);
          const t10 = At(this);
          return Oe2(t10).has.call(t10, e7) || (t10.add(e7), ye3(t10, "add", e7, e7)), this;
        }
        function Ye3(e7, t10) {
          t10 = At(t10);
          const n8 = At(this), { has: i10, get: r9 } = Oe2(n8);
          let o8 = i10.call(n8, e7);
          o8 || (e7 = At(e7), o8 = i10.call(n8, e7));
          const s10 = r9.call(n8, e7);
          return n8.set(e7, t10), o8 ? V3(t10, s10) && ye3(n8, "set", e7, t10) : ye3(n8, "add", e7, t10), this;
        }
        function Ze2(e7) {
          const t10 = At(this), { has: n8, get: i10 } = Oe2(t10);
          let r9 = n8.call(t10, e7);
          r9 || (e7 = At(e7), r9 = n8.call(t10, e7)), i10 && i10.call(t10, e7);
          const o8 = t10.delete(e7);
          return r9 && ye3(t10, "delete", e7, void 0), o8;
        }
        function Be3() {
          const e7 = At(this), t10 = 0 !== e7.size, n8 = e7.clear();
          return t10 && ye3(e7, "clear", void 0, void 0), n8;
        }
        function We2(e7, t10) {
          return function(n8, i10) {
            const r9 = this, o8 = r9.__v_raw, s10 = At(o8), a8 = t10 ? ke3 : e7 ? Mt : pt3;
            return !e7 && me3(s10, 0, ce3), o8.forEach((e8, t11) => n8.call(i10, a8(e8), a8(t11), r9));
          };
        }
        function Ge2(e7, t10, n8) {
          return function(...i10) {
            const r9 = this.__v_raw, o8 = At(r9), s10 = x4(o8), a8 = "entries" === e7 || e7 === Symbol.iterator && s10, l8 = "keys" === e7 && s10, c9 = r9[e7](...i10), u7 = n8 ? ke3 : t10 ? Mt : pt3;
            return !t10 && me3(o8, 0, l8 ? ue3 : ce3), { next() {
              const { value: e8, done: t11 } = c9.next();
              return t11 ? { value: e8, done: t11 } : { value: a8 ? [u7(e8[0]), u7(e8[1])] : u7(e8), done: t11 };
            }, [Symbol.iterator]() {
              return this;
            } };
          };
        }
        function He2(e7) {
          return function(...t10) {
            return "delete" !== e7 && this;
          };
        }
        function _e2() {
          const e7 = { get(e8) {
            return Pe2(this, e8);
          }, get size() {
            return Qe3(this);
          }, has: Ue3, add: Re, set: Ye3, delete: Ze2, clear: Be3, forEach: We2(false, false) }, t10 = { get(e8) {
            return Pe2(this, e8, false, true);
          }, get size() {
            return Qe3(this);
          }, has: Ue3, add: Re, set: Ye3, delete: Ze2, clear: Be3, forEach: We2(false, true) }, n8 = { get(e8) {
            return Pe2(this, e8, true);
          }, get size() {
            return Qe3(this, true);
          }, has(e8) {
            return Ue3.call(this, e8, true);
          }, add: He2("add"), set: He2("set"), delete: He2("delete"), clear: He2("clear"), forEach: We2(true, false) }, i10 = { get(e8) {
            return Pe2(this, e8, true, true);
          }, get size() {
            return Qe3(this, true);
          }, has(e8) {
            return Ue3.call(this, e8, true);
          }, add: He2("add"), set: He2("set"), delete: He2("delete"), clear: He2("clear"), forEach: We2(true, true) };
          return ["keys", "values", "entries", Symbol.iterator].forEach((r9) => {
            e7[r9] = Ge2(r9, false, false), n8[r9] = Ge2(r9, true, false), t10[r9] = Ge2(r9, false, true), i10[r9] = Ge2(r9, true, true);
          }), [e7, n8, t10, i10];
        }
        const [Ve2, Fe2, Je2, Xe2] = _e2();
        function Ke2(e7, t10) {
          const n8 = t10 ? e7 ? Xe2 : Je2 : e7 ? Fe2 : Ve2;
          return (t11, i10, r9) => "__v_isReactive" === i10 ? !e7 : "__v_isReadonly" === i10 ? e7 : "__v_raw" === i10 ? t11 : Reflect.get(b5(n8, i10) && i10 in t11 ? n8 : t11, i10, r9);
        }
        const qe2 = { get: Ke2(false, false) }, $e2 = { get: Ke2(false, true) }, et2 = { get: Ke2(true, false) }, tt2 = /* @__PURE__ */ new WeakMap(), nt2 = /* @__PURE__ */ new WeakMap(), it2 = /* @__PURE__ */ new WeakMap(), rt2 = /* @__PURE__ */ new WeakMap();
        function ot2(e7) {
          return ct2(e7) ? e7 : at2(e7, false, Ce3, qe2, tt2);
        }
        function st2(e7) {
          return at2(e7, true, Se3, et2, it2);
        }
        function at2(e7, t10, n8, i10, r9) {
          if (!S5(e7))
            return e7;
          if (e7.__v_raw && (!t10 || !e7.__v_isReactive))
            return e7;
          const o8 = r9.get(e7);
          if (o8)
            return o8;
          const s10 = (a8 = e7).__v_skip || !Object.isExtensible(a8) ? 0 : function(e8) {
            switch (e8) {
              case "Object":
              case "Array":
                return 1;
              case "Map":
              case "Set":
              case "WeakMap":
              case "WeakSet":
                return 2;
              default:
                return 0;
            }
          }(P4(a8));
          var a8;
          if (0 === s10)
            return e7;
          const l8 = new Proxy(e7, 2 === s10 ? i10 : n8);
          return r9.set(e7, l8), l8;
        }
        function lt(e7) {
          return ct2(e7) ? lt(e7.__v_raw) : !(!e7 || !e7.__v_isReactive);
        }
        function ct2(e7) {
          return !(!e7 || !e7.__v_isReadonly);
        }
        function ut2(e7) {
          return !(!e7 || !e7.__v_isShallow);
        }
        function dt2(e7) {
          return lt(e7) || ct2(e7);
        }
        function At(e7) {
          const t10 = e7 && e7.__v_raw;
          return t10 ? At(t10) : e7;
        }
        function gt2(e7) {
          return J3(e7, "__v_skip", true), e7;
        }
        const pt3 = (e7) => S5(e7) ? ot2(e7) : e7, Mt = (e7) => S5(e7) ? st2(e7) : e7;
        function ft2(e7) {
          ge3 && le3 && he3((e7 = At(e7)).dep || (e7.dep = te3()));
        }
        function mt2(e7, t10) {
          (e7 = At(e7)).dep && Ie3(e7.dep);
        }
        function ht2(e7) {
          return !(!e7 || true !== e7.__v_isRef);
        }
        function yt2(e7) {
          return n8 = false, ht2(t10 = e7) ? t10 : new It(t10, n8);
          var t10, n8;
        }
        class It {
          constructor(e7, t10) {
            this.__v_isShallow = t10, this.dep = void 0, this.__v_isRef = true, this._rawValue = t10 ? e7 : At(e7), this._value = t10 ? e7 : pt3(e7);
          }
          get value() {
            return ft2(this), this._value;
          }
          set value(e7) {
            const t10 = this.__v_isShallow || ut2(e7) || ct2(e7);
            e7 = t10 ? e7 : At(e7), V3(e7, this._rawValue) && (this._rawValue = e7, this._value = t10 ? e7 : pt3(e7), mt2(this));
          }
        }
        const wt2 = { get: (e7, t10, n8) => {
          return ht2(i10 = Reflect.get(e7, t10, n8)) ? i10.value : i10;
          var i10;
        }, set: (e7, t10, n8, i10) => {
          const r9 = e7[t10];
          return ht2(r9) && !ht2(n8) ? (r9.value = n8, true) : Reflect.set(e7, t10, n8, i10);
        } };
        function Nt(e7) {
          return lt(e7) ? e7 : new Proxy(e7, wt2);
        }
        var jt;
        class bt {
          constructor(e7, t10, n8, i10) {
            this._setter = t10, this.dep = void 0, this.__v_isRef = true, this[jt] = false, this._dirty = true, this.effect = new de3(e7, () => {
              this._dirty || (this._dirty = true, mt2(this));
            }), this.effect.computed = this, this.effect.active = this._cacheable = !i10, this.__v_isReadonly = n8;
          }
          get value() {
            const e7 = At(this);
            return ft2(e7), !e7._dirty && e7._cacheable || (e7._dirty = false, e7._value = e7.effect.run()), e7._value;
          }
          set value(e7) {
            this._setter(e7);
          }
        }
        function Dt(e7, t10, n8, i10) {
          let r9;
          try {
            r9 = i10 ? e7(...i10) : e7();
          } catch (e8) {
            Lt(e8, t10, n8);
          }
          return r9;
        }
        function xt2(e7, t10, n8, i10) {
          if (T2(e7)) {
            const r10 = Dt(e7, t10, n8, i10);
            return r10 && E6(r10) && r10.catch((e8) => {
              Lt(e8, t10, n8);
            }), r10;
          }
          const r9 = [];
          for (let o8 = 0; o8 < e7.length; o8++)
            r9.push(xt2(e7[o8], t10, n8, i10));
          return r9;
        }
        function Lt(e7, t10, n8, i10 = true) {
          if (t10 && t10.vnode, t10) {
            let i11 = t10.parent;
            const r9 = t10.proxy, o8 = n8;
            for (; i11; ) {
              const t11 = i11.ec;
              if (t11) {
                for (let n9 = 0; n9 < t11.length; n9++)
                  if (false === t11[n9](e7, r9, o8))
                    return;
              }
              i11 = i11.parent;
            }
            const s10 = t10.appContext.config.errorHandler;
            if (s10)
              return void Dt(s10, null, 10, [e7, r9, o8]);
          }
          !function(e8, t11, n9, i11 = true) {
            console.error(e8);
          }(e7, 0, 0, i10);
        }
        jt = "__v_isReadonly";
        let vt = false, Tt2 = false;
        const zt = [];
        let Ct = 0;
        const St2 = [];
        let Et2 = null, kt = 0;
        const Ot = Promise.resolve();
        let Pt = null;
        function Ut(e7) {
          const t10 = Pt || Ot;
          return e7 ? t10.then(this ? e7.bind(this) : e7) : t10;
        }
        function Qt(e7) {
          zt.length && zt.includes(e7, vt && e7.allowRecurse ? Ct + 1 : Ct) || (null == e7.id ? zt.push(e7) : zt.splice(function(e8) {
            let t10 = Ct + 1, n8 = zt.length;
            for (; t10 < n8; ) {
              const i10 = t10 + n8 >>> 1;
              Bt(zt[i10]) < e8 ? t10 = i10 + 1 : n8 = i10;
            }
            return t10;
          }(e7.id), 0, e7), Rt());
        }
        function Rt() {
          vt || Tt2 || (Tt2 = true, Pt = Ot.then(Gt));
        }
        function Yt(e7, t10 = vt ? Ct + 1 : 0) {
          for (; t10 < zt.length; t10++) {
            const e8 = zt[t10];
            e8 && e8.pre && (zt.splice(t10, 1), t10--, e8());
          }
        }
        function Zt(e7) {
          if (St2.length) {
            const e8 = [...new Set(St2)];
            if (St2.length = 0, Et2)
              return void Et2.push(...e8);
            for (Et2 = e8, Et2.sort((e9, t10) => Bt(e9) - Bt(t10)), kt = 0; kt < Et2.length; kt++)
              Et2[kt]();
            Et2 = null, kt = 0;
          }
        }
        const Bt = (e7) => null == e7.id ? 1 / 0 : e7.id, Wt = (e7, t10) => {
          const n8 = Bt(e7) - Bt(t10);
          if (0 === n8) {
            if (e7.pre && !t10.pre)
              return -1;
            if (t10.pre && !e7.pre)
              return 1;
          }
          return n8;
        };
        function Gt(e7) {
          Tt2 = false, vt = true, zt.sort(Wt);
          try {
            for (Ct = 0; Ct < zt.length; Ct++) {
              const e8 = zt[Ct];
              e8 && false !== e8.active && Dt(e8, null, 14);
            }
          } finally {
            Ct = 0, zt.length = 0, Zt(), vt = false, Pt = null, (zt.length || St2.length) && Gt(e7);
          }
        }
        /* @__PURE__ */ new Set(), /* @__PURE__ */ new Map();
        let Ht, _t2 = [], Vt = false;
        function Ft(e7, ...t10) {
          Ht ? Ht.emit(e7, ...t10) : Vt || _t2.push({ event: e7, args: t10 });
        }
        function Jt(e7, t10) {
          var n8, i10;
          Ht = e7, Ht ? (Ht.enabled = true, _t2.forEach(({ event: e8, args: t11 }) => Ht.emit(e8, ...t11)), _t2 = []) : "undefined" != typeof window && window.HTMLElement && !(null === (i10 = null === (n8 = window.navigator) || void 0 === n8 ? void 0 : n8.userAgent) || void 0 === i10 ? void 0 : i10.includes("jsdom")) ? ((t10.__VUE_DEVTOOLS_HOOK_REPLAY__ = t10.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((e8) => {
            Jt(e8, t10);
          }), setTimeout(() => {
            Ht || (t10.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Vt = true, _t2 = []);
          }, 3e3)) : (Vt = true, _t2 = []);
        }
        const Xt = en("component:added"), Kt = en("component:updated"), qt = en("component:removed"), $t = (e7) => {
          Ht && "function" == typeof Ht.cleanupBuffer && !Ht.cleanupBuffer(e7) && qt(e7);
        };
        function en(e7) {
          return (t10) => {
            Ft(e7, t10.appContext.app, t10.uid, t10.parent ? t10.parent.uid : void 0, t10);
          };
        }
        function tn(e7, t10, ...n8) {
          if (e7.isUnmounted)
            return;
          const i10 = e7.vnode.props || p5;
          let r9 = n8;
          const o8 = t10.startsWith("update:"), s10 = o8 && t10.slice(7);
          if (s10 && s10 in i10) {
            const e8 = `${"modelValue" === s10 ? "model" : s10}Modifiers`, { number: t11, trim: o9 } = i10[e8] || p5;
            o9 && (r9 = n8.map((e9) => e9.trim())), t11 && (r9 = n8.map(X4));
          }
          let a8;
          __VUE_PROD_DEVTOOLS__ && function(e8, t11, n9) {
            Ft("component:emit", e8.appContext.app, e8, t11, n9);
          }(e7, t10, r9);
          let l8 = i10[a8 = _4(t10)] || i10[a8 = _4(B3(t10))];
          !l8 && o8 && (l8 = i10[a8 = _4(G3(t10))]), l8 && xt2(l8, e7, 6, r9);
          const c9 = i10[a8 + "Once"];
          if (c9) {
            if (e7.emitted) {
              if (e7.emitted[a8])
                return;
            } else
              e7.emitted = {};
            e7.emitted[a8] = true, xt2(c9, e7, 6, r9);
          }
        }
        function nn(e7, t10, n8 = false) {
          const i10 = t10.emitsCache, r9 = i10.get(e7);
          if (void 0 !== r9)
            return r9;
          const o8 = e7.emits;
          let s10 = {}, a8 = false;
          if (__VUE_OPTIONS_API__ && !T2(e7)) {
            const i11 = (e8) => {
              const n9 = nn(e8, t10, true);
              n9 && (a8 = true, w6(s10, n9));
            };
            !n8 && t10.mixins.length && t10.mixins.forEach(i11), e7.extends && i11(e7.extends), e7.mixins && e7.mixins.forEach(i11);
          }
          return o8 || a8 ? (D4(o8) ? o8.forEach((e8) => s10[e8] = null) : w6(s10, o8), S5(e7) && i10.set(e7, s10), s10) : (S5(e7) && i10.set(e7, null), null);
        }
        function rn(e7, t10) {
          return !(!e7 || !y7(t10)) && (t10 = t10.slice(2).replace(/Once$/, ""), b5(e7, t10[0].toLowerCase() + t10.slice(1)) || b5(e7, G3(t10)) || b5(e7, t10));
        }
        let on = null, sn = null;
        function an(e7) {
          const t10 = on;
          return on = e7, sn = e7 && e7.type.__scopeId || null, t10;
        }
        function ln(e7) {
          sn = e7;
        }
        function cn2() {
          sn = null;
        }
        function un(e7, t10 = on, n8) {
          if (!t10)
            return e7;
          if (e7._n)
            return e7;
          const i10 = (...n9) => {
            i10._d && Ji(-1);
            const r9 = an(t10);
            let o8;
            try {
              o8 = e7(...n9);
            } finally {
              an(r9), i10._d && Ji(1);
            }
            return __VUE_PROD_DEVTOOLS__ && Kt(t10), o8;
          };
          return i10._n = true, i10._c = true, i10._d = true, i10;
        }
        function dn(e7) {
          const { type: t10, vnode: n8, proxy: i10, withProxy: r9, props: o8, propsOptions: [s10], slots: a8, attrs: l8, emit: c9, render: u7, renderCache: d7, data: A6, setupState: g8, ctx: p6, inheritAttrs: M5 } = e7;
          let f6, m6;
          const h7 = an(e7);
          try {
            if (4 & n8.shapeFlag) {
              const e8 = r9 || i10;
              f6 = ur(u7.call(e8, e8, d7, o8, g8, A6, p6)), m6 = l8;
            } else {
              const e8 = t10;
              f6 = ur(e8.length > 1 ? e8(o8, { attrs: l8, slots: a8, emit: c9 }) : e8(o8, null)), m6 = t10.props ? l8 : An(l8);
            }
          } catch (t11) {
            Hi.length = 0, Lt(t11, e7, 1), f6 = or(Wi);
          }
          let y8 = f6;
          if (m6 && false !== M5) {
            const e8 = Object.keys(m6), { shapeFlag: t11 } = y8;
            e8.length && 7 & t11 && (s10 && e8.some(I4) && (m6 = gn(m6, s10)), y8 = sr(y8, m6));
          }
          return n8.dirs && (y8 = sr(y8), y8.dirs = y8.dirs ? y8.dirs.concat(n8.dirs) : n8.dirs), n8.transition && (y8.transition = n8.transition), f6 = y8, an(h7), f6;
        }
        const An = (e7) => {
          let t10;
          for (const n8 in e7)
            ("class" === n8 || "style" === n8 || y7(n8)) && ((t10 || (t10 = {}))[n8] = e7[n8]);
          return t10;
        }, gn = (e7, t10) => {
          const n8 = {};
          for (const i10 in e7)
            I4(i10) && i10.slice(9) in t10 || (n8[i10] = e7[i10]);
          return n8;
        };
        function pn(e7, t10, n8) {
          const i10 = Object.keys(t10);
          if (i10.length !== Object.keys(e7).length)
            return true;
          for (let r9 = 0; r9 < i10.length; r9++) {
            const o8 = i10[r9];
            if (t10[o8] !== e7[o8] && !rn(n8, o8))
              return true;
          }
          return false;
        }
        function Mn(e7, t10) {
          if (mr) {
            let n8 = mr.provides;
            const i10 = mr.parent && mr.parent.provides;
            i10 === n8 && (n8 = mr.provides = Object.create(i10)), n8[e7] = t10;
          }
        }
        function fn(e7, t10, n8 = false) {
          const i10 = mr || on;
          if (i10) {
            const r9 = null == i10.parent ? i10.vnode.appContext && i10.vnode.appContext.provides : i10.parent.provides;
            if (r9 && e7 in r9)
              return r9[e7];
            if (arguments.length > 1)
              return n8 && T2(t10) ? t10.call(i10.proxy) : t10;
          }
        }
        const mn = {};
        function hn(e7, t10, n8) {
          return yn(e7, t10, n8);
        }
        function yn(e7, t10, { immediate: n8, deep: i10, flush: r9, onTrack: o8, onTrigger: s10 } = p5) {
          const a8 = mr;
          let l8, c9, u7 = false, d7 = false;
          if (ht2(e7) ? (l8 = () => e7.value, u7 = ut2(e7)) : lt(e7) ? (l8 = () => e7, i10 = true) : D4(e7) ? (d7 = true, u7 = e7.some((e8) => lt(e8) || ut2(e8)), l8 = () => e7.map((e8) => ht2(e8) ? e8.value : lt(e8) ? Nn(e8) : T2(e8) ? Dt(e8, a8, 2) : void 0)) : l8 = T2(e7) ? t10 ? () => Dt(e7, a8, 2) : () => {
            if (!a8 || !a8.isUnmounted)
              return c9 && c9(), xt2(e7, a8, 3, [A6]);
          } : f5, t10 && i10) {
            const e8 = l8;
            l8 = () => Nn(e8());
          }
          let A6 = (e8) => {
            c9 = h7.onStop = () => {
              Dt(e8, a8, 4);
            };
          };
          if (br)
            return A6 = f5, t10 ? n8 && xt2(t10, a8, 3, [l8(), d7 ? [] : void 0, A6]) : l8(), f5;
          let g8 = d7 ? [] : mn;
          const M5 = () => {
            if (h7.active)
              if (t10) {
                const e8 = h7.run();
                (i10 || u7 || (d7 ? e8.some((e9, t11) => V3(e9, g8[t11])) : V3(e8, g8))) && (c9 && c9(), xt2(t10, a8, 3, [e8, g8 === mn ? void 0 : g8, A6]), g8 = e8);
              } else
                h7.run();
          };
          let m6;
          M5.allowRecurse = !!t10, "sync" === r9 ? m6 = M5 : "post" === r9 ? m6 = () => Ui(M5, a8 && a8.suspense) : (M5.pre = true, a8 && (M5.id = a8.uid), m6 = () => Qt(M5));
          const h7 = new de3(l8, m6);
          return t10 ? n8 ? M5() : g8 = h7.run() : "post" === r9 ? Ui(h7.run.bind(h7), a8 && a8.suspense) : h7.run(), () => {
            h7.stop(), a8 && a8.scope && N4(a8.scope.effects, h7);
          };
        }
        function In(e7, t10, n8) {
          const i10 = this.proxy, r9 = z3(e7) ? e7.includes(".") ? wn(i10, e7) : () => i10[e7] : e7.bind(i10, i10);
          let o8;
          T2(t10) ? o8 = t10 : (o8 = t10.handler, n8 = t10);
          const s10 = mr;
          yr(this);
          const a8 = yn(r9, o8.bind(i10), n8);
          return s10 ? yr(s10) : Ir(), a8;
        }
        function wn(e7, t10) {
          const n8 = t10.split(".");
          return () => {
            let t11 = e7;
            for (let e8 = 0; e8 < n8.length && t11; e8++)
              t11 = t11[n8[e8]];
            return t11;
          };
        }
        function Nn(e7, t10) {
          if (!S5(e7) || e7.__v_skip)
            return e7;
          if ((t10 = t10 || /* @__PURE__ */ new Set()).has(e7))
            return e7;
          if (t10.add(e7), ht2(e7))
            Nn(e7.value, t10);
          else if (D4(e7))
            for (let n8 = 0; n8 < e7.length; n8++)
              Nn(e7[n8], t10);
          else if (L5(e7) || x4(e7))
            e7.forEach((e8) => {
              Nn(e8, t10);
            });
          else if (U4(e7))
            for (const n8 in e7)
              Nn(e7[n8], t10);
          return e7;
        }
        const jn = [Function, Array], bn = { name: "BaseTransition", props: { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: jn, onEnter: jn, onAfterEnter: jn, onEnterCancelled: jn, onBeforeLeave: jn, onLeave: jn, onAfterLeave: jn, onLeaveCancelled: jn, onBeforeAppear: jn, onAppear: jn, onAfterAppear: jn, onAppearCancelled: jn }, setup(e7, { slots: t10 }) {
          const n8 = hr(), i10 = function() {
            const e8 = { isMounted: false, isLeaving: false, isUnmounting: false, leavingVNodes: /* @__PURE__ */ new Map() };
            return Yn(() => {
              e8.isMounted = true;
            }), Wn(() => {
              e8.isUnmounting = true;
            }), e8;
          }();
          let r9;
          return () => {
            const o8 = t10.default && zn(t10.default(), true);
            if (!o8 || !o8.length)
              return;
            let s10 = o8[0];
            if (o8.length > 1) {
              let e8 = false;
              for (const t11 of o8)
                if (t11.type !== Wi) {
                  s10 = t11, e8 = true;
                  break;
                }
            }
            const a8 = At(e7), { mode: l8 } = a8;
            if (i10.isLeaving)
              return Ln(s10);
            const c9 = vn(s10);
            if (!c9)
              return Ln(s10);
            const u7 = xn(c9, a8, i10, n8);
            Tn(c9, u7);
            const d7 = n8.subTree, A6 = d7 && vn(d7);
            let g8 = false;
            const { getTransitionKey: p6 } = c9.type;
            if (p6) {
              const e8 = p6();
              void 0 === r9 ? r9 = e8 : e8 !== r9 && (r9 = e8, g8 = true);
            }
            if (A6 && A6.type !== Wi && (!er(c9, A6) || g8)) {
              const e8 = xn(A6, a8, i10, n8);
              if (Tn(A6, e8), "out-in" === l8)
                return i10.isLeaving = true, e8.afterLeave = () => {
                  i10.isLeaving = false, n8.update();
                }, Ln(s10);
              "in-out" === l8 && c9.type !== Wi && (e8.delayLeave = (e9, t11, n9) => {
                Dn(i10, A6)[String(A6.key)] = A6, e9._leaveCb = () => {
                  t11(), e9._leaveCb = void 0, delete u7.delayedLeave;
                }, u7.delayedLeave = n9;
              });
            }
            return s10;
          };
        } };
        function Dn(e7, t10) {
          const { leavingVNodes: n8 } = e7;
          let i10 = n8.get(t10.type);
          return i10 || (i10 = /* @__PURE__ */ Object.create(null), n8.set(t10.type, i10)), i10;
        }
        function xn(e7, t10, n8, i10) {
          const { appear: r9, mode: o8, persisted: s10 = false, onBeforeEnter: a8, onEnter: l8, onAfterEnter: c9, onEnterCancelled: u7, onBeforeLeave: d7, onLeave: A6, onAfterLeave: g8, onLeaveCancelled: p6, onBeforeAppear: M5, onAppear: f6, onAfterAppear: m6, onAppearCancelled: h7 } = t10, y8 = String(e7.key), I5 = Dn(n8, e7), w7 = (e8, t11) => {
            e8 && xt2(e8, i10, 9, t11);
          }, N5 = (e8, t11) => {
            const n9 = t11[1];
            w7(e8, t11), D4(e8) ? e8.every((e9) => e9.length <= 1) && n9() : e8.length <= 1 && n9();
          }, j5 = { mode: o8, persisted: s10, beforeEnter(t11) {
            let i11 = a8;
            if (!n8.isMounted) {
              if (!r9)
                return;
              i11 = M5 || a8;
            }
            t11._leaveCb && t11._leaveCb(true);
            const o9 = I5[y8];
            o9 && er(e7, o9) && o9.el._leaveCb && o9.el._leaveCb(), w7(i11, [t11]);
          }, enter(e8) {
            let t11 = l8, i11 = c9, o9 = u7;
            if (!n8.isMounted) {
              if (!r9)
                return;
              t11 = f6 || l8, i11 = m6 || c9, o9 = h7 || u7;
            }
            let s11 = false;
            const a9 = e8._enterCb = (t12) => {
              s11 || (s11 = true, w7(t12 ? o9 : i11, [e8]), j5.delayedLeave && j5.delayedLeave(), e8._enterCb = void 0);
            };
            t11 ? N5(t11, [e8, a9]) : a9();
          }, leave(t11, i11) {
            const r10 = String(e7.key);
            if (t11._enterCb && t11._enterCb(true), n8.isUnmounting)
              return i11();
            w7(d7, [t11]);
            let o9 = false;
            const s11 = t11._leaveCb = (n9) => {
              o9 || (o9 = true, i11(), w7(n9 ? p6 : g8, [t11]), t11._leaveCb = void 0, I5[r10] === e7 && delete I5[r10]);
            };
            I5[r10] = e7, A6 ? N5(A6, [t11, s11]) : s11();
          }, clone: (e8) => xn(e8, t10, n8, i10) };
          return j5;
        }
        function Ln(e7) {
          if (Sn(e7))
            return (e7 = sr(e7)).children = null, e7;
        }
        function vn(e7) {
          return Sn(e7) ? e7.children ? e7.children[0] : void 0 : e7;
        }
        function Tn(e7, t10) {
          6 & e7.shapeFlag && e7.component ? Tn(e7.component.subTree, t10) : 128 & e7.shapeFlag ? (e7.ssContent.transition = t10.clone(e7.ssContent), e7.ssFallback.transition = t10.clone(e7.ssFallback)) : e7.transition = t10;
        }
        function zn(e7, t10 = false, n8) {
          let i10 = [], r9 = 0;
          for (let o8 = 0; o8 < e7.length; o8++) {
            let s10 = e7[o8];
            const a8 = null == n8 ? s10.key : String(n8) + String(null != s10.key ? s10.key : o8);
            s10.type === Zi ? (128 & s10.patchFlag && r9++, i10 = i10.concat(zn(s10.children, t10, a8))) : (t10 || s10.type !== Wi) && i10.push(null != a8 ? sr(s10, { key: a8 }) : s10);
          }
          if (r9 > 1)
            for (let e8 = 0; e8 < i10.length; e8++)
              i10[e8].patchFlag = -2;
          return i10;
        }
        const Cn = (e7) => !!e7.type.__asyncLoader, Sn = (e7) => e7.type.__isKeepAlive;
        function En(e7, t10) {
          On(e7, "a", t10);
        }
        function kn(e7, t10) {
          On(e7, "da", t10);
        }
        function On(e7, t10, n8 = mr) {
          const i10 = e7.__wdc || (e7.__wdc = () => {
            let t11 = n8;
            for (; t11; ) {
              if (t11.isDeactivated)
                return;
              t11 = t11.parent;
            }
            return e7();
          });
          if (Un(t10, i10, n8), n8) {
            let e8 = n8.parent;
            for (; e8 && e8.parent; )
              Sn(e8.parent.vnode) && Pn(i10, t10, n8, e8), e8 = e8.parent;
          }
        }
        function Pn(e7, t10, n8, i10) {
          const r9 = Un(t10, e7, i10, true);
          Gn(() => {
            N4(i10[t10], r9);
          }, n8);
        }
        function Un(e7, t10, n8 = mr, i10 = false) {
          if (n8) {
            const r9 = n8[e7] || (n8[e7] = []), o8 = t10.__weh || (t10.__weh = (...i11) => {
              if (n8.isUnmounted)
                return;
              Me3(), yr(n8);
              const r10 = xt2(t10, n8, e7, i11);
              return Ir(), fe3(), r10;
            });
            return i10 ? r9.unshift(o8) : r9.push(o8), o8;
          }
        }
        RegExp, RegExp;
        const Qn = (e7) => (t10, n8 = mr) => (!br || "sp" === e7) && Un(e7, (...e8) => t10(...e8), n8), Rn = Qn("bm"), Yn = Qn("m"), Zn = Qn("bu"), Bn = Qn("u"), Wn = Qn("bum"), Gn = Qn("um"), Hn = Qn("sp"), _n = Qn("rtg"), Vn = Qn("rtc");
        function Fn(e7, t10 = mr) {
          Un("ec", e7, t10);
        }
        function Jn(e7, t10) {
          const n8 = on;
          if (null === n8)
            return e7;
          const i10 = Lr(n8) || n8.proxy, r9 = e7.dirs || (e7.dirs = []);
          for (let e8 = 0; e8 < t10.length; e8++) {
            let [n9, o8, s10, a8 = p5] = t10[e8];
            T2(n9) && (n9 = { mounted: n9, updated: n9 }), n9.deep && Nn(o8), r9.push({ dir: n9, instance: i10, value: o8, oldValue: void 0, arg: s10, modifiers: a8 });
          }
          return e7;
        }
        function Xn(e7, t10, n8, i10) {
          const r9 = e7.dirs, o8 = t10 && t10.dirs;
          for (let s10 = 0; s10 < r9.length; s10++) {
            const a8 = r9[s10];
            o8 && (a8.oldValue = o8[s10].value);
            let l8 = a8.dir[i10];
            l8 && (Me3(), xt2(l8, n8, 8, [e7.el, a8, e7, t10]), fe3());
          }
        }
        const Kn = "components";
        function qn(e7, t10) {
          return ti(Kn, e7, true, t10) || e7;
        }
        const $n = Symbol();
        function ei(e7) {
          return z3(e7) ? ti(Kn, e7, false) || e7 : e7 || $n;
        }
        function ti(e7, t10, n8 = true, i10 = false) {
          const r9 = on || mr;
          if (r9) {
            const n9 = r9.type;
            if (e7 === Kn) {
              const e8 = function(e9, t11 = true) {
                return T2(e9) ? e9.displayName || e9.name : e9.name || t11 && e9.__name;
              }(n9, false);
              if (e8 && (e8 === t10 || e8 === B3(t10) || e8 === H3(B3(t10))))
                return n9;
            }
            const o8 = ni(r9[e7] || n9[e7], t10) || ni(r9.appContext[e7], t10);
            return !o8 && i10 ? n9 : o8;
          }
        }
        function ni(e7, t10) {
          return e7 && (e7[t10] || e7[B3(t10)] || e7[H3(B3(t10))]);
        }
        function ii(e7, t10, n8, i10) {
          let r9;
          const o8 = n8 && n8[i10];
          if (D4(e7) || z3(e7)) {
            r9 = new Array(e7.length);
            for (let n9 = 0, i11 = e7.length; n9 < i11; n9++)
              r9[n9] = t10(e7[n9], n9, void 0, o8 && o8[n9]);
          } else if ("number" == typeof e7) {
            r9 = new Array(e7);
            for (let n9 = 0; n9 < e7; n9++)
              r9[n9] = t10(n9 + 1, n9, void 0, o8 && o8[n9]);
          } else if (S5(e7))
            if (e7[Symbol.iterator])
              r9 = Array.from(e7, (e8, n9) => t10(e8, n9, void 0, o8 && o8[n9]));
            else {
              const n9 = Object.keys(e7);
              r9 = new Array(n9.length);
              for (let i11 = 0, s10 = n9.length; i11 < s10; i11++) {
                const s11 = n9[i11];
                r9[i11] = t10(e7[s11], s11, i11, o8 && o8[i11]);
              }
            }
          else
            r9 = [];
          return n8 && (n8[i10] = r9), r9;
        }
        function ri(e7, t10, n8 = {}, i10, r9) {
          if (on.isCE || on.parent && Cn(on.parent) && on.parent.isCE)
            return or("slot", "default" === t10 ? null : { name: t10 }, i10 && i10());
          let o8 = e7[t10];
          o8 && o8._c && (o8._d = false), Vi();
          const s10 = o8 && oi(o8(n8)), a8 = qi(Zi, { key: n8.key || s10 && s10.key || `_${t10}` }, s10 || (i10 ? i10() : []), s10 && 1 === e7._ ? 64 : -2);
          return !r9 && a8.scopeId && (a8.slotScopeIds = [a8.scopeId + "-s"]), o8 && o8._c && (o8._d = true), a8;
        }
        function oi(e7) {
          return e7.some((e8) => !$i(e8) || e8.type !== Wi && !(e8.type === Zi && !oi(e8.children))) ? e7 : null;
        }
        const si = (e7) => e7 ? wr(e7) ? Lr(e7) || e7.proxy : si(e7.parent) : null, ai = w6(/* @__PURE__ */ Object.create(null), { $: (e7) => e7, $el: (e7) => e7.vnode.el, $data: (e7) => e7.data, $props: (e7) => e7.props, $attrs: (e7) => e7.attrs, $slots: (e7) => e7.slots, $refs: (e7) => e7.refs, $parent: (e7) => si(e7.parent), $root: (e7) => si(e7.root), $emit: (e7) => e7.emit, $options: (e7) => __VUE_OPTIONS_API__ ? Ai(e7) : e7.type, $forceUpdate: (e7) => e7.f || (e7.f = () => Qt(e7.update)), $nextTick: (e7) => e7.n || (e7.n = Ut.bind(e7.proxy)), $watch: (e7) => __VUE_OPTIONS_API__ ? In.bind(e7) : f5 }), li = { get({ _: e7 }, t10) {
          const { ctx: n8, setupState: i10, data: r9, props: o8, accessCache: s10, type: a8, appContext: l8 } = e7;
          let c9;
          if ("$" !== t10[0]) {
            const a9 = s10[t10];
            if (void 0 !== a9)
              switch (a9) {
                case 1:
                  return i10[t10];
                case 2:
                  return r9[t10];
                case 4:
                  return n8[t10];
                case 3:
                  return o8[t10];
              }
            else {
              if (i10 !== p5 && b5(i10, t10))
                return s10[t10] = 1, i10[t10];
              if (r9 !== p5 && b5(r9, t10))
                return s10[t10] = 2, r9[t10];
              if ((c9 = e7.propsOptions[0]) && b5(c9, t10))
                return s10[t10] = 3, o8[t10];
              if (n8 !== p5 && b5(n8, t10))
                return s10[t10] = 4, n8[t10];
              __VUE_OPTIONS_API__ && !ci || (s10[t10] = 0);
            }
          }
          const u7 = ai[t10];
          let d7, A6;
          return u7 ? ("$attrs" === t10 && me3(e7, 0, t10), u7(e7)) : (d7 = a8.__cssModules) && (d7 = d7[t10]) ? d7 : n8 !== p5 && b5(n8, t10) ? (s10[t10] = 4, n8[t10]) : (A6 = l8.config.globalProperties, b5(A6, t10) ? A6[t10] : void 0);
        }, set({ _: e7 }, t10, n8) {
          const { data: i10, setupState: r9, ctx: o8 } = e7;
          return r9 !== p5 && b5(r9, t10) ? (r9[t10] = n8, true) : i10 !== p5 && b5(i10, t10) ? (i10[t10] = n8, true) : !(b5(e7.props, t10) || "$" === t10[0] && t10.slice(1) in e7 || (o8[t10] = n8, 0));
        }, has({ _: { data: e7, setupState: t10, accessCache: n8, ctx: i10, appContext: r9, propsOptions: o8 } }, s10) {
          let a8;
          return !!n8[s10] || e7 !== p5 && b5(e7, s10) || t10 !== p5 && b5(t10, s10) || (a8 = o8[0]) && b5(a8, s10) || b5(i10, s10) || b5(ai, s10) || b5(r9.config.globalProperties, s10);
        }, defineProperty(e7, t10, n8) {
          return null != n8.get ? e7._.accessCache[t10] = 0 : b5(n8, "value") && this.set(e7, t10, n8.value, null), Reflect.defineProperty(e7, t10, n8);
        } };
        let ci = true;
        function ui(e7, t10, n8) {
          xt2(D4(e7) ? e7.map((e8) => e8.bind(t10.proxy)) : e7.bind(t10.proxy), t10, n8);
        }
        function di(e7, t10, n8, i10) {
          const r9 = i10.includes(".") ? wn(n8, i10) : () => n8[i10];
          if (z3(e7)) {
            const n9 = t10[e7];
            T2(n9) && hn(r9, n9);
          } else if (T2(e7))
            hn(r9, e7.bind(n8));
          else if (S5(e7))
            if (D4(e7))
              e7.forEach((e8) => di(e8, t10, n8, i10));
            else {
              const i11 = T2(e7.handler) ? e7.handler.bind(n8) : t10[e7.handler];
              T2(i11) && hn(r9, i11, e7);
            }
        }
        function Ai(e7) {
          const t10 = e7.type, { mixins: n8, extends: i10 } = t10, { mixins: r9, optionsCache: o8, config: { optionMergeStrategies: s10 } } = e7.appContext, a8 = o8.get(t10);
          let l8;
          return a8 ? l8 = a8 : r9.length || n8 || i10 ? (l8 = {}, r9.length && r9.forEach((e8) => gi(l8, e8, s10, true)), gi(l8, t10, s10)) : l8 = t10, S5(t10) && o8.set(t10, l8), l8;
        }
        function gi(e7, t10, n8, i10 = false) {
          const { mixins: r9, extends: o8 } = t10;
          o8 && gi(e7, o8, n8, true), r9 && r9.forEach((t11) => gi(e7, t11, n8, true));
          for (const r10 in t10)
            if (i10 && "expose" === r10)
              ;
            else {
              const i11 = pi[r10] || n8 && n8[r10];
              e7[r10] = i11 ? i11(e7[r10], t10[r10]) : t10[r10];
            }
          return e7;
        }
        const pi = { data: Mi, props: hi, emits: hi, methods: hi, computed: hi, beforeCreate: mi, created: mi, beforeMount: mi, mounted: mi, beforeUpdate: mi, updated: mi, beforeDestroy: mi, beforeUnmount: mi, destroyed: mi, unmounted: mi, activated: mi, deactivated: mi, errorCaptured: mi, serverPrefetch: mi, components: hi, directives: hi, watch: function(e7, t10) {
          if (!e7)
            return t10;
          if (!t10)
            return e7;
          const n8 = w6(/* @__PURE__ */ Object.create(null), e7);
          for (const i10 in t10)
            n8[i10] = mi(e7[i10], t10[i10]);
          return n8;
        }, provide: Mi, inject: function(e7, t10) {
          return hi(fi(e7), fi(t10));
        } };
        function Mi(e7, t10) {
          return t10 ? e7 ? function() {
            return w6(T2(e7) ? e7.call(this, this) : e7, T2(t10) ? t10.call(this, this) : t10);
          } : t10 : e7;
        }
        function fi(e7) {
          if (D4(e7)) {
            const t10 = {};
            for (let n8 = 0; n8 < e7.length; n8++)
              t10[e7[n8]] = e7[n8];
            return t10;
          }
          return e7;
        }
        function mi(e7, t10) {
          return e7 ? [...new Set([].concat(e7, t10))] : t10;
        }
        function hi(e7, t10) {
          return e7 ? w6(w6(/* @__PURE__ */ Object.create(null), e7), t10) : t10;
        }
        function yi(e7, t10, n8, i10) {
          const [r9, o8] = e7.propsOptions;
          let s10, a8 = false;
          if (t10)
            for (let l8 in t10) {
              if (R3(l8))
                continue;
              const c9 = t10[l8];
              let u7;
              r9 && b5(r9, u7 = B3(l8)) ? o8 && o8.includes(u7) ? (s10 || (s10 = {}))[u7] = c9 : n8[u7] = c9 : rn(e7.emitsOptions, l8) || l8 in i10 && c9 === i10[l8] || (i10[l8] = c9, a8 = true);
            }
          if (o8) {
            const t11 = At(n8), i11 = s10 || p5;
            for (let s11 = 0; s11 < o8.length; s11++) {
              const a9 = o8[s11];
              n8[a9] = Ii(r9, t11, a9, i11[a9], e7, !b5(i11, a9));
            }
          }
          return a8;
        }
        function Ii(e7, t10, n8, i10, r9, o8) {
          const s10 = e7[n8];
          if (null != s10) {
            const e8 = b5(s10, "default");
            if (e8 && void 0 === i10) {
              const e9 = s10.default;
              if (s10.type !== Function && T2(e9)) {
                const { propsDefaults: o9 } = r9;
                n8 in o9 ? i10 = o9[n8] : (yr(r9), i10 = o9[n8] = e9.call(null, t10), Ir());
              } else
                i10 = e9;
            }
            s10[0] && (o8 && !e8 ? i10 = false : !s10[1] || "" !== i10 && i10 !== G3(n8) || (i10 = true));
          }
          return i10;
        }
        function wi(e7, t10, n8 = false) {
          const i10 = t10.propsCache, r9 = i10.get(e7);
          if (r9)
            return r9;
          const o8 = e7.props, s10 = {}, a8 = [];
          let l8 = false;
          if (__VUE_OPTIONS_API__ && !T2(e7)) {
            const i11 = (e8) => {
              l8 = true;
              const [n9, i12] = wi(e8, t10, true);
              w6(s10, n9), i12 && a8.push(...i12);
            };
            !n8 && t10.mixins.length && t10.mixins.forEach(i11), e7.extends && i11(e7.extends), e7.mixins && e7.mixins.forEach(i11);
          }
          if (!o8 && !l8)
            return S5(e7) && i10.set(e7, M4), M4;
          if (D4(o8))
            for (let e8 = 0; e8 < o8.length; e8++) {
              const t11 = B3(o8[e8]);
              Ni(t11) && (s10[t11] = p5);
            }
          else if (o8)
            for (const e8 in o8) {
              const t11 = B3(e8);
              if (Ni(t11)) {
                const n9 = o8[e8], i11 = s10[t11] = D4(n9) || T2(n9) ? { type: n9 } : n9;
                if (i11) {
                  const e9 = Di(Boolean, i11.type), n10 = Di(String, i11.type);
                  i11[0] = e9 > -1, i11[1] = n10 < 0 || e9 < n10, (e9 > -1 || b5(i11, "default")) && a8.push(t11);
                }
              }
            }
          const c9 = [s10, a8];
          return S5(e7) && i10.set(e7, c9), c9;
        }
        function Ni(e7) {
          return "$" !== e7[0];
        }
        function ji(e7) {
          const t10 = e7 && e7.toString().match(/^\s*function (\w+)/);
          return t10 ? t10[1] : null === e7 ? "null" : "";
        }
        function bi(e7, t10) {
          return ji(e7) === ji(t10);
        }
        function Di(e7, t10) {
          return D4(t10) ? t10.findIndex((t11) => bi(t11, e7)) : T2(t10) && bi(t10, e7) ? 0 : -1;
        }
        const xi = (e7) => "_" === e7[0] || "$stable" === e7, Li = (e7) => D4(e7) ? e7.map(ur) : [ur(e7)], vi = (e7, t10, n8) => {
          if (t10._n)
            return t10;
          const i10 = un((...e8) => Li(t10(...e8)), n8);
          return i10._c = false, i10;
        }, Ti = (e7, t10, n8) => {
          const i10 = e7._ctx;
          for (const n9 in e7) {
            if (xi(n9))
              continue;
            const r9 = e7[n9];
            if (T2(r9))
              t10[n9] = vi(0, r9, i10);
            else if (null != r9) {
              const e8 = Li(r9);
              t10[n9] = () => e8;
            }
          }
        }, zi = (e7, t10) => {
          const n8 = Li(t10);
          e7.slots.default = () => n8;
        }, Ci = (e7, t10) => {
          if (32 & e7.vnode.shapeFlag) {
            const n8 = t10._;
            n8 ? (e7.slots = At(t10), J3(t10, "_", n8)) : Ti(t10, e7.slots = {});
          } else
            e7.slots = {}, t10 && zi(e7, t10);
          J3(e7.slots, tr, 1);
        }, Si = (e7, t10, n8) => {
          const { vnode: i10, slots: r9 } = e7;
          let o8 = true, s10 = p5;
          if (32 & i10.shapeFlag) {
            const e8 = t10._;
            e8 ? n8 && 1 === e8 ? o8 = false : (w6(r9, t10), n8 || 1 !== e8 || delete r9._) : (o8 = !t10.$stable, Ti(t10, r9)), s10 = t10;
          } else
            t10 && (zi(e7, t10), s10 = { default: 1 });
          if (o8)
            for (const e8 in r9)
              xi(e8) || e8 in s10 || delete r9[e8];
        };
        function Ei() {
          return { app: null, config: { isNativeTag: m5, performance: false, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: /* @__PURE__ */ Object.create(null), optionsCache: /* @__PURE__ */ new WeakMap(), propsCache: /* @__PURE__ */ new WeakMap(), emitsCache: /* @__PURE__ */ new WeakMap() };
        }
        let ki = 0;
        function Oi(e7, t10) {
          return function(n8, i10 = null) {
            T2(n8) || (n8 = Object.assign({}, n8)), null == i10 || S5(i10) || (i10 = null);
            const r9 = Ei(), o8 = /* @__PURE__ */ new Set();
            let s10 = false;
            const a8 = r9.app = { _uid: ki++, _component: n8, _props: i10, _container: null, _context: r9, _instance: null, version: Tr, get config() {
              return r9.config;
            }, set config(e8) {
            }, use: (e8, ...t11) => (o8.has(e8) || (e8 && T2(e8.install) ? (o8.add(e8), e8.install(a8, ...t11)) : T2(e8) && (o8.add(e8), e8(a8, ...t11))), a8), mixin: (e8) => (__VUE_OPTIONS_API__ && (r9.mixins.includes(e8) || r9.mixins.push(e8)), a8), component: (e8, t11) => t11 ? (r9.components[e8] = t11, a8) : r9.components[e8], directive: (e8, t11) => t11 ? (r9.directives[e8] = t11, a8) : r9.directives[e8], mount(o9, l8, c9) {
              if (!s10) {
                const u7 = or(n8, i10);
                return u7.appContext = r9, l8 && t10 ? t10(u7, o9) : e7(u7, o9, c9), s10 = true, a8._container = o9, o9.__vue_app__ = a8, __VUE_PROD_DEVTOOLS__ && (a8._instance = u7.component, function(e8, t11) {
                  Ft("app:init", e8, t11, { Fragment: Zi, Text: Bi, Comment: Wi, Static: Gi });
                }(a8, Tr)), Lr(u7.component) || u7.component.proxy;
              }
            }, unmount() {
              s10 && (e7(null, a8._container), __VUE_PROD_DEVTOOLS__ && (a8._instance = null, function(e8) {
                Ft("app:unmount", e8);
              }(a8)), delete a8._container.__vue_app__);
            }, provide: (e8, t11) => (r9.provides[e8] = t11, a8) };
            return a8;
          };
        }
        function Pi(e7, t10, n8, i10, r9 = false) {
          if (D4(e7))
            return void e7.forEach((e8, o9) => Pi(e8, t10 && (D4(t10) ? t10[o9] : t10), n8, i10, r9));
          if (Cn(i10) && !r9)
            return;
          const o8 = 4 & i10.shapeFlag ? Lr(i10.component) || i10.component.proxy : i10.el, s10 = r9 ? null : o8, { i: a8, r: l8 } = e7, c9 = t10 && t10.r, u7 = a8.refs === p5 ? a8.refs = {} : a8.refs, d7 = a8.setupState;
          if (null != c9 && c9 !== l8 && (z3(c9) ? (u7[c9] = null, b5(d7, c9) && (d7[c9] = null)) : ht2(c9) && (c9.value = null)), T2(l8))
            Dt(l8, a8, 12, [s10, u7]);
          else {
            const t11 = z3(l8), i11 = ht2(l8);
            if (t11 || i11) {
              const a9 = () => {
                if (e7.f) {
                  const n9 = t11 ? b5(d7, l8) ? d7[l8] : u7[l8] : l8.value;
                  r9 ? D4(n9) && N4(n9, o8) : D4(n9) ? n9.includes(o8) || n9.push(o8) : t11 ? (u7[l8] = [o8], b5(d7, l8) && (d7[l8] = u7[l8])) : (l8.value = [o8], e7.k && (u7[e7.k] = l8.value));
                } else
                  t11 ? (u7[l8] = s10, b5(d7, l8) && (d7[l8] = s10)) : i11 && (l8.value = s10, e7.k && (u7[e7.k] = s10));
              };
              s10 ? (a9.id = -1, Ui(a9, n8)) : a9();
            }
          }
        }
        const Ui = function(e7, t10) {
          var n8;
          t10 && t10.pendingBranch ? D4(e7) ? t10.effects.push(...e7) : t10.effects.push(e7) : (D4(n8 = e7) ? St2.push(...n8) : Et2 && Et2.includes(n8, n8.allowRecurse ? kt + 1 : kt) || St2.push(n8), Rt());
        };
        function Qi(e7, t10) {
          "boolean" != typeof __VUE_OPTIONS_API__ && (q4().__VUE_OPTIONS_API__ = true), "boolean" != typeof __VUE_PROD_DEVTOOLS__ && (q4().__VUE_PROD_DEVTOOLS__ = false);
          const n8 = q4();
          n8.__VUE__ = true, __VUE_PROD_DEVTOOLS__ && Jt(n8.__VUE_DEVTOOLS_GLOBAL_HOOK__, n8);
          const { insert: i10, remove: r9, patchProp: o8, createElement: s10, createText: a8, createComment: l8, setText: c9, setElementText: u7, parentNode: d7, nextSibling: A6, setScopeId: g8 = f5, insertStaticContent: m6 } = e7, h7 = (e8, t11, n9, i11 = null, r10 = null, o9 = null, s11 = false, a9 = null, l9 = !!t11.dynamicChildren) => {
            if (e8 === t11)
              return;
            e8 && !er(e8, t11) && (i11 = K4(e8), W5(e8, r10, o9, true), e8 = null), -2 === t11.patchFlag && (l9 = false, t11.dynamicChildren = null);
            const { type: c10, ref: u8, shapeFlag: d8 } = t11;
            switch (c10) {
              case Bi:
                y8(e8, t11, n9, i11);
                break;
              case Wi:
                I5(e8, t11, n9, i11);
                break;
              case Gi:
                null == e8 && w7(t11, n9, i11, s11);
                break;
              case Zi:
                z4(e8, t11, n9, i11, r10, o9, s11, a9, l9);
                break;
              default:
                1 & d8 ? N5(e8, t11, n9, i11, r10, o9, s11, a9, l9) : 6 & d8 ? C6(e8, t11, n9, i11, r10, o9, s11, a9, l9) : (64 & d8 || 128 & d8) && c10.process(e8, t11, n9, i11, r10, o9, s11, a9, l9, te4);
            }
            null != u8 && r10 && Pi(u8, e8 && e8.ref, o9, t11 || e8, !t11);
          }, y8 = (e8, t11, n9, r10) => {
            if (null == e8)
              i10(t11.el = a8(t11.children), n9, r10);
            else {
              const n10 = t11.el = e8.el;
              t11.children !== e8.children && c9(n10, t11.children);
            }
          }, I5 = (e8, t11, n9, r10) => {
            null == e8 ? i10(t11.el = l8(t11.children || ""), n9, r10) : t11.el = e8.el;
          }, w7 = (e8, t11, n9, i11) => {
            [e8.el, e8.anchor] = m6(e8.children, t11, n9, i11, e8.el, e8.anchor);
          }, N5 = (e8, t11, n9, i11, r10, o9, s11, a9, l9) => {
            s11 = s11 || "svg" === t11.type, null == e8 ? j5(t11, n9, i11, r10, o9, s11, a9, l9) : L6(e8, t11, r10, o9, s11, a9, l9);
          }, j5 = (e8, t11, n9, r10, a9, l9, c10, d8) => {
            let A7, g9;
            const { type: p6, props: M5, shapeFlag: f6, transition: m7, dirs: h8 } = e8;
            if (A7 = e8.el = s10(e8.type, l9, M5 && M5.is, M5), 8 & f6 ? u7(A7, e8.children) : 16 & f6 && x5(e8.children, A7, null, r10, a9, l9 && "foreignObject" !== p6, c10, d8), h8 && Xn(e8, null, r10, "created"), M5) {
              for (const t12 in M5)
                "value" === t12 || R3(t12) || o8(A7, t12, null, M5[t12], l9, e8.children, r10, a9, X5);
              "value" in M5 && o8(A7, "value", null, M5.value), (g9 = M5.onVnodeBeforeMount) && pr(g9, r10, e8);
            }
            D5(A7, e8, e8.scopeId, c10, r10), __VUE_PROD_DEVTOOLS__ && (Object.defineProperty(A7, "__vnode", { value: e8, enumerable: false }), Object.defineProperty(A7, "__vueParentComponent", { value: r10, enumerable: false })), h8 && Xn(e8, null, r10, "beforeMount");
            const y9 = (!a9 || a9 && !a9.pendingBranch) && m7 && !m7.persisted;
            y9 && m7.beforeEnter(A7), i10(A7, t11, n9), ((g9 = M5 && M5.onVnodeMounted) || y9 || h8) && Ui(() => {
              g9 && pr(g9, r10, e8), y9 && m7.enter(A7), h8 && Xn(e8, null, r10, "mounted");
            }, a9);
          }, D5 = (e8, t11, n9, i11, r10) => {
            if (n9 && g8(e8, n9), i11)
              for (let t12 = 0; t12 < i11.length; t12++)
                g8(e8, i11[t12]);
            if (r10 && t11 === r10.subTree) {
              const t12 = r10.vnode;
              D5(e8, t12, t12.scopeId, t12.slotScopeIds, r10.parent);
            }
          }, x5 = (e8, t11, n9, i11, r10, o9, s11, a9, l9 = 0) => {
            for (let c10 = l9; c10 < e8.length; c10++) {
              const l10 = e8[c10] = a9 ? dr(e8[c10]) : ur(e8[c10]);
              h7(null, l10, t11, n9, i11, r10, o9, s11, a9);
            }
          }, L6 = (e8, t11, n9, i11, r10, s11, a9) => {
            const l9 = t11.el = e8.el;
            let { patchFlag: c10, dynamicChildren: d8, dirs: A7 } = t11;
            c10 |= 16 & e8.patchFlag;
            const g9 = e8.props || p5, M5 = t11.props || p5;
            let f6;
            n9 && Ri(n9, false), (f6 = M5.onVnodeBeforeUpdate) && pr(f6, n9, t11, e8), A7 && Xn(t11, e8, n9, "beforeUpdate"), n9 && Ri(n9, true);
            const m7 = r10 && "foreignObject" !== t11.type;
            if (d8 ? v6(e8.dynamicChildren, d8, l9, n9, i11, m7, s11) : a9 || U5(e8, t11, l9, null, n9, i11, m7, s11, false), c10 > 0) {
              if (16 & c10)
                T3(l9, t11, g9, M5, n9, i11, r10);
              else if (2 & c10 && g9.class !== M5.class && o8(l9, "class", null, M5.class, r10), 4 & c10 && o8(l9, "style", g9.style, M5.style, r10), 8 & c10) {
                const s12 = t11.dynamicProps;
                for (let t12 = 0; t12 < s12.length; t12++) {
                  const a10 = s12[t12], c11 = g9[a10], u8 = M5[a10];
                  u8 === c11 && "value" !== a10 || o8(l9, a10, c11, u8, r10, e8.children, n9, i11, X5);
                }
              }
              1 & c10 && e8.children !== t11.children && u7(l9, t11.children);
            } else
              a9 || null != d8 || T3(l9, t11, g9, M5, n9, i11, r10);
            ((f6 = M5.onVnodeUpdated) || A7) && Ui(() => {
              f6 && pr(f6, n9, t11, e8), A7 && Xn(t11, e8, n9, "updated");
            }, i11);
          }, v6 = (e8, t11, n9, i11, r10, o9, s11) => {
            for (let a9 = 0; a9 < t11.length; a9++) {
              const l9 = e8[a9], c10 = t11[a9], u8 = l9.el && (l9.type === Zi || !er(l9, c10) || 70 & l9.shapeFlag) ? d7(l9.el) : n9;
              h7(l9, c10, u8, null, i11, r10, o9, s11, true);
            }
          }, T3 = (e8, t11, n9, i11, r10, s11, a9) => {
            if (n9 !== i11) {
              if (n9 !== p5)
                for (const l9 in n9)
                  R3(l9) || l9 in i11 || o8(e8, l9, n9[l9], null, a9, t11.children, r10, s11, X5);
              for (const l9 in i11) {
                if (R3(l9))
                  continue;
                const c10 = i11[l9], u8 = n9[l9];
                c10 !== u8 && "value" !== l9 && o8(e8, l9, u8, c10, a9, t11.children, r10, s11, X5);
              }
              "value" in i11 && o8(e8, "value", n9.value, i11.value);
            }
          }, z4 = (e8, t11, n9, r10, o9, s11, l9, c10, u8) => {
            const d8 = t11.el = e8 ? e8.el : a8(""), A7 = t11.anchor = e8 ? e8.anchor : a8("");
            let { patchFlag: g9, dynamicChildren: p6, slotScopeIds: M5 } = t11;
            M5 && (c10 = c10 ? c10.concat(M5) : M5), null == e8 ? (i10(d8, n9, r10), i10(A7, n9, r10), x5(t11.children, n9, A7, o9, s11, l9, c10, u8)) : g9 > 0 && 64 & g9 && p6 && e8.dynamicChildren ? (v6(e8.dynamicChildren, p6, n9, o9, s11, l9, c10), (null != t11.key || o9 && t11 === o9.subTree) && Yi(e8, t11, true)) : U5(e8, t11, n9, A7, o9, s11, l9, c10, u8);
          }, C6 = (e8, t11, n9, i11, r10, o9, s11, a9, l9) => {
            t11.slotScopeIds = a9, null == e8 ? 512 & t11.shapeFlag ? r10.ctx.activate(t11, n9, i11, s11, l9) : S6(t11, n9, i11, r10, o9, s11, l9) : k5(e8, t11, l9);
          }, S6 = (e8, t11, n9, i11, r10, o9, s11) => {
            const a9 = e8.component = function(e9, t12, n10) {
              const i12 = e9.type, r11 = (t12 ? t12.appContext : e9.appContext) || Mr, o10 = { uid: fr++, vnode: e9, type: i12, parent: t12, appContext: r11, root: null, next: null, subTree: null, effect: null, update: null, scope: new ee3(true), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t12 ? t12.provides : Object.create(r11.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: wi(i12, r11), emitsOptions: nn(i12, r11), emit: null, emitted: null, propsDefaults: p5, inheritAttrs: i12.inheritAttrs, ctx: p5, data: p5, props: p5, attrs: p5, slots: p5, refs: p5, setupState: p5, setupContext: null, suspense: n10, suspenseId: n10 ? n10.pendingId : 0, asyncDep: null, asyncResolved: false, isMounted: false, isUnmounted: false, isDeactivated: false, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null };
              return o10.ctx = { _: o10 }, o10.root = t12 ? t12.root : o10, o10.emit = tn.bind(null, o10), e9.ce && e9.ce(o10), o10;
            }(e8, i11, r10);
            if (Sn(e8) && (a9.ctx.renderer = te4), function(e9, t12 = false) {
              br = t12;
              const { props: n10, children: i12 } = e9.vnode, r11 = wr(e9);
              (function(e10, t13, n11, i13 = false) {
                const r12 = {}, o11 = {};
                J3(o11, tr, 1), e10.propsDefaults = /* @__PURE__ */ Object.create(null), yi(e10, t13, r12, o11);
                for (const t14 in e10.propsOptions[0])
                  t14 in r12 || (r12[t14] = void 0);
                n11 ? e10.props = i13 ? r12 : at2(r12, false, Ee3, $e2, nt2) : e10.type.props ? e10.props = r12 : e10.props = o11, e10.attrs = o11;
              })(e9, n10, r11, t12), Ci(e9, i12);
              const o10 = r11 ? function(e10, t13) {
                const n11 = e10.type;
                e10.accessCache = /* @__PURE__ */ Object.create(null), e10.proxy = gt2(new Proxy(e10.ctx, li));
                const { setup: i13 } = n11;
                if (i13) {
                  const n12 = e10.setupContext = i13.length > 1 ? function(e11) {
                    const t14 = (t15) => {
                      e11.exposed = t15 || {};
                    };
                    let n13;
                    return { get attrs() {
                      return n13 || (n13 = function(e12) {
                        return new Proxy(e12.attrs, { get: (t15, n14) => (me3(e12, 0, "$attrs"), t15[n14]) });
                      }(e11));
                    }, slots: e11.slots, emit: e11.emit, expose: t14 };
                  }(e10) : null;
                  yr(e10), Me3();
                  const r12 = Dt(i13, e10, 0, [e10.props, n12]);
                  if (fe3(), Ir(), E6(r12)) {
                    if (r12.then(Ir, Ir), t13)
                      return r12.then((n13) => {
                        Dr(e10, n13, t13);
                      }).catch((t14) => {
                        Lt(t14, e10, 0);
                      });
                    e10.asyncDep = r12;
                  } else
                    Dr(e10, r12, t13);
                } else
                  xr(e10, t13);
              }(e9, t12) : void 0;
              br = false;
            }(a9), a9.asyncDep) {
              if (r10 && r10.registerDep(a9, O4), !e8.el) {
                const e9 = a9.subTree = or(Wi);
                I5(null, e9, t11, n9);
              }
            } else
              O4(a9, e8, t11, n9, r10, o9, s11);
          }, k5 = (e8, t11, n9) => {
            const i11 = t11.component = e8.component;
            if (function(e9, t12, n10) {
              const { props: i12, children: r10, component: o9 } = e9, { props: s11, children: a9, patchFlag: l9 } = t12, c10 = o9.emitsOptions;
              if (t12.dirs || t12.transition)
                return true;
              if (!(n10 && l9 >= 0))
                return !(!r10 && !a9 || a9 && a9.$stable) || i12 !== s11 && (i12 ? !s11 || pn(i12, s11, c10) : !!s11);
              if (1024 & l9)
                return true;
              if (16 & l9)
                return i12 ? pn(i12, s11, c10) : !!s11;
              if (8 & l9) {
                const e10 = t12.dynamicProps;
                for (let t13 = 0; t13 < e10.length; t13++) {
                  const n11 = e10[t13];
                  if (s11[n11] !== i12[n11] && !rn(c10, n11))
                    return true;
                }
              }
              return false;
            }(e8, t11, n9)) {
              if (i11.asyncDep && !i11.asyncResolved)
                return void P5(i11, t11, n9);
              i11.next = t11, function(e9) {
                const t12 = zt.indexOf(e9);
                t12 > Ct && zt.splice(t12, 1);
              }(i11.update), i11.update();
            } else
              t11.el = e8.el, i11.vnode = t11;
          }, O4 = (e8, t11, n9, i11, r10, o9, s11) => {
            const a9 = e8.effect = new de3(() => {
              if (e8.isMounted) {
                let t12, { next: n10, bu: i12, u: a10, parent: l10, vnode: c10 } = e8, u8 = n10;
                Ri(e8, false), n10 ? (n10.el = c10.el, P5(e8, n10, s11)) : n10 = c10, i12 && F4(i12), (t12 = n10.props && n10.props.onVnodeBeforeUpdate) && pr(t12, l10, n10, c10), Ri(e8, true);
                const A7 = dn(e8), g9 = e8.subTree;
                e8.subTree = A7, h7(g9, A7, d7(g9.el), K4(g9), e8, r10, o9), n10.el = A7.el, null === u8 && function({ vnode: e9, parent: t13 }, n11) {
                  for (; t13 && t13.subTree === e9; )
                    (e9 = t13.vnode).el = n11, t13 = t13.parent;
                }(e8, A7.el), a10 && Ui(a10, r10), (t12 = n10.props && n10.props.onVnodeUpdated) && Ui(() => pr(t12, l10, n10, c10), r10), __VUE_PROD_DEVTOOLS__ && Kt(e8);
              } else {
                let s12;
                const { el: a10, props: l10 } = t11, { bm: c10, m: u8, parent: d8 } = e8, A7 = Cn(t11);
                if (Ri(e8, false), c10 && F4(c10), !A7 && (s12 = l10 && l10.onVnodeBeforeMount) && pr(s12, d8, t11), Ri(e8, true), a10 && ie5) {
                  const n10 = () => {
                    e8.subTree = dn(e8), ie5(a10, e8.subTree, e8, r10, null);
                  };
                  A7 ? t11.type.__asyncLoader().then(() => !e8.isUnmounted && n10()) : n10();
                } else {
                  const s13 = e8.subTree = dn(e8);
                  h7(null, s13, n9, i11, e8, r10, o9), t11.el = s13.el;
                }
                if (u8 && Ui(u8, r10), !A7 && (s12 = l10 && l10.onVnodeMounted)) {
                  const e9 = t11;
                  Ui(() => pr(s12, d8, e9), r10);
                }
                (256 & t11.shapeFlag || d8 && Cn(d8.vnode) && 256 & d8.vnode.shapeFlag) && e8.a && Ui(e8.a, r10), e8.isMounted = true, __VUE_PROD_DEVTOOLS__ && Xt(e8), t11 = n9 = i11 = null;
              }
            }, () => Qt(l9), e8.scope), l9 = e8.update = () => a9.run();
            l9.id = e8.uid, Ri(e8, true), l9();
          }, P5 = (e8, t11, n9) => {
            t11.component = e8;
            const i11 = e8.vnode.props;
            e8.vnode = t11, e8.next = null, function(e9, t12, n10, i12) {
              const { props: r10, attrs: o9, vnode: { patchFlag: s11 } } = e9, a9 = At(r10), [l9] = e9.propsOptions;
              let c10 = false;
              if (!(i12 || s11 > 0) || 16 & s11) {
                let i13;
                yi(e9, t12, r10, o9) && (c10 = true);
                for (const o10 in a9)
                  t12 && (b5(t12, o10) || (i13 = G3(o10)) !== o10 && b5(t12, i13)) || (l9 ? !n10 || void 0 === n10[o10] && void 0 === n10[i13] || (r10[o10] = Ii(l9, a9, o10, void 0, e9, true)) : delete r10[o10]);
                if (o9 !== a9)
                  for (const e10 in o9)
                    t12 && b5(t12, e10) || (delete o9[e10], c10 = true);
              } else if (8 & s11) {
                const n11 = e9.vnode.dynamicProps;
                for (let i13 = 0; i13 < n11.length; i13++) {
                  let s12 = n11[i13];
                  if (rn(e9.emitsOptions, s12))
                    continue;
                  const u8 = t12[s12];
                  if (l9)
                    if (b5(o9, s12))
                      u8 !== o9[s12] && (o9[s12] = u8, c10 = true);
                    else {
                      const t13 = B3(s12);
                      r10[t13] = Ii(l9, a9, t13, u8, e9, false);
                    }
                  else
                    u8 !== o9[s12] && (o9[s12] = u8, c10 = true);
                }
              }
              c10 && ye3(e9, "set", "$attrs");
            }(e8, t11.props, i11, n9), Si(e8, t11.children, n9), Me3(), Yt(), fe3();
          }, U5 = (e8, t11, n9, i11, r10, o9, s11, a9, l9 = false) => {
            const c10 = e8 && e8.children, d8 = e8 ? e8.shapeFlag : 0, A7 = t11.children, { patchFlag: g9, shapeFlag: p6 } = t11;
            if (g9 > 0) {
              if (128 & g9)
                return void Y4(c10, A7, n9, i11, r10, o9, s11, a9, l9);
              if (256 & g9)
                return void Q4(c10, A7, n9, i11, r10, o9, s11, a9, l9);
            }
            8 & p6 ? (16 & d8 && X5(c10, r10, o9), A7 !== c10 && u7(n9, A7)) : 16 & d8 ? 16 & p6 ? Y4(c10, A7, n9, i11, r10, o9, s11, a9, l9) : X5(c10, r10, o9, true) : (8 & d8 && u7(n9, ""), 16 & p6 && x5(A7, n9, i11, r10, o9, s11, a9, l9));
          }, Q4 = (e8, t11, n9, i11, r10, o9, s11, a9, l9) => {
            t11 = t11 || M4;
            const c10 = (e8 = e8 || M4).length, u8 = t11.length, d8 = Math.min(c10, u8);
            let A7;
            for (A7 = 0; A7 < d8; A7++) {
              const i12 = t11[A7] = l9 ? dr(t11[A7]) : ur(t11[A7]);
              h7(e8[A7], i12, n9, null, r10, o9, s11, a9, l9);
            }
            c10 > u8 ? X5(e8, r10, o9, true, false, d8) : x5(t11, n9, i11, r10, o9, s11, a9, l9, d8);
          }, Y4 = (e8, t11, n9, i11, r10, o9, s11, a9, l9) => {
            let c10 = 0;
            const u8 = t11.length;
            let d8 = e8.length - 1, A7 = u8 - 1;
            for (; c10 <= d8 && c10 <= A7; ) {
              const i12 = e8[c10], u9 = t11[c10] = l9 ? dr(t11[c10]) : ur(t11[c10]);
              if (!er(i12, u9))
                break;
              h7(i12, u9, n9, null, r10, o9, s11, a9, l9), c10++;
            }
            for (; c10 <= d8 && c10 <= A7; ) {
              const i12 = e8[d8], c11 = t11[A7] = l9 ? dr(t11[A7]) : ur(t11[A7]);
              if (!er(i12, c11))
                break;
              h7(i12, c11, n9, null, r10, o9, s11, a9, l9), d8--, A7--;
            }
            if (c10 > d8) {
              if (c10 <= A7) {
                const e9 = A7 + 1, d9 = e9 < u8 ? t11[e9].el : i11;
                for (; c10 <= A7; )
                  h7(null, t11[c10] = l9 ? dr(t11[c10]) : ur(t11[c10]), n9, d9, r10, o9, s11, a9, l9), c10++;
              }
            } else if (c10 > A7)
              for (; c10 <= d8; )
                W5(e8[c10], r10, o9, true), c10++;
            else {
              const g9 = c10, p6 = c10, f6 = /* @__PURE__ */ new Map();
              for (c10 = p6; c10 <= A7; c10++) {
                const e9 = t11[c10] = l9 ? dr(t11[c10]) : ur(t11[c10]);
                null != e9.key && f6.set(e9.key, c10);
              }
              let m7, y9 = 0;
              const I6 = A7 - p6 + 1;
              let w8 = false, N6 = 0;
              const j6 = new Array(I6);
              for (c10 = 0; c10 < I6; c10++)
                j6[c10] = 0;
              for (c10 = g9; c10 <= d8; c10++) {
                const i12 = e8[c10];
                if (y9 >= I6) {
                  W5(i12, r10, o9, true);
                  continue;
                }
                let u9;
                if (null != i12.key)
                  u9 = f6.get(i12.key);
                else
                  for (m7 = p6; m7 <= A7; m7++)
                    if (0 === j6[m7 - p6] && er(i12, t11[m7])) {
                      u9 = m7;
                      break;
                    }
                void 0 === u9 ? W5(i12, r10, o9, true) : (j6[u9 - p6] = c10 + 1, u9 >= N6 ? N6 = u9 : w8 = true, h7(i12, t11[u9], n9, null, r10, o9, s11, a9, l9), y9++);
              }
              const b6 = w8 ? function(e9) {
                const t12 = e9.slice(), n10 = [0];
                let i12, r11, o10, s12, a10;
                const l10 = e9.length;
                for (i12 = 0; i12 < l10; i12++) {
                  const l11 = e9[i12];
                  if (0 !== l11) {
                    if (r11 = n10[n10.length - 1], e9[r11] < l11) {
                      t12[i12] = r11, n10.push(i12);
                      continue;
                    }
                    for (o10 = 0, s12 = n10.length - 1; o10 < s12; )
                      a10 = o10 + s12 >> 1, e9[n10[a10]] < l11 ? o10 = a10 + 1 : s12 = a10;
                    l11 < e9[n10[o10]] && (o10 > 0 && (t12[i12] = n10[o10 - 1]), n10[o10] = i12);
                  }
                }
                for (o10 = n10.length, s12 = n10[o10 - 1]; o10-- > 0; )
                  n10[o10] = s12, s12 = t12[s12];
                return n10;
              }(j6) : M4;
              for (m7 = b6.length - 1, c10 = I6 - 1; c10 >= 0; c10--) {
                const e9 = p6 + c10, d9 = t11[e9], A8 = e9 + 1 < u8 ? t11[e9 + 1].el : i11;
                0 === j6[c10] ? h7(null, d9, n9, A8, r10, o9, s11, a9, l9) : w8 && (m7 < 0 || c10 !== b6[m7] ? Z5(d9, n9, A8, 2) : m7--);
              }
            }
          }, Z5 = (e8, t11, n9, r10, o9 = null) => {
            const { el: s11, type: a9, transition: l9, children: c10, shapeFlag: u8 } = e8;
            if (6 & u8)
              Z5(e8.component.subTree, t11, n9, r10);
            else if (128 & u8)
              e8.suspense.move(t11, n9, r10);
            else if (64 & u8)
              a9.move(e8, t11, n9, te4);
            else if (a9 !== Zi)
              if (a9 !== Gi)
                if (2 !== r10 && 1 & u8 && l9)
                  if (0 === r10)
                    l9.beforeEnter(s11), i10(s11, t11, n9), Ui(() => l9.enter(s11), o9);
                  else {
                    const { leave: e9, delayLeave: r11, afterLeave: o10 } = l9, a10 = () => i10(s11, t11, n9), c11 = () => {
                      e9(s11, () => {
                        a10(), o10 && o10();
                      });
                    };
                    r11 ? r11(s11, a10, c11) : c11();
                  }
                else
                  i10(s11, t11, n9);
              else
                (({ el: e9, anchor: t12 }, n10, r11) => {
                  let o10;
                  for (; e9 && e9 !== t12; )
                    o10 = A6(e9), i10(e9, n10, r11), e9 = o10;
                  i10(t12, n10, r11);
                })(e8, t11, n9);
            else {
              i10(s11, t11, n9);
              for (let e9 = 0; e9 < c10.length; e9++)
                Z5(c10[e9], t11, n9, r10);
              i10(e8.anchor, t11, n9);
            }
          }, W5 = (e8, t11, n9, i11 = false, r10 = false) => {
            const { type: o9, props: s11, ref: a9, children: l9, dynamicChildren: c10, shapeFlag: u8, patchFlag: d8, dirs: A7 } = e8;
            if (null != a9 && Pi(a9, null, n9, e8, true), 256 & u8)
              return void t11.ctx.deactivate(e8);
            const g9 = 1 & u8 && A7, p6 = !Cn(e8);
            let M5;
            if (p6 && (M5 = s11 && s11.onVnodeBeforeUnmount) && pr(M5, t11, e8), 6 & u8)
              V4(e8.component, n9, i11);
            else {
              if (128 & u8)
                return void e8.suspense.unmount(n9, i11);
              g9 && Xn(e8, null, t11, "beforeUnmount"), 64 & u8 ? e8.type.remove(e8, t11, n9, r10, te4, i11) : c10 && (o9 !== Zi || d8 > 0 && 64 & d8) ? X5(c10, t11, n9, false, true) : (o9 === Zi && 384 & d8 || !r10 && 16 & u8) && X5(l9, t11, n9), i11 && H4(e8);
            }
            (p6 && (M5 = s11 && s11.onVnodeUnmounted) || g9) && Ui(() => {
              M5 && pr(M5, t11, e8), g9 && Xn(e8, null, t11, "unmounted");
            }, n9);
          }, H4 = (e8) => {
            const { type: t11, el: n9, anchor: i11, transition: o9 } = e8;
            if (t11 === Zi)
              return void _5(n9, i11);
            if (t11 === Gi)
              return void (({ el: e9, anchor: t12 }) => {
                let n10;
                for (; e9 && e9 !== t12; )
                  n10 = A6(e9), r9(e9), e9 = n10;
                r9(t12);
              })(e8);
            const s11 = () => {
              r9(n9), o9 && !o9.persisted && o9.afterLeave && o9.afterLeave();
            };
            if (1 & e8.shapeFlag && o9 && !o9.persisted) {
              const { leave: t12, delayLeave: i12 } = o9, r10 = () => t12(n9, s11);
              i12 ? i12(e8.el, s11, r10) : r10();
            } else
              s11();
          }, _5 = (e8, t11) => {
            let n9;
            for (; e8 !== t11; )
              n9 = A6(e8), r9(e8), e8 = n9;
            r9(t11);
          }, V4 = (e8, t11, n9) => {
            const { bum: i11, scope: r10, update: o9, subTree: s11, um: a9 } = e8;
            i11 && F4(i11), r10.stop(), o9 && (o9.active = false, W5(s11, e8, t11, n9)), a9 && Ui(a9, t11), Ui(() => {
              e8.isUnmounted = true;
            }, t11), t11 && t11.pendingBranch && !t11.isUnmounted && e8.asyncDep && !e8.asyncResolved && e8.suspenseId === t11.pendingId && (t11.deps--, 0 === t11.deps && t11.resolve()), __VUE_PROD_DEVTOOLS__ && $t(e8);
          }, X5 = (e8, t11, n9, i11 = false, r10 = false, o9 = 0) => {
            for (let s11 = o9; s11 < e8.length; s11++)
              W5(e8[s11], t11, n9, i11, r10);
          }, K4 = (e8) => 6 & e8.shapeFlag ? K4(e8.component.subTree) : 128 & e8.shapeFlag ? e8.suspense.next() : A6(e8.anchor || e8.el), $4 = (e8, t11, n9) => {
            null == e8 ? t11._vnode && W5(t11._vnode, null, null, true) : h7(t11._vnode || null, e8, t11, null, null, null, n9), Yt(), Zt(), t11._vnode = e8;
          }, te4 = { p: h7, um: W5, m: Z5, r: H4, mt: S6, mc: x5, pc: U5, pbc: v6, n: K4, o: e7 };
          let ne4, ie5;
          return t10 && ([ne4, ie5] = t10(te4)), { render: $4, hydrate: ne4, createApp: Oi($4, ne4) };
        }
        function Ri({ effect: e7, update: t10 }, n8) {
          e7.allowRecurse = t10.allowRecurse = n8;
        }
        function Yi(e7, t10, n8 = false) {
          const i10 = e7.children, r9 = t10.children;
          if (D4(i10) && D4(r9))
            for (let e8 = 0; e8 < i10.length; e8++) {
              const t11 = i10[e8];
              let o8 = r9[e8];
              1 & o8.shapeFlag && !o8.dynamicChildren && ((o8.patchFlag <= 0 || 32 === o8.patchFlag) && (o8 = r9[e8] = dr(r9[e8]), o8.el = t11.el), n8 || Yi(t11, o8));
            }
        }
        const Zi = Symbol(void 0), Bi = Symbol(void 0), Wi = Symbol(void 0), Gi = Symbol(void 0), Hi = [];
        let _i = null;
        function Vi(e7 = false) {
          Hi.push(_i = e7 ? null : []);
        }
        let Fi = 1;
        function Ji(e7) {
          Fi += e7;
        }
        function Xi(e7) {
          return e7.dynamicChildren = Fi > 0 ? _i || M4 : null, Hi.pop(), _i = Hi[Hi.length - 1] || null, Fi > 0 && _i && _i.push(e7), e7;
        }
        function Ki(e7, t10, n8, i10, r9, o8) {
          return Xi(rr(e7, t10, n8, i10, r9, o8, true));
        }
        function qi(e7, t10, n8, i10, r9) {
          return Xi(or(e7, t10, n8, i10, r9, true));
        }
        function $i(e7) {
          return !!e7 && true === e7.__v_isVNode;
        }
        function er(e7, t10) {
          return e7.type === t10.type && e7.key === t10.key;
        }
        const tr = "__vInternal", nr = ({ key: e7 }) => null != e7 ? e7 : null, ir = ({ ref: e7, ref_key: t10, ref_for: n8 }) => null != e7 ? z3(e7) || ht2(e7) || T2(e7) ? { i: on, r: e7, k: t10, f: !!n8 } : e7 : null;
        function rr(e7, t10 = null, n8 = null, i10 = 0, r9 = null, o8 = e7 === Zi ? 0 : 1, s10 = false, a8 = false) {
          const l8 = { __v_isVNode: true, __v_skip: true, type: e7, props: t10, key: t10 && nr(t10), ref: t10 && ir(t10), scopeId: sn, slotScopeIds: null, children: n8, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: o8, patchFlag: i10, dynamicProps: r9, dynamicChildren: null, appContext: null };
          return a8 ? (Ar(l8, n8), 128 & o8 && e7.normalize(l8)) : n8 && (l8.shapeFlag |= z3(n8) ? 8 : 16), Fi > 0 && !s10 && _i && (l8.patchFlag > 0 || 6 & o8) && 32 !== l8.patchFlag && _i.push(l8), l8;
        }
        const or = function(e7, t10 = null, n8 = null, i10 = 0, r9 = null, s10 = false) {
          if (e7 && e7 !== $n || (e7 = Wi), $i(e7)) {
            const i11 = sr(e7, t10, true);
            return n8 && Ar(i11, n8), Fi > 0 && !s10 && _i && (6 & i11.shapeFlag ? _i[_i.indexOf(e7)] = i11 : _i.push(i11)), i11.patchFlag |= -2, i11;
          }
          if (a8 = e7, T2(a8) && "__vccOpts" in a8 && (e7 = e7.__vccOpts), t10) {
            t10 = function(e9) {
              return e9 ? dt2(e9) || tr in e9 ? w6({}, e9) : e9 : null;
            }(t10);
            let { class: e8, style: n9 } = t10;
            e8 && !z3(e8) && (t10.class = c8(e8)), S5(n9) && (dt2(n9) && !D4(n9) && (n9 = w6({}, n9)), t10.style = o7(n9));
          }
          var a8;
          return rr(e7, t10, n8, i10, r9, z3(e7) ? 1 : ((e8) => e8.__isSuspense)(e7) ? 128 : ((e8) => e8.__isTeleport)(e7) ? 64 : S5(e7) ? 4 : T2(e7) ? 2 : 0, s10, true);
        };
        function sr(e7, t10, n8 = false) {
          const { props: i10, ref: r9, patchFlag: o8, children: s10 } = e7, a8 = t10 ? gr(i10 || {}, t10) : i10;
          return { __v_isVNode: true, __v_skip: true, type: e7.type, props: a8, key: a8 && nr(a8), ref: t10 && t10.ref ? n8 && r9 ? D4(r9) ? r9.concat(ir(t10)) : [r9, ir(t10)] : ir(t10) : r9, scopeId: e7.scopeId, slotScopeIds: e7.slotScopeIds, children: s10, target: e7.target, targetAnchor: e7.targetAnchor, staticCount: e7.staticCount, shapeFlag: e7.shapeFlag, patchFlag: t10 && e7.type !== Zi ? -1 === o8 ? 16 : 16 | o8 : o8, dynamicProps: e7.dynamicProps, dynamicChildren: e7.dynamicChildren, appContext: e7.appContext, dirs: e7.dirs, transition: e7.transition, component: e7.component, suspense: e7.suspense, ssContent: e7.ssContent && sr(e7.ssContent), ssFallback: e7.ssFallback && sr(e7.ssFallback), el: e7.el, anchor: e7.anchor };
        }
        function ar(e7 = " ", t10 = 0) {
          return or(Bi, null, e7, t10);
        }
        function lr(e7, t10) {
          const n8 = or(Gi, null, e7);
          return n8.staticCount = t10, n8;
        }
        function cr(e7 = "", t10 = false) {
          return t10 ? (Vi(), qi(Wi, null, e7)) : or(Wi, null, e7);
        }
        function ur(e7) {
          return null == e7 || "boolean" == typeof e7 ? or(Wi) : D4(e7) ? or(Zi, null, e7.slice()) : "object" == typeof e7 ? dr(e7) : or(Bi, null, String(e7));
        }
        function dr(e7) {
          return null === e7.el && -1 !== e7.patchFlag || e7.memo ? e7 : sr(e7);
        }
        function Ar(e7, t10) {
          let n8 = 0;
          const { shapeFlag: i10 } = e7;
          if (null == t10)
            t10 = null;
          else if (D4(t10))
            n8 = 16;
          else if ("object" == typeof t10) {
            if (65 & i10) {
              const n9 = t10.default;
              return void (n9 && (n9._c && (n9._d = false), Ar(e7, n9()), n9._c && (n9._d = true)));
            }
            {
              n8 = 32;
              const i11 = t10._;
              i11 || tr in t10 ? 3 === i11 && on && (1 === on.slots._ ? t10._ = 1 : (t10._ = 2, e7.patchFlag |= 1024)) : t10._ctx = on;
            }
          } else
            T2(t10) ? (t10 = { default: t10, _ctx: on }, n8 = 32) : (t10 = String(t10), 64 & i10 ? (n8 = 16, t10 = [ar(t10)]) : n8 = 8);
          e7.children = t10, e7.shapeFlag |= n8;
        }
        function gr(...e7) {
          const t10 = {};
          for (let n8 = 0; n8 < e7.length; n8++) {
            const i10 = e7[n8];
            for (const e8 in i10)
              if ("class" === e8)
                t10.class !== i10.class && (t10.class = c8([t10.class, i10.class]));
              else if ("style" === e8)
                t10.style = o7([t10.style, i10.style]);
              else if (y7(e8)) {
                const n9 = t10[e8], r9 = i10[e8];
                !r9 || n9 === r9 || D4(n9) && n9.includes(r9) || (t10[e8] = n9 ? [].concat(n9, r9) : r9);
              } else
                "" !== e8 && (t10[e8] = i10[e8]);
          }
          return t10;
        }
        function pr(e7, t10, n8, i10 = null) {
          xt2(e7, t10, 7, [n8, i10]);
        }
        const Mr = Ei();
        let fr = 0;
        let mr = null;
        const hr = () => mr || on, yr = (e7) => {
          mr = e7, e7.scope.on();
        }, Ir = () => {
          mr && mr.scope.off(), mr = null;
        };
        function wr(e7) {
          return 4 & e7.vnode.shapeFlag;
        }
        let Nr, jr, br = false;
        function Dr(e7, t10, n8) {
          T2(t10) ? e7.type.__ssrInlineRender ? e7.ssrRender = t10 : e7.render = t10 : S5(t10) && (__VUE_PROD_DEVTOOLS__ && (e7.devtoolsRawSetupState = t10), e7.setupState = Nt(t10)), xr(e7, n8);
        }
        function xr(e7, t10, n8) {
          const i10 = e7.type;
          if (!e7.render) {
            if (!t10 && Nr && !i10.render) {
              const t11 = i10.template || Ai(e7).template;
              if (t11) {
                const { isCustomElement: n9, compilerOptions: r9 } = e7.appContext.config, { delimiters: o8, compilerOptions: s10 } = i10, a8 = w6(w6({ isCustomElement: n9, delimiters: o8 }, r9), s10);
                i10.render = Nr(t11, a8);
              }
            }
            e7.render = i10.render || f5, jr && jr(e7);
          }
          __VUE_OPTIONS_API__ && (yr(e7), Me3(), function(e8) {
            const t11 = Ai(e8), n9 = e8.proxy, i11 = e8.ctx;
            ci = false, t11.beforeCreate && ui(t11.beforeCreate, e8, "bc");
            const { data: r9, computed: o8, methods: s10, watch: a8, provide: l8, inject: c9, created: u7, beforeMount: d7, mounted: A6, beforeUpdate: g8, updated: p6, activated: M5, deactivated: m6, beforeDestroy: h7, beforeUnmount: y8, destroyed: I5, unmounted: w7, render: N5, renderTracked: j5, renderTriggered: b6, errorCaptured: x5, serverPrefetch: L6, expose: v6, inheritAttrs: z4, components: C6, directives: E7, filters: k5 } = t11;
            if (c9 && function(e9, t12, n10 = f5, i12 = false) {
              D4(e9) && (e9 = fi(e9));
              for (const n11 in e9) {
                const r10 = e9[n11];
                let o9;
                o9 = S5(r10) ? "default" in r10 ? fn(r10.from || n11, r10.default, true) : fn(r10.from || n11) : fn(r10), ht2(o9) && i12 ? Object.defineProperty(t12, n11, { enumerable: true, configurable: true, get: () => o9.value, set: (e10) => o9.value = e10 }) : t12[n11] = o9;
              }
            }(c9, i11, null, e8.appContext.config.unwrapInjectedRef), s10)
              for (const e9 in s10) {
                const t12 = s10[e9];
                T2(t12) && (i11[e9] = t12.bind(n9));
              }
            if (r9) {
              const t12 = r9.call(n9, n9);
              S5(t12) && (e8.data = ot2(t12));
            }
            if (ci = true, o8)
              for (const e9 in o8) {
                const t12 = o8[e9], r10 = T2(t12) ? t12.bind(n9, n9) : T2(t12.get) ? t12.get.bind(n9, n9) : f5, s11 = !T2(t12) && T2(t12.set) ? t12.set.bind(n9) : f5, a9 = vr({ get: r10, set: s11 });
                Object.defineProperty(i11, e9, { enumerable: true, configurable: true, get: () => a9.value, set: (e10) => a9.value = e10 });
              }
            if (a8)
              for (const e9 in a8)
                di(a8[e9], i11, n9, e9);
            if (l8) {
              const e9 = T2(l8) ? l8.call(n9) : l8;
              Reflect.ownKeys(e9).forEach((t12) => {
                Mn(t12, e9[t12]);
              });
            }
            function O4(e9, t12) {
              D4(t12) ? t12.forEach((t13) => e9(t13.bind(n9))) : t12 && e9(t12.bind(n9));
            }
            if (u7 && ui(u7, e8, "c"), O4(Rn, d7), O4(Yn, A6), O4(Zn, g8), O4(Bn, p6), O4(En, M5), O4(kn, m6), O4(Fn, x5), O4(Vn, j5), O4(_n, b6), O4(Wn, y8), O4(Gn, w7), O4(Hn, L6), D4(v6))
              if (v6.length) {
                const t12 = e8.exposed || (e8.exposed = {});
                v6.forEach((e9) => {
                  Object.defineProperty(t12, e9, { get: () => n9[e9], set: (t13) => n9[e9] = t13 });
                });
              } else
                e8.exposed || (e8.exposed = {});
            N5 && e8.render === f5 && (e8.render = N5), null != z4 && (e8.inheritAttrs = z4), C6 && (e8.components = C6), E7 && (e8.directives = E7);
          }(e7), fe3(), Ir());
        }
        function Lr(e7) {
          if (e7.exposed)
            return e7.exposeProxy || (e7.exposeProxy = new Proxy(Nt(gt2(e7.exposed)), { get: (t10, n8) => n8 in t10 ? t10[n8] : n8 in ai ? ai[n8](e7) : void 0 }));
        }
        const vr = (e7, t10) => function(e8, t11, n8 = false) {
          let i10, r9;
          const o8 = T2(e8);
          return o8 ? (i10 = e8, r9 = f5) : (i10 = e8.get, r9 = e8.set), new bt(i10, r9, o8 || !r9, n8);
        }(e7, 0, br);
        Symbol("");
        const Tr = "3.2.41", zr = "undefined" != typeof document ? document : null, Cr = zr && zr.createElement("template"), Sr = { insert: (e7, t10, n8) => {
          t10.insertBefore(e7, n8 || null);
        }, remove: (e7) => {
          const t10 = e7.parentNode;
          t10 && t10.removeChild(e7);
        }, createElement: (e7, t10, n8, i10) => {
          const r9 = t10 ? zr.createElementNS("http://www.w3.org/2000/svg", e7) : zr.createElement(e7, n8 ? { is: n8 } : void 0);
          return "select" === e7 && i10 && null != i10.multiple && r9.setAttribute("multiple", i10.multiple), r9;
        }, createText: (e7) => zr.createTextNode(e7), createComment: (e7) => zr.createComment(e7), setText: (e7, t10) => {
          e7.nodeValue = t10;
        }, setElementText: (e7, t10) => {
          e7.textContent = t10;
        }, parentNode: (e7) => e7.parentNode, nextSibling: (e7) => e7.nextSibling, querySelector: (e7) => zr.querySelector(e7), setScopeId(e7, t10) {
          e7.setAttribute(t10, "");
        }, insertStaticContent(e7, t10, n8, i10, r9, o8) {
          const s10 = n8 ? n8.previousSibling : t10.lastChild;
          if (r9 && (r9 === o8 || r9.nextSibling))
            for (; t10.insertBefore(r9.cloneNode(true), n8), r9 !== o8 && (r9 = r9.nextSibling); )
              ;
          else {
            Cr.innerHTML = i10 ? `<svg>${e7}</svg>` : e7;
            const r10 = Cr.content;
            if (i10) {
              const e8 = r10.firstChild;
              for (; e8.firstChild; )
                r10.appendChild(e8.firstChild);
              r10.removeChild(e8);
            }
            t10.insertBefore(r10, n8);
          }
          return [s10 ? s10.nextSibling : t10.firstChild, n8 ? n8.previousSibling : t10.lastChild];
        } }, Er = /\s*!important$/;
        function kr(e7, t10, n8) {
          if (D4(n8))
            n8.forEach((n9) => kr(e7, t10, n9));
          else if (null == n8 && (n8 = ""), t10.startsWith("--"))
            e7.setProperty(t10, n8);
          else {
            const i10 = function(e8, t11) {
              const n9 = Pr[t11];
              if (n9)
                return n9;
              let i11 = B3(t11);
              if ("filter" !== i11 && i11 in e8)
                return Pr[t11] = i11;
              i11 = H3(i11);
              for (let n10 = 0; n10 < Or.length; n10++) {
                const r9 = Or[n10] + i11;
                if (r9 in e8)
                  return Pr[t11] = r9;
              }
              return t11;
            }(e7, t10);
            Er.test(n8) ? e7.setProperty(G3(i10), n8.replace(Er, ""), "important") : e7[i10] = n8;
          }
        }
        const Or = ["Webkit", "Moz", "ms"], Pr = {}, Ur = "http://www.w3.org/1999/xlink";
        function Qr(e7, t10, n8, i10) {
          e7.addEventListener(t10, n8, i10);
        }
        const Rr = /(?:Once|Passive|Capture)$/;
        let Yr = 0;
        const Zr = Promise.resolve(), Br2 = () => Yr || (Zr.then(() => Yr = 0), Yr = Date.now()), Wr = /^on[a-z]/;
        function Gr(e7, t10) {
          const n8 = function(e8) {
            return T2(e8) ? { setup: e8, name: e8.name } : e8;
          }(e7);
          class i10 extends _r {
            constructor(e8) {
              super(n8, e8, t10);
            }
          }
          return i10.def = n8, i10;
        }
        const Hr2 = "undefined" != typeof HTMLElement ? HTMLElement : class {
        };
        class _r extends Hr2 {
          constructor(e7, t10 = {}, n8) {
            super(), this._def = e7, this._props = t10, this._instance = null, this._connected = false, this._resolved = false, this._numberProps = null, this.shadowRoot && n8 ? n8(this._createVNode(), this.shadowRoot) : this.attachShadow({ mode: "open" });
          }
          connectedCallback() {
            this._connected = true, this._instance || this._resolveDef();
          }
          disconnectedCallback() {
            this._connected = false, Ut(() => {
              this._connected || (po(null, this.shadowRoot), this._instance = null);
            });
          }
          _resolveDef() {
            if (this._resolved)
              return;
            this._resolved = true;
            for (let e8 = 0; e8 < this.attributes.length; e8++)
              this._setAttr(this.attributes[e8].name);
            new MutationObserver((e8) => {
              for (const t11 of e8)
                this._setAttr(t11.attributeName);
            }).observe(this, { attributes: true });
            const e7 = (e8) => {
              const { props: t11, styles: n8 } = e8, i10 = !D4(t11), r9 = t11 ? i10 ? Object.keys(t11) : t11 : [];
              let o8;
              if (i10)
                for (const e9 in this._props) {
                  const n9 = t11[e9];
                  (n9 === Number || n9 && n9.type === Number) && (this._props[e9] = X4(this._props[e9]), (o8 || (o8 = /* @__PURE__ */ Object.create(null)))[e9] = true);
                }
              this._numberProps = o8;
              for (const e9 of Object.keys(this))
                "_" !== e9[0] && this._setProp(e9, this[e9], true, false);
              for (const e9 of r9.map(B3))
                Object.defineProperty(this, e9, { get() {
                  return this._getProp(e9);
                }, set(t12) {
                  this._setProp(e9, t12);
                } });
              this._applyStyles(n8), this._update();
            }, t10 = this._def.__asyncLoader;
            t10 ? t10().then(e7) : e7(this._def);
          }
          _setAttr(e7) {
            let t10 = this.getAttribute(e7);
            this._numberProps && this._numberProps[e7] && (t10 = X4(t10)), this._setProp(B3(e7), t10, false);
          }
          _getProp(e7) {
            return this._props[e7];
          }
          _setProp(e7, t10, n8 = true, i10 = true) {
            t10 !== this._props[e7] && (this._props[e7] = t10, i10 && this._instance && this._update(), n8 && (true === t10 ? this.setAttribute(G3(e7), "") : "string" == typeof t10 || "number" == typeof t10 ? this.setAttribute(G3(e7), t10 + "") : t10 || this.removeAttribute(G3(e7))));
          }
          _update() {
            po(this._createVNode(), this.shadowRoot);
          }
          _createVNode() {
            const e7 = or(this._def, w6({}, this._props));
            return this._instance || (e7.ce = (e8) => {
              this._instance = e8, e8.isCE = true, e8.emit = (e9, ...t11) => {
                this.dispatchEvent(new CustomEvent(e9, { detail: t11 }));
              };
              let t10 = this;
              for (; t10 = t10 && (t10.parentNode || t10.host); )
                if (t10 instanceof _r) {
                  e8.parent = t10._instance;
                  break;
                }
            }), e7;
          }
          _applyStyles(e7) {
            e7 && e7.forEach((e8) => {
              const t10 = document.createElement("style");
              t10.textContent = e8, this.shadowRoot.appendChild(t10);
            });
          }
        }
        const Vr = "transition", Fr = "animation", Jr = (e7, { slots: t10 }) => function(e8, t11, n8) {
          const i10 = arguments.length;
          return 2 === i10 ? S5(t11) && !D4(t11) ? $i(t11) ? or(e8, null, [t11]) : or(e8, t11) : or(e8, null, t11) : (i10 > 3 ? n8 = Array.prototype.slice.call(arguments, 2) : 3 === i10 && $i(n8) && (n8 = [n8]), or(e8, t11, n8));
        }(bn, function(e8) {
          const t11 = {};
          for (const n9 in e8)
            n9 in Xr || (t11[n9] = e8[n9]);
          if (false === e8.css)
            return t11;
          const { name: n8 = "v", type: i10, duration: r9, enterFromClass: o8 = `${n8}-enter-from`, enterActiveClass: s10 = `${n8}-enter-active`, enterToClass: a8 = `${n8}-enter-to`, appearFromClass: l8 = o8, appearActiveClass: c9 = s10, appearToClass: u7 = a8, leaveFromClass: d7 = `${n8}-leave-from`, leaveActiveClass: A6 = `${n8}-leave-active`, leaveToClass: g8 = `${n8}-leave-to` } = e8, p6 = function(e9) {
            if (null == e9)
              return null;
            if (S5(e9))
              return [$r(e9.enter), $r(e9.leave)];
            {
              const t12 = $r(e9);
              return [t12, t12];
            }
          }(r9), M5 = p6 && p6[0], f6 = p6 && p6[1], { onBeforeEnter: m6, onEnter: h7, onEnterCancelled: y8, onLeave: I5, onLeaveCancelled: N5, onBeforeAppear: j5 = m6, onAppear: b6 = h7, onAppearCancelled: D5 = y8 } = t11, x5 = (e9, t12, n9) => {
            to(e9, t12 ? u7 : a8), to(e9, t12 ? c9 : s10), n9 && n9();
          }, L6 = (e9, t12) => {
            e9._isLeaving = false, to(e9, d7), to(e9, g8), to(e9, A6), t12 && t12();
          }, v6 = (e9) => (t12, n9) => {
            const r10 = e9 ? b6 : h7, s11 = () => x5(t12, e9, n9);
            Kr(r10, [t12, s11]), no(() => {
              to(t12, e9 ? l8 : o8), eo(t12, e9 ? u7 : a8), qr(r10) || ro(t12, i10, M5, s11);
            });
          };
          return w6(t11, { onBeforeEnter(e9) {
            Kr(m6, [e9]), eo(e9, o8), eo(e9, s10);
          }, onBeforeAppear(e9) {
            Kr(j5, [e9]), eo(e9, l8), eo(e9, c9);
          }, onEnter: v6(false), onAppear: v6(true), onLeave(e9, t12) {
            e9._isLeaving = true;
            const n9 = () => L6(e9, t12);
            eo(e9, d7), document.body.offsetHeight, eo(e9, A6), no(() => {
              e9._isLeaving && (to(e9, d7), eo(e9, g8), qr(I5) || ro(e9, i10, f6, n9));
            }), Kr(I5, [e9, n9]);
          }, onEnterCancelled(e9) {
            x5(e9, false), Kr(y8, [e9]);
          }, onAppearCancelled(e9) {
            x5(e9, true), Kr(D5, [e9]);
          }, onLeaveCancelled(e9) {
            L6(e9), Kr(N5, [e9]);
          } });
        }(e7), t10);
        Jr.displayName = "Transition";
        const Xr = { name: String, type: String, css: { type: Boolean, default: true }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, Kr = (Jr.props = w6({}, bn.props, Xr), (e7, t10 = []) => {
          D4(e7) ? e7.forEach((e8) => e8(...t10)) : e7 && e7(...t10);
        }), qr = (e7) => !!e7 && (D4(e7) ? e7.some((e8) => e8.length > 1) : e7.length > 1);
        function $r(e7) {
          return X4(e7);
        }
        function eo(e7, t10) {
          t10.split(/\s+/).forEach((t11) => t11 && e7.classList.add(t11)), (e7._vtc || (e7._vtc = /* @__PURE__ */ new Set())).add(t10);
        }
        function to(e7, t10) {
          t10.split(/\s+/).forEach((t11) => t11 && e7.classList.remove(t11));
          const { _vtc: n8 } = e7;
          n8 && (n8.delete(t10), n8.size || (e7._vtc = void 0));
        }
        function no(e7) {
          requestAnimationFrame(() => {
            requestAnimationFrame(e7);
          });
        }
        let io = 0;
        function ro(e7, t10, n8, i10) {
          const r9 = e7._endId = ++io, o8 = () => {
            r9 === e7._endId && i10();
          };
          if (n8)
            return setTimeout(o8, n8);
          const { type: s10, timeout: a8, propCount: l8 } = function(e8, t11) {
            const n9 = window.getComputedStyle(e8), i11 = (e9) => (n9[e9] || "").split(", "), r10 = i11(Vr + "Delay"), o9 = i11(Vr + "Duration"), s11 = oo(r10, o9), a9 = i11(Fr + "Delay"), l9 = i11(Fr + "Duration"), c10 = oo(a9, l9);
            let u8 = null, d8 = 0, A7 = 0;
            return t11 === Vr ? s11 > 0 && (u8 = Vr, d8 = s11, A7 = o9.length) : t11 === Fr ? c10 > 0 && (u8 = Fr, d8 = c10, A7 = l9.length) : (d8 = Math.max(s11, c10), u8 = d8 > 0 ? s11 > c10 ? Vr : Fr : null, A7 = u8 ? u8 === Vr ? o9.length : l9.length : 0), { type: u8, timeout: d8, propCount: A7, hasTransform: u8 === Vr && /\b(transform|all)(,|$)/.test(n9[Vr + "Property"]) };
          }(e7, t10);
          if (!s10)
            return i10();
          const c9 = s10 + "end";
          let u7 = 0;
          const d7 = () => {
            e7.removeEventListener(c9, A6), o8();
          }, A6 = (t11) => {
            t11.target === e7 && ++u7 >= l8 && d7();
          };
          setTimeout(() => {
            u7 < l8 && d7();
          }, a8 + 1), e7.addEventListener(c9, A6);
        }
        function oo(e7, t10) {
          for (; e7.length < t10.length; )
            e7 = e7.concat(e7);
          return Math.max(...t10.map((t11, n8) => so(t11) + so(e7[n8])));
        }
        function so(e7) {
          return 1e3 * Number(e7.slice(0, -1).replace(",", "."));
        }
        /* @__PURE__ */ new WeakMap(), /* @__PURE__ */ new WeakMap();
        const ao = (e7) => {
          const t10 = e7.props["onUpdate:modelValue"] || false;
          return D4(t10) ? (e8) => F4(t10, e8) : t10;
        }, lo = { deep: true, created(e7, t10, n8) {
          e7._assign = ao(n8), Qr(e7, "change", () => {
            const t11 = e7._modelValue, n9 = function(e8) {
              return "_value" in e8 ? e8._value : e8.value;
            }(e7), i10 = e7.checked, r9 = e7._assign;
            if (D4(t11)) {
              const e8 = d6(t11, n9), o8 = -1 !== e8;
              if (i10 && !o8)
                r9(t11.concat(n9));
              else if (!i10 && o8) {
                const n10 = [...t11];
                n10.splice(e8, 1), r9(n10);
              }
            } else if (L5(t11)) {
              const e8 = new Set(t11);
              i10 ? e8.add(n9) : e8.delete(n9), r9(e8);
            } else
              r9(uo(e7, i10));
          });
        }, mounted: co, beforeUpdate(e7, t10, n8) {
          e7._assign = ao(n8), co(e7, t10, n8);
        } };
        function co(e7, { value: t10, oldValue: n8 }, i10) {
          e7._modelValue = t10, D4(t10) ? e7.checked = d6(t10, i10.props.value) > -1 : L5(t10) ? e7.checked = t10.has(i10.props.value) : t10 !== n8 && (e7.checked = u6(t10, uo(e7, true)));
        }
        function uo(e7, t10) {
          const n8 = t10 ? "_trueValue" : "_falseValue";
          return n8 in e7 ? e7[n8] : t10;
        }
        const Ao = w6({ patchProp: (e7, n8, i10, o8, s10 = false, a8, l8, c9, u7) => {
          "class" === n8 ? function(e8, t10, n9) {
            const i11 = e8._vtc;
            i11 && (t10 = (t10 ? [t10, ...i11] : [...i11]).join(" ")), null == t10 ? e8.removeAttribute("class") : n9 ? e8.setAttribute("class", t10) : e8.className = t10;
          }(e7, o8, s10) : "style" === n8 ? function(e8, t10, n9) {
            const i11 = e8.style, r9 = z3(n9);
            if (n9 && !r9) {
              for (const e9 in n9)
                kr(i11, e9, n9[e9]);
              if (t10 && !z3(t10))
                for (const e9 in t10)
                  null == n9[e9] && kr(i11, e9, "");
            } else {
              const o9 = i11.display;
              r9 ? t10 !== n9 && (i11.cssText = n9) : t10 && e8.removeAttribute("style"), "_vod" in e8 && (i11.display = o9);
            }
          }(e7, i10, o8) : y7(n8) ? I4(n8) || function(e8, t10, n9, i11, r9 = null) {
            const o9 = e8._vei || (e8._vei = {}), s11 = o9[t10];
            if (i11 && s11)
              s11.value = i11;
            else {
              const [n10, a9] = function(e9) {
                let t11;
                if (Rr.test(e9)) {
                  let n11;
                  for (t11 = {}; n11 = e9.match(Rr); )
                    e9 = e9.slice(0, e9.length - n11[0].length), t11[n11[0].toLowerCase()] = true;
                }
                return [":" === e9[2] ? e9.slice(3) : G3(e9.slice(2)), t11];
              }(t10);
              if (i11) {
                const s12 = o9[t10] = function(e9, t11) {
                  const n11 = (e10) => {
                    if (e10._vts) {
                      if (e10._vts <= n11.attached)
                        return;
                    } else
                      e10._vts = Date.now();
                    xt2(function(e11, t12) {
                      if (D4(t12)) {
                        const n12 = e11.stopImmediatePropagation;
                        return e11.stopImmediatePropagation = () => {
                          n12.call(e11), e11._stopped = true;
                        }, t12.map((e12) => (t13) => !t13._stopped && e12 && e12(t13));
                      }
                      return t12;
                    }(e10, n11.value), t11, 5, [e10]);
                  };
                  return n11.value = e9, n11.attached = Br2(), n11;
                }(i11, r9);
                Qr(e8, n10, s12, a9);
              } else
                s11 && (function(e9, t11, n11, i12) {
                  e9.removeEventListener(t11, n11, i12);
                }(e8, n10, s11, a9), o9[t10] = void 0);
            }
          }(e7, n8, 0, o8, l8) : ("." === n8[0] ? (n8 = n8.slice(1), 1) : "^" === n8[0] ? (n8 = n8.slice(1), 0) : function(e8, t10, n9, i11) {
            return i11 ? "innerHTML" === t10 || "textContent" === t10 || !!(t10 in e8 && Wr.test(t10) && T2(n9)) : "spellcheck" !== t10 && "draggable" !== t10 && "translate" !== t10 && ("form" !== t10 && (("list" !== t10 || "INPUT" !== e8.tagName) && (("type" !== t10 || "TEXTAREA" !== e8.tagName) && ((!Wr.test(t10) || !z3(n9)) && t10 in e8))));
          }(e7, n8, o8, s10)) ? function(e8, t10, n9, i11, o9, s11, a9) {
            if ("innerHTML" === t10 || "textContent" === t10)
              return i11 && a9(i11, o9, s11), void (e8[t10] = null == n9 ? "" : n9);
            if ("value" === t10 && "PROGRESS" !== e8.tagName && !e8.tagName.includes("-")) {
              e8._value = n9;
              const i12 = null == n9 ? "" : n9;
              return e8.value === i12 && "OPTION" !== e8.tagName || (e8.value = i12), void (null == n9 && e8.removeAttribute(t10));
            }
            let l9 = false;
            if ("" === n9 || null == n9) {
              const i12 = typeof e8[t10];
              "boolean" === i12 ? n9 = r8(n9) : null == n9 && "string" === i12 ? (n9 = "", l9 = true) : "number" === i12 && (n9 = 0, l9 = true);
            }
            try {
              e8[t10] = n9;
            } catch (e9) {
            }
            l9 && e8.removeAttribute(t10);
          }(e7, n8, o8, a8, l8, c9, u7) : ("true-value" === n8 ? e7._trueValue = o8 : "false-value" === n8 && (e7._falseValue = o8), function(e8, n9, i11, o9, s11) {
            if (o9 && n9.startsWith("xlink:"))
              null == i11 ? e8.removeAttributeNS(Ur, n9.slice(6, n9.length)) : e8.setAttributeNS(Ur, n9, i11);
            else {
              const o10 = t9(n9);
              null == i11 || o10 && !r8(i11) ? e8.removeAttribute(n9) : e8.setAttribute(n9, o10 ? "" : i11);
            }
          }(e7, n8, o8, s10));
        } }, Sr);
        let go;
        const po = (...e7) => {
          (go || (go = Qi(Ao))).render(...e7);
        }, Mo = { id: "corbado-auth", class: "container" };
        function fo(e7, t10) {
          return function() {
            return e7.apply(t10, arguments);
          };
        }
        const { toString: mo } = Object.prototype, { getPrototypeOf: ho } = Object, yo = (Io = /* @__PURE__ */ Object.create(null), (e7) => {
          const t10 = mo.call(e7);
          return Io[t10] || (Io[t10] = t10.slice(8, -1).toLowerCase());
        });
        var Io;
        const wo = (e7) => (e7 = e7.toLowerCase(), (t10) => yo(t10) === e7), No = (e7) => (t10) => typeof t10 === e7, { isArray: jo } = Array, bo = No("undefined"), Do = wo("ArrayBuffer"), xo = No("string"), Lo = No("function"), vo = No("number"), To = (e7) => null !== e7 && "object" == typeof e7, zo = (e7) => {
          if ("object" !== yo(e7))
            return false;
          const t10 = ho(e7);
          return !(null !== t10 && t10 !== Object.prototype && null !== Object.getPrototypeOf(t10) || Symbol.toStringTag in e7 || Symbol.iterator in e7);
        }, Co = wo("Date"), So = wo("File"), Eo = wo("Blob"), ko = wo("FileList"), Oo = wo("URLSearchParams");
        function Po(e7, t10, { allOwnKeys: n8 = false } = {}) {
          if (null == e7)
            return;
          let i10, r9;
          if ("object" != typeof e7 && (e7 = [e7]), jo(e7))
            for (i10 = 0, r9 = e7.length; i10 < r9; i10++)
              t10.call(null, e7[i10], i10, e7);
          else {
            const r10 = n8 ? Object.getOwnPropertyNames(e7) : Object.keys(e7), o8 = r10.length;
            let s10;
            for (i10 = 0; i10 < o8; i10++)
              s10 = r10[i10], t10.call(null, e7[s10], s10, e7);
          }
        }
        const Uo = (Qo = "undefined" != typeof Uint8Array && ho(Uint8Array), (e7) => Qo && e7 instanceof Qo);
        var Qo;
        const Ro = wo("HTMLFormElement"), Yo = (({ hasOwnProperty: e7 }) => (t10, n8) => e7.call(t10, n8))(Object.prototype), Zo = wo("RegExp"), Bo = (e7, t10) => {
          const n8 = Object.getOwnPropertyDescriptors(e7), i10 = {};
          Po(n8, (n9, r9) => {
            false !== t10(n9, r9, e7) && (i10[r9] = n9);
          }), Object.defineProperties(e7, i10);
        }, Wo = { isArray: jo, isArrayBuffer: Do, isBuffer: function(e7) {
          return null !== e7 && !bo(e7) && null !== e7.constructor && !bo(e7.constructor) && Lo(e7.constructor.isBuffer) && e7.constructor.isBuffer(e7);
        }, isFormData: (e7) => {
          const t10 = "[object FormData]";
          return e7 && ("function" == typeof FormData && e7 instanceof FormData || mo.call(e7) === t10 || Lo(e7.toString) && e7.toString() === t10);
        }, isArrayBufferView: function(e7) {
          let t10;
          return t10 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e7) : e7 && e7.buffer && Do(e7.buffer), t10;
        }, isString: xo, isNumber: vo, isBoolean: (e7) => true === e7 || false === e7, isObject: To, isPlainObject: zo, isUndefined: bo, isDate: Co, isFile: So, isBlob: Eo, isRegExp: Zo, isFunction: Lo, isStream: (e7) => To(e7) && Lo(e7.pipe), isURLSearchParams: Oo, isTypedArray: Uo, isFileList: ko, forEach: Po, merge: function e7() {
          const t10 = {}, n8 = (n9, i10) => {
            zo(t10[i10]) && zo(n9) ? t10[i10] = e7(t10[i10], n9) : zo(n9) ? t10[i10] = e7({}, n9) : jo(n9) ? t10[i10] = n9.slice() : t10[i10] = n9;
          };
          for (let e8 = 0, t11 = arguments.length; e8 < t11; e8++)
            arguments[e8] && Po(arguments[e8], n8);
          return t10;
        }, extend: (e7, t10, n8, { allOwnKeys: i10 } = {}) => (Po(t10, (t11, i11) => {
          n8 && Lo(t11) ? e7[i11] = fo(t11, n8) : e7[i11] = t11;
        }, { allOwnKeys: i10 }), e7), trim: (e7) => e7.trim ? e7.trim() : e7.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e7) => (65279 === e7.charCodeAt(0) && (e7 = e7.slice(1)), e7), inherits: (e7, t10, n8, i10) => {
          e7.prototype = Object.create(t10.prototype, i10), e7.prototype.constructor = e7, Object.defineProperty(e7, "super", { value: t10.prototype }), n8 && Object.assign(e7.prototype, n8);
        }, toFlatObject: (e7, t10, n8, i10) => {
          let r9, o8, s10;
          const a8 = {};
          if (t10 = t10 || {}, null == e7)
            return t10;
          do {
            for (r9 = Object.getOwnPropertyNames(e7), o8 = r9.length; o8-- > 0; )
              s10 = r9[o8], i10 && !i10(s10, e7, t10) || a8[s10] || (t10[s10] = e7[s10], a8[s10] = true);
            e7 = false !== n8 && ho(e7);
          } while (e7 && (!n8 || n8(e7, t10)) && e7 !== Object.prototype);
          return t10;
        }, kindOf: yo, kindOfTest: wo, endsWith: (e7, t10, n8) => {
          e7 = String(e7), (void 0 === n8 || n8 > e7.length) && (n8 = e7.length), n8 -= t10.length;
          const i10 = e7.indexOf(t10, n8);
          return -1 !== i10 && i10 === n8;
        }, toArray: (e7) => {
          if (!e7)
            return null;
          if (jo(e7))
            return e7;
          let t10 = e7.length;
          if (!vo(t10))
            return null;
          const n8 = new Array(t10);
          for (; t10-- > 0; )
            n8[t10] = e7[t10];
          return n8;
        }, forEachEntry: (e7, t10) => {
          const n8 = (e7 && e7[Symbol.iterator]).call(e7);
          let i10;
          for (; (i10 = n8.next()) && !i10.done; ) {
            const n9 = i10.value;
            t10.call(e7, n9[0], n9[1]);
          }
        }, matchAll: (e7, t10) => {
          let n8;
          const i10 = [];
          for (; null !== (n8 = e7.exec(t10)); )
            i10.push(n8);
          return i10;
        }, isHTMLForm: Ro, hasOwnProperty: Yo, hasOwnProp: Yo, reduceDescriptors: Bo, freezeMethods: (e7) => {
          Bo(e7, (t10, n8) => {
            const i10 = e7[n8];
            Lo(i10) && (t10.enumerable = false, "writable" in t10 ? t10.writable = false : t10.set || (t10.set = () => {
              throw Error("Can not read-only method '" + n8 + "'");
            }));
          });
        }, toObjectSet: (e7, t10) => {
          const n8 = {}, i10 = (e8) => {
            e8.forEach((e9) => {
              n8[e9] = true;
            });
          };
          return jo(e7) ? i10(e7) : i10(String(e7).split(t10)), n8;
        }, toCamelCase: (e7) => e7.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g, function(e8, t10, n8) {
          return t10.toUpperCase() + n8;
        }), noop: () => {
        }, toFiniteNumber: (e7, t10) => (e7 = +e7, Number.isFinite(e7) ? e7 : t10) };
        function Go(e7, t10, n8, i10, r9) {
          Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e7, this.name = "AxiosError", t10 && (this.code = t10), n8 && (this.config = n8), i10 && (this.request = i10), r9 && (this.response = r9);
        }
        Wo.inherits(Go, Error, { toJSON: function() {
          return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
        } });
        const Ho = Go.prototype, _o = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e7) => {
          _o[e7] = { value: e7 };
        }), Object.defineProperties(Go, _o), Object.defineProperty(Ho, "isAxiosError", { value: true }), Go.from = (e7, t10, n8, i10, r9, o8) => {
          const s10 = Object.create(Ho);
          return Wo.toFlatObject(e7, s10, function(e8) {
            return e8 !== Error.prototype;
          }, (e8) => "isAxiosError" !== e8), Go.call(s10, e7.message, t10, n8, i10, r9), s10.cause = e7, s10.name = e7.name, o8 && Object.assign(s10, o8), s10;
        };
        const Vo = Go, Fo = n7(230);
        function Jo(e7) {
          return Wo.isPlainObject(e7) || Wo.isArray(e7);
        }
        function Xo(e7) {
          return Wo.endsWith(e7, "[]") ? e7.slice(0, -2) : e7;
        }
        function Ko(e7, t10, n8) {
          return e7 ? e7.concat(t10).map(function(e8, t11) {
            return e8 = Xo(e8), !n8 && t11 ? "[" + e8 + "]" : e8;
          }).join(n8 ? "." : "") : t10;
        }
        const qo = Wo.toFlatObject(Wo, {}, null, function(e7) {
          return /^is[A-Z]/.test(e7);
        }), $o = function(e7, t10, n8) {
          if (!Wo.isObject(e7))
            throw new TypeError("target must be an object");
          t10 = t10 || new (Fo || FormData)();
          const i10 = (n8 = Wo.toFlatObject(n8, { metaTokens: true, dots: false, indexes: false }, false, function(e8, t11) {
            return !Wo.isUndefined(t11[e8]);
          })).metaTokens, r9 = n8.visitor || u7, o8 = n8.dots, s10 = n8.indexes, a8 = (n8.Blob || "undefined" != typeof Blob && Blob) && (l8 = t10) && Wo.isFunction(l8.append) && "FormData" === l8[Symbol.toStringTag] && l8[Symbol.iterator];
          var l8;
          if (!Wo.isFunction(r9))
            throw new TypeError("visitor must be a function");
          function c9(e8) {
            if (null === e8)
              return "";
            if (Wo.isDate(e8))
              return e8.toISOString();
            if (!a8 && Wo.isBlob(e8))
              throw new Vo("Blob is not supported. Use a Buffer instead.");
            return Wo.isArrayBuffer(e8) || Wo.isTypedArray(e8) ? a8 && "function" == typeof Blob ? new Blob([e8]) : Buffer.from(e8) : e8;
          }
          function u7(e8, n9, r10) {
            let a9 = e8;
            if (e8 && !r10 && "object" == typeof e8) {
              if (Wo.endsWith(n9, "{}"))
                n9 = i10 ? n9 : n9.slice(0, -2), e8 = JSON.stringify(e8);
              else if (Wo.isArray(e8) && function(e9) {
                return Wo.isArray(e9) && !e9.some(Jo);
              }(e8) || Wo.isFileList(e8) || Wo.endsWith(n9, "[]") && (a9 = Wo.toArray(e8)))
                return n9 = Xo(n9), a9.forEach(function(e9, i11) {
                  !Wo.isUndefined(e9) && null !== e9 && t10.append(true === s10 ? Ko([n9], i11, o8) : null === s10 ? n9 : n9 + "[]", c9(e9));
                }), false;
            }
            return !!Jo(e8) || (t10.append(Ko(r10, n9, o8), c9(e8)), false);
          }
          const d7 = [], A6 = Object.assign(qo, { defaultVisitor: u7, convertValue: c9, isVisitable: Jo });
          if (!Wo.isObject(e7))
            throw new TypeError("data must be an object");
          return function e8(n9, i11) {
            if (!Wo.isUndefined(n9)) {
              if (-1 !== d7.indexOf(n9))
                throw Error("Circular reference detected in " + i11.join("."));
              d7.push(n9), Wo.forEach(n9, function(n10, o9) {
                true === (!(Wo.isUndefined(n10) || null === n10) && r9.call(t10, n10, Wo.isString(o9) ? o9.trim() : o9, i11, A6)) && e8(n10, i11 ? i11.concat(o9) : [o9]);
              }), d7.pop();
            }
          }(e7), t10;
        };
        function es(e7) {
          const t10 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
          return encodeURIComponent(e7).replace(/[!'()~]|%20|%00/g, function(e8) {
            return t10[e8];
          });
        }
        function ts(e7, t10) {
          this._pairs = [], e7 && $o(e7, this, t10);
        }
        const ns = ts.prototype;
        ns.append = function(e7, t10) {
          this._pairs.push([e7, t10]);
        }, ns.toString = function(e7) {
          const t10 = e7 ? function(t11) {
            return e7.call(this, t11, es);
          } : es;
          return this._pairs.map(function(e8) {
            return t10(e8[0]) + "=" + t10(e8[1]);
          }, "").join("&");
        };
        const is2 = ts;
        function rs(e7) {
          return encodeURIComponent(e7).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        }
        function os(e7, t10, n8) {
          if (!t10)
            return e7;
          const i10 = n8 && n8.encode || rs, r9 = n8 && n8.serialize;
          let o8;
          if (o8 = r9 ? r9(t10, n8) : Wo.isURLSearchParams(t10) ? t10.toString() : new is2(t10, n8).toString(i10), o8) {
            const t11 = e7.indexOf("#");
            -1 !== t11 && (e7 = e7.slice(0, t11)), e7 += (-1 === e7.indexOf("?") ? "?" : "&") + o8;
          }
          return e7;
        }
        const ss = class {
          constructor() {
            this.handlers = [];
          }
          use(e7, t10, n8) {
            return this.handlers.push({ fulfilled: e7, rejected: t10, synchronous: !!n8 && n8.synchronous, runWhen: n8 ? n8.runWhen : null }), this.handlers.length - 1;
          }
          eject(e7) {
            this.handlers[e7] && (this.handlers[e7] = null);
          }
          clear() {
            this.handlers && (this.handlers = []);
          }
          forEach(e7) {
            Wo.forEach(this.handlers, function(t10) {
              null !== t10 && e7(t10);
            });
          }
        }, as = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, ls = "undefined" != typeof URLSearchParams ? URLSearchParams : is2, cs = FormData, us = (() => {
          let e7;
          return ("undefined" == typeof navigator || "ReactNative" !== (e7 = navigator.product) && "NativeScript" !== e7 && "NS" !== e7) && "undefined" != typeof window && "undefined" != typeof document;
        })(), ds = { isBrowser: true, classes: { URLSearchParams: ls, FormData: cs, Blob }, isStandardBrowserEnv: us, protocols: ["http", "https", "file", "blob", "url", "data"] }, As = function(e7) {
          function t10(e8, n8, i10, r9) {
            let o8 = e8[r9++];
            const s10 = Number.isFinite(+o8), a8 = r9 >= e8.length;
            return o8 = !o8 && Wo.isArray(i10) ? i10.length : o8, a8 ? (Wo.hasOwnProp(i10, o8) ? i10[o8] = [i10[o8], n8] : i10[o8] = n8, !s10) : (i10[o8] && Wo.isObject(i10[o8]) || (i10[o8] = []), t10(e8, n8, i10[o8], r9) && Wo.isArray(i10[o8]) && (i10[o8] = function(e9) {
              const t11 = {}, n9 = Object.keys(e9);
              let i11;
              const r10 = n9.length;
              let o9;
              for (i11 = 0; i11 < r10; i11++)
                o9 = n9[i11], t11[o9] = e9[o9];
              return t11;
            }(i10[o8])), !s10);
          }
          if (Wo.isFormData(e7) && Wo.isFunction(e7.entries)) {
            const n8 = {};
            return Wo.forEachEntry(e7, (e8, i10) => {
              t10(function(e9) {
                return Wo.matchAll(/\w+|\[(\w*)]/g, e9).map((e10) => "[]" === e10[0] ? "" : e10[1] || e10[0]);
              }(e8), i10, n8, 0);
            }), n8;
          }
          return null;
        }, gs = ds.isStandardBrowserEnv ? { write: function(e7, t10, n8, i10, r9, o8) {
          const s10 = [];
          s10.push(e7 + "=" + encodeURIComponent(t10)), Wo.isNumber(n8) && s10.push("expires=" + new Date(n8).toGMTString()), Wo.isString(i10) && s10.push("path=" + i10), Wo.isString(r9) && s10.push("domain=" + r9), true === o8 && s10.push("secure"), document.cookie = s10.join("; ");
        }, read: function(e7) {
          const t10 = document.cookie.match(new RegExp("(^|;\\s*)(" + e7 + ")=([^;]*)"));
          return t10 ? decodeURIComponent(t10[3]) : null;
        }, remove: function(e7) {
          this.write(e7, "", Date.now() - 864e5);
        } } : { write: function() {
        }, read: function() {
          return null;
        }, remove: function() {
        } };
        function ps(e7, t10) {
          return e7 && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t10) ? function(e8, t11) {
            return t11 ? e8.replace(/\/+$/, "") + "/" + t11.replace(/^\/+/, "") : e8;
          }(e7, t10) : t10;
        }
        const Ms = ds.isStandardBrowserEnv ? function() {
          const e7 = /(msie|trident)/i.test(navigator.userAgent), t10 = document.createElement("a");
          let n8;
          function i10(n9) {
            let i11 = n9;
            return e7 && (t10.setAttribute("href", i11), i11 = t10.href), t10.setAttribute("href", i11), { href: t10.href, protocol: t10.protocol ? t10.protocol.replace(/:$/, "") : "", host: t10.host, search: t10.search ? t10.search.replace(/^\?/, "") : "", hash: t10.hash ? t10.hash.replace(/^#/, "") : "", hostname: t10.hostname, port: t10.port, pathname: "/" === t10.pathname.charAt(0) ? t10.pathname : "/" + t10.pathname };
          }
          return n8 = i10(window.location.href), function(e8) {
            const t11 = Wo.isString(e8) ? i10(e8) : e8;
            return t11.protocol === n8.protocol && t11.host === n8.host;
          };
        }() : function() {
          return true;
        };
        function fs(e7, t10, n8) {
          Vo.call(this, null == e7 ? "canceled" : e7, Vo.ERR_CANCELED, t10, n8), this.name = "CanceledError";
        }
        Wo.inherits(fs, Vo, { __CANCEL__: true });
        const ms = fs, hs = Wo.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), ys = Symbol("internals"), Is = Symbol("defaults");
        function ws(e7) {
          return e7 && String(e7).trim().toLowerCase();
        }
        function Ns(e7) {
          return false === e7 || null == e7 ? e7 : Wo.isArray(e7) ? e7.map(Ns) : String(e7);
        }
        function js(e7, t10, n8, i10) {
          return Wo.isFunction(i10) ? i10.call(this, t10, n8) : Wo.isString(t10) ? Wo.isString(i10) ? -1 !== t10.indexOf(i10) : Wo.isRegExp(i10) ? i10.test(t10) : void 0 : void 0;
        }
        function bs(e7, t10) {
          t10 = t10.toLowerCase();
          const n8 = Object.keys(e7);
          let i10, r9 = n8.length;
          for (; r9-- > 0; )
            if (i10 = n8[r9], t10 === i10.toLowerCase())
              return i10;
          return null;
        }
        function Ds(e7, t10) {
          e7 && this.set(e7), this[Is] = t10 || null;
        }
        Object.assign(Ds.prototype, { set: function(e7, t10, n8) {
          const i10 = this;
          function r9(e8, t11, n9) {
            const r10 = ws(t11);
            if (!r10)
              throw new Error("header name must be a non-empty string");
            const o8 = bs(i10, r10);
            (!o8 || true === n9 || false !== i10[o8] && false !== n9) && (i10[o8 || t11] = Ns(e8));
          }
          return Wo.isPlainObject(e7) ? Wo.forEach(e7, (e8, n9) => {
            r9(e8, n9, t10);
          }) : r9(t10, e7, n8), this;
        }, get: function(e7, t10) {
          if (!(e7 = ws(e7)))
            return;
          const n8 = bs(this, e7);
          if (n8) {
            const e8 = this[n8];
            if (!t10)
              return e8;
            if (true === t10)
              return function(e9) {
                const t11 = /* @__PURE__ */ Object.create(null), n9 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                let i10;
                for (; i10 = n9.exec(e9); )
                  t11[i10[1]] = i10[2];
                return t11;
              }(e8);
            if (Wo.isFunction(t10))
              return t10.call(this, e8, n8);
            if (Wo.isRegExp(t10))
              return t10.exec(e8);
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }, has: function(e7, t10) {
          if (e7 = ws(e7)) {
            const n8 = bs(this, e7);
            return !(!n8 || t10 && !js(0, this[n8], n8, t10));
          }
          return false;
        }, delete: function(e7, t10) {
          const n8 = this;
          let i10 = false;
          function r9(e8) {
            if (e8 = ws(e8)) {
              const r10 = bs(n8, e8);
              !r10 || t10 && !js(0, n8[r10], r10, t10) || (delete n8[r10], i10 = true);
            }
          }
          return Wo.isArray(e7) ? e7.forEach(r9) : r9(e7), i10;
        }, clear: function() {
          return Object.keys(this).forEach(this.delete.bind(this));
        }, normalize: function(e7) {
          const t10 = this, n8 = {};
          return Wo.forEach(this, (i10, r9) => {
            const o8 = bs(n8, r9);
            if (o8)
              return t10[o8] = Ns(i10), void delete t10[r9];
            const s10 = e7 ? function(e8) {
              return e8.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e9, t11, n9) => t11.toUpperCase() + n9);
            }(r9) : String(r9).trim();
            s10 !== r9 && delete t10[r9], t10[s10] = Ns(i10), n8[s10] = true;
          }), this;
        }, toJSON: function(e7) {
          const t10 = /* @__PURE__ */ Object.create(null);
          return Wo.forEach(Object.assign({}, this[Is] || null, this), (n8, i10) => {
            null != n8 && false !== n8 && (t10[i10] = e7 && Wo.isArray(n8) ? n8.join(", ") : n8);
          }), t10;
        } }), Object.assign(Ds, { from: function(e7) {
          return Wo.isString(e7) ? new this(((e8) => {
            const t10 = {};
            let n8, i10, r9;
            return e8 && e8.split("\n").forEach(function(e9) {
              r9 = e9.indexOf(":"), n8 = e9.substring(0, r9).trim().toLowerCase(), i10 = e9.substring(r9 + 1).trim(), !n8 || t10[n8] && hs[n8] || ("set-cookie" === n8 ? t10[n8] ? t10[n8].push(i10) : t10[n8] = [i10] : t10[n8] = t10[n8] ? t10[n8] + ", " + i10 : i10);
            }), t10;
          })(e7)) : e7 instanceof this ? e7 : new this(e7);
        }, accessor: function(e7) {
          const t10 = (this[ys] = this[ys] = { accessors: {} }).accessors, n8 = this.prototype;
          function i10(e8) {
            const i11 = ws(e8);
            t10[i11] || (function(e9, t11) {
              const n9 = Wo.toCamelCase(" " + t11);
              ["get", "set", "has"].forEach((i12) => {
                Object.defineProperty(e9, i12 + n9, { value: function(e10, n10, r9) {
                  return this[i12].call(this, t11, e10, n10, r9);
                }, configurable: true });
              });
            }(n8, e8), t10[i11] = true);
          }
          return Wo.isArray(e7) ? e7.forEach(i10) : i10(e7), this;
        } }), Ds.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]), Wo.freezeMethods(Ds.prototype), Wo.freezeMethods(Ds);
        const xs = Ds, Ls = function(e7, t10) {
          e7 = e7 || 10;
          const n8 = new Array(e7), i10 = new Array(e7);
          let r9, o8 = 0, s10 = 0;
          return t10 = void 0 !== t10 ? t10 : 1e3, function(a8) {
            const l8 = Date.now(), c9 = i10[s10];
            r9 || (r9 = l8), n8[o8] = a8, i10[o8] = l8;
            let u7 = s10, d7 = 0;
            for (; u7 !== o8; )
              d7 += n8[u7++], u7 %= e7;
            if (o8 = (o8 + 1) % e7, o8 === s10 && (s10 = (s10 + 1) % e7), l8 - r9 < t10)
              return;
            const A6 = c9 && l8 - c9;
            return A6 ? Math.round(1e3 * d7 / A6) : void 0;
          };
        };
        function vs(e7, t10) {
          let n8 = 0;
          const i10 = Ls(50, 250);
          return (r9) => {
            const o8 = r9.loaded, s10 = r9.lengthComputable ? r9.total : void 0, a8 = o8 - n8, l8 = i10(a8);
            n8 = o8;
            const c9 = { loaded: o8, total: s10, progress: s10 ? o8 / s10 : void 0, bytes: a8, rate: l8 || void 0, estimated: l8 && s10 && o8 <= s10 ? (s10 - o8) / l8 : void 0 };
            c9[t10 ? "download" : "upload"] = true, e7(c9);
          };
        }
        function Ts(e7) {
          return new Promise(function(t10, n8) {
            let i10 = e7.data;
            const r9 = xs.from(e7.headers).normalize(), o8 = e7.responseType;
            let s10;
            function a8() {
              e7.cancelToken && e7.cancelToken.unsubscribe(s10), e7.signal && e7.signal.removeEventListener("abort", s10);
            }
            Wo.isFormData(i10) && ds.isStandardBrowserEnv && r9.setContentType(false);
            let l8 = new XMLHttpRequest();
            if (e7.auth) {
              const t11 = e7.auth.username || "", n9 = e7.auth.password ? unescape(encodeURIComponent(e7.auth.password)) : "";
              r9.set("Authorization", "Basic " + btoa(t11 + ":" + n9));
            }
            const c9 = ps(e7.baseURL, e7.url);
            function u7() {
              if (!l8)
                return;
              const i11 = xs.from("getAllResponseHeaders" in l8 && l8.getAllResponseHeaders());
              !function(e8, t11, n9) {
                const i12 = n9.config.validateStatus;
                n9.status && i12 && !i12(n9.status) ? t11(new Vo("Request failed with status code " + n9.status, [Vo.ERR_BAD_REQUEST, Vo.ERR_BAD_RESPONSE][Math.floor(n9.status / 100) - 4], n9.config, n9.request, n9)) : e8(n9);
              }(function(e8) {
                t10(e8), a8();
              }, function(e8) {
                n8(e8), a8();
              }, { data: o8 && "text" !== o8 && "json" !== o8 ? l8.response : l8.responseText, status: l8.status, statusText: l8.statusText, headers: i11, config: e7, request: l8 }), l8 = null;
            }
            if (l8.open(e7.method.toUpperCase(), os(c9, e7.params, e7.paramsSerializer), true), l8.timeout = e7.timeout, "onloadend" in l8 ? l8.onloadend = u7 : l8.onreadystatechange = function() {
              l8 && 4 === l8.readyState && (0 !== l8.status || l8.responseURL && 0 === l8.responseURL.indexOf("file:")) && setTimeout(u7);
            }, l8.onabort = function() {
              l8 && (n8(new Vo("Request aborted", Vo.ECONNABORTED, e7, l8)), l8 = null);
            }, l8.onerror = function() {
              n8(new Vo("Network Error", Vo.ERR_NETWORK, e7, l8)), l8 = null;
            }, l8.ontimeout = function() {
              let t11 = e7.timeout ? "timeout of " + e7.timeout + "ms exceeded" : "timeout exceeded";
              const i11 = e7.transitional || as;
              e7.timeoutErrorMessage && (t11 = e7.timeoutErrorMessage), n8(new Vo(t11, i11.clarifyTimeoutError ? Vo.ETIMEDOUT : Vo.ECONNABORTED, e7, l8)), l8 = null;
            }, ds.isStandardBrowserEnv) {
              const t11 = (e7.withCredentials || Ms(c9)) && e7.xsrfCookieName && gs.read(e7.xsrfCookieName);
              t11 && r9.set(e7.xsrfHeaderName, t11);
            }
            void 0 === i10 && r9.setContentType(null), "setRequestHeader" in l8 && Wo.forEach(r9.toJSON(), function(e8, t11) {
              l8.setRequestHeader(t11, e8);
            }), Wo.isUndefined(e7.withCredentials) || (l8.withCredentials = !!e7.withCredentials), o8 && "json" !== o8 && (l8.responseType = e7.responseType), "function" == typeof e7.onDownloadProgress && l8.addEventListener("progress", vs(e7.onDownloadProgress, true)), "function" == typeof e7.onUploadProgress && l8.upload && l8.upload.addEventListener("progress", vs(e7.onUploadProgress)), (e7.cancelToken || e7.signal) && (s10 = (t11) => {
              l8 && (n8(!t11 || t11.type ? new ms(null, e7, l8) : t11), l8.abort(), l8 = null);
            }, e7.cancelToken && e7.cancelToken.subscribe(s10), e7.signal && (e7.signal.aborted ? s10() : e7.signal.addEventListener("abort", s10)));
            const d7 = function(e8) {
              const t11 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e8);
              return t11 && t11[1] || "";
            }(c9);
            d7 && -1 === ds.protocols.indexOf(d7) ? n8(new Vo("Unsupported protocol " + d7 + ":", Vo.ERR_BAD_REQUEST, e7)) : l8.send(i10 || null);
          });
        }
        const zs = { http: Ts, xhr: Ts }, Cs = (e7) => {
          if (Wo.isString(e7)) {
            const t10 = zs[e7];
            if (!e7)
              throw Error(Wo.hasOwnProp(e7) ? `Adapter '${e7}' is not available in the build` : `Can not resolve adapter '${e7}'`);
            return t10;
          }
          if (!Wo.isFunction(e7))
            throw new TypeError("adapter is not a function");
          return e7;
        }, Ss = { "Content-Type": "application/x-www-form-urlencoded" }, Es = { transitional: as, adapter: function() {
          let e7;
          return "undefined" != typeof XMLHttpRequest ? e7 = Cs("xhr") : "undefined" != typeof process && "process" === Wo.kindOf(process) && (e7 = Cs("http")), e7;
        }(), transformRequest: [function(e7, t10) {
          const n8 = t10.getContentType() || "", i10 = n8.indexOf("application/json") > -1, r9 = Wo.isObject(e7);
          if (r9 && Wo.isHTMLForm(e7) && (e7 = new FormData(e7)), Wo.isFormData(e7))
            return i10 && i10 ? JSON.stringify(As(e7)) : e7;
          if (Wo.isArrayBuffer(e7) || Wo.isBuffer(e7) || Wo.isStream(e7) || Wo.isFile(e7) || Wo.isBlob(e7))
            return e7;
          if (Wo.isArrayBufferView(e7))
            return e7.buffer;
          if (Wo.isURLSearchParams(e7))
            return t10.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e7.toString();
          let o8;
          if (r9) {
            if (n8.indexOf("application/x-www-form-urlencoded") > -1)
              return function(e8, t11) {
                return $o(e8, new ds.classes.URLSearchParams(), Object.assign({ visitor: function(e9, t12, n9, i11) {
                  return ds.isNode && Wo.isBuffer(e9) ? (this.append(t12, e9.toString("base64")), false) : i11.defaultVisitor.apply(this, arguments);
                } }, t11));
              }(e7, this.formSerializer).toString();
            if ((o8 = Wo.isFileList(e7)) || n8.indexOf("multipart/form-data") > -1) {
              const t11 = this.env && this.env.FormData;
              return $o(o8 ? { "files[]": e7 } : e7, t11 && new t11(), this.formSerializer);
            }
          }
          return r9 || i10 ? (t10.setContentType("application/json", false), function(e8, t11, n9) {
            if (Wo.isString(e8))
              try {
                return (0, JSON.parse)(e8), Wo.trim(e8);
              } catch (e9) {
                if ("SyntaxError" !== e9.name)
                  throw e9;
              }
            return (0, JSON.stringify)(e8);
          }(e7)) : e7;
        }], transformResponse: [function(e7) {
          const t10 = this.transitional || Es.transitional, n8 = t10 && t10.forcedJSONParsing, i10 = "json" === this.responseType;
          if (e7 && Wo.isString(e7) && (n8 && !this.responseType || i10)) {
            const n9 = !(t10 && t10.silentJSONParsing) && i10;
            try {
              return JSON.parse(e7);
            } catch (e8) {
              if (n9) {
                if ("SyntaxError" === e8.name)
                  throw Vo.from(e8, Vo.ERR_BAD_RESPONSE, this, null, this.response);
                throw e8;
              }
            }
          }
          return e7;
        }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: ds.classes.FormData, Blob: ds.classes.Blob }, validateStatus: function(e7) {
          return e7 >= 200 && e7 < 300;
        }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
        Wo.forEach(["delete", "get", "head"], function(e7) {
          Es.headers[e7] = {};
        }), Wo.forEach(["post", "put", "patch"], function(e7) {
          Es.headers[e7] = Wo.merge(Ss);
        });
        const ks = Es;
        function Os(e7, t10) {
          const n8 = this || ks, i10 = t10 || n8, r9 = xs.from(i10.headers);
          let o8 = i10.data;
          return Wo.forEach(e7, function(e8) {
            o8 = e8.call(n8, o8, r9.normalize(), t10 ? t10.status : void 0);
          }), r9.normalize(), o8;
        }
        function Ps(e7) {
          return !(!e7 || !e7.__CANCEL__);
        }
        function Us(e7) {
          if (e7.cancelToken && e7.cancelToken.throwIfRequested(), e7.signal && e7.signal.aborted)
            throw new ms();
        }
        function Qs(e7) {
          return Us(e7), e7.headers = xs.from(e7.headers), e7.data = Os.call(e7, e7.transformRequest), (e7.adapter || ks.adapter)(e7).then(function(t10) {
            return Us(e7), t10.data = Os.call(e7, e7.transformResponse, t10), t10.headers = xs.from(t10.headers), t10;
          }, function(t10) {
            return Ps(t10) || (Us(e7), t10 && t10.response && (t10.response.data = Os.call(e7, e7.transformResponse, t10.response), t10.response.headers = xs.from(t10.response.headers))), Promise.reject(t10);
          });
        }
        function Rs(e7, t10) {
          t10 = t10 || {};
          const n8 = {};
          function i10(e8, t11) {
            return Wo.isPlainObject(e8) && Wo.isPlainObject(t11) ? Wo.merge(e8, t11) : Wo.isPlainObject(t11) ? Wo.merge({}, t11) : Wo.isArray(t11) ? t11.slice() : t11;
          }
          function r9(n9) {
            return Wo.isUndefined(t10[n9]) ? Wo.isUndefined(e7[n9]) ? void 0 : i10(void 0, e7[n9]) : i10(e7[n9], t10[n9]);
          }
          function o8(e8) {
            if (!Wo.isUndefined(t10[e8]))
              return i10(void 0, t10[e8]);
          }
          function s10(n9) {
            return Wo.isUndefined(t10[n9]) ? Wo.isUndefined(e7[n9]) ? void 0 : i10(void 0, e7[n9]) : i10(void 0, t10[n9]);
          }
          function a8(n9) {
            return n9 in t10 ? i10(e7[n9], t10[n9]) : n9 in e7 ? i10(void 0, e7[n9]) : void 0;
          }
          const l8 = { url: o8, method: o8, data: o8, baseURL: s10, transformRequest: s10, transformResponse: s10, paramsSerializer: s10, timeout: s10, timeoutMessage: s10, withCredentials: s10, adapter: s10, responseType: s10, xsrfCookieName: s10, xsrfHeaderName: s10, onUploadProgress: s10, onDownloadProgress: s10, decompress: s10, maxContentLength: s10, maxBodyLength: s10, beforeRedirect: s10, transport: s10, httpAgent: s10, httpsAgent: s10, cancelToken: s10, socketPath: s10, responseEncoding: s10, validateStatus: a8 };
          return Wo.forEach(Object.keys(e7).concat(Object.keys(t10)), function(e8) {
            const t11 = l8[e8] || r9, i11 = t11(e8);
            Wo.isUndefined(i11) && t11 !== a8 || (n8[e8] = i11);
          }), n8;
        }
        const Ys = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach((e7, t10) => {
          Ys[e7] = function(n8) {
            return typeof n8 === e7 || "a" + (t10 < 1 ? "n " : " ") + e7;
          };
        });
        const Zs = {};
        Ys.transitional = function(e7, t10, n8) {
          function i10(e8, t11) {
            return "[Axios v1.1.3] Transitional option '" + e8 + "'" + t11 + (n8 ? ". " + n8 : "");
          }
          return (n9, r9, o8) => {
            if (false === e7)
              throw new Vo(i10(r9, " has been removed" + (t10 ? " in " + t10 : "")), Vo.ERR_DEPRECATED);
            return t10 && !Zs[r9] && (Zs[r9] = true, console.warn(i10(r9, " has been deprecated since v" + t10 + " and will be removed in the near future"))), !e7 || e7(n9, r9, o8);
          };
        };
        const Bs = { assertOptions: function(e7, t10, n8) {
          if ("object" != typeof e7)
            throw new Vo("options must be an object", Vo.ERR_BAD_OPTION_VALUE);
          const i10 = Object.keys(e7);
          let r9 = i10.length;
          for (; r9-- > 0; ) {
            const o8 = i10[r9], s10 = t10[o8];
            if (s10) {
              const t11 = e7[o8], n9 = void 0 === t11 || s10(t11, o8, e7);
              if (true !== n9)
                throw new Vo("option " + o8 + " must be " + n9, Vo.ERR_BAD_OPTION_VALUE);
            } else if (true !== n8)
              throw new Vo("Unknown option " + o8, Vo.ERR_BAD_OPTION);
          }
        }, validators: Ys }, Ws = Bs.validators;
        class Gs {
          constructor(e7) {
            this.defaults = e7, this.interceptors = { request: new ss(), response: new ss() };
          }
          request(e7, t10) {
            "string" == typeof e7 ? (t10 = t10 || {}).url = e7 : t10 = e7 || {}, t10 = Rs(this.defaults, t10);
            const { transitional: n8, paramsSerializer: i10 } = t10;
            void 0 !== n8 && Bs.assertOptions(n8, { silentJSONParsing: Ws.transitional(Ws.boolean), forcedJSONParsing: Ws.transitional(Ws.boolean), clarifyTimeoutError: Ws.transitional(Ws.boolean) }, false), void 0 !== i10 && Bs.assertOptions(i10, { encode: Ws.function, serialize: Ws.function }, true), t10.method = (t10.method || this.defaults.method || "get").toLowerCase();
            const r9 = t10.headers && Wo.merge(t10.headers.common, t10.headers[t10.method]);
            r9 && Wo.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(e8) {
              delete t10.headers[e8];
            }), t10.headers = new xs(t10.headers, r9);
            const o8 = [];
            let s10 = true;
            this.interceptors.request.forEach(function(e8) {
              "function" == typeof e8.runWhen && false === e8.runWhen(t10) || (s10 = s10 && e8.synchronous, o8.unshift(e8.fulfilled, e8.rejected));
            });
            const a8 = [];
            let l8;
            this.interceptors.response.forEach(function(e8) {
              a8.push(e8.fulfilled, e8.rejected);
            });
            let c9, u7 = 0;
            if (!s10) {
              const e8 = [Qs.bind(this), void 0];
              for (e8.unshift.apply(e8, o8), e8.push.apply(e8, a8), c9 = e8.length, l8 = Promise.resolve(t10); u7 < c9; )
                l8 = l8.then(e8[u7++], e8[u7++]);
              return l8;
            }
            c9 = o8.length;
            let d7 = t10;
            for (u7 = 0; u7 < c9; ) {
              const e8 = o8[u7++], t11 = o8[u7++];
              try {
                d7 = e8(d7);
              } catch (e9) {
                t11.call(this, e9);
                break;
              }
            }
            try {
              l8 = Qs.call(this, d7);
            } catch (e8) {
              return Promise.reject(e8);
            }
            for (u7 = 0, c9 = a8.length; u7 < c9; )
              l8 = l8.then(a8[u7++], a8[u7++]);
            return l8;
          }
          getUri(e7) {
            return os(ps((e7 = Rs(this.defaults, e7)).baseURL, e7.url), e7.params, e7.paramsSerializer);
          }
        }
        Wo.forEach(["delete", "get", "head", "options"], function(e7) {
          Gs.prototype[e7] = function(t10, n8) {
            return this.request(Rs(n8 || {}, { method: e7, url: t10, data: (n8 || {}).data }));
          };
        }), Wo.forEach(["post", "put", "patch"], function(e7) {
          function t10(t11) {
            return function(n8, i10, r9) {
              return this.request(Rs(r9 || {}, { method: e7, headers: t11 ? { "Content-Type": "multipart/form-data" } : {}, url: n8, data: i10 }));
            };
          }
          Gs.prototype[e7] = t10(), Gs.prototype[e7 + "Form"] = t10(true);
        });
        const Hs = Gs;
        class _s {
          constructor(e7) {
            if ("function" != typeof e7)
              throw new TypeError("executor must be a function.");
            let t10;
            this.promise = new Promise(function(e8) {
              t10 = e8;
            });
            const n8 = this;
            this.promise.then((e8) => {
              if (!n8._listeners)
                return;
              let t11 = n8._listeners.length;
              for (; t11-- > 0; )
                n8._listeners[t11](e8);
              n8._listeners = null;
            }), this.promise.then = (e8) => {
              let t11;
              const i10 = new Promise((e9) => {
                n8.subscribe(e9), t11 = e9;
              }).then(e8);
              return i10.cancel = function() {
                n8.unsubscribe(t11);
              }, i10;
            }, e7(function(e8, i10, r9) {
              n8.reason || (n8.reason = new ms(e8, i10, r9), t10(n8.reason));
            });
          }
          throwIfRequested() {
            if (this.reason)
              throw this.reason;
          }
          subscribe(e7) {
            this.reason ? e7(this.reason) : this._listeners ? this._listeners.push(e7) : this._listeners = [e7];
          }
          unsubscribe(e7) {
            if (!this._listeners)
              return;
            const t10 = this._listeners.indexOf(e7);
            -1 !== t10 && this._listeners.splice(t10, 1);
          }
          static source() {
            let e7;
            return { token: new _s(function(t10) {
              e7 = t10;
            }), cancel: e7 };
          }
        }
        const Vs = _s, Fs = function e7(t10) {
          const n8 = new Hs(t10), i10 = fo(Hs.prototype.request, n8);
          return Wo.extend(i10, Hs.prototype, n8, { allOwnKeys: true }), Wo.extend(i10, n8, null, { allOwnKeys: true }), i10.create = function(n9) {
            return e7(Rs(t10, n9));
          }, i10;
        }(ks);
        Fs.Axios = Hs, Fs.CanceledError = ms, Fs.CancelToken = Vs, Fs.isCancel = Ps, Fs.VERSION = "1.1.3", Fs.toFormData = $o, Fs.AxiosError = Vo, Fs.Cancel = Fs.CanceledError, Fs.all = function(e7) {
          return Promise.all(e7);
        }, Fs.spread = function(e7) {
          return function(t10) {
            return e7.apply(null, t10);
          };
        }, Fs.isAxiosError = function(e7) {
          return Wo.isObject(e7) && true === e7.isAxiosError;
        }, Fs.formToJSON = (e7) => As(Wo.isHTMLForm(e7) ? new FormData(e7) : e7);
        const Js = Fs, { Axios: Xs, AxiosError: Ks, CanceledError: qs, isCancel: $s, CancelToken: ea, VERSION: ta, all: na, Cancel: ia, isAxiosError: ra, spread: oa, toFormData: sa } = Js, aa = Js;
        function la(e7) {
          const t10 = {};
          return e7.forEach((e8) => {
            t10[e8.field] = e8.message;
          }), t10;
        }
        function ca() {
          return "undefined" != typeof navigator && "undefined" != typeof window ? window : void 0 !== n7.g ? n7.g : {};
        }
        const ua = "function" == typeof Proxy, da = "devtools-plugin:setup";
        let Aa, ga;
        class pa {
          constructor(e7, t10) {
            this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e7, this.hook = t10;
            const i10 = {};
            if (e7.settings)
              for (const t11 in e7.settings) {
                const n8 = e7.settings[t11];
                i10[t11] = n8.defaultValue;
              }
            const r9 = `__vue-devtools-plugin-settings__${e7.id}`;
            let o8 = Object.assign({}, i10);
            try {
              const e8 = localStorage.getItem(r9), t11 = JSON.parse(e8);
              Object.assign(o8, t11);
            } catch (e8) {
            }
            this.fallbacks = { getSettings: () => o8, setSettings(e8) {
              try {
                localStorage.setItem(r9, JSON.stringify(e8));
              } catch (e9) {
              }
              o8 = e8;
            }, now: () => function() {
              var e8;
              return void 0 !== Aa || ("undefined" != typeof window && window.performance ? (Aa = true, ga = window.performance) : void 0 !== n7.g && (null === (e8 = n7.g.perf_hooks) || void 0 === e8 ? void 0 : e8.performance) ? (Aa = true, ga = n7.g.perf_hooks.performance) : Aa = false), Aa;
            }() ? ga.now() : Date.now() }, t10 && t10.on("plugin:settings:set", (e8, t11) => {
              e8 === this.plugin.id && this.fallbacks.setSettings(t11);
            }), this.proxiedOn = new Proxy({}, { get: (e8, t11) => this.target ? this.target.on[t11] : (...e9) => {
              this.onQueue.push({ method: t11, args: e9 });
            } }), this.proxiedTarget = new Proxy({}, { get: (e8, t11) => this.target ? this.target[t11] : "on" === t11 ? this.proxiedOn : Object.keys(this.fallbacks).includes(t11) ? (...e9) => (this.targetQueue.push({ method: t11, args: e9, resolve: () => {
            } }), this.fallbacks[t11](...e9)) : (...e9) => new Promise((n8) => {
              this.targetQueue.push({ method: t11, args: e9, resolve: n8 });
            }) });
          }
          async setRealTarget(e7) {
            this.target = e7;
            for (const e8 of this.onQueue)
              this.target.on[e8.method](...e8.args);
            for (const e8 of this.targetQueue)
              e8.resolve(await this.target[e8.method](...e8.args));
          }
        }
        function Ma(e7, t10) {
          Object.keys(e7).forEach(function(n8) {
            return t10(e7[n8], n8);
          });
        }
        function fa(e7) {
          return null !== e7 && "object" == typeof e7;
        }
        function ma(e7, t10, n8) {
          return t10.indexOf(e7) < 0 && (n8 && n8.prepend ? t10.unshift(e7) : t10.push(e7)), function() {
            var n9 = t10.indexOf(e7);
            n9 > -1 && t10.splice(n9, 1);
          };
        }
        function ha(e7, t10) {
          e7._actions = /* @__PURE__ */ Object.create(null), e7._mutations = /* @__PURE__ */ Object.create(null), e7._wrappedGetters = /* @__PURE__ */ Object.create(null), e7._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
          var n8 = e7.state;
          Ia(e7, n8, [], e7._modules.root, true), ya(e7, n8, t10);
        }
        function ya(e7, t10, n8) {
          var i10 = e7._state, r9 = e7._scope;
          e7.getters = {}, e7._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
          var o8 = e7._wrappedGetters, s10 = {}, a8 = {}, l8 = new ee3(true);
          l8.run(function() {
            Ma(o8, function(t11, n9) {
              s10[n9] = /* @__PURE__ */ function(e8, t12) {
                return function() {
                  return e8(t12);
                };
              }(t11, e7), a8[n9] = vr(function() {
                return s10[n9]();
              }), Object.defineProperty(e7.getters, n9, { get: function() {
                return a8[n9].value;
              }, enumerable: true });
            });
          }), e7._state = ot2({ data: t10 }), e7._scope = l8, e7.strict && function(e8) {
            hn(function() {
              return e8._state.data;
            }, function() {
            }, { deep: true, flush: "sync" });
          }(e7), i10 && n8 && e7._withCommit(function() {
            i10.data = null;
          }), r9 && r9.stop();
        }
        function Ia(e7, t10, n8, i10, r9) {
          var o8 = !n8.length, s10 = e7._modules.getNamespace(n8);
          if (i10.namespaced && (e7._modulesNamespaceMap[s10], e7._modulesNamespaceMap[s10] = i10), !o8 && !r9) {
            var a8 = Na(t10, n8.slice(0, -1)), l8 = n8[n8.length - 1];
            e7._withCommit(function() {
              a8[l8] = i10.state;
            });
          }
          var c9 = i10.context = function(e8, t11, n9) {
            var i11 = "" === t11, r10 = { dispatch: i11 ? e8.dispatch : function(n10, i12, r11) {
              var o9 = ja(n10, i12, r11), s11 = o9.payload, a9 = o9.options, l9 = o9.type;
              return a9 && a9.root || (l9 = t11 + l9), e8.dispatch(l9, s11);
            }, commit: i11 ? e8.commit : function(n10, i12, r11) {
              var o9 = ja(n10, i12, r11), s11 = o9.payload, a9 = o9.options, l9 = o9.type;
              a9 && a9.root || (l9 = t11 + l9), e8.commit(l9, s11, a9);
            } };
            return Object.defineProperties(r10, { getters: { get: i11 ? function() {
              return e8.getters;
            } : function() {
              return wa(e8, t11);
            } }, state: { get: function() {
              return Na(e8.state, n9);
            } } }), r10;
          }(e7, s10, n8);
          i10.forEachMutation(function(t11, n9) {
            !function(e8, t12, n10, i11) {
              (e8._mutations[t12] || (e8._mutations[t12] = [])).push(function(t13) {
                n10.call(e8, i11.state, t13);
              });
            }(e7, s10 + n9, t11, c9);
          }), i10.forEachAction(function(t11, n9) {
            var i11 = t11.root ? n9 : s10 + n9, r10 = t11.handler || t11;
            !function(e8, t12, n10, i12) {
              (e8._actions[t12] || (e8._actions[t12] = [])).push(function(t13) {
                var r11, o9 = n10.call(e8, { dispatch: i12.dispatch, commit: i12.commit, getters: i12.getters, state: i12.state, rootGetters: e8.getters, rootState: e8.state }, t13);
                return (r11 = o9) && "function" == typeof r11.then || (o9 = Promise.resolve(o9)), e8._devtoolHook ? o9.catch(function(t14) {
                  throw e8._devtoolHook.emit("vuex:error", t14), t14;
                }) : o9;
              });
            }(e7, i11, r10, c9);
          }), i10.forEachGetter(function(t11, n9) {
            !function(e8, t12, n10, i11) {
              e8._wrappedGetters[t12] || (e8._wrappedGetters[t12] = function(e9) {
                return n10(i11.state, i11.getters, e9.state, e9.getters);
              });
            }(e7, s10 + n9, t11, c9);
          }), i10.forEachChild(function(i11, o9) {
            Ia(e7, t10, n8.concat(o9), i11, r9);
          });
        }
        function wa(e7, t10) {
          if (!e7._makeLocalGettersCache[t10]) {
            var n8 = {}, i10 = t10.length;
            Object.keys(e7.getters).forEach(function(r9) {
              if (r9.slice(0, i10) === t10) {
                var o8 = r9.slice(i10);
                Object.defineProperty(n8, o8, { get: function() {
                  return e7.getters[r9];
                }, enumerable: true });
              }
            }), e7._makeLocalGettersCache[t10] = n8;
          }
          return e7._makeLocalGettersCache[t10];
        }
        function Na(e7, t10) {
          return t10.reduce(function(e8, t11) {
            return e8[t11];
          }, e7);
        }
        function ja(e7, t10, n8) {
          return fa(e7) && e7.type && (n8 = t10, t10 = e7, e7 = e7.type), { type: e7, payload: t10, options: n8 };
        }
        var ba = "vuex:mutations", Da = "vuex:actions", xa = "vuex", La = 0;
        function va(e7, t10) {
          !function(e8, t11) {
            const n8 = e8, i10 = ca(), r9 = ca().__VUE_DEVTOOLS_GLOBAL_HOOK__, o8 = ua && n8.enableEarlyProxy;
            if (!r9 || !i10.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ && o8) {
              const e9 = o8 ? new pa(n8, r9) : null;
              (i10.__VUE_DEVTOOLS_PLUGINS__ = i10.__VUE_DEVTOOLS_PLUGINS__ || []).push({ pluginDescriptor: n8, setupFn: t11, proxy: e9 }), e9 && t11(e9.proxiedTarget);
            } else
              r9.emit(da, e8, t11);
          }({ id: "org.vuejs.vuex", app: e7, label: "Vuex", homepage: "https://next.vuex.vuejs.org/", logo: "https://vuejs.org/images/icons/favicon-96x96.png", packageName: "vuex", componentStateTypes: ["vuex bindings"] }, function(n8) {
            n8.addTimelineLayer({ id: ba, label: "Vuex Mutations", color: Ta }), n8.addTimelineLayer({ id: Da, label: "Vuex Actions", color: Ta }), n8.addInspector({ id: xa, label: "Vuex", icon: "storage", treeFilterPlaceholder: "Filter stores..." }), n8.on.getInspectorTree(function(n9) {
              if (n9.app === e7 && n9.inspectorId === xa)
                if (n9.filter) {
                  var i10 = [];
                  Ea(i10, t10._modules.root, n9.filter, ""), n9.rootNodes = i10;
                } else
                  n9.rootNodes = [Sa(t10._modules.root, "")];
            }), n8.on.getInspectorState(function(n9) {
              if (n9.app === e7 && n9.inspectorId === xa) {
                var i10 = n9.nodeId;
                wa(t10, i10), n9.state = function(e8, t11, n10) {
                  t11 = "root" === n10 ? t11 : t11[n10];
                  var i11 = Object.keys(t11), r10 = { state: Object.keys(e8.state).map(function(t12) {
                    return { key: t12, editable: true, value: e8.state[t12] };
                  }) };
                  if (i11.length) {
                    var o9 = function(e9) {
                      var t12 = {};
                      return Object.keys(e9).forEach(function(n11) {
                        var i12 = n11.split("/");
                        if (i12.length > 1) {
                          var r11 = t12, o10 = i12.pop();
                          i12.forEach(function(e10) {
                            r11[e10] || (r11[e10] = { _custom: { value: {}, display: e10, tooltip: "Module", abstract: true } }), r11 = r11[e10]._custom.value;
                          }), r11[o10] = ka(function() {
                            return e9[n11];
                          });
                        } else
                          t12[n11] = ka(function() {
                            return e9[n11];
                          });
                      }), t12;
                    }(t11);
                    r10.getters = Object.keys(o9).map(function(e9) {
                      return { key: e9.endsWith("/") ? Ca(e9) : e9, editable: false, value: ka(function() {
                        return o9[e9];
                      }) };
                    });
                  }
                  return r10;
                }((r9 = t10._modules, (s10 = (o8 = i10).split("/").filter(function(e8) {
                  return e8;
                })).reduce(function(e8, t11, n10) {
                  var i11 = e8[t11];
                  if (!i11)
                    throw new Error('Missing module "' + t11 + '" for path "' + o8 + '".');
                  return n10 === s10.length - 1 ? i11 : i11._children;
                }, "root" === o8 ? r9 : r9.root._children)), "root" === i10 ? t10.getters : t10._makeLocalGettersCache, i10);
              }
              var r9, o8, s10;
            }), n8.on.editInspectorState(function(n9) {
              if (n9.app === e7 && n9.inspectorId === xa) {
                var i10 = n9.nodeId, r9 = n9.path;
                "root" !== i10 && (r9 = i10.split("/").filter(Boolean).concat(r9)), t10._withCommit(function() {
                  n9.set(t10._state.data, r9, n9.state.value);
                });
              }
            }), t10.subscribe(function(e8, t11) {
              var i10 = {};
              e8.payload && (i10.payload = e8.payload), i10.state = t11, n8.notifyComponentUpdate(), n8.sendInspectorTree(xa), n8.sendInspectorState(xa), n8.addTimelineEvent({ layerId: ba, event: { time: Date.now(), title: e8.type, data: i10 } });
            }), t10.subscribeAction({ before: function(e8, t11) {
              var i10 = {};
              e8.payload && (i10.payload = e8.payload), e8._id = La++, e8._time = Date.now(), i10.state = t11, n8.addTimelineEvent({ layerId: Da, event: { time: e8._time, title: e8.type, groupId: e8._id, subtitle: "start", data: i10 } });
            }, after: function(e8, t11) {
              var i10 = {}, r9 = Date.now() - e8._time;
              i10.duration = { _custom: { type: "duration", display: r9 + "ms", tooltip: "Action duration", value: r9 } }, e8.payload && (i10.payload = e8.payload), i10.state = t11, n8.addTimelineEvent({ layerId: Da, event: { time: Date.now(), title: e8.type, groupId: e8._id, subtitle: "end", data: i10 } });
            } });
          });
        }
        var Ta = 8702998, za = { label: "namespaced", textColor: 16777215, backgroundColor: 6710886 };
        function Ca(e7) {
          return e7 && "root" !== e7 ? e7.split("/").slice(-2, -1)[0] : "Root";
        }
        function Sa(e7, t10) {
          return { id: t10 || "root", label: Ca(t10), tags: e7.namespaced ? [za] : [], children: Object.keys(e7._children).map(function(n8) {
            return Sa(e7._children[n8], t10 + n8 + "/");
          }) };
        }
        function Ea(e7, t10, n8, i10) {
          i10.includes(n8) && e7.push({ id: i10 || "root", label: i10.endsWith("/") ? i10.slice(0, i10.length - 1) : i10 || "Root", tags: t10.namespaced ? [za] : [] }), Object.keys(t10._children).forEach(function(r9) {
            Ea(e7, t10._children[r9], n8, i10 + r9 + "/");
          });
        }
        function ka(e7) {
          try {
            return e7();
          } catch (e8) {
            return e8;
          }
        }
        var Oa = function(e7, t10) {
          this.runtime = t10, this._children = /* @__PURE__ */ Object.create(null), this._rawModule = e7;
          var n8 = e7.state;
          this.state = ("function" == typeof n8 ? n8() : n8) || {};
        }, Pa = { namespaced: { configurable: true } };
        Pa.namespaced.get = function() {
          return !!this._rawModule.namespaced;
        }, Oa.prototype.addChild = function(e7, t10) {
          this._children[e7] = t10;
        }, Oa.prototype.removeChild = function(e7) {
          delete this._children[e7];
        }, Oa.prototype.getChild = function(e7) {
          return this._children[e7];
        }, Oa.prototype.hasChild = function(e7) {
          return e7 in this._children;
        }, Oa.prototype.update = function(e7) {
          this._rawModule.namespaced = e7.namespaced, e7.actions && (this._rawModule.actions = e7.actions), e7.mutations && (this._rawModule.mutations = e7.mutations), e7.getters && (this._rawModule.getters = e7.getters);
        }, Oa.prototype.forEachChild = function(e7) {
          Ma(this._children, e7);
        }, Oa.prototype.forEachGetter = function(e7) {
          this._rawModule.getters && Ma(this._rawModule.getters, e7);
        }, Oa.prototype.forEachAction = function(e7) {
          this._rawModule.actions && Ma(this._rawModule.actions, e7);
        }, Oa.prototype.forEachMutation = function(e7) {
          this._rawModule.mutations && Ma(this._rawModule.mutations, e7);
        }, Object.defineProperties(Oa.prototype, Pa);
        var Ua = function(e7) {
          this.register([], e7, false);
        };
        function Qa(e7, t10, n8) {
          if (t10.update(n8), n8.modules)
            for (var i10 in n8.modules) {
              if (!t10.getChild(i10))
                return;
              Qa(e7.concat(i10), t10.getChild(i10), n8.modules[i10]);
            }
        }
        Ua.prototype.get = function(e7) {
          return e7.reduce(function(e8, t10) {
            return e8.getChild(t10);
          }, this.root);
        }, Ua.prototype.getNamespace = function(e7) {
          var t10 = this.root;
          return e7.reduce(function(e8, n8) {
            return e8 + ((t10 = t10.getChild(n8)).namespaced ? n8 + "/" : "");
          }, "");
        }, Ua.prototype.update = function(e7) {
          Qa([], this.root, e7);
        }, Ua.prototype.register = function(e7, t10, n8) {
          var i10 = this;
          void 0 === n8 && (n8 = true);
          var r9 = new Oa(t10, n8);
          0 === e7.length ? this.root = r9 : this.get(e7.slice(0, -1)).addChild(e7[e7.length - 1], r9), t10.modules && Ma(t10.modules, function(t11, r10) {
            i10.register(e7.concat(r10), t11, n8);
          });
        }, Ua.prototype.unregister = function(e7) {
          var t10 = this.get(e7.slice(0, -1)), n8 = e7[e7.length - 1], i10 = t10.getChild(n8);
          i10 && i10.runtime && t10.removeChild(n8);
        }, Ua.prototype.isRegistered = function(e7) {
          var t10 = this.get(e7.slice(0, -1)), n8 = e7[e7.length - 1];
          return !!t10 && t10.hasChild(n8);
        };
        var Ra = function(e7) {
          var t10 = this;
          void 0 === e7 && (e7 = {});
          var n8 = e7.plugins;
          void 0 === n8 && (n8 = []);
          var i10 = e7.strict;
          void 0 === i10 && (i10 = false);
          var r9 = e7.devtools;
          this._committing = false, this._actions = /* @__PURE__ */ Object.create(null), this._actionSubscribers = [], this._mutations = /* @__PURE__ */ Object.create(null), this._wrappedGetters = /* @__PURE__ */ Object.create(null), this._modules = new Ua(e7), this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null), this._subscribers = [], this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null), this._scope = null, this._devtools = r9;
          var o8 = this, s10 = this.dispatch, a8 = this.commit;
          this.dispatch = function(e8, t11) {
            return s10.call(o8, e8, t11);
          }, this.commit = function(e8, t11, n9) {
            return a8.call(o8, e8, t11, n9);
          }, this.strict = i10;
          var l8 = this._modules.root.state;
          Ia(this, l8, [], this._modules.root), ya(this, l8), n8.forEach(function(e8) {
            return e8(t10);
          });
        }, Ya = { state: { configurable: true } };
        function Za(e7) {
          return function(e8) {
            return Array.isArray(e8) || fa(e8);
          }(e7) ? Array.isArray(e7) ? e7.map(function(e8) {
            return { key: e8, val: e8 };
          }) : Object.keys(e7).map(function(t10) {
            return { key: t10, val: e7[t10] };
          }) : [];
        }
        function Ba(e7) {
          return function(t10, n8) {
            return "string" != typeof t10 ? (n8 = t10, t10 = "") : "/" !== t10.charAt(t10.length - 1) && (t10 += "/"), e7(t10, n8);
          };
        }
        function Wa(e7, t10, n8) {
          return e7._modulesNamespaceMap[n8];
        }
        function Ga() {
          const e7 = document.URL.split("#");
          return e7.length > 1 ? e7[1] : null;
        }
        Ra.prototype.install = function(e7, t10) {
          e7.provide(t10 || "store", this), e7.config.globalProperties.$store = this, (void 0 !== this._devtools ? this._devtools : __VUE_PROD_DEVTOOLS__) && va(e7, this);
        }, Ya.state.get = function() {
          return this._state.data;
        }, Ya.state.set = function(e7) {
        }, Ra.prototype.commit = function(e7, t10, n8) {
          var i10 = this, r9 = ja(e7, t10, n8), o8 = r9.type, s10 = r9.payload, a8 = (r9.options, { type: o8, payload: s10 }), l8 = this._mutations[o8];
          l8 && (this._withCommit(function() {
            l8.forEach(function(e8) {
              e8(s10);
            });
          }), this._subscribers.slice().forEach(function(e8) {
            return e8(a8, i10.state);
          }));
        }, Ra.prototype.dispatch = function(e7, t10) {
          var n8 = this, i10 = ja(e7, t10), r9 = i10.type, o8 = i10.payload, s10 = { type: r9, payload: o8 }, a8 = this._actions[r9];
          if (a8) {
            try {
              this._actionSubscribers.slice().filter(function(e8) {
                return e8.before;
              }).forEach(function(e8) {
                return e8.before(s10, n8.state);
              });
            } catch (e8) {
            }
            var l8 = a8.length > 1 ? Promise.all(a8.map(function(e8) {
              return e8(o8);
            })) : a8[0](o8);
            return new Promise(function(e8, t11) {
              l8.then(function(t12) {
                try {
                  n8._actionSubscribers.filter(function(e9) {
                    return e9.after;
                  }).forEach(function(e9) {
                    return e9.after(s10, n8.state);
                  });
                } catch (e9) {
                }
                e8(t12);
              }, function(e9) {
                try {
                  n8._actionSubscribers.filter(function(e10) {
                    return e10.error;
                  }).forEach(function(t12) {
                    return t12.error(s10, n8.state, e9);
                  });
                } catch (e10) {
                }
                t11(e9);
              });
            });
          }
        }, Ra.prototype.subscribe = function(e7, t10) {
          return ma(e7, this._subscribers, t10);
        }, Ra.prototype.subscribeAction = function(e7, t10) {
          return ma("function" == typeof e7 ? { before: e7 } : e7, this._actionSubscribers, t10);
        }, Ra.prototype.watch = function(e7, t10, n8) {
          var i10 = this;
          return hn(function() {
            return e7(i10.state, i10.getters);
          }, t10, Object.assign({}, n8));
        }, Ra.prototype.replaceState = function(e7) {
          var t10 = this;
          this._withCommit(function() {
            t10._state.data = e7;
          });
        }, Ra.prototype.registerModule = function(e7, t10, n8) {
          void 0 === n8 && (n8 = {}), "string" == typeof e7 && (e7 = [e7]), this._modules.register(e7, t10), Ia(this, this.state, e7, this._modules.get(e7), n8.preserveState), ya(this, this.state);
        }, Ra.prototype.unregisterModule = function(e7) {
          var t10 = this;
          "string" == typeof e7 && (e7 = [e7]), this._modules.unregister(e7), this._withCommit(function() {
            delete Na(t10.state, e7.slice(0, -1))[e7[e7.length - 1]];
          }), ha(this);
        }, Ra.prototype.hasModule = function(e7) {
          return "string" == typeof e7 && (e7 = [e7]), this._modules.isRegistered(e7);
        }, Ra.prototype.hotUpdate = function(e7) {
          this._modules.update(e7), ha(this, true);
        }, Ra.prototype._withCommit = function(e7) {
          var t10 = this._committing;
          this._committing = true, e7(), this._committing = t10;
        }, Object.defineProperties(Ra.prototype, Ya), Ba(function(e7, t10) {
          var n8 = {};
          return Za(t10).forEach(function(t11) {
            var i10 = t11.key, r9 = t11.val;
            n8[i10] = function() {
              var t12 = this.$store.state, n9 = this.$store.getters;
              if (e7) {
                var i11 = Wa(this.$store, 0, e7);
                if (!i11)
                  return;
                t12 = i11.context.state, n9 = i11.context.getters;
              }
              return "function" == typeof r9 ? r9.call(this, t12, n9) : t12[r9];
            }, n8[i10].vuex = true;
          }), n8;
        }), Ba(function(e7, t10) {
          var n8 = {};
          return Za(t10).forEach(function(t11) {
            var i10 = t11.key, r9 = t11.val;
            n8[i10] = function() {
              for (var t12 = [], n9 = arguments.length; n9--; )
                t12[n9] = arguments[n9];
              var i11 = this.$store.commit;
              if (e7) {
                var o8 = Wa(this.$store, 0, e7);
                if (!o8)
                  return;
                i11 = o8.context.commit;
              }
              return "function" == typeof r9 ? r9.apply(this, [i11].concat(t12)) : i11.apply(this.$store, [r9].concat(t12));
            };
          }), n8;
        }), Ba(function(e7, t10) {
          var n8 = {};
          return Za(t10).forEach(function(t11) {
            var i10 = t11.key, r9 = t11.val;
            r9 = e7 + r9, n8[i10] = function() {
              if (!e7 || Wa(this.$store, 0, e7))
                return this.$store.getters[r9];
            }, n8[i10].vuex = true;
          }), n8;
        }), Ba(function(e7, t10) {
          var n8 = {};
          return Za(t10).forEach(function(t11) {
            var i10 = t11.key, r9 = t11.val;
            n8[i10] = function() {
              for (var t12 = [], n9 = arguments.length; n9--; )
                t12[n9] = arguments[n9];
              var i11 = this.$store.dispatch;
              if (e7) {
                var o8 = Wa(this.$store, 0, e7);
                if (!o8)
                  return;
                i11 = o8.context.dispatch;
              }
              return "function" == typeof r9 ? r9.apply(this, [i11].concat(t12)) : i11.apply(this.$store, [r9].concat(t12));
            };
          }), n8;
        });
        const Ha = { state: () => ({ currentPage: Ga(), companyImageUrl: "", context: "" }), mutations: { switchPage(e7, t10) {
          window.history.pushState("", "", "#" + t10), e7.currentPage = t10;
        }, setCompanyImageUrl(e7, t10) {
          e7.companyImageUrl = t10;
        }, setContext(e7, t10) {
          e7.context = t10;
        } } };
        function _a3(e7) {
          "" !== e7 && void 0 !== e7 && (localStorage ? localStorage.setItem("cbo_long_session", e7) : console.error("No localstorage available"));
        }
        const Va = new function() {
          let e7 = aa.create({ headers: { "X-Corbado-WC-Version": "1.0.104", "Cache-Control": "no-cache", Pragma: "no-cache", Expires: "0" }, params: { t: (/* @__PURE__ */ new Date()).getTime() } });
          this.configure = (t10) => {
            e7 = t10(e7);
          }, this.get = () => {
            const t10 = localStorage ? localStorage.getItem("cbo_long_session") ?? "" : (console.error("No localstorage available"), "");
            return e7.defaults.headers.common["X-Corbado-Mode"] = Sl.state.webComponent.mode, "" !== t10 && (e7.defaults.headers.common.Authorization = "Bearer " + t10), e7;
          };
        }();
        function Fa(e7) {
          for (var t10 = 1; t10 < arguments.length; t10++) {
            var n8 = arguments[t10];
            for (var i10 in n8)
              e7[i10] = n8[i10];
          }
          return e7;
        }
        var Ja = function e7(t10, n8) {
          function i10(e8, i11, r9) {
            if ("undefined" != typeof document) {
              "number" == typeof (r9 = Fa({}, n8, r9)).expires && (r9.expires = new Date(Date.now() + 864e5 * r9.expires)), r9.expires && (r9.expires = r9.expires.toUTCString()), e8 = encodeURIComponent(e8).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
              var o8 = "";
              for (var s10 in r9)
                r9[s10] && (o8 += "; " + s10, true !== r9[s10] && (o8 += "=" + r9[s10].split(";")[0]));
              return document.cookie = e8 + "=" + t10.write(i11, e8) + o8;
            }
          }
          return Object.create({ set: i10, get: function(e8) {
            if ("undefined" != typeof document && (!arguments.length || e8)) {
              for (var n9 = document.cookie ? document.cookie.split("; ") : [], i11 = {}, r9 = 0; r9 < n9.length; r9++) {
                var o8 = n9[r9].split("="), s10 = o8.slice(1).join("=");
                try {
                  var a8 = decodeURIComponent(o8[0]);
                  if (i11[a8] = t10.read(s10, a8), e8 === a8)
                    break;
                } catch (e9) {
                }
              }
              return e8 ? i11[e8] : i11;
            }
          }, remove: function(e8, t11) {
            i10(e8, "", Fa({}, t11, { expires: -1 }));
          }, withAttributes: function(t11) {
            return e7(this.converter, Fa({}, this.attributes, t11));
          }, withConverter: function(t11) {
            return e7(Fa({}, this.converter, t11), this.attributes);
          } }, { attributes: { value: Object.freeze(n8) }, converter: { value: Object.freeze(t10) } });
        }({ read: function(e7) {
          return '"' === e7[0] && (e7 = e7.slice(1, -1)), e7.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
        }, write: function(e7) {
          return encodeURIComponent(e7).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
        } }, { path: "/" });
        const Xa = Ja;
        function Ka(e7) {
          var t10;
          e7.shortSession && (t10 = e7.shortSession, Xa.set(t10.key, t10.value, { path: t10.path, expires: new Date(t10.expires), secure: t10.secure, sameSite: t10.sameSite, domain: t10.domain }));
        }
        function qa(e7) {
          const t10 = document.cookie.match("(^|;)\\s*" + e7 + "\\s*=\\s*([^;]+)");
          return t10 ? t10.pop() : "";
        }
        class $a {
          constructor(e7) {
            this._errorHandler = e7;
          }
          tokenFieldName = "accessToken";
          userDataFieldName = "userData";
          CreateSession(e7, t10) {
            localStorage.setItem(this.tokenFieldName, e7), localStorage.setItem(this.userDataFieldName, JSON.stringify(t10));
          }
          AuthMethods(e7) {
            return El(Va.get().post("/v1/users/authmethods", { username: e7 }), this._errorHandler).then((e8) => e8.data.data);
          }
          ProjectConfig() {
            return El(Va.get().get("/v1/projects/projectConfig"), this._errorHandler).then((e7) => e7.data.data);
          }
          LoginToken(e7) {
            return El(Va.get().post("/v1/users/logintoken", { token: e7 }), this._errorHandler).then((e8) => (Ka(e8.data.data), _a3(e8.data.data.longSession), { sessionToken: e8.data.data.sessionToken, redirectURL: e8.data.data.redirectURL, authMethods: e8.data.data.authMethods }));
          }
          DevicePasskey(e7, t10) {
            return El(Va.get().post("/v1/users/device/passkey", { loginIdentifier: e7, loginIdentifierType: t10 }), this._errorHandler);
          }
        }
        function el(e7) {
          const t10 = "==".slice(0, (4 - e7.length % 4) % 4), n8 = e7.replace(/-/g, "+").replace(/_/g, "/") + t10, i10 = atob(n8), r9 = new ArrayBuffer(i10.length), o8 = new Uint8Array(r9);
          for (let e8 = 0; e8 < i10.length; e8++)
            o8[e8] = i10.charCodeAt(e8);
          return r9;
        }
        function tl(e7) {
          const t10 = new Uint8Array(e7);
          let n8 = "";
          for (const e8 of t10)
            n8 += String.fromCharCode(e8);
          return btoa(n8).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
        }
        var nl = "copy", il = "convert";
        function rl(e7, t10, n8) {
          if (t10 === nl)
            return n8;
          if (t10 === il)
            return e7(n8);
          if (t10 instanceof Array)
            return n8.map((n9) => rl(e7, t10[0], n9));
          if (t10 instanceof Object) {
            const i10 = {};
            for (const [r9, o8] of Object.entries(t10)) {
              if (o8.derive) {
                const e8 = o8.derive(n8);
                void 0 !== e8 && (n8[r9] = e8);
              }
              if (r9 in n8)
                null != n8[r9] ? i10[r9] = rl(e7, o8.schema, n8[r9]) : i10[r9] = null;
              else if (o8.required)
                throw new Error(`Missing key: ${r9}`);
            }
            return i10;
          }
        }
        function ol(e7, t10) {
          return { required: true, schema: e7, derive: t10 };
        }
        function sl(e7) {
          return { required: true, schema: e7 };
        }
        function al(e7) {
          return { required: false, schema: e7 };
        }
        var ll = { type: sl(nl), id: sl(il), transports: al(nl) }, cl = { appid: al(nl), appidExclude: al(nl), credProps: al(nl) }, ul = { appid: al(nl), appidExclude: al(nl), credProps: al(nl) }, dl = { publicKey: sl({ rp: sl(nl), user: sl({ id: sl(il), name: sl(nl), displayName: sl(nl) }), challenge: sl(il), pubKeyCredParams: sl(nl), timeout: al(nl), excludeCredentials: al([ll]), authenticatorSelection: al(nl), attestation: al(nl), extensions: al(cl) }), signal: al(nl) }, Al = { type: sl(nl), id: sl(nl), rawId: sl(il), authenticatorAttachment: al(nl), response: sl({ clientDataJSON: sl(il), attestationObject: sl(il), transports: ol(nl, (e7) => {
          var t10;
          return (null == (t10 = e7.getTransports) ? void 0 : t10.call(e7)) || [];
        }) }), clientExtensionResults: ol(ul, (e7) => e7.getClientExtensionResults()) }, gl = { mediation: al(nl), publicKey: sl({ challenge: sl(il), timeout: al(nl), rpId: al(nl), allowCredentials: al([ll]), userVerification: al(nl), extensions: al(cl) }), signal: al(nl) }, pl = { type: sl(nl), id: sl(nl), rawId: sl(il), authenticatorAttachment: al(nl), response: sl({ clientDataJSON: sl(il), authenticatorData: sl(il), signature: sl(il), userHandle: sl(il) }), clientExtensionResults: ol(ul, (e7) => e7.getClientExtensionResults()) };
        async function Ml(e7) {
          const t10 = await navigator.credentials.create(function(e8) {
            return rl(el, dl, e8);
          }(e7));
          return function(e8) {
            return rl(tl, Al, e8);
          }(t10);
        }
        async function fl(e7) {
          const t10 = await navigator.credentials.get(function(e8) {
            return rl(el, gl, e8);
          }(e7));
          return function(e8) {
            return rl(tl, pl, e8);
          }(t10);
        }
        const ml = new function() {
          this.debug = (e7, t10 = null) => {
            Sl.state.projectConfig.debug && (null === t10 ? console.log(e7) : console.log(e7, t10));
          }, this.error = (e7, t10 = null) => {
            null === t10 ? console.error(e7) : console.error(e7, t10);
          };
        }();
        let hl = null;
        const yl = class {
          constructor(e7) {
            this._errorHandler = e7;
          }
          SignIn(e7) {
            return this.AbortMediation(), El(Va.get().post("/v1/users/passkey/login/start", { username: e7 }), this._errorHandler).then((e8) => (ml.debug("Webauthn challenge", { signedChallenge: e8.data.data.challenge }), fl(JSON.parse(e8.data.data.challenge)).then((e9) => (ml.debug("Webauthn signed challenge", { signedChallenge: JSON.stringify(e9) }), Va.get().post("/v1/users/passkey/login/finish", { signedChallenge: JSON.stringify(e9) }).then((e10) => (Ka(e10.data.data), _a3(e10.data.data.longSession), e10.data.data.redirectURL)))))).catch(this._handleNavigatorError);
          }
          SignUp(e7, t10) {
            return this.AbortMediation(), El(Va.get().post("/v1/users/passkey/register/start", { username: e7, fullName: t10 }), this._errorHandler).then((e8) => (ml.debug("Webauthn challenge", { signedChallenge: e8.data.data.challenge }), Ml(JSON.parse(e8.data.data.challenge)).then((e9) => (ml.debug("Webauthn signed challenge", { signedChallenge: JSON.stringify(e9) }), Va.get().post("/v1/users/passkey/register/finish", { signedChallenge: JSON.stringify(e9) }).then((e10) => (Ka(e10.data.data), _a3(e10.data.data.longSession), e10.data.data.redirectURL)))))).catch(this._handleNavigatorError);
          }
          Append(e7) {
            return El(Va.get().post("/v1/users/passkey/append/start", {}, "" !== e7 && void 0 !== e7 ? { headers: { Authorization: `Bearer ${e7}` } } : {}), this._errorHandler).then((e8) => (ml.debug("Webauthn challenge", { signedChallenge: e8.data.data.challenge }), Ml(JSON.parse(e8.data.data.challenge)).then((e9) => (ml.debug("Webauthn signed challenge", { signedChallenge: JSON.stringify(e9) }), Va.get().post("/v1/users/passkey/append/finish", { signedChallenge: JSON.stringify(e9) }).then((e10) => (_a3(e10.data.data.longSession), e10.data.data.redirectURL)))))).catch(this._handleNavigatorError);
          }
          _handleNavigatorError(e7) {
            if ("DomException" === e7.name || "SecurityError" === e7.name)
              throw console.error(e7), this._errorHandler.value.error = { message: "Relying Party ID and Browser URL not matching. Please check the Corbado developer panel", errorLink: "https://app.corbado.com/app/settings/general/urls" }, null;
            throw e7;
          }
          MediationStart(e7) {
            this.AbortMediation();
            const t10 = new AbortController(), n8 = t10.signal;
            return hl = t10, El(Va.get().post("/v1/users/passkey/mediation/start", { username: e7 }), this._errorHandler).then((e8) => {
              ml.debug("Webauthn challenge", { challenge: e8.data.data.challenge });
              const t11 = JSON.parse(e8.data.data.challenge);
              return t11.mediation = "conditional", t11.signal = n8, fl(t11).then((e9) => (ml.debug("Webauthn signed challenge", { signedChallenge: JSON.stringify(e9) }), Va.get().post("/v1/users/passkey/login/finish", { signedChallenge: JSON.stringify(e9) }).then((e10) => (Ka(e10.data.data), { redirectURL: e10.data.data.redirectURL, username: e10.data.data.username, confirmedCredential: e10.data.data.confirmedCredential }))));
            }).catch(this._handleNavigatorError);
          }
          AbortMediation() {
            if (hl) {
              try {
                hl.abort("User chose different login");
              } catch (e7) {
                ml.error("Mediation failed", e7);
              }
              hl = null;
            }
          }
          AssociateStart(e7) {
            return El(Va.get().post("/v1/users/passkey/associate/start", { associationToken: e7 }), this._errorHandler).then((e8) => (ml.debug("Webauthn challenge", { signedChallenge: e8.data.data.challenge }), Ml(JSON.parse(e8.data.data.challenge)).then((e9) => (ml.debug("Webauthn signed challenge", { signedChallenge: JSON.stringify(e9) }), Va.get().post("/v1/users/passkey/append/finish", { signedChallenge: JSON.stringify(e9) }))))).catch(this._handleNavigatorError);
          }
          AssociateLogin(e7) {
            return El(Va.get().post("/v1/users/passkey/login/start", { username: e7 }), this._errorHandler).then((e8) => (ml.debug("Webauthn challenge", { signedChallenge: e8.data.data.challenge }), fl(JSON.parse(e8.data.data.challenge)).then((e9) => (ml.debug("Webauthn signed challenge", { signedChallenge: JSON.stringify(e9) }), Va.get().post("/v1/users/passkey/login/finish", { signedChallenge: JSON.stringify(e9) }).then((e10) => (Ka(e10.data.data), _a3(e10.data.data.longSession), e10.data.data.redirectURL)))))).catch(this._handleNavigatorError);
          }
          async DeletePasskey(e7) {
            return await Va.get().delete(`/v1/me/passkeys/${e7}`);
          }
          CheckDevicePasskeyReadiness() {
            return window.PublicKeyCredential ? window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable() : Promise.resolve(false);
          }
        }, Il = { state: () => ({ username: "", userFullName: "", userFieldFocus: false, loginMethods: [], passwordLoginEndpoint: "", sessionToken: "", redirectURL: "", currentLoginMethod: "", debug: false }), mutations: { setUsername(e7, t10) {
          localStorage.setItem("username", t10);
          const n8 = document.getElementById("corbado-username");
          null !== n8 && (n8.value = t10), e7.username = t10, e7.loginMethods = [];
        }, setUserFullName(e7, t10) {
          e7.userFullName = t10;
        }, setUserFieldFocus(e7, t10) {
          e7.userFieldFocus = t10;
        }, setLoginMethods(e7, t10) {
          e7.loginMethods = t10;
        }, setPasswordLoginEndpoint(e7, t10) {
          e7.passwordLoginEndpoint = t10;
        }, setCurrentLoginMethod(e7, t10) {
          e7.currentLoginMethod = t10;
        }, setSessionToken(e7, t10) {
          e7.sessionToken = t10;
        }, setRedirectURL(e7, t10) {
          e7.redirectURL = t10;
        } }, getters: { renderingType: (e7) => e7.renderingType }, actions: { fetchLoginMethods: async ({ commit: e7 }, { username: t10, errorHandler: n8 }) => new $a(n8).AuthMethods(t10).then((t11) => (e7("setLoginMethods", t11.selectedMethods), e7("setPasswordLoginEndpoint", t11.passwordLoginEndpoint), t11)), async processWebauthnMediation({ state: e7, commit: t10 }, { errorHandler: n8 }) {
          if (!PublicKeyCredential.isConditionalMediationAvailable || !await PublicKeyCredential.isConditionalMediationAvailable())
            return void ml.debug("Conditional ui not possible");
          const i10 = parseFloat(("" + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", ""));
          if (!(navigator.userAgent.indexOf("Edg/") > -1 || navigator.userAgent.indexOf("iPhone") > -1 && i10 < 16.4))
            return ml.debug("Start conditional ui"), new yl(n8).MediationStart(e7.username).then(({ confirmedCredential: e8, username: n9, redirectURL: i11 }) => {
              if (t10("setUsername", n9), !e8)
                throw new Error("authentication_method_pending");
              window.location = i11;
            });
          ml.debug("Conditional ui for iphone iOS < 16.4 and edge not possible", { userAgent: navigator.userAgent });
        } } }, wl = { state: () => ({ webauthnSupported: null, biometricMethod: "Face ID / Touch ID" }), mutations: { setWebauthnSupported(e7, t10) {
          e7.webauthnSupported = t10;
        } }, actions: { async detectWebauthnSupported({ commit: e7 }) {
          new Promise((e8) => window.PublicKeyCredential ? (ml.debug("Browser webauthn possible"), window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then((t10) => {
            t10 ? ml.debug("Platform authenticator possible") : ml.debug("Platform authenticator not possible"), e8(t10);
          }).catch(() => {
            e8(false);
          })) : e8(false)).then((t10) => {
            e7("setWebauthnSupported", t10);
          }).catch(() => {
            e7("setWebauthnSupported", false);
          });
        } } }, Nl = { state: () => ({ pendingID: null }), mutations: { setEMailLinkIDPending(e7, t10) {
          e7.pendingID = t10;
        } } }, jl = { state: () => ({ allowUserRegistration: null, passkeyAppendInterval: null, fallbackLanguage: null, autoDetectLanguage: null, showPasskeyAppend: null, userFullNameRequired: false, environment: "prod" }), mutations: { setFromProjectConfig(e7, t10) {
          e7.userFullNameRequired = t10.userFullNameRequired, e7.allowUserRegistration = t10.allowUserRegistration, e7.passkeyAppendInterval = t10.passkeyAppendInterval, e7.fallbackLanguage = t10.fallbackLanguage, e7.autoDetectLanguage = t10.autoDetectLanguage, e7.debug = t10.webComponentDebug, e7.environment = t10.environment, e7.showPasskeyAppend = ((e8) => {
            let t11 = localStorage.getItem("passkeyAppendPopUpShownAt");
            if (t11) {
              t11 = new Date(t11);
              const n8 = /* @__PURE__ */ new Date(), i10 = n8.getTime() - t11.getTime();
              if (Math.ceil(i10 / 864e5) < e8)
                return false;
              localStorage.setItem("passkeyAppendPopUpShownAt", n8.toISOString());
            } else
              localStorage.setItem("passkeyAppendPopUpShownAt", (/* @__PURE__ */ new Date()).toISOString());
            return true;
          })(((e8) => {
            switch (e8) {
              case "0d":
                e8 = 0;
                break;
              case "1d":
                e8 = 1;
                break;
              case "3d":
                e8 = 3;
                break;
              case "1w":
                e8 = 7;
                break;
              case "3w":
                e8 = 21;
                break;
              case "1m":
                e8 = 30;
                break;
              case "3m":
                e8 = 90;
                break;
              default:
                ml.error("Invalid interval", { passkeyAppendInterval: e8 }), e8 = 0;
            }
            return e8;
          })(t10.passkeyAppendInterval));
        } } }, bl = { state: () => ({ validationRules: {} }), mutations: { addField(e7, { name: t10, validate: n8 }) {
          e7.validationRules[t10] = n8;
        } } };
        class Dl extends Error {
          constructor(e7) {
            super(e7), this._type = "generic";
          }
          get type() {
            return this._type;
          }
        }
        class xl extends Dl {
          constructor(e7, t10 = "", n8 = false) {
            super(e7), this._link = t10, this._forceShowError = n8, this._type = "client";
          }
          get link() {
            return this._link;
          }
          get forceShowError() {
            return this._forceShowError;
          }
        }
        function Ll(e7, t10, n8 = false, i10 = "https://docs.corbado.com/web-app-integrations/web-component") {
          throw new xl('Invalid attribute "' + e7 + '": ' + t10, i10, n8);
        }
        function vl(e7) {
          void 0 === e7 && Ll("project-id", "Is missing", true), e7.match(/^pro\-\d+$/) || Ll("project-id", 'It must start with "pro-" followed by number (e.g. pro-123456789)', true);
        }
        function Tl(e7) {
          e7.startsWith("https://") || e7.startsWith("http://") || Ll("endpoint", 'It must start with "https://" or "http://"', true), "/" === e7.substring(e7.length - 1, e7.length) && Ll("endpoint", 'It must not end with "/"', true);
        }
        const zl = [(e7) => {
          let t10 = e7.projectId;
          "" === t10 && (t10 = e7.project_id), "" !== t10 && vl(t10);
        }, (e7) => {
          "" !== e7.endpoint && Tl(e7.endpoint);
        }, (e7) => {
          "" === e7.endpoint && "" === e7.projectId && "" === e7.project_id && Ll("projectID", 'Attribute "endpoint" or "projectID" not given. Provide at least one', true);
        }], Cl = [(e7) => {
          ["yes", "no"].includes(e7.conditional) || Ll("conditional", "Should be yes or no.");
        }, (e7) => {
          e7.companyimageurl.length > 0 && !e7.companyimageurl.startsWith("/") && !e7.companyimageurl.startsWith("http://") && !e7.companyimageurl.startsWith("https://") && Ll("companyimageurl", "Should start with / or http:// or https://"), e7.companyImageUrl.length > 0 && !e7.companyImageUrl.startsWith("/") && !e7.companyImageUrl.startsWith("http://") && !e7.companyImageUrl.startsWith("https://") && Ll("companyimageurl", "Should be yes or no.");
        }, (e7) => {
          ["yes", "no"].includes(e7.debug) || Ll("debug", "Should be yes or no.");
        }, (e7) => {
          ["yes", "no"].includes(e7.disableInputAnimation) || Ll("disable-input-animation", "Should be yes or no.");
        }, (e7) => {
          if (!["normal", "preview"].includes(e7.mode))
            throw new Error("Invalid mode, should be normal or preview.");
        }, (e7) => {
          [Ol.PAGE_TIMEOUT, Ol.PAGE_LOGIN, Ol.PAGE_EMAIL_PENDING, Ol.PAGE_REGISTER, Ol.PAGE_EMAIL_PENDING, Ol.PAGE_EMAIL_LINK_CONFIRM, Ol.PAGE_APPEND_PASSKEY, Ol.PAGE_TOO_MANY_REQUESTS, Ol.PAGE_LOGIN_TOKEN].includes(e7.page) || Ll("page", "Should be login, register, timeout, email-pending, email-link-confirm, append-passkey or too-many-requests.");
        }], Sl = new Ra({ modules: { pages: Ha, browser: wl, user: Il, emaillink: Nl, projectConfig: jl, error: { state: () => ({ errorMessage: "", errorDetailLink: "", errorLinks: "", errorRequestLink: "", errorRequestID: "", errorSide: "", errorType: "", forceShowError: "" }), mutations: {} }, fields: bl, webComponent: { state: () => ({ projectID: null, endpoint: null, conditionalUI: null, companyImageURL: null, registerTitle: null, loginTitle: null, subTitle: null, passkeyAppendTitle: null, passkeyAppendText: null, registerBtn: null, loginBtn: null, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone, mode: null, disableInputAnimation: false }), mutations: { setRequiredFromProps(e7, t10) {
          "" !== t10.projectId ? e7.projectID = t10.projectId : "" !== t10.project_id ? e7.projectID = t10.project_id : e7.projectID = "", "" !== t10.endpoint ? e7.endpoint = t10.endpoint : e7.endpoint = "https://" + e7.projectID + ".frontendapi.corbado.io";
        }, setOptionalFromProps(e7, t10) {
          "" !== t10.companyImageUrl ? e7.companyImageURL = t10.companyImageUrl : "" !== t10.companyimageurl && (e7.companyImageURL = t10.companyimageurl), e7.conditionalUI = t10.conditional, null !== t10.registerTitle ? e7.registerTitle = t10.registerTitle : null !== t10.register_title && (e7.registerTitle = t10.register_title), null !== t10.registerBtn ? e7.registerBtn = t10.registerBtn : null !== t10.register_btn && (e7.registerBtn = t10.register_btn), null !== t10.loginTitle ? e7.loginTitle = t10.loginTitle : null !== t10.login_title && (e7.loginTitle = t10.login_title), null !== t10.loginBtn ? e7.loginBtn = t10.loginBtn : null !== t10.login_btn && (e7.loginBtn = t10.login_btn), null !== t10.subTitle ? e7.subTitle = t10.subTitle : null !== t10.sub_title && (e7.subTitle = t10.sub_title), null !== t10.subTitle ? e7.subTitle = t10.subTitle : null !== t10.sub_title && (e7.subTitle = t10.sub_title), null !== t10.passkeyAppendTitle && (e7.passkeyAppendTitle = t10.passkeyAppendTitle), null !== t10.passkeyAppendText && (e7.passkeyAppendText = t10.passkeyAppendText), null !== t10.mode && (e7.mode = t10.mode), null !== t10.disableInputAnimation && (e7.disableInputAnimation = "yes" === t10.disableInputAnimation);
        } } } } });
        function El(e7, t10) {
          return e7.catch((e8) => {
            if ("AxiosError" === e8.name) {
              let n8 = "";
              if ("" !== e8.response?.headers?.get("x-corbado-help") && void 0 !== e8.response?.headers?.get("x-corbado-help") && (n8 = e8.response.headers.get("x-corbado-help")), "ERR_NETWORK" === e8.code)
                throw void 0 === e8.response ? t10.value.error = { message: "Network error - it seams like you're offline or have CORS issues", detailLink: n8, requestLink: "https://www.corbado.com/cors-error", requestID: e8.response?.data?.requestData?.requestID, errorType: e8.response?.data?.error?.type } : t10.value.error = { message: "Network error - please check your CORS settings", detailLink: n8, requestLink: "https://www.corbado.com/cors-error", requestID: e8.response?.data?.requestData?.requestID, errorType: e8.response?.data?.error?.type }, null;
              if ("ECONNABORTED" === e8.code)
                throw Sl.commit("switchPage", Ol.PAGE_TIMEOUT), null;
              if ("invalid_origin" === e8.response.data.error.type)
                throw t10.value.error = { message: "Network error - please check cors settings", detailLink: n8, errorType: e8.response.data.error.type, requestID: e8.response.data.requestData.requestID, requestLink: "https://www.corbado.com/cors-error", links: e8.response.data.error.links }, null;
              if ("client_error" === e8.response.data.error.type)
                throw t10.value.error = { message: "It seems like you have set up Corbado webhooks to make Corbado exchange user information with your backend. Unfortunately, your backend is not reachable or the Corbado CLI is not set up correctly (e.g. when you're testing locally). Please remove webhooks URL, webhooks username and webhooks password in the developer panel if you don't have existing users in your backend that you need to connect to Corbado (e.g. you're building an entirely new application).", detailLink: n8, customError: "webhookError", errorType: e8.response.data.error.type, requestID: e8.response.data.requestData.requestID, requestLink: e8.response.data.requestData.link, links: e8.response.data.error.links }, null;
              if (422 === e8.response.status) {
                let i10 = "";
                throw e8.response.data.error.validation?.forEach((e9) => {
                  i10 += e9.field + ": " + e9.message + "; ";
                }), t10.value.error = { message: e8.response.data.error.details, detailLink: n8, errorType: e8.response.data.error.type, requestID: e8.response.data.requestData.requestID, requestLink: e8.response.data.requestData.link, links: e8.response.data.error.links }, null;
              }
              if (429 === e8.response.status)
                throw Sl.commit("switchPage", Ol.PAGE_TOO_MANY_REQUESTS), null;
              if ("validation_error" === e8.response.data.error.type)
                throw Object.assign({}, la(e8.response.data.error.validation));
              if (500 === e8.response.status)
                throw t10.value.error = { message: "An server error has occurred. Check the developer console.", detailLink: n8, errorType: e8.response.data.error.type, requestID: e8.response.data.requestData.requestID, requestLink: e8.response.data.requestData.link, links: e8.response.data.error.links }, null;
              if ("" !== n8)
                throw t10.value.error = { requestID: "", detailLink: n8, message: "Please follow the link in order to better understand the error", requestLink: e8.response.data.requestData.link }, null;
            }
            throw e8;
          });
        }
        class kl {
          constructor(e7) {
            this._errorHandler = e7;
          }
          SignIn(e7) {
            return El(Va.get().post("/v1/users/emaillinks/login/start", { username: e7 }), this._errorHandler).then((e8) => (Ka(e8.data.data), e8.data.data.emailLinkID));
          }
          Confirm(e7, t10) {
            return El(Va.get().post("/v1/users/emaillinks/confirm", { emailLinkID: e7, token: t10 }), this._errorHandler).then((e8) => (Ka(e8.data.data), _a3(e8.data.data.longSession), { redirectURL: e8.data.data.redirectURL, sessionToken: e8.data.data.sessionToken, authMethods: e8.data.data.authMethods }));
          }
          Status(e7) {
            return El(Va.get().post("/v1/users/emaillinks/status", { emailLinkID: e7 }), this._errorHandler).then((e8) => (Ka(e8.data.data), _a3(e8.data.data.longSession), { redirectURL: e8.data.data.redirectURL, sessionToken: e8.data.data.sessionToken }));
          }
          SignUp(e7, t10) {
            return El(Va.get().post("/v1/users/emaillinks/register/start", { email: e7, username: t10 }), this._errorHandler).then((e8) => e8.data.data.emailLinkID);
          }
        }
        const Ol = { PAGE_LOGIN: "login", PAGE_REGISTER: "register", PAGE_APPEND_PASSKEY: "append-passkey", PAGE_EMAIL_PENDING: "email-pending", PAGE_EMAIL_LINK_CONFIRM: "email-link-confirm", PAGE_TIMEOUT: "timeout", PAGE_TOO_MANY_REQUESTS: "too-many-requests", PAGE_LOGIN_TOKEN: "login-token" }, Pl = "webauthn", Ul = "password", Ql = "email_direct", Rl = "email";
        class Yl {
          constructor(e7, t10) {
            this.store = e7, this.emailLinkSvc = new kl(t10);
          }
          async handle(e7, t10 = true, n8 = []) {
            let i10 = "";
            if (ml.debug("Handle user flow", { methods: e7 }), e7.length > 0 && (i10 = e7.includes("webauthn") && Sl.state.browser.webauthnSupported && !n8.includes("webauthn") ? Pl : e7.includes("email") && !e7.includes("password") && t10 && !n8.includes("email") ? Ql : e7.includes("password") && !n8.includes("password") ? Ul : Rl), i10 === Ql) {
              const e8 = await this.emailLinkSvc.SignIn(Sl.state.user.username);
              Sl.commit("setEMailLinkIDPending", e8);
            }
            return ml.debug("Selected flow", { selectedMethod: i10 }), i10;
          }
        }
        const Zl = { class: "heading text-center" }, Bl = ["src"], Wl = { key: 1 }, Gl = { class: "input-group" }, Hl = { key: 1, class: "text-small text-center" }, _l = ["type", "name", "data-input", "v-model", "value", "autocomplete", "disabled"], Vl = { name: "error-field", props: { errorMessage: String } };
        var Fl = n7(744);
        const Jl = (0, Fl.Z)(Vl, [["render", function(e7, t10, n8, i10, r9, o8) {
          return Vi(), Ki("span", null, "\u26A0 " + A5(n8.errorMessage), 1);
        }], ["styles", ["\nspan[data-v-4c642af6] {\n  margin-left: 1.4rem;\n  margin-top: 2rem;\n  color: var(--error-color, #FF4C51);\n  font-size: 0.75rem;\n}\n\n"]], ["__scopeId", "data-v-4c642af6"]]), Xl = { name: "InputFieldContainer", components: { ErrorField: Jl }, props: { label: String, errorMessage: String, hasFocus: Boolean, hasContent: Boolean }, computed: { cssClasses() {
          let e7 = "input-effect";
          return this.hasContent && (e7 += " has-content"), this.hasFocus && (e7 += " has-focus"), e7;
        } } }, Kl = (0, Fl.Z)(Xl, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("error-field");
          return Vi(), Ki("div", { class: c8(o8.cssClasses) }, [ri(e7.$slots, "default"), rr("label", null, A5(n8.label), 1), "" !== n8.errorMessage && void 0 !== n8.errorMessage ? (Vi(), qi(s10, { key: 0, "error-message": n8.errorMessage }, null, 8, ["error-message"])) : cr("v-if", true)], 2);
        }], ["styles", ["\n.input-effect :focus {\n  outline: none;\n}\n.input-effect {\n  position: relative;\n  margin: var(--input-margin, 2rem 0 1rem 0);\n  width: 100%;\n}\n.input-effect input[disabled] {\n  color: var(--text-disabled-color, var(--text-color, #535e80));\n}\n.input-effect input:-webkit-autofill,\n.input-effect input:-webkit-autofill:hover,\n.input-effect input:-webkit-autofill:focus,\n.input-effect input:-webkit-autofill:active{\n  -webkit-box-shadow: 0 0 0 30px var(--primary-background-color, '#ffffff') inset !important;\n  box-shadow: 0 0 0 1000px white inset;\n}\n\n/*Change text in autofill textbox*/\n.input-effect input:-webkit-autofill{\n  -webkit-text-fill-color: var(--text-color, #535e80)!important;\n}\n.input-effect input {\n  color: var(--text-color, #535e80);\n  font-size: 1rem;\n  padding: var(--input-padding, 0.8rem 1.4rem);\n  width: 100%;\n  border-width: 1px;\n  border-style: solid;\n  border-radius: var(--border-radius, 1.5rem);\n  border-color: var(--border-color, rgba(143, 155, 191, 0.5));\n  position: relative;\n  background: transparent;\n  z-index: 2;\n  box-sizing: border-box;\n  -webkit-text-fill-color: var(--text-color, #535e80);\n  -webkit-background-clip: text !important;\n  background-clip: text !important;\n}\n.input-effect label {\n  color: var(--light-color, #8f9bbf);\n  position: absolute;\n  left: 1.4rem;\n  top: 0.8rem;\n  transition: 0.3s;\n  z-index: 1;\n}\n.input-effect.has-content label,\n.input-effect.has-focus label {\n  top: -1.1rem;\n  left: 1.4rem;\n  font-size: 0.75rem;\n  color: var(--text-color, #535e80);\n  transition: 0.3s;\n}\n"]]]), ql = { name: "InputField", components: { InputFieldContainer: Kl, ErrorField: Jl }, props: { type: String, name: { type: String, default: "username", validate: (e7) => ["name", "username", "password"].includes(e7) }, autocomplete: String, label: String, errorMessage: String, value: String, disabled: { default: false, type: Boolean } }, setup() {
          const e7 = yt2(false);
          return { hasFocus: e7, focusIn: () => {
            e7.value = true;
          }, focusOut: () => {
            e7.value = false;
          } };
        }, computed: { hasContent() {
          return !(void 0 === this.value || "" === this.value) || Sl.state.webComponent.disableInputAnimation;
        }, disabledValue() {
          return this.disabled ? "disabled" : null;
        } } }, $l = (0, Fl.Z)(ql, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field-container");
          return Vi(), qi(s10, { "error-message": n8.errorMessage, label: n8.label, "has-content": o8.hasContent, "has-focus": i10.hasFocus }, { default: un(() => [rr("input", { type: n8.type, name: n8.name, "data-input": n8.name, "v-model": n8.value, value: n8.value, onInput: t10[0] || (t10[0] = (t11) => e7.$emit("update:modelValue", t11.target.value)), autocomplete: n8.autocomplete, disabled: o8.disabledValue, onFocusin: t10[1] || (t10[1] = (...e8) => i10.focusIn && i10.focusIn(...e8)), onFocusout: t10[2] || (t10[2] = (...e8) => i10.focusOut && i10.focusOut(...e8)) }, null, 40, _l)]), _: 1 }, 8, ["error-message", "label", "has-content", "has-focus"]);
        }]]), ec = ["data-action", "disabled"], tc = { class: "btn-text" }, nc = { name: "styled-btn", props: { dataAction: { type: String, default: "continue" }, type: { type: String, default: "primary", validator: (e7) => ["primary", "secondary"].includes(e7) }, fullWidth: Boolean, isLoading: Boolean, disabled: { type: Boolean, default: false }, classes: { type: String, default: "" } }, computed: { cssClasses() {
          let e7 = [this.type + "-btn"];
          return this.fullWidth && e7.push("full-width"), this.isLoading && e7.push("loading-btn"), "" !== this.classes && e7.push(this.classes), e7;
        } } }, ic = (0, Fl.Z)(nc, [["render", function(e7, t10, n8, i10, r9, o8) {
          return Vi(), Ki("button", { class: c8(o8.cssClasses), "data-action": n8.dataAction, disabled: n8.disabled }, [rr("span", tc, [ri(e7.$slots, "default")])], 10, ec);
        }], ["styles", ['\nbutton {\n  font-family: var(--primary-font, sans-serif);\n  padding: 0.8rem 1.4rem;\n  font-size: var(--button-font-size, 1rem);\n  border-radius: var(--border-radius, 1.5rem);\n  cursor: pointer;\n  position: relative;\n}\nbutton[disabled], button[disabled]:hover {\n  cursor: not-allowed;\n  background-color: var(--disabled-color, #666666)!important;\n}\n.primary-btn {\n  background-color: var(--primary-color, #1953ff);\n  border: none;\n  color: white;\n}\n.primary-btn:hover {\n  background-color: var(--primary-hover-color, var(--primary-color, #1953ff));\n}\n.secondary-btn {\n  border-width: 1px;\n  border-style: solid;\n  border-color: var(--secondary-border-color, #1953ff);\n  background-color: var(--secondary-background-color, #fff);\n  color: var(--secondary-font-color, #1953ff);\n}\n.secondary-btn:hover {\n  border-color: var(--secondary-border-hover-color, var(--secondary-border-color, #1953ff));\n  background-color: var(--secondary-background-hover-color, var(--secondary-background-color, #fff));\n  color: var(--secondary-font-hover-color, var(--secondary-font-color, #1953ff));\n}\n.full-width {\n  width: 100%;\n}\n.loading-btn .btn-text {\n  visibility: hidden;\n  opacity: 0;\n}\n.loading-btn::after {\n  content: "";\n  position: absolute;\n  width: 1.1rem;\n  height: 1.1rem;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  margin: auto;\n  border: 0.25rem solid rgba(255, 255, 255, 0.2);\n  border-top-color: #fff;\n  border-radius: 50%;\n  animation: button-loading-spinner 1s ease infinite;\n}\n.secondary-btn.loading-btn::after {\n  border: 0.25rem solid rgba(var(--primary-color-rgb, 25, 83, 255), 0.2);\n  border-top-color: var(--primary-color, #1953ff);\n}\n@keyframes button-loading-spinner {\nfrom {\n    transform: rotate(0turn);\n}\nto {\n    transform: rotate(1turn);\n}\n}\n']]]), rc = { name: "UsernameInputField", components: { InputFieldContainer: Kl, ErrorField: Jl }, props: { label: String, errorMessage: String }, setup() {
          const e7 = document.getElementById("corbado-username"), t10 = yt2(Sl.state.user.username), n8 = yt2(false);
          return e7.addEventListener("focusin", () => {
            n8.value = true;
          }), e7.addEventListener("focusout", () => {
            n8.value = false;
          }), e7.addEventListener("keyup", (e8) => {
            t10.value = e8.target.value;
          }), e7.addEventListener("paste", (e8) => {
            let n9 = (e8.clipboardData || window.clipboardData).getData("Text");
            n9.length > 1 && (t10.value = n9);
          }), { hasUsernameFocus: n8, username: t10 };
        }, computed: { hasUsernameContent() {
          return this.username.length > 0 || Sl.state.webComponent.disableInputAnimation;
        } } }, oc = (0, Fl.Z)(rc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field-container");
          return Vi(), qi(s10, { label: n8.label, errorMessage: n8.errorMessage, "has-content": o8.hasUsernameContent, "has-focus": i10.hasUsernameFocus }, { default: un(() => [ri(e7.$slots, "default")]), _: 3 }, 8, ["label", "errorMessage", "has-content", "has-focus"]);
        }]]), sc = Symbol();
        function ac(e7) {
          const t10 = (n8 = e7, { changeLocale: (e8) => {
            n8.value.locale !== e8 && (n8.value.locale = e8);
          }, $t: (e8) => n8.value.messages[n8.value.locale][e8] });
          var n8;
          return Mn(sc, t10), t10;
        }
        function lc() {
          const e7 = fn(sc);
          if (!e7)
            throw new Error("No i18n provided!!!");
          return e7;
        }
        const cc = { components: { UsernameInputField: oc, InputFieldContainer: Kl, ErrorField: Jl, StyledBtn: ic, InputField: $l }, setup(e7, { slots: t10 }) {
          const n8 = lc(), i10 = document.getElementById("corbado-username"), r9 = fn("errorHandler"), o8 = new yl(r9), s10 = yt2(false), a8 = yt2(vr(() => Sl.state.user.username).value), l8 = yt2({}), c9 = vr(() => Sl.state.projectConfig.allowUserRegistration), u7 = new kl(r9), d7 = yt2(""), A6 = !!t10.usernameField, g8 = vr(() => Sl.state.user.loginMethods), p6 = new Yl(Sl, r9), M5 = (e8) => {
            e8.preventDefault(), o8.AbortMediation(), A6 && (Sl.commit("setUsername", i10.value), a8.value = i10.value), l8.value = {}, 0 !== a8.value.trim().length ? (Sl.commit("setUsername", a8.value), s10.value = true, Sl.dispatch("fetchLoginMethods", { username: a8.value, errorHandler: r9 }).then(async (e9) => {
              const t11 = await p6.handle(e9.selectedMethods);
              return ml.debug("Login flow selected " + t11, { methods: e9.selectedMethods }), t11 === Pl ? (ml.debug("Start webauthn signin"), o8.SignIn(a8.value).then((e10) => {
                ml.debug("Finish webauthn signin", { redirectURL: e10 }), s10.value = false, window.location = e10;
              }).catch((t12) => {
                null !== t12 && (s10.value = false, "SecurityError" === t12.name ? r9.value.error = { message: "Relying Party ID and Browser URL not matching. Please check the Corbado developer panel", errorLink: "https://app.corbado.com/app/settings/general/urls" } : "NotAllowedError" === t12.name || "not_found" === t12?.response?.data?.error?.type ? (ml.debug("Webauthn failed"), p6.handle(e9.selectedMethods, true, ["webauthn"]).then((e10) => {
                  ml.debug("Change method", { selectedMethod: e10 }), Sl.commit("setCurrentLoginMethod", e10), Sl.commit("setContext", "passkey_cancelled");
                }).catch((e10) => {
                  l8.value = la(e10);
                })) : l8.value = t12);
              })) : (Sl.commit("setCurrentLoginMethod", t11), s10.value = false, e9);
            }).catch((e9) => {
              s10.value = false, null !== e9 && (l8.value = e9);
            })) : l8.value = { username: n8.$t("missing_username") };
          }, f6 = Sl.state.webComponent.companyImageURL;
          return A6 && (i10.onkeyup = (e8) => {
            "Enter" === e8.key && M5(e8);
          }), { loading: s10, errorMessage: l8, SignUp: (e8) => {
            if (e8.preventDefault(), A6) {
              const e9 = document.getElementById("corbado-username");
              Sl.commit("setUsername", e9.value);
            }
            o8.AbortMediation(), Sl.commit("switchPage", Ol.PAGE_REGISTER);
          }, continueLoginHandler: M5, loginMethods: g8, password: d7, allowUserRegistration: c9, username: a8, companyImageUrl: f6, performConditionalUI: A6, i18n: n8, emailLinkSvc: u7, errorHandler: r9 };
        }, mounted() {
          this.performConditionalUI && Sl.dispatch("processWebauthnMediation", { errorHandler: this.errorHandler }).catch((e7) => {
            if (null !== e7)
              return 400 === e7?.response?.status || "authentication_method_pending" === e7.message ? (e7.response.data.errorData.username && Sl.commit("setUsername", e7.response.data.errorData.username), this.emailLinkSvc.SignIn(Sl.state.user.username).then((t10) => {
                Sl.commit("setEMailLinkIDPending", t10), Sl.commit("switchPage", Ol.PAGE_EMAIL_PENDING), Sl.commit("switchPage", Ol.PAGE_EMAIL_PENDING), Sl.commit("setContext", "authentication_method_pending" === e7.message ? "authentication_method_pending" : "passkey_deleted");
              }).catch((e8) => {
                e8.response && e8.response.data && e8.response.data.error && e8.response.data.error.validation ? this.errorMessage.value = Object.assign({}, la(e8.response.data.error.validation)) : ml.error("Failed to send email magic link", e8);
              })) : void ("User choose different login" !== e7 && ml.error("Conditional ui failed", e7));
          });
        }, computed: { pageTitle() {
          return Sl.state.webComponent.loginTitle ?? this.i18n.$t("login");
        }, subTitle() {
          return Sl.state.webComponent.subTitle ?? this.i18n.$t("welcome_back");
        }, ButtonText() {
          return Sl.state.webComponent.loginBtn ?? this.i18n.$t("continue");
        } } }, uc = (0, Fl.Z)(cc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("username-input-field"), a8 = qn("input-field"), l8 = qn("styled-btn"), c9 = qn("error-field");
          return Vi(), Ki("div", null, [rr("div", Zl, [null !== i10.companyImageUrl ? (Vi(), Ki("img", { key: 0, src: i10.companyImageUrl, height: "40", style: { "margin-bottom": "20px", display: "inline-block" } }, null, 8, Bl)) : cr("v-if", true), rr("h1", null, A5(o8.pageTitle), 1), "" != o8.subTitle ? (Vi(), Ki("p", Wl, A5(o8.subTitle), 1)) : cr("v-if", true)]), rr("form", { onSubmit: t10[2] || (t10[2] = (...e8) => i10.continueLoginHandler && i10.continueLoginHandler(...e8)) }, [rr("div", Gl, [i10.performConditionalUI ? (Vi(), qi(s10, { key: 0, label: i10.i18n.$t("email_address"), "error-message": i10.errorMessage.username }, { default: un(() => [ri(e7.$slots, "usernameField")]), _: 3 }, 8, ["label", "error-message"])) : cr("v-if", true), i10.performConditionalUI ? cr("v-if", true) : (Vi(), qi(a8, { key: 1, id: "username", type: "email", name: "username", autocomplete: "username webauthn", label: i10.i18n.$t("email_address"), value: i10.username, modelValue: i10.username, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.username = e8), "error-message": i10.errorMessage.username }, null, 8, ["label", "value", "modelValue", "error-message"]))]), or(l8, { onClick: i10.continueLoginHandler, type: "primary", dataAction: "continue", fullWidth: true, isLoading: i10.loading }, { default: un(() => [ar(A5(o8.ButtonText), 1)]), _: 1 }, 8, ["onClick", "isLoading"]), void 0 !== i10.errorMessage.global ? (Vi(), qi(c9, { key: 0, errorMessage: i10.errorMessage.global }, null, 8, ["errorMessage"])) : cr("v-if", true), i10.allowUserRegistration ? (Vi(), Ki("p", Hl, [ar(A5(i10.i18n.$t("dont_have_account")) + " ", 1), rr("span", { class: "link", onClick: t10[1] || (t10[1] = (...e8) => i10.SignUp && i10.SignUp(...e8)), "data-action": "switch_to_sign_up" }, A5(i10.i18n.$t("sign_up")), 1)])) : cr("v-if", true)], 32)]);
        }], ["styles", ["\nbutton {\n  margin: 1rem 0;\n}\n"]]]), dc = { class: "heading text-center" }, Ac = { class: "input-group" }, gc = { key: 0, class: "text-small text-center" }, pc = { props: { classes: { type: String, default: "" } } }, Mc = (0, Fl.Z)(pc, [["render", function(e7, t10, n8, i10, r9, o8) {
          return Vi(), Ki("hr", { class: c8(n8.classes) }, null, 2);
        }], ["styles", ["\nhr {\n  border: none;\n  border-top: 1px solid var(--light-color, #8f9bbf);\n  text-align: center;\n  font-size: 1rem;\n  height: 0.6rem;\n  overflow: visible;\n  line-height: 1.5rem;\n  margin-top: 1.2rem;\n}\nhr:after {\n  background: #fff;\n  content: 'OR';\n  padding: 0 4px;\n  position: relative;\n  color: 1px solid var(--light-color, #8f9bbf);\n  font-size: 1rem;\n  top: -0.7rem;\n}\n"]]]);
        class fc {
          constructor(e7) {
            this._errorHandler = e7;
          }
          SignIn(e7, t10) {
            return El(Va.get().post("/v1/users/password/verify", { username: e7, password: t10 }), this._errorHandler).then((e8) => (Ka(e8.data.data), _a3(e8.data.data.longSession), { sessionToken: e8.data.data.sessionToken, redirectURL: e8.data.data.redirectURL })).catch((e8) => {
              throw e8;
            });
          }
        }
        const mc = { components: { StyledBtn: ic, InputField: $l, ErrorField: Jl }, name: "password-login", setup() {
          const e7 = lc(), t10 = yt2(""), n8 = yt2({}), i10 = yt2(false), r9 = fn("errorHandler"), o8 = new fc(r9);
          return { password: t10, errorMessage: n8, handleLogin: (e8) => {
            e8.preventDefault(), i10.value = true, o8.SignIn(Sl.state.user.username, t10.value).then(({ sessionToken: e9, redirectURL: t11 }) => {
              ml.debug("Password sign in successful", { sessionToken: e9, redirectURL: t11 }), i10.value = false, Sl.state.browser.webauthnSupported && !Sl.state.user.loginMethods.includes("webauthn") ? (Sl.commit("setSessionToken", e9), Sl.commit("setRedirectURL", t11), Sl.commit("switchPage", Ol.PAGE_APPEND_PASSKEY)) : window.location = t11;
            }).catch((e9) => {
              i10.value = false, null !== e9 && (n8.value = e9);
            });
          }, loading: i10, i18n: e7 };
        } }, hc = (0, Fl.Z)(mc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field"), a8 = qn("error-field"), l8 = qn("styled-btn");
          return Vi(), Ki("div", null, [or(s10, { id: "password", type: "password", label: i10.i18n.$t("password"), name: "password", autocomplete: "password", modelValue: i10.password, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.password = e8), value: i10.password, errorMessage: i10.errorMessage.password }, null, 8, ["label", "modelValue", "value", "errorMessage"]), void 0 !== i10.errorMessage.global ? (Vi(), qi(a8, { key: 0, errorMessage: i10.errorMessage.global }, null, 8, ["errorMessage"])) : cr("v-if", true), or(l8, { dataAction: "login", type: "primary", "full-width": true, onClick: i10.handleLogin, "is-loading": i10.loading }, { default: un(() => [ar(A5(i10.i18n.$t("login")), 1)]), _: 1 }, 8, ["onClick", "is-loading"])]);
        }]]), yc = { class: "text-center" }, Ic = { style: { "margin-bottom": "1rem", display: "inline-block" } }, wc = { style: { position: "absolute", left: "25px", top: "5px", height: "32px", width: "32px" }, viewBox: "0 0 24 24" }, Nc = [((e7) => (ln("data-v-73144638"), e7 = e7(), cn2(), e7))(() => rr("path", { fill: "currentColor", d: "M22 6C22 4.9 21.1 4 20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6M20 6L12 11L4 6H20M20 18H4V8L12 13L20 8V18Z" }, null, -1))], jc = { components: { ErrorField: Jl, StyledBtn: ic }, name: "email-link-login", setup() {
          const e7 = lc(), t10 = yt2(false), n8 = yt2({}), i10 = fn("errorHandler"), r9 = new kl(i10);
          return { emailMagicLink: (e8) => (e8.preventDefault(), t10.value = true, r9.SignIn(Sl.state.user.username).then((e9) => {
            ml.debug("Send email link", { username: Sl.state.user.username, emailLinkID: e9 }), t10.value = false, Sl.commit("setEMailLinkIDPending", e9), Sl.commit("switchPage", Ol.PAGE_EMAIL_PENDING);
          }).catch((e9) => {
            t10.value = false, null !== e9 && (n8.value = e9);
          })), canEmailMagicLink: vr(() => Sl.state.user.loginMethods.includes("email")), loading: t10, errorMessage: n8, i18n: e7 };
        } }, bc = (0, Fl.Z)(jc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn"), a8 = qn("error-field");
          return Vi(), Ki("div", null, [i10.canEmailMagicLink ? (Vi(), qi(s10, { key: 0, dataAction: "email_link", type: "primary", fullWidth: true, onClick: i10.emailMagicLink, classes: "email-btn", "is-loading": i10.loading }, { default: un(() => [(Vi(), Ki("svg", wc, Nc)), ar(" " + A5(i10.i18n.$t("email_magic_link")), 1)]), _: 1 }, 8, ["onClick", "is-loading"])) : cr("v-if", true), void 0 !== i10.errorMessage.username && "" !== i10.errorMessage.username ? (Vi(), qi(a8, { key: 1, "error-message": i10.errorMessage.username }, null, 8, ["error-message"])) : cr("v-if", true)]);
        }], ["styles", ["\n.email-btn[data-v-73144638] {\n  position: relative;\n}\n\n"]], ["__scopeId", "data-v-73144638"]]), Dc = { components: { EmailLinkLogin: bc }, name: "other-login-options", setup: () => ({ i18n: lc() }) }, xc = (0, Fl.Z)(Dc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("email-link-login");
          return Vi(), Ki("div", yc, [rr("b", Ic, A5(i10.i18n.$t("login_passwordless")), 1), or(s10)]);
        }], ["styles", ["\n.email-btn[data-v-86ffb468] {\n  position: relative;\n}\n\n"]], ["__scopeId", "data-v-86ffb468"]]), Lc = { components: { OtherLoginOptions: xc, PasswordLogin: hc, InputField: $l, StyledHr: Mc }, setup() {
          const e7 = lc();
          return { username: vr(() => Sl.state.user.username), methods: vr(() => Sl.state.user.loginMethods), signup: vr(() => Sl.commit("switchPage", Ol.PAGE_REGISTER)), back: (e8) => {
            e8.preventDefault(), Sl.commit("switchPage", Ol.PAGE_LOGIN), Sl.commit("setCurrentLoginMethod", "");
          }, allowUserRegistration: vr(() => Sl.state.projectConfig.allowUserRegistration), i18n: e7 };
        } }, vc = (0, Fl.Z)(Lc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field"), a8 = qn("password-login"), l8 = qn("styled-hr"), c9 = qn("other-login-options");
          return Vi(), Ki("div", null, [rr("div", dc, [rr("h1", null, A5(i10.i18n.$t("login")), 1)]), rr("form", null, [rr("div", Ac, [or(s10, { id: "username", type: "email", label: i10.i18n.$t("email_address"), name: "username", autocomplete: "username webauthn", value: i10.username, modelValue: i10.username, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.username = e8), disabled: true }, null, 8, ["label", "value", "modelValue"]), or(a8), i10.methods.includes("email") ? (Vi(), qi(l8, { key: 0, classes: "text-small" })) : cr("v-if", true), i10.methods.includes("email") ? (Vi(), qi(c9, { key: 1 })) : cr("v-if", true)])]), i10.allowUserRegistration ? (Vi(), Ki("p", gc, [ar(A5(i10.i18n.$t("dont_have_account")) + " ", 1), rr("span", { class: "link", onClick: t10[1] || (t10[1] = (...e8) => i10.signup && i10.signup(...e8)), "data-action": "switch_to_sign_up" }, A5(i10.i18n.$t("sign_up")) + ".", 1)])) : cr("v-if", true), rr("p", { class: "pointer text-center text-small", onClick: t10[2] || (t10[2] = (...e8) => i10.back && i10.back(...e8)) }, A5(i10.i18n.$t("back")), 1)]);
        }]]), Tc = { class: "heading text-center" }, zc = { class: "input-group" }, Cc = { key: 0, class: "text-small text-center" }, Sc = { components: { ErrorField: Jl, StyledBtn: ic }, name: "passkeys-login", setup() {
          const e7 = lc(), t10 = vr(() => Sl.state.browser.biometricMethod), n8 = fn("errorHandler"), i10 = new yl(n8), r9 = new kl(n8), o8 = yt2(false), s10 = yt2({});
          return { biometricMethod: t10, handleLogin: (e8) => (e8.preventDefault(), o8.value = true, i10.SignIn(Sl.state.user.username).then((e9) => {
            o8.value = false, window.location = e9;
          }).catch((e9) => {
            null !== e9 && (o8.value = false, "NotAllowedError" === e9.name ? r9.SignIn(Sl.state.user.username).then((e10) => {
              Sl.commit("setEMailLinkIDPending", e10), Sl.commit("switchPage", Ol.PAGE_EMAIL_PENDING), Sl.commit("setContext", "passkey_cancelled");
            }).catch((e10) => {
              null !== e10 && (s10.value = e10);
            }) : s10.value = e9);
          })), errorMessage: s10, loading: o8, i18n: e7 };
        } }, Ec = (0, Fl.Z)(Sc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn"), a8 = qn("error-field");
          return Vi(), Ki(Zi, null, [or(s10, { dataAction: "continue_with_biometric_method", type: "primary", "full-width": true, onClick: i10.handleLogin, isLoading: i10.loading }, { default: un(() => [ar(A5(i10.i18n.$t("continue_with_biometric_method")) + " " + A5(i10.biometricMethod), 1)]), _: 1 }, 8, ["onClick", "isLoading"]), void 0 !== i10.errorMessage.username && "" !== i10.errorMessage.username ? (Vi(), qi(a8, { key: 0, "error-message": i10.errorMessage.username }, null, 8, ["error-message"])) : cr("v-if", true)], 64);
        }]]), kc = { components: { StyledBtn: ic }, name: "expand-other-login-options", setup: () => ({ showOthers: async (e7) => {
          e7.preventDefault();
          const t10 = fn("errorHandler"), n8 = new Yl(Sl, t10), i10 = await n8.handle(Sl.state.user.loginMethods.filter((e8) => "webauthn" !== e8), false);
          Sl.commit("setCurrentLoginMethod", i10);
        }, i18n: lc() }) }, Oc = { components: { ExpandOtherLoginOptions: (0, Fl.Z)(kc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn");
          return Vi(), qi(s10, { dataAction: "other_login_options", type: "secondary", fullWidth: true, onClick: i10.showOthers }, { default: un(() => [ar(A5(i10.i18n.$t("other_login_options")), 1)]), _: 1 }, 8, ["onClick"]);
        }]]), PasskeysLogin: Ec, OtherLoginOptions: xc, PasswordLogin: hc, InputField: $l, StyledHr: Mc, InputFieldContainer: Kl, UsernameInputField: oc }, setup() {
          const e7 = lc();
          return { username: vr(() => Sl.state.user.username), methods: vr(() => Sl.state.user.loginMethods), signup: vr(() => Sl.commit("switchPage", Ol.PAGE_REGISTER)), back: (e8) => {
            e8.preventDefault(), Sl.commit("switchPage", Ol.PAGE_LOGIN), Sl.commit("setCurrentLoginMethod", "");
          }, allowUserRegistration: vr(() => Sl.state.projectConfig.allowUserRegistration), i18n: e7 };
        } }, Pc = (0, Fl.Z)(Oc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field"), a8 = qn("passkeys-login"), l8 = qn("styled-hr"), c9 = qn("expand-other-login-options");
          return Vi(), Ki("div", null, [rr("div", Tc, [rr("h1", null, A5(i10.i18n.$t("login")), 1)]), rr("form", null, [rr("div", zc, [or(s10, { id: "username", type: "email", label: i10.i18n.$t("email_address"), name: "username", autocomplete: "username webauthn", value: i10.username, modelValue: i10.username, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.username = e8), disabled: "" }, null, 8, ["label", "value", "modelValue"]), or(a8), or(l8, { classes: "text-small" }), or(c9)])]), i10.allowUserRegistration ? (Vi(), Ki("p", Cc, [ar(A5(i10.i18n.$t("dont_have_account")) + " ", 1), rr("span", { class: "link", onClick: t10[1] || (t10[1] = (...e8) => i10.signup && i10.signup(...e8)), "data-action": "switch_to_sign_up" }, A5(i10.i18n.$t("sign_up")) + ".", 1)])) : cr("v-if", true), rr("p", { class: "pointer text-center text-small", onClick: t10[2] || (t10[2] = (...e8) => i10.back && i10.back(...e8)) }, A5(i10.i18n.$t("back")), 1)]);
        }]]), Uc = { class: "text-center" }, Qc = ["innerHTML"], Rc = { class: "provider-options", part: "email-providers" }, Yc = { class: "provider-btn text-small", href: "https://mail.google.com/mail/u/0/#search/from%3A%40corbado+in%3Aanywhere", target: "_blank" }, Zc = lr('<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="22" height="22" fill="url(#gmail-952288)"></rect><defs><pattern id="gmail-952288" patternContentUnits="objectBoundingBox" width="1" height="1"><use href="#gmailImage" transform="scale(0.000976562)"></use></pattern><image id="gmailImage" width="1024" height="1024" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAIAAAB7GkOtAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QIJCio5sGz9jQAASWZJREFUeNrt3XecVNXZB/DnObdM3Vl2l95Z2lLteY29R42JxiQaDSrBrsSYaIxJjFETTWJiRwUVRcUejfG1xfJaEgvYEBCUJlVAYBd2p997z/P+cXdXNKiU3Wn39/3kE2UHmTvDzPnd89xzn8MiQgAAEDyq2AcAAADFgQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKDMYh9AQYhs4YfMxT4sACgRWxoiqPKHiIoLAH+sF5G2f2eltjjWi9YkQkzs/zUzIxIAgkGIhKTtX0gRqy3/NvGImNqHCKIKSwWWLZ4dlx0Rf9BntYW/SPE8f6z3XzKJZtPawh+iRUgYSQBQmYREE6stD+LaIVabTQWY2NjSn+ER82epUObKPABERGtmpvZxX0t2+TJn/TqnqSm/fp27YYOzfr3T0rL5SybRbFl2Ta3do4dZV2fV1lq1NXaPnlZd1y/9YwGgLAmJEMnmo7nkPqHcanLWUX695NdIfg3nG0lcf0wXIvZPGO0aDvVgo6uEerLVlUI9OTJosz/YI6IvjZMyUbYB4B9226m6u3Fjav689MKF6Q8/9AMg39jofPqp29RIxGya//Vfi7iuEYlY3bpZfgb06BEbMiza0BAfMzY8YMDnnggTAoCypDdf5yLJ+dLyNiXnSuojyq0hZ53kP6V88vO/azP+0GgZHOpNVleye3K0nqrGcGwMx8eSGd/sWcp1QlB2ASCtfyvMROQ0NW18+f9SHy3ILFyQXrI4u2iRm2xRoTCbZuv/DINoSxeB/TFdi7iueK52XXEcctxQv37RUSMjAwfFR46KjRlbtcsurb9fa1wkACgTbZV9/xdNr0rzW5KcS+lF0jKL8snW4VoRsUlsEvFXXQQWl8QhIdJEmshkjo+m2DAVG07xnanuCG5NAt32n5TTKFF2AdAqNX/++scfa545I/Xhh7k1q9kwVDiiwmE2DNK69Qrw1rw0ZiJqrfsz6byj02kvk7Hq6sJ9+yZ23qXu6GNqDjyYDf/DJOX1twsQPK1fUvHStO4fet3fZeM7lF1BLpEiMg1iq+0isLT9/q/Fn9X9xSPtkEdERKFqrt6Va/bn7idybOgXDqAslEkAbFaHaXr5pcZnnmqZMyf1wTwvlTSrEmxbJCSiSesdfj+YlSJW4rk6nRbPiwwcVLXT2LrvHF1z0EFGLP6FgwGA0tBaGSAiyq/X6x6T9U/QppmSWUeKyLCJDCJNorduxP9KrPzpA+ksuUJWiKvGcPUu3O1Erj3giwdT2sokAIiIaOPrr62++cbmD+blVn3ChjLicVaGaG+rzvS3461Ripi9VErn83a37pF+fbuPG9fj+BOVbRf7nQCALRCniVZcpz99QtKLyUmSIjJCrYt/OgUTKxKXPI+EKNqHq/dQA37D1Xu0H1GJx0B5BEB25YrVd97e+Oy/MkuWkGUZkQj5izsLQClWSmcyOpezamoSu+/e76KLq8buVOy3BAA+Rxqf1x9fJRvfIjdFhkHKJJG20nyn4tbbCLwcCXF8KPf4nup7AYW6F/st2YpDL9EAaCuzeOn0mvunr556R3bFChJR0Sj793AVGDMbhk6nxXXt3r17HP+jPmeeZVZ32fxQAaCw2sr92U/0x5fL2kcpv4GUahv6Cz6ysSIR0g6R4uhINfBn3Hs8sbn5oZaakgyAtiE1/fGSpZf8dtPMGV465a/tKdBZ/5dRioh0NqNMK7Hnnv0vvCix2+6bHzAAFErrkKrXP62X/I6a55A4ZNjFGfo3x4q0R9ojK85dj1JDr+Fw780PuKSUXgC0DaYbnn5yxU03JWfNYtviUIj8zg0lgJXS+TwxW1VVPU8+pfdZZ5tVic2PHAA6U9tImlvjLfmjrHmY3HXE/ol/wWsDW8bETDovQqrmADXo11x32OeOvGSUWAD4Y6jnrZp864pbJrmbNqlQiJTqgOU9HYuZiHQmw4ZRe9hhA3716+jQYZ8dPwB0lrYxdNOb3sKLpOk1Ik3KanuolLAi8Uh7ZHdXQy5Xfc763PGXhlIKABFizi5btuK6a9c9+YS4busdvKVzhF9gGOI4JBKprx/4q1/XHHQwW1Zb06ES+jsGqAhtayu9tKx9UC/+reTWEQtx6Zz4/zf2O8qxinDv8TzoEg71KqkMKJkAECHm3No1i37x8w3/etZMJEip0h362zGT1tpxDMPsPXFin9NON7vUtHYZxFQAoMO0Xe/NfaKXXCGrppAQqa+4ibd0cOtNZ57HvX6gRk5lM1E6GVAaAeCf+y9fvvQPV6x74nEjkdja+3hLATP5zYUyma7fPqr/Ly+KDhve/qKKfXAAFaC1WY9selMv/JU0vSrKZir2xd5tZoiXU31OVUOu4lD3EsmAEggA/9x/9epFv7yg8cknje5dySvZCd3X0JlMuF/fgZdeXnfkt5mZtEY/UYAdIppYic7K6vtl4c/FaSZlldvQ347FdVSvH6sRN7JVWwoZUOwAECHm/Nq1H1/2+08fecioqyPXLe47skMMQ6czViTa98ILehx/gtmlyxe6lgLAVtus7LPsBll5C+l0KS312T4GeTnue64aeiVb1UXPgKIGgNaklNvcvOiCX6x77FGjrpZct+zHSqXEcSSdrjv66P7n/yI2ajQRykEA26h15xaipte8xRdK45ukzGKfLnfci/Nco+/Zavg1ZEToS7tRF0LxChQifnlk7X33rv/7342udZUw+hOR1myaqrp6w5NPLjj/pxuefpqo9VpxsY8MoEz4ZR9x9Kq7vbknSuObZIQqZvQnIjZCetWtes1DRESkiljRKtIMoP1ur2efXnjBL7xMhitg6P8Cw9AtScMO9f7pxF4nnWz36Nm6y1jlvVKADtPayl8yi/Sy62TlVJIcGXaZl322+EI9CvVUox9UNfsV8SiKGQDphQs/OvO01OLFyqy4vemJiIgNw8vnWaj20EMH/Ori6NBhWCEK8OXaiv6bZsjCi3TTqyV2f2/HYtIOd9lLjXmIw32LdTGgGCUgEWKWfH7lDde3zJ2rLGvH/8jSJJ6nTJNNY/1TTy44/7wNTz9JTMRchGZ2ACVONBGTzuuVd+i5p+gNr5JhExsVOvoTkZCypfF1+vgqIirWDQ0FnwG0FX/W3HvPkssuFa3ZMMpmyf/2YqXc5haztqbXSaf0O+9nRjyOy8IAmxEipvw6b9Gv9ep7ycuzGWrddb2SsX+TsBpzP3f7bnGOoCgBkFu16oOTfpxZsqRtq8XKx4bhZdIqFK495JB+5/881jCy/d0o9qEBFFFb2Wfjq7Lkd7rR7+1jB2D0b38DNFfvYez8DFk1hS8EFXb8ldYV8Wvun55ZvIg5QAvkxfOMcIQ8b90TT3x48snrn3qSiIi54mc/AF9OiFjE9VZO0bPH6fWvEjOxGaDRn5hIZNO7sua+tl8WVGEDgImIsiuWr//n46293oI0/InWZBhGLJZZuWLJxRct+8tVOpcLTgQCbKats5uzUX94riz6jeRWkBna7KGAEFImiaNX3StOU+FffgEDoG2sX3HjddkVK5RtF78LReGJkNYqHs9vaFx16+T5E05JLfjwC+8PQKUTIhYiafqPfu8AWXk7OY1kBKns88U3gyU1V5ZfQ0QFvhpcwABgJqLmt9/a+PIr4nlBO/3/HM8z4jFi2viff394yikbnn2m9f0J7BsCwcJEJCun6jk/0pveJ6Uqc6X/1hJSJum0XvMIpRa1vz+FUagAaBvaPn3kYWfDBmVZQTz93/z98DwyDLbszNKPF138q2VX/9nduLG1HBTsdwYqV9sHO/eJnn+mXnSRZFeRsohUgEf/tjeGmXKfyJp7CvzMBb0G4CWTm15+2UulWjdOCTgRElHxuLth/YqbJy244GfZFcuJMBWASiRtq31a3tezj9MrbyO3kUyLyq+rc6e8O6RMcpN6/dNt70aB3pOCBsCG557NN29SoVDAT/8/R2sOh5Whml54cd5J49Y/+b/i90TCWwSVwd/bg5kk662c4s06Wm98jZRBjLPAzQgTk2Q+kQ0vFPJpCxUATETU9PSTblMTh8LojPY5WpMy2DRTH3248Oc/WzXpRkqnUQ6CSuAP/cx67Xrv/Z/Lwp9SZhkps7gd0EqSkDLJWa3XPVzIZy3YDIBTH85Pzf+IRLDucQtEiMiMx13H/fTWm5r/cLG7YhkRykFQztruc3QWzt94yS/zM+/mkEvK9h8r9sGVGiFWpEk2zaP8pwVbC1SQABAhosZnnslt2KCiUXTC+VKiiYktK//qi5t+/dPsS8+T1sQc9EtkUI78ll+uk/nfxzZdPNGZ+TbbkdbdcWGLREgRZRfpdf8s2HMW7hpA6r233KZGXP79GkIkpKqqveXLkldfln54uqTTxKqcNkmGgGsr+sumjem7Jidv+LM0NnEigfOYr6dMcj6l5tcK9oSd34dZhJi9dCq3/BPxPGbGMPZ1RLTHobDkcslbr3Xefyd2+nlm/WD/Edw5DCWtvezzwezkbTc478zkUIRMk/IY/b+WECtySKdWKaK2KlDnft8L1Ig/vWCBk0kp28bl360lQkqxEcq99JzX1BgbNyG09/6tUwFkAJQm/8PputkXnkndd5e3cD4nqvGV3zaKyFkv6cUcHVyYZ+tkIkSU/uhDp6WZg9n+YUeIcKKLO2dWy58uTU6+USeTbbtL4m2EUtJW9tGN65PXXdVyzR+9ZUsw+m8z/4w/v1pS89t+3bkKNAPILlzoNjYZVVX4QGwz7XEsJulU+sF79JpPoiefZg4eRoRyEJSMto9ifva76elT82/8m60Qh0L4sm87IWWQs57THxAdVYDn6/wAYCaizKKFkstxdTWWAG0Prcm0mCj7r//1Vq+Mjjs1tN/BrStEkQFQXKL9ymT2mSdSD0xzF8xX1V1Ia6xZ2C5CbJGTldRspkLsDtDJASBCzE5jo5dOk2F07nNVNhEi4kS188Hslr/+wZk3JzbhHLbtYh8WBB4raWlO3XZD5rmnJZ1S1TWkA9nUs8MICYmTISrEdimFKAG5zc06nw/C1o+dTmuOxXVLc+bhe/W6T6PjJpiDhhChHAQF1172mTMrc/9duddeYcPgSBSjfwdQRDpFbjOZic6eBRQiALyWFi+bIxWU3R87l9ZsWaR15pkn3I/mRU85I3zokRj9odD80u5jD6YfuNtbtZyjsbblCdARvIy4zWwmOvt5ChIAqaTO51kpzAA6hggppWJx9+PFqcnXu8uWxH58KkcixT4sCBC9aWPqrltzLzyrN23keBVuVOxITKKz5CYL8FQFCYDmZp3LEit8QDqMCJFwLOZtWJ+++3Zv0UfRs35uDaxvfQgTAugM7WWfubNTU6533p3JdogjEZz4dzjWaXI3FuCJChEAOpsRx2GFvmYdTWu2bfLc3OuvemvXxE45M3TAIRj9obMwE1H2fx9NPTDNW7mcwxEyDIz+HU2IiSRPkinAkxVmFVCTl0rhGkCn8FtJW8pdvKDluiudjxdHf3iiilcRYSoAHaTtg6QbN6QeuCv75D8knWI7hKJ/p/BPkt0k5de3/brMLwJLPk+exwqDUecQIcUcCutNmzJ33ep9ODd+3kVGn364UQA6wGctnT9quf5P7vvvsmWxHULRvxMxkWiSfAGeqiB3AjNjGOpc/l0ClkVa5974t96wPnLCKaGDD2dkAGw3f3xnJs/LPPlY5pHp7orlHAqRMtDXsyAK8bUtUCsItK4pBL9/nG07C+a7f/6998mq6PdP4Gj0s28ywFZqL/tsbEo/MC3z0L0iwpaF3SkKqBCDZqECAArDnwqEQiSSvv1Gd+H82Cmnm4OHtz6EDICt0V72mTMredetzszXORxpnU2i7FNZEACVyP+W2uHsc096SxbGzvxZaJ8DcUkAtor/IXGc7PNPp6ZO8tas5kgMO3lVKqzMqWCiqqq9VSuar7wkdc8dkkkTTuLgK7S3dN7YlLxjUvPfLtdNTRyNoYBbwTADqGgiZJiUz6cmX+cuWRA94RSrYXTrzzEVgM213+T13szU9Dud117iWDUx4XShsiEAAsBQHE/knntKr1wePfXc0F77oRwEn9PW0jn34rOpO252VyzlRA3W+AcBAiAAhIg0VyWchR+2/PG3zne/Hz3+JFVThwwAIv/cX3mfrEw/MC377BOUdzgWx+gfEAiAwNCaQ2HJpNPTp+p1a6MnjDeHYHVQsPl/9czO7PdS99+Ve+UFFYkSNu4OEgRAkIiQabJhZP/1lPvRvOi4U8OHfxfloIASIWYhyj56f/q+u7x1az/rIAKBgQAIGBFi5kjEXbokOekab9WKyHEnqaoEMiBwmL11a9P335V9+p+STnMkihP/AEIABI9/s1g0Li3NqXunuss+jv3kLHPQENwwHAhtSe9+8H7yrin5ma+xwk5ewYUACCrtUSjErpt78Vlv6ZLIieMjh3+32McEnc/fyevR+9MP3eOtWsXhMBkGRv/AQgAEmNZkGByNuUuXpCZdoz9dG/necaqqutiHBZ2htauwt+7TzMP3Zp74u2QyHIuRCCo/QYYACDa/HBQOS0tzauotzux3q356kTFgUOtDKAdVhvayz/w5LTde7Xwwh5g5HMbQD2gFAURaUyjEhnLenrHpsouyr7xIRK2rg6Dc+aO/9jJPP77p8ovdeXPZsjgUwugPhBkAtNKaDJNY3CULW/74G3f+idFxE7CzWHlrW+avGzckp96cffpx1kJ+S2eM/kBECAD4jAgxsR0ix0k/dI+3cln8tInGwHrcKFCW2ss+8+Ykp1zvzJ7FQuSf+GNiB20QAPB5ImRZ7Hm5/7zsLvs4fuZ5oT33JdNEBpSNtuW8ksnkXn0hNfVmvXYtmSYphRN/+AJcA4D/IkKGwYbhLV/actlFqelTJZ1uHf1x8lji2so+0rwxeftNLVf9zvt0LVkWKYW/O/hvmAHAlvg3DNu2eF5q2mRv8YLISadZw0agHFTS/KaeRM7776buujX/3ttsWuwP/Rj9YUsQAPDl/E2GmbMvP+98ND/+0wvtfQ5kf1dYxtyxxIgQK3HyuRf/lbzlGt3UxHaIFCZt8FXwNYavw8zhqLf2k5Y/XZq+/y7dvMnvHY+RpVS0Ff31hnXJO25u/tsVsmkTRyLE2MsLvgZmALAVRLMdkkwmdfPf3A/nRU853UIr6RLRvoH73Fnpqbfk3vwPR2No6QxbCQEAW8dvJW1W5V5+zlu5LDbh3NC+B+CSQJH5b77nZV54Jn3XLd7KFew3dsXkDLYOAgC2mt83IhJ1F37U/MdfR344LnrMD1XX7siAYhASImZv5fL03+/PPPEIOS5HYzjxh22CAIBtpDVHo5LLZe6701u6JHb6RBO9gwqsda0nOR99kJp8vfPuW2yYFIlg9IdthQCAbac1WxaJ5F56zlu2JHri+PARR7c2GFBYVtDJtCalxHUzjz2YefQ+b+VKjkZbfw6wjRAAsF38clAs5i5ZmJx0jbfmk+jxJ3M0hnlA5xIhpXRTY3r6HZkn/yHJJMfi6OYP2w0BADtAa45X6Zbm9P3T3MWLYj85yxw8lAjloE7QvoH73PdTd97szHqXtMboDzsIAQA7xvM4HCbXzb30nLdkQfSM88IHHIrVQR3M38Dd8zJP/SN99xS9ejVHo9jJC3YcAgB2mL+zWCzmrliWvP5P3sIPY+NOp0iYiNo3ooLttHlvn6m3Zl98RjZt5HgVaQ9rPWHHIQCgI4iQCEeiesOG9AN3Ox/Ni59zgVk/hAhTgR3QfpPXB++nJv3NmTeXSLCBO3QgrNmAjqM1RyLEnH/rzebf/zL32stEhNF/+zGTSOaZJ5ovvzj/wWyyLLKxjyN0JMwAoENpTUqxZbkfL2656lLn28fETj6dsbPYNml7o3Tj+tRtN2ZfflFSLRyOEBEJRn/oSAgA6GgiRMyRiKSSmUfuc1euqJp4gdG7L64Mb5X2nbwWL2i56a/ue2+TUhyOoOIPnaEwAcBoTBgwQkJkWaS9/Osvb1y2JHbGT8P7HEiGgQz4Uu07eTlO9rknU3dO1us/ZX8nL4z+QVSIr0khAoA9R4iEFSMEAkWElMGsvGVLkn+5zPt4UfS4kzgaa30IMbC59rLPpqb0tMmZp/4pmQyHw60PQYCICDERUyEu9RciAHS8iyEueXltRFncAjwjlIq2/nGSy6Xvvs2ZNzd+1vlm/RCUgz7HX+Yv4s6bk7z1WnfOLDItDocx9AeQkDKZiClPUbvzn65zVwEJMxEtG7TfotFHKXFMJyNsdP6LghLjj/WGmf/3/zVfemH2pedaf4IBjtpGf9fNPvnYpkt/4bwzk+wQ3pxg0sQWOR7Rv3XDB14PIpJOLgR1cgAQE9HHVp/H9/3LjP+ZmLMjtpMSVp39qqA0cVXCXf5x8i+Xpx+YplPJ1mEusCOd/9qZdVNj+o5JyRv+LI2NrQ39IWCESIhsdjZK6I7srn9t2WV5vlJKQLa4TVn92Dd/v6J21H4zbujVuMAxw1oZjDVtQaM1h8KSzyVvvc6Z/V7sjPPM+iFEgbwksNlNXsnJNzjvzOBIjEwLy/wDSBObpBXreU7tHdnRT2T7DLQ32gXZdrtAy0ANIjfd8uawH2wMddt31uSG5S+zGJ5hIwMCx99oPhLNvfy8t7EpNm5CaK/9Wxe6BCcD/BfrutkXnk7dP81bMJ8TXdDdIZg0sU2eJn4+23dapuE9p65aUorDhXn2wt0HwKxCueRHffddVdew7+xpe8+5M5xPOmYIGRBEWnOi2p0zq+WqS52jvhc96XRVVRWIDNhsA/fU1Fuyzz0l+TwnqtHdIYD8j4LN7gYvck9m6EOZ+oxYCeXmvMJ9Cwp8IxjbTiodrn1ht4lNiT77zrq977r30+FaZEAQac2xmGTS6Yen60/XRMedZg4ZRlTR5aC2l5af/W56+p35N15lO8ShEMo+AeR3STSVMy9fNy0z/IVcbyIOsasL256n0HcCCyvTzWplvDZq3JqaYfu9f/vYRf/0zKhmZsx/g0ZrMk0myj77pLtkUfTHPwl/6zvETKKpIAXQQr9YpcjzMv94MPXIfd6yJSrRhbRG2SeANLFFmkgeT9ffmxk6z62Js1OUldFFaAUhrJTocD65tOfuTVW9GxP993n/NsvTrhEi8tA9OFj8GwUSCXfJwuQt17pLl8R+cjbbBVgAXXBKSbI5NeXGzPNPSzrVOvpD8AiRzW5a7DtSwx/ODmrRoSrOE3FRTgSK0wvIXwZqO6nmaM/ndj9/Q/WAfd6f2nPD3LxdgzvFgkhrjsb0po2ZB+/Rqz+JnnyqWV8p5aDPyj7vpe+bmn/j32yYHMYG7kEkRExssTsv3/Xu7JDnc320cJhdXbyz3mI2gxNWlptxDfv1UeNWdht72MyrRy95Km/VSJl/5WF7aM2WTVpnnnvSXfRR9JQzwoceWfajP7V2w8489mD6gWneyhUcixEzRv9gMkmYvKczA6akGxZ71SH2QuwVcfSnoncDFVamlze0u6LbmMf3vXJtbcM3595ru1lPmegeFzgipJSKVbkfL05Nvs5dujh64gQVi/mPlVltsL23T1Nj6u7JuRf/pTduZH+lE4r+AdN6vZf1Jm3fnRn6eGbgeh2JsktExR39qegBQETCikhsJ9NY1fepPX+9um7EIW9f36NxYd6KEpqIBo0IkXAs5m1Yn777dm/RR9FzfmENqC+zncXayz5z309Nvt55bybbYY6g7BNEQqSIDHY/dGpvSY16Kd/LYIkUteyzueIHABERsTBZbtYzrPcHf2d9l0GHvnX9iKUveoalK281CHwtrdkOkeHl3viP9+na2EmnhQ76VpmM/n6Zl4ko8/hD6Yeme6tWcNjfwB2jf7C0nfgLC/0rM2BKpmGpl7BZm6RLZPSnkgkAIiJhZXiuVmpZt50fOPj6g969eY8PH47kNnnKEiYsEg0Wf2cx23YXLWi++orIogXRE8erEt9ZrL3ss2F96u4p2aceF8dh20bRP4Dayz7rvciD2fr70kPTYlrsqRIo+2yuhAKAiIRZiba8bNaKP73nrz7pOuKIN/9a27LMMcJambhfLFhEiJnDYcplM/ff5S1eEDvvIrNPvxJtJd3e22fhhy3X/9mb8x6ZFodCKPoHkBAbpBV7y9zqa5NjXnF6KZIQe1R6Fe3SCgBqWyFqiOuxOWvI0eur6w9++9qG5a8anuMZFouU3nsIncYfOk2TtM698aq3bm30xJ+EDjmCWzOASuLKcFt3B/K8zBN/Tz883Vu1gi0bO3kFkP/3bbHnino2M+COTMNSt0qxmKX6USjRCrsQG57L2lvefeeHDr5xxqgT83bMziep8xtkQ8nx+8fZIW/xgparL0/dO1UyaWImKYHdsvwTf2a9sSl5+43JG/7irV7FNkb/IPLLPhZ7G3XonszQy1O7LnETpTz6UwnOANoJM5M2vWzOij2+z+VLe+xxwKyb+6z7wLFimhXKQcHif4OsEGmdvv0md/7c2MmnWQ2jWh8qVjmofbXPe2+lpk1x3pnB4QgHfJODoGpv6TzXqbst1fBKvpfFYrMu8ZJF6QYAEfkTfBZNpN5q+OG6msGHz/jz4FWvm564aCMaREJEbIdy//esXv5x7MzzQvscWLRLAv6TOk72hadTd0zy1qzmaAxDfzBpYpvdvJivZPtMSo1c7CUirEtgfvr1SrQE9AUsXthJruw66v6Db35z1LicHQ/lU9hdMqhEVSW8Vcubr7wkdc8dbeWgAo687Tt5bWxK3jGp+a9X6Kam1tEfAkaIhNhmp0mHp6eH/i6523KvKspeaZ/3f6bEZwDtWIhMz0lHqp/Y+4pVXcfuO/u2fp/OydoJIeIyea+hw4iQYVI+n5p8nbtkQfSEU6yG0a0/7+ypwGdln5mp6Xc6r73EsWrisjjbgw7WdpOXM9epuzPd8Fyuj8XaYl1GH4VyCQAiImE23ZywMWPkCeu7DPzWjD/Xf/KuMHmGzYI2osFjKI4ncs89pVcuj556bmiv/Tq9HOT3qRbJvfhs6o6b3RVLOVGDNf7BpIlt9rSoV3K9J6VGz3dr/O4OZTT6U3kFALX2jdChfHJJrz3vO+y2veZO22vOvfHMuqydUGgjGjRCRJqrEs7CD1v++Fvnu9+PHn+SqqnrrAwQIVbeJyvTD0zLPvsE5R2OxTH6B5MmtpWzzo1Nzwx9NDuwWewYOyV1h9dWKrMAICIiFmbbSbVE6p7f/fzmaK995kzttX52NoSdxQLJ32g+k05Pn6rXrY2eMN4cMpyoQ8tBbWs9ndnvpe6/K/fKCyoSJdvG6B9A/lpPm515+bp70kOfyfVnKqHePtuqHAOAqLWVdFYr843RP17Wc5dvzfzbyKXPe8rWykAMBI4ImSYbRvZfT7kfzYuOOzV8+Hc7rBwkQsxClH30/vR9d3nr1n7WkQICxt/AXZifyg68JTVihVcVYs/fwa7Yh7adyjUAiEhYsXiW663sOuYf+/5xbe2wvebcHck15+w4C7bYDhi/b0Qk4i5dkpx0jbdqReS4k1RVogMygNlbtzZ9/13Zp/8p6TRHojjxDyZNbLOzUUfuSQ19LDdwvReOsafL/NbUMg4AIvJXB4Wdlsaqvi/sdt66LoMPfvvarpuW5q0qzAMCx99dMhqXlubUvVPdZR/HfnKWOWjIZ60atvVPYyYi94P3k3dNyc98jZXBkShpnFsETmvZh9xFTs2t6ZGv5HvlRcXZ9cp56PeVewAQEWk2wk7KNUJvNfxwdW3DoW9fN+rjf3lGCK2kg0h7FAqx6+ZefNZbuiRy4vjI4d/dnj/Hb+n86P3ph+7xVq3icJgMA6N/AAmRRZqYnswOmJJuWOombNaRihj9qTICgIg0K8NzDO2s6D72H/v9YX31wD3mPxRxko4KMWEqEDBak2FwNOYuXZKadI3+dG3ke8epquqt+49btx7z1n2aefjezBN/l0yGYzESQeUngITIYt3ohR7KDHk4O2i9DkfZkxJr6bwjKiQAiEjY32g+3RTr88yeFy/tuft3XrustuUT1wxpUrhZLFj8clA4LC3Nqam3OLPfrfrpRcaAQa0PfVk5qL3sM39Oy41XOx/Mae1HjaE/eITIIFLsLXESV6d2nul0c4WjZbva58tUWpFEWNluRpP6YOBh0w+b8lH//UnE1A5uEwsirSkUYkM5b8/YdNlF2VdeJKLW1UH/zV/to73M049vuvxid95ctiwOhTD6B5PFWhM9n+t3YcueM5zuTBQp9gbunaHSAoD8ncW0y6KX99jl3m/d+urOZ+bMmKEdIi7r6/WwPbQmwyTDdJcsbPnjb5KTb9DJltYZQHsMtF0l1o0bWq65suWvV+jVn5BlkVIY/YPG/0yYpDdpe1Jy9CXNeyxyq03SRjmv9fwKlVMC2pzfStpys1mr6sXdfrqmdtjhM/5Wt2mpY4aws1jgiBAT2yFynMxD93grl8VPm2gMrP9sKuCXfebNSU653pk9i4nIP/HHSv+AEWKTNLNe4lRfmxoz0+meFxVpXetZmSozAIiobaP5nKus94YevSEx8LC3/jZo9dumm3bNKG4UCBwRsizyvNx/XnaXfRw/87zQnvuSaRKRZDK5V19ITb1Zr11LpokT/2Dye/tktfnvfO8p6RELnWqLtc0V/lGowBLQ5oSZxTM8Z2nPXacfdsuMkSe6Zsh2WlAOCiIRMgw2DG/50pbfX5SaPlUyab1pY/L2m1qu+p336drWsg9O/APGHwpsclPauisz/LfNeyxwutisVeWe+Ler4BlAOyYS283krPjTe168qtuo/d+9qWfTx54yUQ4KHP+GYdsW10vffZv70TxJJfNzZrFhsmFgO5cA0sQWaSaZ69bdnhr+H6cXEYXZK/GdvDpKEAKA/BuGlXY0GzOHH7eqbvRRb1w2eNVMy83kzahCOShoRMhQJJJ7/VUmYtP80qVBUNHad/L6T77n31JjlrlV5djSeUdUeAno85jFCzmpVV1HPHLg9a+POSVnRcL5lOCG4WBiZtsm2y7alsJQPP4Jvs1Osw7dlRp+WctuK91YnJ1iH1ehBWQG0I6FOeRkNsW6P7HX71fXjjhg1q09Ghe5ZggbzQcRzvoDqX0D9w+cuqmp4c/l+9qsw6wrcqHnVwtaABC17iyWF+YZI05Y32XQIW9fP2zFq4qVa2CjeYAK56/2IeEXsn1vyzR84NTG2Q1Ixf+/BTEAqK1vRNhJLurzzfXVA/aZM+1/5t0fT6/PWzGsEAWoSP5NHza7a73og5nBf8/UN0qoip3KaOu2fQIaAD7NKpxrSUa6vbDbz9ZV1x/69rV1m5Y5ZhQbzQNUmLYN3N0lbvVNqVEv53ozSzzYoz8FPACISFiZblaz8VbDcWtrhx4w67adFzzmmhEPK0QBKoUmtthjoscyg+/NDF7oVkfY4wpq6rndgh4A5O8sRtp2Uh/33C25128aq/ruPfs220nnrSgyAKDcCZHNbotnT8sMeyw7aI2OJNjRxJjjEwKgDQtzNNfSGOvzwm4/XVMz7OB3bui2cYlrRoQk6CcJAOXJ39vBYvcjt/bW1IjX8j0dUtWBL/tsDgHwGc3KdjOuEZ454vhPa4cc+tYNI5Y+p5WllVHsQwOAbSNEFguJPJkZNDUz/EO3OsaeTR5G/80hAD5HWCnthpzU8u47P77vFWtrB+89+05DRDP7LSWKfYAA8DX8E3+TpcUz784M+0d20Kc6XNV6iy9G/89BAHyRMBOJ7WQ2JPo9t8eFK7vtdPibf+ravNxTtmbsLAZQ0oRIkRisF7hdrkuOmZHv7lEF7uTVURAAW8TCZDtprcz3Bx/VVNXn8Jl/G7riP8yslYV5AEDJskiI5YVsv1vTIxa41SH2LAriLb5bCW1wvpSwUtozvPzSHrs9cPD1z+9xvmOGlHap7T4yACgRfm3HJL1JrKtbdrqiZdcFbnWYPYW1nl8JM4CvIsyKtO2mU+GaF3eduDHe+5C3b6htXuEZhqdsLBIFKAVCbLJm0kvc6lvSI17M9mWWCHuE2frXQQB8Df/MQmlX2JjZcNwnXUce/ubVQ1a9Znp510AGABST393BIu2IejnX5+b0qI/dKou9IOzl0iFQAtpKrMQzPWd5t50eOuja/4z9iWOGbCdNKAcBFIkQKxKL3WaxpqQaLmvZdYlbZWP03xaYAWwtISbStptOh7s8/T+/Xl036qB3b+rWtEQrAzuLARRY205eNN+pnZJpeCnX2yYJo+yzjRAA24SJiEUz8YwRx63rUn/wO9eP/Ph5JZ5rhNFGFKAwNLFNnhA9ne1/e2bEfDeRCHBL5x2BEtD20ZFcy7IeOz+6/1/fGHNSzorYTkpY4TYTgE7VvpNXk4TuTA+/Krnzx268mh0M/dsHM4Dtw8JsudlkpOaxfa9e1mOPg969ueeGjxwzrJWBchBAZ2jfyWu+U3dbuuGZXN84e1Ygd/LqKAiAHcFKu4q8GSOOb4n22Pf9KQ3LX2YxPKwOAuhoftlHEz+f7Tst0/CuU1fNDr5mOwgBsIOYiCK55Ef99lvVdcS+s6ftPeeucL7FMbG7JEDHaN/Ja4MXuScz9KFMfUbMBOdx4r/jEAAdQJhtJ5UO1b6w28SmRJ99Z93ed9376XAtMgBgB7V2dlPOvHzdtMzwF3K9iTjEHkb/DoEA6BjCyvSyWhmvjRq3pmbYfu/fPnbRPz0zqplZcIEKYHv4az2J5PF0/b2ZofPcmjg7TILVFh0FAdBhhJUSHc4nl/bcramqd2Oi/z7v32Z52jVCRB7hIwuwLfydvNLaviM9/OHsoGYdSnBesJNXh0IAdCT/xMR20s3Rns/tfv6G6gH7vD+154a5ebuGxS320QGUByFiYovdefmud2eHPJ/ro4UjaOncCRAAHU9YWW7GNezXR41b2W3sYTOvHr3kqbxVg70lAbaGScLkPZ0ZMCXdsNirDrGHon8nQQB0CmFlenlDuyu6jXl83yvX1jZ8c+69tpv1lInbFQG2qG0nL71J23dnhj6eGbheR6LsElo6dxoEQGcRVv7OYo1VfZ/a89er60Yc8vb1PRoX5q0odpcE+AIhUkQGux86tbekRr2U72WwoOzT2RAAnYqFyXKznmG9P/g767sMOvSt60csfdEzLM1owgFAtNkWviz0r8yAKZmGpV7CZm1iJ6/Oh2Go0wkrw3OJ9LJuOz9w8PUv73JW1q4ytOv3kyj20QEUU3vZZ4MXnpQeeVlyt8VutSJtkGD0LwDMAApBmJVoy8tmrfjTe/7qk64jjnjzr7UtyxzD7x2EchAEkRAZJIq9ZW71tckxrzi9FEkILZ0LCAFQIP4KUUNcj81ZQ45eX11/8NvXNix/1fDEMywW9LKFAGndyYs9V9SzmQF3ZBqWulWKxSScDRUUSkAFJcSG57L2lnff+aGDb5wx6sScHbPzSf8hRAAEgV/2sdht0qF7MkMvT+26xE1g9C8KzAAKTZiZtOllc1bs8X0uX9pj9wNm3dJn3VzHigsrIrQPgkrW3tJ5rlN3W6rhlXwvi8VmjSlwUSAAiqJ1ZzEi9VbDcetqhhzx1l/ql79mkrgqVOxjA+gsWpTNbp6MV7J9JqVGLvaqI+wShv7iQQmomFi8UD65suvoBw69dcaYk7KhqlB2k7CJ5Q9QaZiF2WLdpMPT00N/l9xtua7yb/KCIsIMoLiYmEwv32LG/7n3Fav77rHXe1OGrnuXqAuxRkUUKgQzaR2R/Ae6+9TkiOfy3S0mizQ+30WHACg+YbZ0Xgu9MeTY9T1HfW/G73tnFnpa2LZJ45IAlDmlJJe1rOgruv6W5NAPcuGoyhKaepYGlIBKghAzczjT/L4a+n8/urvLaadzPCHJJCmj2IcGsAOUoZMt3LV7zc8vvK3X0W815hMqh5bOpQMBUELYMCiTdC1FJ54ZO/t8Y1iDtGwi3C0M5YiZiCTZbI3dNX7eRXTMsUaVoZys4JymlKAEVEKEiJVixyGyot8+xh6zU3Lyjfn/vMSWRYaBchCUDaXIcYhV+KhjY6eda3TvSUTacYUVTv5LCgKghPg9Qv0GQSJi9h+U+OXv0oOHZh68W1IpjsWQAVAGlJJki+pSGz3ljPC3j1HxKhHNrFrnsuiEW0oQACWLRWtVUxsff6bRq09q+h16+VKOxAhNI6Bk+ecumbQ5cnT0pDPC+x1EzKI1KZQxSxQCoFQxMSsSTYYROfJoa9TY1JQbcq+8yKEQGQoRACWHWRyHtBc+4pjYqWcbPXoREYmwUoLPa6lCAJQ2Vv7dAOaAQVW//J3Rf2D2ycd0SwvbNu4SgFLhn/jncqquLvL9H0eO+aGKV7V+PrGEobQhAEqe/xUSUTV18bPOt0bvlLzhL96a1WzbpBRiAIqMmTxPXMccNCR+/sX2LnsQEYlg6C8LCIAywex/qUL7HGj06J287QbnrTfJ88iykAFQHMwkJI5DikMHHR477Vyzb38ijP7lBPcBlA8/A4jMocOr/3Bt5ITxHI1LPtf6EEAhMZOIODlV3SV+xnmJS67E6F+OMAMoK23lIA6H46edYw4fkZpyo7diKdshMkwSLBKFglCKHEdc1xw6PH7uBfau32ifoWL0Ly8IgDLkf9kMM3zAoWb/QcnJ1zvvvU25LIXDuFEAOp1Sks1wNB4+cL/Y6RONXn2IcOJfrlACKk/t5aD6IdV/uCZy9A8oHJZ0Cqdg0In81T7ptIpXRU84JXHJlUavPljtU9YwAyhb7eWgUCh+zi+MUWMz99zuLl7Alo2+EdDx/O4OWls77RIdf2Zoj72IcOJf9hAAZc7/+ikVOfAwa+CQ5E1/cWa9I9kshyOkvWIfHFQKpSST5nDE/ua+8XMvNHr0bP05Rv8yhxJQpRBtDqpPXHFN9OTTVXUXSSVJ4S8XdhgzMUs6pbr3iJ/1s8RvrzR69MTK44qBGUClYEUiKh6PjT9T9e6bvm+qt3ghh8IoB8H2U4pcV/J5c/ROsZNPD+21PxHKPhUFAVBB2q4MRw77ttl/UOq2G/LvzGTXpVAIGQDbTCnJZsi0QgceGjttojlgEK73Vh4EQGVpuzJsNYxMXPqnzOOPZB57QDc2cjSKDIBtoJSkUqp37+jxJ0eOPIajMZz4VyQEQCViJhHVpTZ2yhlGn36pO2/1Vi7jUISYUL2Fr8FMWksmbQ4fGTvtHJR9KhsCoEK13ZkZPvRIc8jw1PSpuX89wXaYTBNTAfhSSkk+z9qLHHtC9PiTjN59iTD6VzIEQOVqv1ls0OCqc35h9OydeeRuyaQ5HEXTCNgCf7VPTU30xAmRo47lqgS6O1Q8BEBF87+6Wqu6rvHTJ1qjxiYn/c1buYztUHs8ALR2dstmzRFj4uf8vLWls9ZYSVzxEAAB4G8bwBzaaz/VrUf67im5l59nyybTwE5NQEStO3kddWz0xPFmvwFERCIY/YMAARAMrZcEyBo6vOrCS4yB9ZmH7iXPI6UwFQgu/8Tf81QsFj3p1Mh3fsCxONZ6BgoCIDDadxbrUhs/9VyrYUxy0tXeyhVs22QYyIDA8XfyyufMYSNi510U2nl3IlzvDRwEQMB8trPY/qpbt9S0yc6M18l1yTSRAYHBREKuQ8oIH3F0dNwEc0A9EUb/IEKZL3jaaj7W8JGJS/8UGX8mWRY5TutDUNmYSbS4LserYhN/WXXR780B9SSC0T+YMAMIJGYiISEVicVPPt3o2Sc9bbJeuZwMg0wLi0QrFity8+Jpc1hD7Cdnh/bGTV5BhwAILCYmIiHiyGFH2g0jW265xpn5BrkOWRZuFqs0zEQsTp4tM3TgwfGzzze69SAiIoz+gYYSUMD5UwEx+g9M/PbKyI9OJtOUTJoI5aAKwsrv7sCxWOwnZyd+9XujWw8S8eO/2AcHxYQZAPhTAVJVifgZ55n9B6UfvtdbvJAMA30jKoFS4jgkYu20a/SEU0L7HEhEOPEHHwIAPid8+HfMIcOTU2/O//sl8jxGK+myppRks8QUPvTI2IRzjd592h7A6A9ECAD4IhFzyLDEb/+YfvDu7P8+qjds4EjULxMV+8hgW/gbuKdSRp9+kWOPjxx7Ats2rvfCFyAA4POYSUjFq+KnTTQHDk7dc7u3ZBGHQq39JKAs+Dt5OXlr9E7R8WeEvrlf688x+sPnIQDgv/jbBjCFDznC6NErdd/U/H9eZsvGCtHyoBTl8yQ6fOiR0XGnmvVD0d0BvgwCALakfWexMTsnfndV+sF7M489KC3NHA7jkkBJYyWZtOreM/rDH0e+fyJbFso+8BUQAPDlmEm0ilXFJ5xj9O2fuf8u96N5rW3iodQwk5Bu2WTtvHvsxxNC+x5IhJu84GsgAOArcWsr6ci3jrIGD009MC333FNs45JAiWElrsMk0ePGRY87yejbnwijP3w9BAB8nfadxYYMr/rZxUb3XpmH75FcjkMhZEBJ8Ms+1dWRE8dHf/BjDoWxkxdsJQQAbIX2VtKJ6viZ51kjR6fumuLOn8NV1aS9Yh9csCmlmzfa39g7dsqZ9m7fIMKJP2wDBABstfZW0vseZPTpn7z9hvwrL3IkhuGmaLSWXDZy1LGxU88xemEDd9hmCADYFu3loPohiYsuTw8ZkX1kuuRyZJpEhIpQgfg3eeXzKlEdHXdq5KhjVSyGtZ6wHRAAsI3ay0E1tfFTzzHrB6fvnOwuXsiRCK4MFwST50k2Y43ZOXraxNAe3yTCiT9sJwQAbJe2clD4wG8Z/Qelplyff+tNFk2GSUKEzeY7g/+eey4ZRuiwb8dP/6nRpx8RRn/YfmgHDdurfWexwcOqL782euIEjsYon0OnyU7hb+Cez6ma2tjpExO/uwqjP+w4zABgB7RlAEfC8dMnmoOHpm6/yVu5nC1sNN+hmMl1xXXMIcPiZ//C/sZeRIS1nrDjEACwY9ouCRBz+KBvGfVDUndMyr/2CruCncU6ADMRk5Mn0wwfdmRswrlGj55EOPGHjoESEHSE9nLQwMHVv7ky8t0fUjQmqSROUXeIX/ZJtXCX2sgJ46suvBSjP3QszACgg7QNSRyNVv3819ZOu6bvud1dvIDtEBkGpgLbzG/p7LnWTrvEfnJOa9nH38QRoz90EAQAdIrwQd8y+g1I3TEp/+Zr5DhoI7ptlJJMmu1Q6ODD46dONPr0bXsAQz90JJSAoBOIkIg1tKH68muiP56gamslnSKFD9tWYCZWkkoavfrETj0ncclVRp++bRu4A3QwzACgE7RdGeZwKH7GT836IenpU92P5nG8yv95sY+vVDGT1pJJm2N2jk04J/Q/exOh4g+dCAEAnab9ZrFDjlC9+6TvmJR/5y1WTJaNctAWKCW5LJt26OBvxU491xw4GN0doLMhAKAztU0F7JFjrT9cl35keubRB/SG9RyPIwM+RylJtqhefaM/OjlyzHHYyQsKAwEAnY+ZRHMsFjv5dNW9R+bh6e6C+RyLoxZE1L7WM2nutGv0hPHh/Q4mQtkHCgQBAAXh7yymVOTIY6wxOycn35j/9/+xZQV9hahS5DjEKnzUsfHTzlXdehBh9IfCQQBAobS3ku43MHHBJZnBQ9L3T5NUimOxgGaAUpJsVl1qouPPDh95tIpXobsDFBgCAAqo9ZKAVrW1sQnnGPXDUnfe4i1ZyJEYSZAywG/on0lbO+0Wm3COjZbOUCQIACg4ViSaWIUPOMQcWJ+ccmP+1Rc4FCZDBWKxO7M4DmkvfMTRsQlnGz17E2H0h+JAAEAxcOvWMebA+sTFl6UH1Wef+LtuaWE7RCQVe3HYP/HP5VRdXeS4k6Lf/cFnV8Ix+kMxIACgSNp3FqvuEj/jPGvkmOQNf/HWfMK2TaoSW0kzk+eJ45j1g+Pn/9reZQ//5WPohyJCAEBRtW80v8+BRs8+yTtucma+Qa5DplU5GeAv9HQctqzwQYdFx59l9u1PhNEfig/tWaDY2lcHDRlWfcXfIiecwtG45HOtD5W71tE/r6q7xE47t+o3f8DoD6UDMwAoAe29g+xQfMLZ5tCG1JQbvRVL2Q6RYZbxAiGlyHHEdc2hw+PnXmDvsgcphbWeUDoQAFAy/KmAYYYPONTsPyg5+Xrnvbcpl6UybSWtlGQzHI2HD9wvdvpEo1cfIpz4Q2lBCQhKSXs5qH5I9R+uiRz9AwqHJZ0qs1Nmf7VPOq3iVdETTklccqXRqw9W+0AJwgwASkx7OSgUip/zC2PU2Iy/s5i/0XzpTwX87g5aWzvtEh1/ZmiPzTZwBygxCAAoSf5wqVTkwMOsgUOSN/3FmfWOZLMcjpD2in1wX87fySscsb+5b/zcC1u38CWc+EOJQgkISptoc1B94oproiefrqq7SCpZojuLMROzpFOqe4/4WT9L/PZKo0fPylnJChUKMwAobaxIRMXjsfFnqt590/dN9RYv5FC4tMpB/gbu+bw5eqfYyaeH9tqfCGUfKAMIACh5bVeGI4d92+w/KHXbDc47M8l1KRQqiQxQSrIZMs3QgYfGTptoDhiE671QLhAAUA7argxbDSMTl/4p8/jDmcce0o0bOBotcgYoJamU6t07evzJkSOP4WgMJ/5QRhAAUD6YSUR1qY2NP9Po0z91563eymUcihAXY6P59g3ch4+MnXYOyj5QjhAAUFbaN5o/9EhzyPDU9Km5fz3BdphMs6BTAaUkn2ftRY49IXr8SUbvvkQY/aH8IACg3LTfLDZocNU5vzB69s48crdk0hyOFqhphL/ap6YmeuKEyFHHclUC3R2gTCEAoAz5Q63Wqq5r/PSJ1qixyUl/81YuYzvUHg+d9bwiks2aI8bEz/l5a0tnrUt0ZSrA10EAQNlqa6wW2ms/1a1H+u4puZefZ8sm0+ikncVad/I66tjoiePNfgOIyN/pvthvBMB2QgBAOWu9JEDW0OFVF15iDKzPPHQveR4p1ZFTAf/E3/NULBY96dTId7CTF1QIBACUufadxbrUxk8912oYk5x0tbdyBds2GR2xs5i/k1c+Zw4bETvvotDOu/tPh6EfKgACACrCZzuL7a+6dUtNm+zMeJ1cl0xzBzKAiYRch5QRPuLo6LgJ5oB6Ioz+UDlQvoRK0VbzsYaPTFz6p8j4M8myyHFaH9qeP02L63K8Kjbxl1UX/d4cUE8iGP2hkmAGABWEmUhISEVi8ZNPN3r2SU+brFcuJ8Mg09qGRaKsyM2Lp81hDbGfnB3aGzd5QWVCAECFYWIiEiKOHHak3TCy5ZZrWjeat6yvv1mMmYjFybNlhg48OH72+Ua3HkREhNEfKhBKQFCR/KmAGP0HJn57ZeRHJ5NpSiZD9JXlIFYkWjJpjsViPzk78avfG916kIgfJ8V+RQAdDzMAqFT+VIBUVSJ+xnlm/0Hph+/1Fi8kw9hy3wilxHFIxNpp1+gJp4T2OZCIcOIPlQ0BAIEQPvw7xpDhqak35//9Enkef6GVtFKSzRJT+NAjYxPONXr3aXsAoz9UMgQABIOINWRY4rd/TD94d/Z/H9UbNnAkSm13DEsqZfTpFzn2+MixJ7Bt43ovBAQCAILBbyUdr4qfNtEcODh1z+3e4oUciZCI5HLW6J2i488MfXPfz34zQAAgACAw2vpGhA85wujRK3X/nblXXmTDCB/27ei4CWb9UHR3gKBBAECQtO8sNmbnxG/+kBk6kmPRyPeOZzuEsg8EEAIAgscvB1VVxyac1foTjP4QSAgACKQv9ArF6A+BhACAoMKgD4GHO4EBAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAApYYL8zSFCAAhksK8GgCA8ickuiCjZucGgJ9itsGmYpGCpRoAQLkSEpONkGEV4LkKMQPoEqWoTR5mAQAAX4mJPdFRK1ITShTg6QoRAIkIR2zSggkAAMBXYSItOmKGq+14AZ6ukwOAiYiqwhy2WGtMAQAAvoYWCZuhRMgPgM49bS7IDCBMYQszAACAr8We6LAZ8mcAnT1mFuIicJc4R0LsaVwEBgD4Kszkai9iRUJGSEunV006fQYgQiGLqyLc+a8FAKC8iYiljFrbvwJcAQFARETDuqtEhF0PcwAAgC1j4rx2ukVqx9QN8X/Z2c/Y6QHgv4KRfVTXKs57xEgAAIAtUcw5L18XrR3btYGoEDXzzg8AJiIa1dfoXs2OJwgAAIAtEiIR6lfVq3+8F1XGDMDHikb0MeIhVIEAALaAiR3t1IWrv9FtFBWqfU7hmsHtNkDVxVEFAgDYAsWc85y6SO03uo+lQi2ZLFwA7D7YHNDN0LpgTwgAUDa0CBM11NY31NYX7EkLFABCZCo6aiejJko5F5MAAIDPKOaczveIdj1uyOFEJIVqoFzQ/QD2H2mO7mswEe4JAADwMbGntcnGPr1327XbyNafFUShLgK3/csP/seqibHjkcIkAACAiJnz2ukeqTtx2FGtPynUUxduBuCf9O8x2Nh7mMlEnqAQBABBx8yudi1lfqf+wOE1gwr87IULgPbR/kd7mvXdVc5BGQgAAk8o4+ZG1w0/Yei3C//kRdgTuF9XdcZBdvcqhXsCACDgHO0Mqe5/wS7ja8LVhX/2QgeAf9r/zaHGj/eybIM8jUIQAAQRM7vaS9jxs8b+aGzX4UU5hkIHALdlwA/2tL63h5X3CrbeCQCgVDCxiBDJ+JHHHjlgfyrg0s/NFaEE1L4MdNw+5uFjraxDgr1iACAwmNgTz9Huj4Z921/5IyIF6Pzz34oQANTWIa4qrCYeZh+9m+l6WBQEAIHAzI52FKuTGo6eOHZcyLCFhIs0/JlFfCOEqCbGFxxp96nh+193NmVad44EAKhIBquUk+kd73HGqOO+P+QwIhIqzrm/r5gB4NeClOIf7WV3T6g7Xs5/vF4SIUK7IACoPIq4Mdcytm7oz3Y+ed/eu5Nf+Slq6aOYAUBEzCRCiumQMWafGvXAG87LH7pEZBu4NgwAlYCJmSjr5ZVSJww78pQRx9Qn+pF/7l/swneRA4DaMoCZRvRVvzzK3nu48Y+3nNkrtG2IUkV/fwoKmQdQaURy2vFI9uq503FDj9ir165RM+wv+Cli5add8QOA2q4JC1FVhL811tx9kHp9gffgDGf5BjEVsX8XMf/XVWJp/78KwW3/A6g8XInrPLj9/zb7p4iQiBBpEY/0sNqBExq+/81eO3cJJajYRf8vKIkA8PmXBJiprkp9Zze1xxDz7SXuvz/0Zq/0WjKimP1HmTeLBKqg8VJaN4SrpEgDaKdJ2j7hUjHfWyER0UL+qE9CWoSY2COvS7j6G91HH9R3z2/0GNstUuv/ZhIqqbJGCQUAtU8FhJipZzV/e2drv+HmpgzNXe69t9ybvVxvymgm0pq0kBBpqajO0hj9oYIZIq3fXX+orAiKlcGK2S9XMzPXhbvs2m3UN3qOHV03tNqOJ+y4/ztbr/eW0OBPVGoB4GMmISIhZkpEORGlfnXmt3YykznZkJTGZlmflKa0NKWkMSXNGWGuhI+TEBmKklka3cegijlBAmibq+/edbglUmXHPKmEhX5MpEVqQolu4ZraSHVNqLou3KVntGu3SG3EDCv+7BYrv+ZTUif+n70KKe1TaP/ovvDWSVu1xJ8KlOQbu/2vVymyjGIfB0BHy3uOFl2a4+B2U8yKFZNS//W6/C0eS/z1lnoAtGufEwAAlKzSWeGzNcomAL5APvePylIunx2AbVHRV7jK9dS0XAMAAAB2UHGawQEAQNEhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAACCgEAABBQCAAAgIBCAAAABBQCAAAgoBAAAAABhQAAAAgoBAAAQEAhAAAAAgoBAAAQUAgAAICAQgAAAAQUAgAAIKAQAAAAAYUAAAAIKAQAAEBAIQAAAAIKAQAAEFAIAACAgEIAAAAEFAIAACCgEAAAAAGFAAAACCgEAABAQCEAAAAC6v8BvgDrKD4Bp1wAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDItMDlUMTA6NDI6NTcrMDA6MDAWH3g+AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTAyLTA5VDEwOjQyOjU3KzAwOjAwZ0LAggAAAABJRU5ErkJggg=="></image></defs></svg>', 1), Bc = { class: "provider-btn text-small", href: "https://mail.yahoo.com/d/search/keyword=corbado.com", target: "_blank" }, Wc = lr('<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="22" height="22" fill="url(#yahoo-985559)"></rect><defs><pattern id="yahoo-985559" patternContentUnits="objectBoundingBox" width="1" height="1"><use href="#yahooImage" transform="scale(0.000976562)"></use></pattern><image id="yahooImage" width="1024" height="1024" xlink:href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBw0PDQ8NDQ0NDQ0NDQ0NDQ0NDQ8NDQ0NFREWFhURFRUYKCggGRolHRUVITEhJSkrLi4uFx8zODMsQygtLisBCgoKDg0NFRAQGTAdHx0rLS0tLSs3LS0tLS0tLSstLS0uKy0rLS0tLSstLS0rLTAtLS0tKy0rLS0rLS0rLS0rLf/AABEIAMgAyAMBEQACEQEDEQH/xAAbAAEBAQADAQEAAAAAAAAAAAAAAQcCBQYEA//EAEEQAAEDAQIHDgUBBwUAAAAAAAABAgMEERIFBxQxUVSTBhUWITM0QVNxc3SUsdETYaGzw4EiMkJSkbLhI0NicoL/xAAaAQEBAAMBAQAAAAAAAAAAAAAAAQMEBQIG/8QALhEBAAEDAgMIAgICAwAAAAAAAAECAxETMQVRUgQSFSFBYXGRM4Ey4bHwFCPR/9oADAMBAAIRAxEAPwDxJ9830AgAggUAgEAAQigEAEEAgUsIIAAhBAIoEAAQgAfeZngAgACEECoAAgAioAAhBFAAAqKQQABCCASwCAAIB2BleEAAQABAIRUAAQARUAEEAgAKgAggEAEEAgEAAdgZXlFQIigAIAAhBAoBAIBABFAIAIIFAIQQABCCAQCAdiZXlAiAQABABBAIFQABABFQABCCAAoBCCAAIQQCWAdgZHkKIBwVyaRhEvoMCX00gL6aR5BfTSBL6aQJfTSRUvppAX00oBL6aUHkF9NJBL6aQF5NIXKX00hcpfTSDJfTSES+mkil9ukgl9ukIoUIIoHYGR5QD1GLzc2zCFY5s9uT07Ellai2LIqrY1lvQi2Kq9hz+J9rns9rNG9THcq7sNwpsF0sbEZHTwMY1ERGtiYiIfKzerneqftqd6X65HD1UWzaNWvqkzJkcPUxbNo1K+qTMmRw9TFs2jUr6pMyZHD1MWzaNSvqkzJkcPUxbNo1K+qTMmRQdTFs2jUr5yZkyKDqYtm0alfOTMmRQdTFs2jUr5yZkyKDqYtm0alfOTMmRQdTFs2jUr5yZkyKDqYtm0alfOTMmRQdTFs2jUr5yZkyKDqYtm0alfOTMmRQdTFs2jUr5yZkyKDqYtm0alfOTMmRQdTFs2jUr5yZkyKDqYtm0alfOTMuEmD6dyK10ELmrnR0TFRfoNSvqkzLFsa25KGhliqaVqR09S5zHQp+7FMiW/s6GqlvF0WH0HCu11Xom3XvS2rNcz5PAnXZ0IOwMjy4qBpeJJP9au7un9XnB45Hlb/bB2jzw1g4DWeRfu6YiqmSyLdcqW/EZ0LYdWOFVTET3mxoe7jw8Zqsm1YXwqrqND3OHjNVk2rB4VV1Gh7nDxmqybVg8Kq6jQ9zh4zVZNqweFVdRoe5w8Zqsm1YPCquo0Pc4eM1WTasHhVXUaHucPGarJtWDwqrqND3OHjNVk2rB4VV1Gh7nDxmqybVg8Kq6jQ9zh4zVZNqweFVdRoe5w8Zqsm1YPCquo0Pc4eM1WTasHhVXUaHucPGarJtWDwqrqND3OHjNVk2rB4VV1Gh7nDxmqybVg8Kq6jQ9xd3jNVk2jB4TV1H/H93rKaa/GySyy+xr7LbbLUtsOVVT3apjkwT5M6x5cxpfGfiedXg35qvhmsfyYwfSNsA7A9ogRpWJLlq7u6f1ecHje1v9te/6NXPn/Rrsbl/ed/3f/cp9lT/ABj4h0Y2hxPQAyAyAAZAZAZAZAZAZAZAZAZAZAOL8y9i+gjeD1a9gzm8Hcxf2IfH3f51fM/5c+reXgMefMaXxifaedTg35qvhmsbsYPo22Adge0ANJxJ8tXd3T+rzg8b2t/tr3/Rq58/DWeHwxuLeiukpH30VVcsUi2OtXj/AGXZv6nZ7NxSMRFyNvVs0XvLEvKTwPjcrJWOjen8L0Vq/odiiumuO9ROfhniYnZwPagAAAAAAAAAAAAQDlGxznI1jXPc7iRrUVzl7EQ81VRTGavKEzjd6bBW4yaSx1S74DF/222OlVPn0N+pyu0cUppzp+fv6MNV6Noe8giRjGsbbdY1rUt41sRLEOHVV3pmqfVrTOZZ1jy5jS+MT7Tzr8G/NV8M1jdjB9I2wg7Cw9IhRpOJTlq7u6f1ecHje1v9te/6NXsPn8eeWsWDA+euoIZ2XJo2yN6Lycadi50Mlu5XbnvUTiViZjZ47C24p7bX0j76dTItjuxrsy/qdfs/FYnyux+4bFN/m8rUQvjcrJWOjemdr2q1f8nWouU1xmmcwzxMTs4HpdtwoAAAAAAAEFjY5zkYxrnOdxI1qK5y9iISqqKYzPlCTMRu9NgncbNJY6pd8BnEtxtjpV7ehv1OX2jilFPlbjPv6MNV+I2eywbgmnpm3YI0Zbndne7tcvGce7fuXZzXOWvVVNW77bDDh5LBMDN8eXMaXxn4nnY4L+ar4Z7G7GT6RtoB2JUcSjScSnLVvd0/q84PG9rf7a/aPRrBwGsAAIQfNXUEM7bk0bZG9F5ONOxc6GS3crt1ZonD1FUxs8fhbcU9tr6R99M/wZVsd+jun9Tr2OKZ8r0fuP8Axnov9TytRA+NyslY6N6Z2vRUU61uumuM0zmGeJidnA9qAAAACsY5zkaxrnOXM1qK5yr8kQ81VRTGapxCTON3psE7jJ5LH1LvgM/kbY6VU+fQ36nL7RxOmnytRmefp/bDXeiNnssG4Kp6Zt2GJGr0vzvd2uXjOPev3Ls5rnP+8mvNU1bvtMLypQAAZtjx5jS+MT7Tzr8F/NV8M9jdjJ9K2wg7AqCgaRiU5at7un9XnC43tb/bX7R6NXOA1gAAAAAPlrqCGdlyaNsjf+Scadi50Pdu7XbnNM4WKpifJ4/C24p7bXUj76dTIqI7/wAu6f1Ov2fisZxdjHv/AE2KL3N5WogkjcrJWOjen8L0sX/J1aLlNcd6icwz5ifOHAyKsbXOcjGNc968SNaiucvYiHiqqKYzVPknlG702Cdxk0ljql3wGfyNsdKqejfqcztHFKKfK3HelhqvR6PZYNwVT0zbIImstzvzvd2uXjOPd7Rcuzmucteqqat33IYnkAAAAADNsePMaXxifaedfgv5qvhnsfyY0fStoUg7BSiAaRiV5at7un9XnC43tb/bX7R6NXOA1gAAAAAFgEsA+avoIJ2XJo2yN6LycafNFzoZLd2u3OaJwsVTTs8zJuGjWVFbO9sOdWK1HSJ8kd7nRji1cUYmnz5/0za84eiwZgmnpm2Qxo1el68cju1y8Zz7t+5dnNc5/wAfTFVXNW77bDE8qAAAAAAABm2PHmNL4z8Tzr8F/NV8M9j+TGz6VtIB2IEA0jEty1b3dP6vOFxva3+2v2j0ascBrAAAAAAAAACEFKAAAAAAAAADN8eHMaXxifbedfgv5qvhnsbsaQ+lbQB2BFANHxLctW93T+rzh8b2t/trdo9GrHAawAAAAAAAAAAAAAAAAAAAADN8eHMaXxn4nnX4L+ar4Z7G7Gz6VsoFdgRQDR8S3LVvd0/q84fG9rf7a3aPRqxwGsAAAAAAAAAAAAAAAAAAAAAzfHfzGl8Z+J52OC/nq+GaxuxtT6VtAHYHl6ANGxL8tW93T+rzhcb2tz8tftHo1Y4GWqFAAAAAAAAAAAAAAAAAAAAM3x38xpfGfiedfgs/91Xwz2N2OH0zZQDsTy9IB6/Flh2KjrXsncjIqqNsfxHLY1krXWtvL0Itqpb2HL4t2aq7ZiaPOaWG9RMxltbHIqIqKioqWoqcaKh8w03IAAAAAAAAAAAAAAAAAAAIoGPY4d0ME74aGB7ZMne6Wd7VRWNkVt1sdvSqIqqujiPoODdlqozdr9dmzZpmPNmx3WcA7A8vSBRQj94a+oYl2OoqI2pmayaRrU7ERTHNqifSPqE7scnPfWs1yq8xL7jRt9MfUGIN9azXKrzEvuXRt9MfUJiORvrWa3VeYl9xo2+mPqDEckXCtZrlV5iX3Gjb6Y+oMRyTfWs1yr8xL7jRt9MfUGI5JvrWa5VeYl9xo2+mPqDuwb61mt1XmJfcaNvpj6g7sIuFazW6rzEvuXRt9MfUJ3YN9azXKrzEvuNG30x9QYhxXCtZrlV5iX3Gjb6Y+oMQLhas1yr8xJ7jRt9MfUGITfas1ur8xL7jQt8o+oO7Cb61muVfmJfcaNvpj6hMQb61uuVfmJfcujb6Y+oMQm+1brlX5mX3Gjb6Y+oMQm+1ZrlX5mX3Ghb6Y+oMQb7VuuVfmZfcmjb6Y+oMQ4yYTq3JddV1TmrnR1RIqL28ZdG30x9QuIfIiWfI9iBQDsLDy9IACpYBAgAAhUQABLAIAKIERQIAAhRAiAAIMABCCBXYnh6RSiAAIoEAACogEAAcSgBLAhYBAIUFAgEVAiWAAIBABB2J4ZADgVAKWAQIgAABCogACARSiWAAiAQAUQIgEAAQAB2JjZEAlgEUqIAUKlgRAAAqIBAAEUogACBEAgCwogEVAiKAAgHYmNkQABAIqFRAAEUCAABUQCAAIpRAARAIBABRAIoRAAH/2Q=="></image></defs></svg>', 1), Gc = { class: "provider-btn text-small", href: "https://outlook.office.com/mail/0/inbox", target: "_blank" }, Hc = lr('<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="22" height="22" fill="url(#outlook-382689)"></rect><defs><pattern id="outlook-382689" patternContentUnits="objectBoundingBox" width="1" height="1"><use href="#outlookImage" transform="scale(0.000976562)"></use></pattern><image id="outlookImage" width="1024" height="1024" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu4AAALuCAYAAADxHZPKAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nOzdd4BcZaG/8e+ZtjM7s7OzNVuSLemkJyQhhIQUSKUFAQUERY2IXkWFHyJKs8D1StOrgIhcQa4IKHBFkSJIMYQihBQIkEZCCqRusr2f3x9BpSTsbnZ23vPOPJ9/pM4+uEv47tl3zpEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAx3QAgL6RPe+WCY6j2ZI7R3KOdhyFTTcBAOAFrquVkv7mOs6jjXvrn9JzFzSbbuoOhjuQRrLn//JEx3FPdqTjJRWa7gEAwAau6/5Nrv7YoMD/6tHFe0z3HAzDHbDdzBtjsazAJfLpXDHWAQDoFdfV3Y7j/qD+4fNWm275MIY7YLHo/F+cLjk3OI5KTLcAAJBOXNe9tiHoXKE/fanRdMs/MdwBC4UX/qrC39lxh+NopukWAADSlSttkfSFhoe/9JjpFonhDlgnuuCWC+TqKt5sCgBAarhy72roDHzN9Pl3hjtgifD8m6v8ju8eR5psugUAgAy0q1PO2Y0Pn/uIqQC/qQ8MoPuy5/9yot/Rc46cgaZbAADIUNmOdFZwyPENbev+vNREAMMd8LjI3F9O9Tudj8txcky3AACQ6Rw5c02Nd4Y74GGRBbdO8fncxx3HiZpuAQAA+zly5gYHHV/Ttv7PL6T24wLwpOj8W8c46nhWjhMz3QIAAD7KdTs/1/DIl29P1cdjuANedMzP86Oh4OuOVGw6BQAAfIxOzap/9EtPpeJD+VLxQQD0TCwYuI/RDgCABRz3vugxt6bkv9kMd8BjsufdcqkcZ6bpDgAA0A2Ok69gx+9S8aF4cyrgIdH5t47x+dx7TXcAAIDucxynOjD4hHfa1v355b78OFxxBzzEcVLzHTsAAEguR7ohe85tZX35MRjugEdkL/jl5yVnhOkOAADQc46jbJ+//Yq+/BgMd8AjHLnfM90AAAB6wdG54WNu6rOnnDPcAQ/Inn/LuY7U33QHAADonUDQf3FfvTbDHfAAR7rEdAMAAEgCR+dq3q/y++KlGe6AYdH5v5zrOKoy3QEAAJIjqo7FffG6DHfANMf9lOkEAACQRD73tD552b54UQDd50ifNN0AAACSx5EzMXveLSXJfl2GO2BQeN6t0yTFTHcAAIBkcxcl+xUZ7oBBPl/n0aYbAABA8jmOc1SyX5PhDhjkuO4M0w0AACD5HEdTk/2aDHfAJMcZZzoBAAD0iYE68vpwMl+Q4Q4Y5EjFphsAAEDfiMVjSX2KKsMdMCS68JZRphsAAEDf6fR1MtyBdNDR7vbJU9UAAIBHuE5ZMl+O4Q6Y4nM6TScAAIC+4yi5F+kY7oAhjtPJcAcAIJ05TlEyX47hDpjS4Ws3nQAAAPqOI2Un8/UY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFAqYDgEwVzAp1+v1aaboDOBg3GOx0I2Eu8MCzsgpjphOAj+V2dO6pfzh5r8dwBwyJJvLl97ljTHcAB9PWL3+pW1Yw1XQHcCCu3PaS6YexY+Btrpbu/GnyXo4rKQAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABRjuAAAAgAUY7gAAAIAFGO4AAACABQIp/WgLr61QuztYPqdYnSqUo3w5jj+lDYBH7Njzdlk0HDWdgT7k8/nl8/nl9/kV8Afl96f2l1wAQHrpu/+KLPjvQrltM+VqlqQpkjtcnU62fM7+P8+1fmS4jo5W1Ta0ms5ACjlyFAyEFAqGlRUKKyuULZ+PXwwBAN2T3OG+8Mcl6vCfLrlnyG2bLEly/vknnYP+bQCQCVy5am1vUWt7i+qb9kmSQoEsZYdzFInE5PfxA0gAwMElZ7gvuG6cOt1L1OmcKkc+RjoAdE9re4ta61u0t36XsrNiyoklFAxkmc4CAHhQL4a7K827dqEc5yK5mimHsQ4AvdHYUq/GlnplBSPKiSYUzso2nQQA8JBDPFzpSvOv+4rk/F5yZia1CAAyXEtbk3bvfVcNTbWmUwAAHtLzK+5zrymW7/rfSc5sTsQAQN9w5aqmdqeamuuVF+8nv5/z7wCQ6Xp2xX3+dbPlOKskze6bHADA+zW3NmnHns1qbmkynQIAMKz7w33udZ+X9Fc5TnHf5QAAPqyjs0O79m5TQ1Od6RQAgEHdG+7zr/uefLqt2389ACDpamp3qLZ+j+kMAIAhXQ/xedd9Q9LlfZ8CAOhKbUON6hr2mc4AABjw8cN9/rWny3GvS1ELAKAb9tXvVGNzvekMAECKHXy4z7t+sqQ7JIfjMQDgKY5q9m1XW3ur6RAAQAodeJSfcEu2HPceyQmluAcA0A2upD1735XrdppOAQCkyIGHe1vdzZKqUloCAOiRto421dTuMp0BAEiRjw73udceLTmfMdACAOihxuY6tbRyj3cAyAQfHO4jrgzJ0W2GWgAAh6Cmdqdc1zWdAQDoYx8c7gNyviLHGWyoBQBwCNo72lTfWGs6AwDQx/493I+8PizpYnMpAIBDVd9Yo/1vWQUApKt/D/d45zlyVGKwBQBwiDo6O9TQxL3dASCdvf+ozOeMVQAAeq2hkSeqAkA62z/cj7lhoORMNtwCAOiF1rYWtXe0mc4AAPSR/cM92PlZOYZLAAC940iNzRyXAYB0tX+4u+58wx0AgCRoaeGe7gCQrnyaeUOCYzIAkB5a25rV2dlpOgMA0Ad8CrVP45gMAKQHV65aeZIqAKQln3zOKNMRAIDkae1oNZ0AAOgDPrnOeNMRAIDkaW/nzjIAkI58ctzhpiMAAMnDLSEBID35JCVMRwAAkqejo910AgCgD/jkOmHTEQCA5HFd13QCAKAP+ORwxR0A0kmny+0gASAd+SSFTEcAAJKJK+4AkI58pgMAAAAAdI3hDgAAAFiA4Q4AAABYgOEOAAAAWIDhDgAAAFiA4Q4AAABYgOEOAAAAWIDhDgAAAFiA4Q4AAABYgOEOAAAAWIDhDgAAAFiA4Q4AAABYgOEOAAAAWIDhDgAAAFiA4Q4AAABYgOEOAAAAWIDhDgAAAFiA4Q4AAABYgOEOAAAAWIDhDgAAAFiA4Q4AAABYIGA6AACQfLtr3OW9fY2Iv6M2x1GvXwfoC66jzj3bfVyAhKf5HO1N5usx3AEgDXW6Gtf7F/EvdVy3968D9AGn023v6GTHwNs6XD2fzNfjO1UAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACDHcAAADAAgx3AAAAwAIMdwAAAMACAdMBwKEYPiBfZfkx5UZDikVCioWDikVCioYDyomEFIsEFQ0HFQvv/+2OTlcNzW2qb2rd/7/Nbapvanvfb7eqvrlNtQ2t2ranXm9s3mP6HxEAAOADGO7wrOqSXA0tz9Ow/nkaUpbQ0P75GlKWUHVJbko+/sbttVq3rUZrt+3V2q17tXZbjdZsqdGarTUp+fgAAADvx3CHJ/QvzNEx4yo0a2x/TRxSopGVBaaTVNUvrqp+cR07vvIjf27dtr1a+dZOPblyi55auVmvbtxloBAAAGQShjuMKIhHNGd8pWaO6a9jx1doUGnCdFKPDC5LaHBZQp84aogkaee+Jj21crMeW7ZJDz6/Xjv2NhouBAAA6YbhjpSZO6FScydUava4Co0fVGw6J6mKciM6bfpQnTZ9qG79+hwteW2r/vjcej2wdJ3Wv7PXdB4AAEgDDHf0mVDAr/kTq3TqtCE6YcogJaJZppNSZtrIck0bWa5rFh+tVRt36b4la3Xfs2s5UgMAAA4Zwx1JN21kuRbPH6VTpw1VNBw0nWPc6KpCja4q1JVnHal12/bq7qff0M0PrdS23fWm0wAAgEUY7kiKRCxLn5szSovnj9KICvNvLPWqwWUJXXrGFH37k5N17zNrdO19L+mV9TtMZwEAAAsw3NEriViWvnXqJH3z5AkKh/hy6q6A36czZw3XmbOG6++vbtVP/7hM9y1ZazoLAAB4GEsLhyQSCuibnzhcF506MaPOrveF6aPKNX1UuVa/vVs//v1L+u2Tr6u9o9N0FgAA8Bif6QDYJRIK6MJTJmrjHYt11WePYrQn0YiKAt1+4TxtvGOxvnHyBNM5AADAY7jijm7JiYT01RPH6YJPHK7CeMR0TlorL4jphnNn6vwTx+vS3zyr3z31hlzXdBUAADCNK+7o0leOH6dNv1msq8+ZxmhPoeqSXP32Wwu17OdnafbYCtM5AADAMIY7Dmp0VaH+8d+f1o3/MVt5sbDpnIw1bmCxnvjRqbrr4oUqTmSbzgEAAIYw3HFAV58zTStv/owmDulnOgXvOWPmcL1x6zlaPH+06RQAAGAAwx0fMHVEmdb86nO65FOTTafgAPJiYd369Tl68r9O04CiHNM5AAAghRjukLT/bjE/PW+W/n7tpzSkPM90Drowc8wArbr5M1o0dbDpFAAAkCIMd2hkZYFeveWzOv+k8fI5jukcdFNuNEsPXHaibv36HB5+BQBABmC4Z7iFk6r1/A1namBJrukUHKLF80frHz89k6MzAACkOYZ7Bvv2JyfrT99bpFgkaDoFvTSqqlCv/PwsTR1RZjoFAAD0EYZ7hvrttxbqPz83jaMxaaQgHtGz153OXWcAAEhTDPcMU1kc1/Ibz9aZs4abTkEfufXrc3Tt4qPF92QAAKQXhnsGmT22QstvOltjBxaZTkEfu/CUiXrwikW8aRUAgDTCcM8Qp88YrseuPkWJaJbpFKTI8UcM1JJrP6XCeMR0CgAASAKGewY4fcZw3XXxQvl9nJ3INIcP6afnbjhDJXlR0ykAAKCXGO5p7jPHjtBdFy/kvHMGG1yW0N+v/ZT6F3K7SAAAbMZwT2OfOXaE7rhwPqMdGlyW0FM/Po3xDgCAxRjuaeqTRw/THRfON50BDxlUmtAz13xSZQUx0ykAAOAQMNzT0MJJ1frttxaYzoAHVZfk6sn/Ok2JGG9SBgDANgz3NHPMuAo99P2TFfDzqcWBDS3P02NXnaJomCfmAgBgE9ZdGhlSnqf7Lj3BdAYsMGloiR647ETuNAQAgEUY7mkiLxbWY1edolzu045umjOhUrd+fY7pDAAA0E0M9zQQDPj00PcXqapf3HQKLPO5uaN0/knjTWcAAIBuYLingeu/OFNHHlZmOgOWuu6LM3T4kH6mMwAAQBcCpgPQO4umDtZXTxxnOsOYVzfu0qubdunVjbu14q2d2l3brMaWNjU0t6mxpV0NzW3a19AiScrPCSs7K6hoOKjsrICi4aAGFOVoZGWBxlQXanRVUUb+1CLg9+mPV5yksV+5U7trm0znAACAg2C4W6yyOJ5x92p/etUW3f/sWj29aotWbNjZo793T12z9tQ1f+xfk50V0LhBxZp/eJVOmTZEIyoKepNrjfKCmO66eKHmffc+0ykAAOAgGO4Wu/uS4xTPDpnO6HOPvLRRf1iyRn98br129fEV4caWdi1dvU1LV2/T5Xcu1dDyPJ06fahOnjpYE9P8OMncCZW66NSJuuYPL5lOAQAAB8Bwt9T3z56qKcNLTWf0me01jbrpoRW68U/LjR7fWLO1Rlff/YKuvvsFjago0AWfOFyfnjVc4VB6/qtz9TnT9MTyt7Vs3Q7TKQAA4EN4c6qFJgwu1nfPOMJ0Rp9Y+dZOff6Gx1TxmVv1/d8+56kz16vf3q3FP3lM/c++VVf873PasbfRdFLSBfw+/f67J/BwJgAAPIjhbplwKKB7v3O8fE56PTjnzS17NP/S+zX2K3fq14+9qtb2DtNJB7W7tknf/+1z6nfGL/S1m59UbWOr6aSkGliSq+u+OMN0BgAA+BCGu2Wu++LRGlSaMJ2RNLWNrbrgl09r+Bdv16MvbzSd02M/f/AVVZ/zK934p+WmU5LqSwvHcItRAAA8huFukYlD+unLx6XHrR87Ol394qEVqj7nV7rhgZdN5/TKnrpmffWmv2nUeXfo2dVbTeckza8vmKuAn18iAADwCv6rbAnHkf7ngnlKhxMy7+xp0LQL79aXf/5El7dntMlrm3Zr2oX36Pybn/T0UZ/uGtY/XxefNsl0BgAAeA/D3RJfPm6sRlcVms7otceWbdLIL92h5994x3RKn/nZg69oyjd+p7fe3Wc6pdd++NmjVF2SazoDAACI4W6FwnhEV58zzXRGr11469Oa9937VFOfPlfZD+aV9Ts09it36r4la02n9Nr1vFEVAABPYLhb4IpPT1FuNMt0xiFraG7TURferevvt/sse0/VNbXq1Kv+pMt+s9R0Sq8smjpYR4/ubzoDAICMx3D3uMFlCX35eHvfkFrf1KZZF/9eS1dvM51izA9/97wu+fUS0xm9cvNXj5HflwZvsAAAwGIMd4/76XmzrB1M9U1tmv3t3+sfa941nWLcj+590erxPqKiQF9cMMZ0BgAAGY3h7mEzxwzQwknVpjMOSV1TK6P9Q2wf75efOUWhgN90BgAAGYvh7mFXnnWk6YRDNvc79zHaD+BH976oH9z1vOmMQ1KaH9UX5482nQEAQMZiuHvUlOGlmmHhGwJdVzr1qj+l9e0ee+vyO5dae7eZ755xBFfdAQAwhOHuUd87a6rphEPy3duXWDtKU+nTP/6LXlq73XRGj5XmR/WFeaNMZwAAkJEY7h50+JB+mnt4pemMHrv9r6/pP+990XSGFVraOrTg0vu1cXut6ZQeu/CUw9PiCb4AANiG4e5BF50y0XRCjz27eqs+d/2jpjOssqu2SQsuu990Ro8NKk3ouEkDTWcAAJBxGO4eU14Q02lHDzWd0SMNzW0687/+YjrDSm9s3qP/uPEJ0xk99vVFE0wnAACQcRjuHvONRRPks+wcwjd+8aTe3lFnOsNaN/15hf624m3TGT1y7PgKjagoMJ0BAEBGYbh7SCQU0JeOs+shN4++vFG/evRV0xnWO/uaR1Tb2Go6o0e+bNnXKgAAtmO4e8inZw1XTiRkOqPbauqbdfY1D5vOSAvbdtfr/Jv/ZjqjR846ZoTCoYDpDAAAMgbD3UPOmTvSdEKPfPOWp7VzX5PpjLRxx+Or9ddlm0xndFsimqWTjxxkOgMAgIzBcPeI6pJcHTWi3HRGty3fsEN3PP6a6Yy0841bnlJHp2s6o9u+wJNUAQBIGYa7R3xhrl0PtTnvZ/bdCcUGq9/erVsfXmk6o9uOGVehyuK46QwAADICw90jPjtnhOmEbrv3mTf1whvvmM5IW5ffuVR1Tfa8UfXMmcNNJwAAkBEY7h4w9bAy9S/MMZ3RLS1tHbrotmdMZ6S1nfua9IO7njed0W2nzxxmOgEAgIzAcPeAU6cPMZ3QbTc/tIJ7tqfANX94Se/WNJjO6JYx1UUaXJYwnQEAQNpjuHvAmTMPM53QLZ2uq2v/8JLpjIxx45+Wm07otrNn2/E1DACAzRjuhk09rEz98rJNZ3TL/UvWauvuetMZGeOmP69QS1uH6YxuOXX6UNMJAACkPYa7YSdOsec+2Dc8sMx0QkbZU9es3zy+2nRGt4yoKLDmfRoAANiK4W7YvMMrTSd0y8q3dmrp69tMZ2ScGx542XRCty2cVGU6AQCAtMZwN6g4ka1xg4pNZ3TLVXe/aDohI72+eY8efXmj6YxuWTCx2nQCAABpjeFu0NwJdlxtr29q0wNL15rOyFi2HJeZM6FSfp9jOgMAgLTFcDfIluF+zzNvqq2903RGxnpg6To1tbabzuhSNBzUEcNKTWcAAJC2GO4GzRg9wHRCt9z91BumEzJaU2u7HnxuvemMbjl6dLnpBAAA0hbD3ZCygpgqir1/F44dexv1xIq3TWdkvN9Z8s3T9FH9TScAAJC2GO6GzBhlx5XJ3z31hlzXdAX+8tJbqmtqNZ3RpemjyuVzOOcOAEBfYLgbMs2S4X7PM2tMJ0BSW3un7lvi/TcI50RCGl1daDoDAIC0xHA3ZOqIMtMJXaptbNVz3LvdM55YbseRpYlD+plOAAAgLTHcDQgGfBpTXWQ6o0t/s2QoZorHX7Hj8zFuoB3PJgAAwDYMdwPGVhdZcQ7YlqGYKd6tadC6bXtNZ3Rp3CDvf1MKAICNGO4GTBhsxxXJx5dvMp2AD3lyxWbTCV2aMJijMgAA9AWGuwHjB3l/uO/Y26g3t9SYzsCHPGnBrTmzswIaWJJrOgMAgLTDcDdgVJX377rx8EtvmU7AATy5covphG4ZUVFgOgEAgLTDcDdgWP980wldWrFhp+kEHMC7NQ16Z0+D6YwuDSlPmE4AACDtMNxTLBYJqig3YjqjSyvf2mU6AQdhwzdVQ8vzTCcAAJB2GO4pNtyCq+2S9PK67aYTcBA2DPchDHcAAJKO4Z5iQ8q8f4Rge02j9ta3mM7AQazYsMN0QpeGlDHcAQBINoZ7ig0s9f5wX/mW96/oZrIVFhxjGlCUIwseVQAAgFUY7ilWVhA1ndClVRu9Pwwz2Rub96i1vcN0xsdyHKk4N9t0BgAAaYXhnmLlBTmmE7pkw9M5M1mn62rDO/tMZ3SprCBmOgEAAKPcl1d+oqT6ysnJej2Ge4rZcMV9y6460wnowtbd9aYTulSa7/2vdQAA+lRzS7HjdLxQOvCyO/sNurLXT+BkuKdYuQVXIbfs8v4ozHRbLfgcMdwBAJAcx5HjOGf51Lm2pPqy/6fBXwsd6msx3FPMhuMDXHH3Phs+R4Vx7z+vAACAVHGkuM/nXFPq5r1eWnX53EN5DYZ7CsXCQdMJXWrv6NSu2ibTGejCtt3ef3pqIpZlOgEAAM9xpIGOX4+WDrrs4bLqS4f25O9luKeQDUNm8846ua7pCnRl627vX3FPRL3/9Q4AgCmOnPmuz/da6cDLfxrvf2W3ntDJcE+hRCxsOqFL7+zx/pVcSNss+DzZ8PUOAIBJjhRwHJ0fC3WuLam+/CvSlR+7zRnuKZSIHvJ7EVLG6/cHx351ja2mE7rEFXcAALrJUb7PpxvLBna8Ulp95dEH+8sY7imUnWXHGXd4X11Tm+mELuVEvP+NKgAAnuI4Y+R0PF028LLbyssv+cjxGYZ7CnV0ev/wuA2NkBqbvT/cs8MB0wkAAFjHcRzJcT7vZgXO/fCfY7inUJsFx1AY7nZoaPH+cI+EGO4AABwyx/nP0oGXn//+P8RwT6H2Du+PYo7K2KGlrcPzn6tIFsMdAIDecBz9tN+gS2f/8/cZ7inU1sEVdyRPg8ePy9jwng4AALzO5/pulK4MSQz3lGpt9/YVUknqZLhbo7Gl3XTCx8oK+k0nAABgPcfR8JJBHWdKDPeUsuGMezjE2LJFwO/tf307Or3/jSoAADbwuc4l0mk+b/+XP820WXDFPcwbCq3h9Td/2vD1DgCAFRwN7Vc1cjLDPYW8/mZCSQoHvT0G8W+xiLfPkDPcAQBIHp+v4ySGewq1WTDcuROIHYIePyYj8RReAACSytFU7//XP43YMNx5Q6EdbDjS1NLGcAcAIGlcDWe4p1B9Y6vphC55/dw09su24CcjXr9dJQAANnEcJRjuKdTg8dv3Sd4/N439crJDphO6tLehxXQCAABpw8nKCjHcU2xPXbPphI9VlJutYIAvC6/rXxgzndClvfUMdwAAkiUwsor7uKfaPo9fhXQcqTQvajoDXehfmBRMpbYAACAASURBVGM6oUtccQcAIHmyjhzBcE+1GguuQpYWeP9qbqYrs+BztLfe2z9dAgDAFk4soqyjRjHcU23H3kbTCV0qz+eKu9cNsOCK+469TaYTAABIC9lnHSsnK8hwT7V39tSbTuiSDVdzM50NZ9y37q4znQAAgPUCg8sUPvZwSWK4p9rW3Qx39F65FcPd+1/rAAB4XexLJ8pxHEkM95R7d4/3j8oMLkuYTkAXRlYWmk7o0padDHcAAHojcuoMBQaW/uv3Ge4ptsWC4wOjq7w/CjNZZXHcigcwbdxRazoBAABrBQaXK3rG7A/8MYZ7im3a7v0xM3xAvkIBv+kMHMSYau9/Y7W9plHtHZ2mMwAAsJKTl6OcS878yB/3/mW7NPP65j2mE7pl7MBC/WPNdtMZOAAbfiKyZmuN6YSMF27s/a81HVl+X30WT1OGN7mu1P7kGtMZwMfyb9iucA//HicaVu6V58if+Oj72bjinmItbR3aXuP9c+5jqotMJ+AgRlvwuWG4AwDQc044pNwrz1Gg/4Ev0jHcDVi3ba/phC4x3L3Lhivub26x4ydLAAB4RlZQuVd+9gNvRv0whrsBa7d5/2rk4UOKTSfgACKhgEZWFpjO6NKaLd7/GgcAwCuc7Kz9V9qH9P/Yv47hbsCqt3aZTujSEcNKFYtwttVrZo0dYDqhW17d5P2vcQAAvMDJyVbuD76g4NCPH+0Sw92IV9bvMJ3QpYDfp+kjy01n4EOOGVdhOqFLTa3tWv/OPtMZAAB4nq8oV4mrFytQ1a97f30f9+AAXtng/eEu2TESM40Nn5OXuBsRAABdCgwqU+LH58lf1v0jsAx3A/bWt2ijBfdzt2EkZpJELEtjB3r/TcM2/EQJAACTghOHKfeHX5Avnt2jv4/hbsiydd6/KjluULEK4hHTGXjPvMOrTCd0C8MdAICDi5w2Q7mXnCkn1PPHKTHcDXl29TbTCd0yZ3yl6QS8Z8HEKtMJ3fL863Z8bQMAkEq+REy5P/yCoqfPPvTXSGIPeuA5S4b7J48eajoBkoIBn045yvufiz11zXqDW0ECAPABgVHVStzwHwoe1rtjyD2/Ro+keGnddrW1dyoY8Pb3TsdNrlYkFFBTa7vplIx24hGDrLg955MrNptOAADAOwI+RT+/QOGFR8hxnF6/nLdXYxpra+/UC2++YzqjS6GAX4uOHGQ6I+OdOWu46YRueXoVwx0AAEkK5mep5LwZihw3JSmjXWK4G/X0qi2mE7rllGneP6KRzuLZIX3iqCGmM7rlqZV2fE0DANBnfFJibIFKF1QoUBBN9kvDlMdf2WQ6oVtOmDJQkUN45zOS4xRLRvuu2iat2sgTUwEAmSuYl6XShZXKHVMgx5ecq+zvx3A36KmVW9TY4v2z46GAX6fPtOOoRjr64oLRphO65c8vbDCdAACAEY7PUWJcgUoXViiUl9VnH4fhbtjTK+04E3zxaROVpONZ6IFJQ0t05GFlpjO65eF/vGU6AQCAlAsVhlV6QqVyR/fNVfb3Y7gb9ldLjssM65+v4ycPNJ2Rcf7fKYebTugW15UeXWbH1zIAAMngy/Irb3KxShdUKBgPpeZjpuSj4KDue3at6YRu+9Zpk0wnZJTygphOnW7HG4OXvLZV+xpaTGcAAND3fFLOYXkqW1Sl+LBEqj80THp7R51WbNhpOqNbpo0s16ShJaYzMsY3T54gnyXnk+5bssZ0AgAAfS5cmq3S46uUP7FI/pA/5R+f4e4Bv/+7PaPnsjOPMJ2QEeLZIS2eb8ebUiXp7mfeNJ0AAECfCeZlqWhGmfod21+h3NQcizkQhrsH3GvRcD/hiEGaOKSf6Yy0951PHaHcaN+9Kz2Znn/jHW2vaTSdAQBA0gVyQiqaUaay4yuVXREzncNw94K1W2u08i07jstI0k/Pm2U6Ia2VFcR08SfteT/BHyz6xhMAgO7whXzKm1Sk8kVVnhjs/8Rw94g7n3jddEK3TR1RphOO4A4zfeUHZ081ndAjv3uaYzIAgDThSLEhCZWdVK348DzTNR/BcPeI3zyxWh2drumMbrtm8dHWvHHSJkPL83TO3JGmM7rtkZc2atvuetMZAAD0WqggrNIFFSqYUix/OPVvPO0OhrtH7NjbqEdesucBNsP65+uzc+wZmLa4/twZVn1DdNujq0wnAADQK77we/djX1ihUEHYdM7HYrh7yG8eX206oUeuXXy0ihPZpjPSxukzhuk4ix5ytau2SX98fr3pDAAADokT9Cl3bIHKF1Wn/H7sh4rh7iH3L11n1d058nPCuv3CeaYz0kJRbkQ3ffUY0xk9cvtfX1Nbe6fpDAAAesYn5QxLqHxRtRJjCuQL2jOH7SnNAO0dnbr5oRWmM3pkwcRqncORmV6786IFyot5+8dz79fpurrhgWWmMwAA6JFwWVSlx1Upf7J3z7F/HIa7x/zswVfU0tZhOqNHfnreLJUVeOdWSbb5wrxRmnd4lemMHrnn6Td5UyoAwBqBnKCKZper3zHlCiXMPUCptxjuHrOnrll3PWnPrSGl/U/5/O23FpjOsNLgsoT++8uzTWf02NX3vGg6AQCALjkhn/ImFql8UbWyy6Omc3qN4e5B1973sumEHps5ZoB1Z7RNy4uF9Zfvn6zsrIDplB7567JNenXjLtMZAAAclONzlDMif/8bTw/z3v3YDxXD3YNWv71bD1p4t44vHzdW55803nSGFYIBnx76/iINKbfvF5Mf3v2C6QQAAA4qOiiuskXVyj+8UP4s+86xfxyGu0f94K7nTScckhu+NFNzJlSazvC82y+YryMPKzOd0WNPrtisZ1ZtMZ0BAMBHZJVkq+yEShVOLVEgatdPs7uL4e5RL63drr8u22Q6o8d8jqP7Lz1Ro6oKTad41qVnTNGZs4abzjgk3/71300nAADwAcF4SEWzylUyp7+CiSzTOX2K4e5hV/zvc6YTDkksEtSSaz+lSUNLTKd4zqVnTNEPPjPVdMYheWL523rxzXdNZwAAIEnyZb33xNMTqpTd3/43nnYHw93Dnnt9m5Vn3SUpN5qlJ//rNE0fVW46xRMcR/rl+XOsHe2S9N07njWdAADAvx6gVHZSleLDEnIyaM1m0D+qnS761TPq6HRNZxySaDiov159qhZMrDadYpTPcXTXxQv1xQWjTaccsvuWrNULb7xjOgMAkOEi/WMqPeG9Byil2RtPu4Ph7nFrttboF5Y9TfX9soJ+/eUHJ+vzc0eZTjEiFgnqgctP1Okz7DzTLkkdna4uvPVp0xkAgAwWzMtSvzn9VTyrTKG4vQ9Q6i2GuwW+99vnVN/UZjqjV2775lzdedECRcNB0ykpM2FwsV79xWd14pRBplN65RcPrdCmHbWmMwAAGcgfC6pwWolKj6tUuCTbdI5xDHcL7NzXpO/cbv/dPM6afZhe+flZGp0Bd5z5+qIJeu6GM1RZHDed0iu1ja363m/tfJM0AMBeTtCnvAmFKjupStHquBzHdJE3MNwt8bMHl2v5hh2mM3ptSHmeVt78GZ133FjTKX0iPyesB688ST/50kyFAvafvfvWbc9o574m0xkAgEzx3htPyxdVKz4yXz4fi/39GO4WOfenj5tOSJqbv3qMnrnmUxpYkms6JWnOmn2Y3rj1czrhCLuPxvzTC2+8o1v+stJ0BgAgQ4TLoio9/r03nobtv/jVFxjuFvnHmnf1q0dWmc5ImumjyrX+11/QJZ+abDqlVyqL43r0qlN050ULVJQbMZ2TFO0dnTr72kdMZwAAMkAgJ6ii2eXqd0y5QrmZ+8bT7mC4W+aCXz6tLbvqTGck1dXnTNOqmz+jo0f3N53SI9lZAV38yUl649ZzNHdCpemcpLrq7he0dmuN6QwAQBpzAj4lJhSq9MQqZZdnxgOUesvR/OvsvEl4Bps6okxLrj09Ld+o8dqm3br1kVW64/HXtLe+xXTOAU0c0k+L54/WmbOGKyeSflcGXnzzXR35zd+p0+WXBpvltiV6/yJ5Rc8HC4qm9P6FgORzXbW35+QHTHfg0EQHxpUYX6hANp/CnmC4W+r6c2fomycfbjqjT9399Bu67dHX9Pgrm0ynKD8nrNOmD9WXjxursQOLTOf0mbqmVo049460+6lOJmK4I90x3O2UVRhW/pR+CuVlmU6xEl/wlvrO7c/qmHEVGlOdviPy9BnDdfqM4aqpb9Z9S9bqgaXr9Jd/vJWyj19WENOp04Zo0ZGDNWvsgJR9XJM+e+0jjHYAQNIFcoLKm1Ck7IqY6RSrccXdYlX94lpx02cUz06/4xoHU9fUqvufXavnXn9Hr27crRVv7Ujaw6kGluRqVFWhxlQX6fjJ1TpieGlSXtcWtz36qhb/5DHTGUgSrrgj3XHF3Q6+LL9yxxYoPiwJvyaB4W67ORMq9dhVp5jOMGrzzjqt2rhLq97apb0NLWpsaVNDc5saW9rV2NKmusY2BQM+RcNBZWcFFA0H3/vtoKpL4hpVWaiRlQUZ9VTXD1u1cZcmnf9btbR1mE5BkjDcke4Y7t7mBHyKH5an+Ig8+ULcCyVZ+IK33F+XbdIlv16i//zcNNMpxgwoytGAohwtnFRtOsVK9U1tOv6KBxjtAIBec3yOYkNyFR+dr0CEmZls/D+aBn5074uaMLhYp00fajoFFjr9Rw/p7R2cawcA9E60Oq7EuAIFYpn7E+y+xnBPE2df87Cq+sU1aWiJ6RRY5JJf/10PvbjBdAYAwGKBRJYKj+ynrMKw6ZS0x6GjNNHS1qHjLn9Am3dy5RTdc+OflutH9/7DdAYAwFJO0Ke8ycUqO66S0Z4iDPc0snNfkxZcdr/qmlpNp8Dj7n76DX3t5r+ZzgAA2MiRooNyVb6oWvFhCTmsyZTh/+o089qm3Tr+iv9TW3un6RR41JLXtursax4RD0YFAPRUVr+ISuZXqHBqP/nDftM5GYfhnoaeWbVFZ13zsOkMeNCydTu08LIH1N7BN3YAgO4LJrJUNKtcJXMHcCzGIN6cmqbufeZNlRfEdP25M0ynwCOWrduhYy75PUepAADd5o8FlRhboGh1XI5jugYM9zR2wwMvq765Vbd8bQ7/smW4f6x5V8de8gfVNjLaAQBd84X8yh2br/jwPNMpeB+Ge5q79eFV2tfQqnsuOc50Cgx57vVtmvvd+1Tf1GY6BQDgcY7PUc5hecodlc8TTz2I4Z4B7n3mTe3c16gHr1ikWISHImSSe55+U6f/6CHTGQAAr3OkaBUPUPI6vpXKEE+u2KzpF92jd2saTKcgRX5074uMdgBAl7IKwyo9rlKF00oY7R7HcM8gy9fv0KTz79KrG3eZTkEf+8INj+mSXy8xnQEA8DB/LKjCo0tVsqBCobws0znoBoZ7htmyq05TL7hbjy3bZDoFfWB3bZOOuvBu/c9jr5pOAQB4VcCn3HEFKjuxStHKHNM16AGGewaqa2rVgkvv1w/uel6dPIUnbby6cZfGf/V/tXT1NtMpAAAvcqTowLj6n1SlxOgC+fzccs42DPcM1em6uvzOpZr33fu1u7bJdA566f+eW6cp3/ydNu+sM50CAPCgUGF4/xNPjyqRP5t7k9iK4Z7hHn9lk8Z+5U6u0lrs/Juf1Mnff1ANzdzuEQDwQf5oQIXTSlQyv4InnqYBhju0dXe9jr7oHo7OWOb1zXs0dPGv9bMHXzGdAgDwGCfoU2J8ocpOquapp2mEn5VAktTRuf/ozOPL39Y9lxynkryo6SR8jGv+8A9967a/m84AAHiNT8oZnFDumAL5I37TNUgyrrjjA55ZtUUjzr1Dt/xlpekUHMBLa7dr3H/cyWgHAHxEpDyqshOqlH9EMaM9TTHc8RE19c0672ePa9R5d+jpVVtM50D77wT0jVue0hFfv0srNuw0nQMA8JBATlBFs8tVPLtcwXjIdA76EEdlcFCvbdqtmd+6V584aoiuWXy0Bpbkmk7KSL94aIUuv3Opdu7j7j8AgH9zAj4lxuQrdliefD4OsWcChju6dP+za/Xg8+t17oIxuuLTU1ScyDadlBH+sGSNvv0/S7T+nb2mUwAAXuJI0UG5SowrUCDClMskfLbRLe0dnbrpz8t15xOr9a3TJuqCT0xUdhZfPn3h/mfX6qq7X9CydTtMpwAAPCarKKL8I4oVyssynQIDHM2/jvv/occSsSx97cTxOv+k8SqMR0znWK+lrUO/eXy1fnTvi9rw7j7TOUgDuW2J3r9IXtHzwYKiKb1/ISD5XFft7Tn5GXMFyR8LKm9CoaKVOaZTYBDDHb0SCQW0eP5oXfCJw1XVL246xzq7apt0y19W6mcPvqLtNY2mc5BGGO5Id5ky3J2AT7mj85VzWJ58fs6xZzqGO5LCcaQ54yt17oIxOnHKIAUD3LDo47yxeY9+8n/LdPtfX1NLW4fpHKQhhjvSXdoPd0eKDc5V7ljOsePf+EpAUriu9NiyTXps2Sb1y8vW5+aM0uL5ozSoNAnjIU3srm3S/c+u0z3PvKknlr9tOgcA4FHh0mzlTSxWKMGtHfFBXHFHn5o2slznLhitU6cPVSSUed8nbt5Zp/97bp3+sGStnuGe+Eghrrgj3aXjFfdgIqS8CUWKlPP0chwYwx0pEYsEtXDSQB07rkLzJ1ZpQFH6vrnm1Y279MDSdXrw+fV6ae120znIUAx3pLt0Gu7+SECJsQWKDs6VwzF2fIy0+IKH99U3teneZ97Uvc+8KUkaWp6nY8dXauaY/po1doC1d6Zpbm3Xig079eKad/XK+p16auVmvcVdYQAA3eAEfIqPzFPuiDw5vDcM3cBwhxFrttZozdYa3fTn5ZKksQOLNGvsAM0cPUBjqgtV7cGntDa2tGvZuu1avn6Hlq3fqWXrtmvFhp2mswAAFooNTSgxtkD+sN90CizCcIcnrNiwUys27NRPHlj2rz82srJAA0sSGlVVoMFlCQ0py9OQ8oRK8vr27N87exq0dmuN1r2zV2u37tW6bXu1+u3dWv327j79uACA9JdVFFHBlGIFEzxACT3HcIdnvbZpt17btFt/emH9B/54dlZAIyoKVJgbUSwcUiwSVCwSUiwcVDh04CsXLW0dqm9qU0Nzm+qb21Tf1Kr65vd+v+nfv7+voSUV/2gAgAzjjwWVP6FQ2TxACb3AcId1GlvaedMnAMAKPEAJycRwBwAA6APRQblKjOcBSkgevpIAAACSiHPs6CsMdwAAgCTwx4LKn1ik7AEx0ylIUwx3AACAXnBCPiXGFChnaEIO59jRhxjuAAAAh8LnKGdYQrmj8+XP4n7s6HsMdwAAgB6KVMSUN75QwXjIdAoyCMMdAACgm0KFYeVPKlZWYdh0CjIQwx0AAKAL/lhQeeMLFa3iAUowh+EOAABwEL6QX7lj8hUblpDPxxtPYRbDHQAA4ADiI/KVOzpfvpDPdAogieEOAADwAZH+MeUdzhtP4T0MdwAAAEnB3JDyJhUrUpptOgU4IIY7AADIaE7Ip8S4QuUMyZXDOXZ4GMMdAABkrJxhCeWOLeABSrACwx0AAGScSHlUiQlFCiU4xw57MNwBAEDGCMZDyj+iWOESzrHDPgx3AACQ9nxZfiXGFSg2OCGHuzvCUgx3AACQthyfo5zD8pQ7ivuxw34MdwAAkJai1XElxhUoEAuaTgGSguEOAADSSqgwrPxJxcoqDJtOAZKK4Q4AANKCPxZU3oRCRStzTKcAfYLhDgAArOaEfEqMzldseJ58PEAJaYzhDgBpyA345bR3mM4A+hwPUEImYbgDQBoKnDRVncs3yN2wVXJN1wDJFxlc4Ms5skrBHN54iszBcAeANOREwvIfOULusAHqePlNaXuN6SQgKUL9YopPq1KoOMa9HZFxGO4AkMac/BwF5kyUu3mHOpatleoaTScBh8SfG1b8yApFqvNNpwDGMNwBIAM4A4rlLyuUu2aLOldukNraTCcB3eJEgopP7K/sEcVyeOMpMhzDHQAyhOP3yTmsQs7AUnWu2iB3zRaps9N0FnBQsQnlyplQLifIqRhAYrgDQMZxsoLyTxwmd2h/dbyyVtq803QS8AFZ/XOVO6NagTgPUALej+EOABnKiUcVmDFO7rs1+9/AWlNnOgkZzh/PUnxqJefYgYNguANAhnNK8uRfeITc9dvUuXy91NxiOgmZJuBTzrgyxcaXyQlwLAY4GIY7AECO48gZXC5fVYk6X9uoztUb5cjlADz6XLg6X/EpFQokOBYDdIXhDgD4t4BfvrGD5AwuV+fG3cXi9Az6SKAwqsT0KoVKckynANZguAMAPsKJhuUfWT7YbWiVNu6TU9dqOglpwhcNKX7EAGUPKzKdAliH4Q4AOLhoSBpZJHd3o5y366SWdtNFsJQT9Ck2vlyxsaWcYwcOEcMdANC1gmy5BdnS1jo52+qlDo6/o/uyDytWzuQB8mcHTacAVmO4AwC6rzxHbtF7A357g+kaeFyoPK7cadUK5kdMpwBpgeEOAOiZkF+qTsgticrZWCvtazZdBI8JJMLKPapKWRUJ0ylAWmG4AwAOTSQo97ACqaZZztu1UlOb6SIY5kSCik/ur+iIfqZTgLTEcAcA9E5eWG5eWNpeL22pk9PG+feME/ApNqZUsfFl8oX8pmuAtMVwBwAkR7/Ye29grZfzDjeAzxSRoYXKOaJCgVjIdAqQ9hjuAICkcQI+qTIut19EzuY6aXeT6ST0kWBJjhLTqxUszDadAmQMhjsAIPnCQblD8qWSlv0PcGrg/Hu68MdCik+tVGRQgekUIOMw3AEAfScnSxpdLHdno7S5Vk5rh+kiHKqATzkTeIASYBLDHQDQ94qypfyI3HfqpG31cjpd00XogezhRcqZNEB+zrEDRjHcAQCp4Xek/nG5xVE5m2ulnY2mi9CFUL+Y4tOrFSqKmk4BIIY7ACDFnJBf7qA8qSQmbdwrp67VdBI+xB8LKX5kpSKDOccOeAnDHQBgRjQojSxS554mOZtq5bS0my5CwKecCWWKjS3jHDvgQQx3AIBRTn5k//n3bXVyttZLHTzAyYTsYUXKmcw5dsDLGO4AAG8oy5FbFJWztU56t950TcbgHDtgD4Y7AMA7gj65Vblyi7PlvF0rZ2+z6aK05Y+FFJ9SociQQtMpALqJ4Q4A8BwnOygNL5C7r1nOplqpkQc4JU3Ap5zxZYqN4xw7YBuGOwDAu3LDcseEpe0N0pZaOW2cf++NyLAixTnHDlgrIKlVEv8GA0C68PlNFyRfv6jcwoi0tV7OtjrTNdYJDypQ7pQK+eNZplMA9EJArvbKUbHpEABAcjjBoOmEPuH4fVJFXG5xtrS5Vs7uJtNJnhcozFZierVCJTmmUwAkQUCO2yw5pjsAAEnihNJzuP9LOCANyZdb0iJt3CengfPvH+aLhpQzeYCiw4tMpwBIooBcZ5ccVZgOAQAkhy8rQ04/5mRJo4vl7mqUs7lWaukwXWRewKfYuDLljCuTE+SNp0C6CUhaJ2mC6RAAQHL4YzHTCalVmC03PyJtq5O21cvpdE0XGREZUqicKRUK8MZTIG0F5OgN0xEAgOTxx+OmE1LP50j941JxttzN9XJ2NpguShkeoARkjoBc52U5mXl1AgDSUUYO938KBaRBCbklUWnTPjm1LaaL+gwPUAIyT0DSEsntlBwOwwGA5RyfT8Ei3pCoaFAaUSh3T5O0qVZOS7vpoqRxgj7FxpcrNraUBygBGWb/7WTmXbdCjsYYbgEA9FKgqEi5s2eazvCebfVyttZJHXY/wCkyvFjxyf3lj3KOHchE/3xy6u8lhjsA2C5UWmI6wZvKYuoszpazpU7Ou/Wma3osVB5X7tRKBQs5xw5ksv3D3XX/IMf5geEWAEAvhQYMMJ3gWU7AJ1Xlyu2Xvf/4zN5m00ld8udkKX5UpSLV+aZTAHjAv5+8xHEZALBaID9fuXOOMZ1hj33NcjbVSo3ee4CTE/IrZ2J/xcaWmk4B4CGBf/2Woxsl3WIuBQDQG+GBA00n2CU3LHdMWNrRIG2uk9PmjQc4ZY8pUc7h/eUPB7r+iwFklH//qrDP+Y3inVfIccoM9gAADoEvHFaokodgH5LiqJQfkbbV73+IkyHhqjzlHFmhYCJirAGAt/n/9VtbHm3X4HmdcjTfYA8A4BBERo1SsJj7eR8ynyPlZsktzJbaXTkpPD4TyI8of/4wxcaXyR8OpuzjArDPB38O5wveJLf1y/+/vXuLjfS+yzj+/GfG9tqeg9e7sb2HbNomDaSJkmyLWtqU0qCyCZUAAQVaVCFEb7jpVcWhF4CQuKCUVNwghAJJKxAXgHrTVogW1AohhEBU1Tb2ut7swfau53z0vPO+M++Ji2RLkt3s2uuZ+c/h+7lZyfa889zY+/jn//v+JPOopTwAgENKptOaf+Rh2zEmgjmWkh45rmh1UYntptTuDe695meU+8CDWnhsZWDvAWCymNs+8vwXPyolvj38KACA+5F99qOaWWHp0kBUOjK7Lanbx/PvqYTST51S+vxpJWaS9/56AHjd7T8xXv3WdT3y3DlJ54cfBwBwGHPvfIfmH3237RiTa2FGWl2QEgnJ6cnER7vc/LtPavn5RzX/rmWZJFtPARzOnW9Zj6LPypj3y5gnhpwHAHBAyWxWi+97r+0Yky+RkM5kpJUFxbv7MiXn0JeYWUlr6SffyQIlAEdy+1GZWy588QklzP9Khr3KADBqEkZLFy4omcvaTjJ14o4vc70p0+re82uT6VllP/iQ5h85MYRkACbd2xd3SXr+hU9L8Vckw9/zAGCEpD/4Ac2d4/GPVtU9absp4wW3fcrMJpV+7xllzvOEZQD9c/e7Yl795kU9/FyLR0QCwOhYePppHXuYZUvWzaektbSUTMg4vhS9dgB+8fE1LT/3qI6dW7IcEMCkufvE/ZbnXvgdGX1hwFkAAPew8OSTmn/sR2zHwFuFkTcTmY0Tj586l1yc4YH6AAbiYMVdki68g6fUfwAAET5JREFU8JtK6EVJHJsBgGEzRukfe5/m3vVO20lwF6m5lLJnlzSfZfspgP47eHGXpJ/+0gUl43+UxN1QADAkZialzDPPaGaVRT3jYnZxTksPHtfMPJtQAfTP4Yq7JF34sx9VwvyzpHf0PQ0A4E2SmbQyH/6wktmM7Si4DwsnFpU9vaRkij9WAzi6w69su/LNih76ub9VMjgumfcNIBMAQK8tV8o88yElFjh2Ma5815dTaUuSZhdnZczh52UAcMvRfoI898KTUvyCjPlYn/IAwNSbWVnR4vmnlVzK2Y6CPkrMJJU7s6SF4wu2owAYU/351f9nXnhakT4vo0+Im1cB4PCM0eyZM5p//DGllniM4CSbmZ/R0oPLml1kvyGAw+nv3+w+/qdrCpOflOJPyZj39/XaADCBUidPaO6hhzR79owSx47ZjoMhOra0oNyZJaVmD39qFcB0Gtxhu4/9+Tklw1+U9MuSPjTAdwKAsZI6cUJz585q9syDSixyfn3aZVazyqxmZZL8Rwng7ob3U+KnvnRayWBFyeSyFK8o0kkZLcsYRg0YipmzD34klct81HYOTAdjEjJzszKzs0rMzb3277FZJeY534zbJVIJZU/ltHgybTsKgBHGr/eYGssv7/6BUfxHtnMAwNtJHZvR0oPHNZeesx0FwAjiRlIAAEZE4PmqXC6pcqWsoBvYjgNgxFDcAQAYMd2Wp+JGXvXduqIgsh0HwIhI2Q4AAADurFNpy607yq7llF5hey4w7Zi4AwAwwuIwVvNmQ4X1vNyGazsOAIso7gAAjIGwF6h2raLyVlG+69uOA8ACijsAAGOk5/RU2iyotl1TGIS24wAYIs64AwAwhtyaI6/RUXo1q/RKRokET3gGJh0TdwAAxlQcxdrPN1XcyMupObbjABgwijsAAGMu8kM1tmsqbRbUdbq24wAYEIo7AAATwnd9VbZKql6tsMAJmECccQcAYMJ4TVde01V6JaPsWk4myfl3YBIwcQcAYEK1S/sqrO+pXWnbjgKgDyjuAABMsCiM1Nytq3gpT4EHxhzFHQCAKRB4wesFvqBumxtYgXFEcQcAYIoEnq/K5ZIqr5a5gRUYMxR3AACmUHffU3Ejr8ZuXWEY2Y4D4AB4qgwAAFPMqbTVqTnKnMops5KxHQfAXTBxBwBgysVRrNbNhgrre3Kbru04AN4GxR0AAEiSwl6o2tWKyltF9dye7TgA3oLiDgAA3qTn9FTeLKq+XVXoh7bjAHgdZ9wBAMAddWodufXXNrCm17JKJNjACtjExB0AALytOI61X2ypuL6nTtWxHQeYahR3AABwT1EQqb5TY4ETYBHFHQAAHNitBU7VKxX5LHAChoriDgAADs1ruSpt5NW40VAUxrbjAFOBm1MBAMB9c8r76tQcZU9llX6ABU7AIDFxBwAARxKHkZo3Gipu5FngBAwQxR0AAPRF0A1eX+BUku/5tuMAE4fiDgAA+qrndFW6VFB9u6YwiGzHASYGZ9wBAMBAdGqO3EZHmbWs0isZGcMCJ+AomLgDAICBiaNYrb2mCut5deod23GAsUZxBwAAAxf5oerXqyptFtRzerbjAGOJ4g4AAIbGd32Vt4qqXqsq6IW24wBjhTPuAABg6LxGR16jo/RKRtm1nEyS8+/AvTBxBwAA1rRL+yqs76ldbduOAow8ijsAALAqCiM1d+oqXsqr2+7ajgOMLIo7AAAYCYEXqHK5pMqVsoJuYDsOMHIo7gAAYKR0W56KG3k1duoKQxY4AbdwcyoAABhJTrWtTt1R5lROmZWM7TiAdUzcAQDAyIqjWK2bDRXW9+Q2XNtxAKso7gAAYOSFvVC1axWVt4rquSxwwnSiuAMAgLHRc3oqbxZVv15V6LPACdOFM+4AAGDsdOoduQ1Xi6sZZVazSiRY4ITJx8QdAACMpTiO1S60VFzfk1N1bMcBBo7iDgAAxloURGrs1FS8VGCBEyYaxR0AAEyEwPNVuVxS9UpFPgucMIEo7gAAYKJ4LVeljbwaNxqKwth2HKBvuDkVAABMJKe8r07NUfZUVukHWOCE8cfEHQAATKw4jNS80VBxIy+3xQInjDeKOwAAmHhBN1DtSkXlrZJ817cdB7gvFHcAADA1ek5Xpc2C6js1hUFkOw5wKJxxBwAAU6dTdeTWO8qsZpVezcgYFjhh9DFxBwAAUymOYrXyTRXW8+rUO7bjAPdEcQcAAFMt8kPVr1dV2iyo67DACaOL4g4AACDJd31VtkqqXqso6IW24wC34Yw7AADAG3gNV17DVXolo+xaTibJ+XeMBibuAAAAd9Au7auwvqd2pW07CiCJ4g4AAPC2ojBSc7eu4qWCvH3PdhxMOYo7AADAPQSer+qrZVUulxR0A9txMKUo7gAAAAfUbXdV3MirsVtXGLLACcPFzakAAACH5FTa6tQcZdZyyqxmbMfBlGDiDgAAcB/iKFZrr6HC+p7cBgucMHgUdwAAgCMIe6Fq16oqbxXVc3u242CCUdwBAAD6oOf0VN4sqna9qtBngRP6jzPuAAAAfeTWO/IarhZXMsqsZZVIsMAJ/cHEHQAAoM/iOFa72FJxY09O1bEdBxOC4g4AADAgkR+psVNT8VJB3XbXdhyMOYo7AADAgAWer8rlkqpXKvJZ4IT7RHEHAAAYEq/lqrSRV+NGQ1HAAiccDsUdAABgyJzyvgobe2qX921HwRihuAMAAFgQh7GaNxoqbuTlNl3bcTAGKO4AAAAWBd1AtasVlbdK8l3fdhyMMIo7AADACOg5XZU2C6pt1xQGLHDC7VjABAAAMELcmiOv0VFmNav0akbGsMAJr2HiDgAAMGLiKFYr31RhPS+n1rEdByOC4g4AADCiIj9UY7uq0mZBXYcFTtOO4g4AADDifNdXZauk6tWKAhY4TS3OuAMAAIwJr+nKa7pKr2SUXcvJJDn/Pk2YuAMAAIyZdmlfhfU9tStt21EwRBR3AACAMRSFkZq7dRU38vJanu04GAKKOwAAwBgLuoGqV8qqXC5x/n3CUdwBAAAmQLfdVXEjr8ZuXWEY2Y6DAeDmVAAAgAniVNrq1Bxl1rLKrGZtx0EfMXEHAACYMHEUq7XXVGF9T26DBU6TguIOAAAwocJeqNq1qko/KKrn9mzHwRFR3AEAACac3+mpvFlU7XpVoR/ajoP7xBl3AACAKeHWO/IarhZXMsqsZZVIsMBpnDBxBwAAmCJxHKtdbKm4sSen5tiOg0OguAMAAEyhyI/U2K6peKmgbrtrOw4OgOIOAAAwxQLPV+VySdWrFfkscBppnHEHAACAvKYrr+lq8WRa2VM5JVLMd0cNxR0AAAA/5FTa6tQdZddySq9kbMfBG/CrFAAAAN4kDmM1bzZU3MjLa7q24+B1FHcAAADcUdANVL1aUXmrJN/1bceZehR3AAAA3FXP6aq0WVBtu6YwYIGTLZxxBwAAwIG4NUdeo6P0alaZ1YyMYYHTMDFxBwAAwIHFUaz9fFOF9TwLnIaM4g4AAIBDi/xQje2aSpsFdR0WOA0DxR0AAAD3zXd9VbZeW+AUsMBpoDjjDgAAgCO7tcAp/UBG2VM5mSTn3/uNiTsAAAD6pl3eV2F9T+1K23aUiUNxBwAAQF9FYaTmbl2Fjby8lmc7zsSguAMAAGAgwm6g6pWyKpdL8j0WOB0VxR0AAAAD1W13VbpUUGO3rjCMbMcZW9ycCgAAgKFwKm11ao7Sp7LKrmRtxxk7TNwBAAAwNHEUa/9mU4X1PXXqHdtxxgrFHQAAAEMX9kLVr1dV+kFRPadnO85YoLgDAADAGr/TU3mrqNq1qkI/tB1npHHGHQAAANa5jY7cVkfpB7LKrGWVSLDA6a2YuAMAAGA0RFK72FJxfU9O1bGdZuRQ3AEAADBSoiBSY6em4qWCuu2u7Tgjg+IOAACAkRR4viqXS6peKcvvBrbjWEdxBwAAwEjzWp5KG3k1btQVBdO7wIniDgAAgLHglNsqbOypXdq3HcUKijsAAADGRhzGat5sqLCel9twbccZKoo7AAAAxk7YC1S7VlF5qyTf9W3HGQqKOwAAAMZWz+mqtFlQbbumMJjsBU4sYMLUiKUOqxwAAJhMbs2R1+govZpVeiUziQucOkzcMT3iuG07AgAAGJw4irWfb6q4kVenPlkLnGKpRXHH1IgNxR0AgGkQ+aHq12sqbRbUdSZjgZOhuGOaJGMVbGcAAADD47u+KlslVa9VFIz5AqdY2uOMO6ZGGM1sJZPj/U0LAAAOz2u48hqu0g9klDmVUyI5lufft8YyNXC/Try8E9vOAAAA7EkkE8qezmnxZNp2lEOJpM9xVAbTJY6/azsCAACwJwojNXbrKmzk5bU823EOLtZFijumSmzMd2xnAAAA9oXdQNUrZVUul+R7o7/A6ZXz5l8p7pgqcRx/23YGAAAwOrrtrkqXCqrv1BQGke04dxTH+neJzamYMvX0/HdsZwAAAKOnU3VUXN9Tq9SyHeU2JqGvSRR3TJtfWWnH0pdtxwAAAKMnjmLt32yq8MqeOo2O7Tg/1JvVSxLFHVMojuK/sZ0BAACMrtAPVb9WVekHRfWcnu04X918zNQkicdBYiotv7TzfWP0hO0cAABg9M0fX1D29JJSs8nhv7nRBy8+Zf5LYuKOKWVi8/u2MwAAgPHg1jsqXtpT62ZTUTS8lTCx9J1bpV1i4o4ptvzyzrqR3mM7BwAAGB+JVELZ00taPLE48PeKYj37yvn/f5Q1E3dMMfM52wkAAMB4iYJIjZ2aipcK6ra7g3yrr7+xtEtM3DHlll/e+RcjXbCdAwAAjKe57DHlzh7XzFyqr9eNE3r4+0+aq2/8GBN3TDU/kfis7QwAAGB8dVueSht51Xfrivq1wCnWn7y1tEtM3AEdf2nntxJGf2k7BwAAGG8maZRdyym9kjnKZb538Wlz/o7XP8pVgUmx/PL2N4zMx23nAAAA4y85m1LuzJLml+YP98JYnZ70+OZ5c/1On+aoDCApES38ahzrFds5AADA+At7gWrXKipvFeW7/oFfFxn9wtuVdomJO/BDiy8WV+ZS3f8x0jnbWQAAwOSYP76o3Nmckqm7LHAy+qWLT5mv3u06FHfgDbJ/vftIKhn/G+UdAAD0kzFG6dWM0qtZJRJvruCR0Wdeecq8dM9rDCwdMKbSL+VPzpret4zM07azAACAyZKYSSp3OqeF5dcXOBn97MWnzNcP8lqKO3An/1BKLzvei0b6pO0oAABg8sxlj3VOvPuBn/j+k+a7B30NxR24ixNf3v51ReYvZJS2nQUAAEyGY7n5zf2F2Wdaz+dqh3kdxR24h+W/u3HW+NEXJP2a7SwAAGB8mYSJ5pYW/vDmz5/44/t6fb8DAZNq+Ss3ftwoelGRnrCdBQAAjJeZhZn/dl3/U83fOHfbRtSDorgDh3Ti7/c+nQzjvwqDcMF2FgAAMLpM0mh2ce4/FSc+s/eJk5tHvl4/QgHT6Nw3Gr8XBcHvek1vKQ4j23EAAMCISB1LNWYW5/4pWJr9fOEjmUq/rktxB47o8e/FF/yW99u+53+st++p5/qK/NB2LAAAMAQmlYxSc6lWMpl4NTL6D7cXvdz45OrFgbzXIC4KTKv3rMfpVKAF1ygdt3rHfDeYjYxSkR+mYillOx8AALh/JhUH6iU9zUUdY1LtVGK+dv1Z49nOBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA3/wfjf16F9xCUzgAAAAASUVORK5CYII="></image></defs></svg>', 1), _c = { components: { StyledBtn: ic }, setup() {
          const e7 = lc(), t10 = yt2(false), n8 = fn("errorHandler"), i10 = new kl(n8), r9 = yt2(null), o8 = yt2(true), s10 = yt2(0), a8 = yt2(null), l8 = vr(() => Sl.state.user.username), c9 = vr(() => {
            let t11 = e7.$t("email_was_sent_to");
            return "authentication_method_pending" === Sl.state.pages.context ? t11 = e7.$t("account_not_confirmed") : "passkey_cancelled" === Sl.state.pages.context ? t11 = e7.$t("passkey_cancelled") : "passkey_deleted" === Sl.state.pages.context && (t11 = e7.$t("passkey_deleted")), t11.replace("[username]", l8.value);
          }), u7 = () => {
            s10.value--, s10.value <= 0 && (o8.value = false, clearInterval(a8.value));
          }, d7 = () => {
            o8.value = true, s10.value = 30, a8.value = setInterval(u7, 1e3);
          }, A6 = vr(() => e7.$t("resend_countdown").replace("{{sec}}", s10.value));
          return { headline: vr(() => "passkey_deleted" === Sl.state.pages.context ? e7.$t("passkey_deleted_headline") : e7.$t("check_inbox")), resend: (e8) => {
            e8.preventDefault(), t10.value = true, d7(), i10.SignIn(Sl.state.user.username).then((e9) => {
              t10.value = false, Sl.commit("setEMailLinkIDPending", e9);
            }).catch((e9) => {
              t10.value = false, ml.error("Failed to resend magic link", e9);
            });
          }, resendIsLoading: t10, cancel: (e8) => {
            e8.preventDefault(), clearInterval(r9.value), Sl.commit("setEMailLinkIDPending", null), Sl.commit("switchPage", Ol.PAGE_LOGIN), Sl.commit("setCurrentLoginMethod", "");
          }, username: l8, context: c9, i18n: e7, disableResend: o8, disableResetCnt: s10, resendCountDown: A6, startCountdown: d7 };
        }, mounted() {
          null !== Sl.state.emaillink.pendingID ? this.startCountdown() : Sl.commit("switchPage", Ol.PAGE_LOGIN);
        } }, Vc = (0, Fl.Z)(_c, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn");
          return Vi(), Ki("div", null, [rr("div", Uc, [rr("h1", null, A5(i10.headline), 1), rr("p", { innerHTML: i10.context }, null, 8, Qc)]), rr("div", Rc, [rr("a", Yc, [Zc, ar(" " + A5(i10.i18n.$t("open_gmail")), 1)]), rr("a", Bc, [Wc, ar(" " + A5(i10.i18n.$t("open_yahoo")), 1)]), rr("a", Gc, [Hc, ar(" " + A5(i10.i18n.$t("open_outlook")), 1)])]), or(s10, { dataAction: "resend_email", type: "primary", fullWidth: true, onClick: i10.resend, isLoading: i10.resendIsLoading, classes: "resend", part: "email-resend", disabled: i10.disableResend }, { default: un(() => [i10.disableResetCnt > 0 ? (Vi(), Ki(Zi, { key: 0 }, [ar(A5(i10.resendCountDown), 1)], 64)) : (Vi(), Ki(Zi, { key: 1 }, [ar(A5(i10.i18n.$t("resend_email")), 1)], 64))]), _: 1 }, 8, ["onClick", "isLoading", "disabled"]), rr("p", { class: "pointer text-center text-small", onClick: t10[0] || (t10[0] = (...e8) => i10.cancel && i10.cancel(...e8)) }, A5(i10.i18n.$t("cancel")), 1)]);
        }], ["styles", ["\n.username {\n  font-weight: bold;\n  color: var(--light-color, #1953ff);\n}\n.resend {\n  margin: var(--email-link-resend-margin, 1rem 0);\n}\n.provider-options {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  gap: 0.6rem;\n  margin: 2rem 0;\n}\n.provider-btn {\n  font-family: var(--primary-font, sans-serif);\n  border-radius: 1.5rem;\n  display: flex;\n  flex-direction: row;\n  gap: 0.4rem;\n  align-items: center;\n  align-self: center;\n  border-width: 1px;\n  border-style: solid;\n  border-color: var(--text-color, #535e80);\n  background-color: var(--email-provider-btn-color, #fff);\n  color: var(--text-color, #535e80);\n  padding: 0.5rem 0.8rem;\n}\nsvg {\n  width: 1.2rem;\n  height: 1.2rem;\n}\n@media screen and (min-width: 576px) {\n.provider-options {\n    flex-direction: row;\n}\n}\n"]]]), Fc = { components: { EmailLinkPending: Vc } }, Jc = (0, Fl.Z)(Fc, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("email-link-pending");
          return Vi(), qi(s10);
        }]]), Xc = { class: "heading text-center" }, Kc = { class: "input-group" }, qc = { key: 0, class: "text-small text-center" }, $c = { components: { EmailLinkLogin: bc, OtherLoginOptions: xc, PasswordLogin: hc, InputField: $l, StyledHr: Mc }, setup() {
          const e7 = lc();
          return { username: vr(() => Sl.state.user.username), signup: vr(() => Sl.commit("switchPage", Ol.PAGE_REGISTER)), back: (e8) => {
            e8.preventDefault(), Sl.commit("switchPage", Ol.PAGE_LOGIN), Sl.commit("setCurrentLoginMethod", "");
          }, allowUserRegistration: vr(() => Sl.state.projectConfig.allowUserRegistration), i18n: e7 };
        } }, eu = (0, Fl.Z)($c, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field"), a8 = qn("email-link-login");
          return Vi(), Ki("div", null, [rr("div", Xc, [rr("h1", null, A5(i10.i18n.$t("login")), 1)]), rr("form", null, [rr("div", Kc, [or(s10, { id: "username", type: "email", label: i10.i18n.$t("email_address"), name: "username", autocomplete: "username webauthn", value: i10.username, modelValue: i10.username, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.username = e8), disabled: true }, null, 8, ["label", "value", "modelValue"]), or(a8)])]), i10.allowUserRegistration ? (Vi(), Ki("p", qc, [ar(A5(i10.i18n.$t("dont_have_account")) + " ", 1), rr("span", { class: "link", onClick: t10[1] || (t10[1] = (...e8) => i10.signup && i10.signup(...e8)), "data-action": "switch_to_sign_up" }, A5(i10.i18n.$t("sign_up")) + ".", 1)])) : cr("v-if", true), rr("p", { class: "pointer text-center text-small", onClick: t10[2] || (t10[2] = (...e8) => i10.back && i10.back(...e8)) }, A5(i10.i18n.$t("back")), 1)]);
        }]]), tu = { class: "text-center" }, nu = ((e7) => (ln("data-v-20047e5c"), e7 = e7(), cn2(), e7))(() => rr("svg", { xmlns: "http://www.w3.org/2000/svg", height: "40", width: "40" }, [rr("path", { fill: "#8f9bbf", d: "M5.417 16.292q-.334-.167-.438-.563-.104-.396.104-.729 2.5-3.75 6.5-5.812 4-2.063 8.542-2.063 4.417 0 8.333 1.958 3.917 1.959\n                    6.542 5.584.292.416.208.833-.083.417-.375.625-.291.25-.708.208-.417-.041-.625-.416-2.292-3.25-5.833-5-3.542-1.75-7.542-1.792-4 .042-7.5\n                    1.75t-5.75 5.083q-.292.375-.729.459-.438.083-.729-.125Zm20.041 21.041q-4.958-1-7.729-4.437-2.771-3.438-2.771-8.188 0-2.208 1.5-3.75\n                    1.5-1.541 3.667-1.541t3.687 1.479q1.521 1.479 1.521 3.604 0 1.375.938 2.312.937.938 2.312.938 1.334 0 2.25-.938.917-.937.917-2.312\n                    0-4.75-3.417-7.979-3.416-3.229-8.208-3.229-4.875 0-8.229 3.333-3.354 3.333-3.354 8.083 0 1.625.229 3.104.229 1.48.687\n                    2.771.167.5.042.834-.125.333-.5.458-.417.167-.812.021-.396-.146-.605-.646-.416-1.208-.708-2.875t-.292-3.667q0-5.541 3.979-9.52 3.98-3.98\n                    9.563-3.98 5.625 0 9.625 3.875t4 9.417q0 2.167-1.5 3.688-1.5 1.52-3.667 1.52-2.208 0-3.729-1.437-1.521-1.438-1.521-3.563\n                    0-1.375-.937-2.354-.938-.979-2.271-.979t-2.25.979q-.917.979-.917 2.354 0 4.125 2.292 6.98 2.292 2.854 6.792\n                    3.77.416.084.562.396.146.313.104.688-.125.416-.416.625-.292.208-.834.166ZM10.542 7.417q-.5.25-.854.146-.355-.105-.563-.438-.167-.25-.083-.708.083-.459.458-.625\n                    2.417-1.417 5.146-2.084 2.729-.666 5.479-.666t5.375.666q2.625.667 5.042 1.959.458.208.562.604.104.396-.062.687-.209.334-.563.542-.354.208-.771-.083-2.208-1.125-4.646-1.75-2.437-.625-4.937-.625-2.5 0-4.917.562-2.416.563-4.666 1.813Zm5\n                    29.083q-2.417-2.5-3.584-5.396-1.166-2.896-1.166-6.396 0-3.833 2.708-6.604t6.625-2.771q3.875 0 6.646 2.667t2.771 6.5q0 .458-.25.812-.25.355-.709.355-.5 0-.771-.355-.27-.354-.27-.812 0-3.083-2.167-5.146-2.167-2.062-5.25-2.062t-5.208\n                    2.166q-2.125 2.167-2.125 5.25 0 3.209 1 5.667 1 2.458 3.291 4.833.292.334.313.709.021.375-.188.625-.291.375-.812.333-.521-.042-.854-.375ZM29 33.75q-4.125 0-6.979-2.354t-2.854-6.813q0-.5.271-.791.27-.292.687-.292.458 0\n                    .729.292.271.291.271.791 0 3.625 2.313 5.417Q25.75 31.792 29 31.792q.417 0 .958-.063.542-.062 1-.104.417 0 .688.271.271.271.271.562-.042.459-.229.688-.188.229-.521.312-.5.209-1.125.25-.625.042-1.042.042Z" })], -1)), iu = { components: { StyledBtn: ic }, setup() {
          const e7 = lc(), t10 = yt2(false), n8 = (yt2({}), fn("errorHandler")), i10 = new yl(n8), r9 = yt2(null);
          return Yn(() => {
            r9.value = setInterval(() => {
              Sl.commit("switchPage", Ol.PAGE_LOGIN), Sl.commit("setRedirectURL", ""), Sl.commit("setSessionToken", "");
            }, 27e4);
          }), { cancel: (e8) => {
            e8.preventDefault(), null !== r9.value && clearTimeout(r9.value), window.location = Sl.state.user.redirectURL;
          }, passkeyAppend: (e8) => {
            e8.preventDefault(), null !== r9.value && clearTimeout(r9.value), t10.value = true, i10.Append(Sl.state.user.sessionToken).then((e9) => {
              window.location = e9;
            }).catch((e9) => {
              t10.value = false, e9.sessionToken ? window.location = Sl.state.user.redirectURL : ml.error("Append passkey failed", e9);
            });
          }, passkeyAppendLoading: t10, i18n: e7 };
        }, computed: { passkeyAppendTitle() {
          return Sl.state.webComponent.passkeyAppendTitle ?? this.i18n.$t("tired_of_passwords");
        }, passkeyAppendText() {
          return Sl.state.webComponent.passkeyAppendText ?? this.i18n.$t("login_faster");
        } } }, ru = (0, Fl.Z)(iu, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn");
          return Vi(), Ki("div", null, [rr("div", tu, [rr("h1", null, A5(o8.passkeyAppendTitle), 1), nu, rr("p", null, A5(o8.passkeyAppendText), 1)]), or(s10, { dataAction: "append_passkey", type: "primary", fullWidth: true, onClick: i10.passkeyAppend, isLoading: i10.passkeyAppendLoading }, { default: un(() => [ar(A5(i10.i18n.$t("activate")), 1)]), _: 1 }, 8, ["onClick", "isLoading"]), or(s10, { dataAction: "cancel", type: "secondary", fullWidth: true, onClick: i10.cancel }, { default: un(() => [ar(A5(i10.i18n.$t("maybe_later")), 1)]), _: 1 }, 8, ["onClick"])]);
        }], ["styles", ["\nsvg[data-v-20047e5c] {\n  margin-top: 0.3rem;\n}\n"]], ["__scopeId", "data-v-20047e5c"]]), ou = { class: "text-center" }, su = { class: "mt-8" }, au = { components: { StyledBtn: ic }, setup() {
          const e7 = yt2(""), t10 = fn("errorHandler"), n8 = new kl(t10), i10 = lc(), r9 = yt2(false), o8 = yt2(false), s10 = yt2(false);
          return { message: e7, emailLinkSvc: n8, i18n: i10, back: (e8) => {
            e8.preventDefault(), Sl.commit("switchPage", Ol.PAGE_LOGIN), Sl.commit("setCurrentLoginMethod", "");
          }, showBack: r9, showResend: o8, resendIsLoading: s10, resend: (e8) => {
            e8.preventDefault(), s10.value = true, n8.SignIn(Sl.state.user.username).then((e9) => {
              s10.value = false, ml.debug("Send email link", { username: Sl.state.user.username, emailLinkID: e9 }), Sl.commit("setEMailLinkIDPending", e9), Sl.commit("switchPage", Ol.PAGE_EMAIL_PENDING);
            }).catch((e9) => {
              s10.value = false, ml.error("Failed to resend email magic link", e9);
            });
          } };
        }, beforeMount() {
          const e7 = lc(), t10 = new URLSearchParams(window.location.search), n8 = Object.fromEntries(t10.entries());
          void 0 === n8.corbadoEmailLinkID || void 0 === n8.corbadoToken ? this.message = e7.$t("invalid_email_link") : (this.message = e7.$t("processing"), this.emailLinkSvc.Confirm(n8.corbadoEmailLinkID, n8.corbadoToken).then(({ redirectURL: e8, sessionToken: t11, authMethods: n9 }) => {
            Sl.state.browser.webauthnSupported && !n9.includes("webauthn") && Sl.state.projectConfig.showPasskeyAppend ? (Sl.commit("setSessionToken", t11), Sl.commit("setRedirectURL", e8), Sl.commit("switchPage", Ol.PAGE_APPEND_PASSKEY)) : window.location = e8;
          }).catch((t11) => {
            400 === t11.response.data.httpStatusCode ? ("" !== Sl.state.user.username ? (this.showBack = true, this.showResend = true) : (this.showResend = false, this.showBack = true), this.message = e7.$t("email_link_expired")) : this.message = "Login failed with " + t11.message;
          }));
        } }, lu = (0, Fl.Z)(au, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn");
          return Vi(), Ki(Zi, null, [rr("p", ou, A5(i10.message), 1), rr("div", su, [i10.showResend ? (Vi(), qi(s10, { key: 0, type: "primary", fullWidth: true, onClick: i10.resend, isLoading: i10.resendIsLoading }, { default: un(() => [ar(A5(i10.i18n.$t("resend_email")), 1)]), _: 1 }, 8, ["onClick", "isLoading"])) : cr("v-if", true), i10.showBack ? (Vi(), qi(s10, { key: 1, type: "secondary", fullWidth: true, onClick: i10.back, isLoading: false }, { default: un(() => [ar(A5(i10.i18n.$t("back")), 1)]), _: 1 }, 8, ["onClick"])) : cr("v-if", true)])], 64);
        }]]), cu = { components: { EmailLinkPending: Vc } }, uu = (0, Fl.Z)(cu, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("EmailLinkPending", true);
          return Vi(), qi(s10);
        }]]), du = { class: "heading text-center" }, Au = ["src"], gu = { class: "input-group" }, pu = { class: "text-small text-center" }, Mu = { components: { ErrorField: Jl, StyledBtn: ic, InputField: $l }, setup() {
          const e7 = lc(), t10 = fn("errorHandler"), n8 = yt2(false), i10 = yt2({}), r9 = yt2(vr(() => Sl.state.user.username).value), o8 = yt2(vr(() => Sl.state.user.userFullName).value), s10 = vr(() => Sl.state.projectConfig.userFullNameRequired), a8 = new yl(t10), l8 = new kl(t10), c9 = Sl.state.pages.companyImageUrl;
          return { signupHandler: (t11) => {
            t11.preventDefault(), n8.value = true, i10.value = {}, 0 === r9.value.trim().length && (i10.value = Object.assign({}, i10.value, { username: e7.$t("missing_username") })), 0 === o8.value.trim().length && s10.value && (i10.value = Object.assign({}, i10.value, { name: e7.$t("missing_full_name") }));
            let c10 = false;
            Object.keys(Sl.state.fields.validationRules).forEach((e8) => {
              false === (0, Sl.state.fields.validationRules[e8])() && (c10 = true);
            }), Object.keys(i10.value).length > 0 || c10 ? n8.value = false : (Sl.commit("setUsername", r9.value), Sl.state.browser.webauthnSupported ? (ml.debug("Initiate webauthn signup"), a8.SignUp(r9.value, o8.value).then((e8) => {
              ml.debug("Performed webauthn signup", { redirectURL: e8 }), n8.value = false, window.location = e8;
            }).catch((e8) => {
              null !== e8 && (n8.value = false, "NotAllowedError" === e8.name || "UnknownError" === e8.name ? (ml.debug("Webauthn signup failed", { err: e8 }), l8.SignIn(Sl.state.user.username).then((e9) => {
                ml.debug("Sent email link", { username: Sl.state.user.username, emailLinkID: e9 }), Sl.commit("setEMailLinkIDPending", e9), Sl.commit("switchPage", Ol.PAGE_EMAIL_PENDING), Sl.commit("setContext", "authentication_method_pending");
              }).catch((e9) => {
                null !== e9 && (i10.value = e9);
              })) : i10.value = e8);
            })) : l8.SignUp(r9.value, o8.value).then((e8) => {
              n8.value = false, ml.debug("Send email link", { username: r9.value, emailLinkID: e8 }), Sl.commit("setEMailLinkIDPending", e8), Sl.commit("switchPage", Ol.PAGE_EMAIL_PENDING);
            }).catch((e8) => {
              n8.value = false, null !== e8 && (i10.value = e8);
            }));
          }, signupLoading: n8, errorMessage: i10, switchPageLogin: (e8) => {
            e8.preventDefault(), Sl.commit("switchPage", Ol.PAGE_LOGIN);
          }, username: r9, name: o8, companyImageUrl: c9, i18n: e7, showUserFullName: s10 };
        }, computed: { pageTitle() {
          return Sl.state.webComponent.registerTitle ?? this.i18n.$t("sign_up");
        }, ButtonText() {
          return Sl.state.webComponent.registerBtn ?? this.i18n.$t("sign_up");
        } } }, fu = (0, Fl.Z)(Mu, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field"), a8 = qn("error-field"), l8 = qn("styled-btn");
          return Vi(), Ki("div", null, [rr("div", du, ["" !== i10.companyImageUrl ? (Vi(), Ki("img", { key: 0, src: i10.companyImageUrl, height: "40", style: { "margin-bottom": "20px", display: "inline-block" } }, null, 8, Au)) : cr("v-if", true), rr("h1", null, A5(o8.pageTitle), 1)]), rr("form", { onSubmit: t10[3] || (t10[3] = (...e8) => i10.signupHandler && i10.signupHandler(...e8)) }, [rr("div", gu, [i10.showUserFullName ? (Vi(), qi(s10, { key: 0, id: "name", type: "text", name: "name", label: i10.i18n.$t("name"), autocomplete: "name", modelValue: i10.name, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.name = e8), value: i10.name, errorMessage: i10.errorMessage.name }, null, 8, ["label", "modelValue", "value", "errorMessage"])) : cr("v-if", true), or(s10, { id: "username", type: "email", name: "username", autocomplete: "email", label: i10.i18n.$t("email_address"), modelValue: i10.username, "onUpdate:modelValue": t10[1] || (t10[1] = (e8) => i10.username = e8), value: i10.username, errorMessage: i10.errorMessage.username }, null, 8, ["label", "modelValue", "value", "errorMessage"]), ri(e7.$slots, "signupFields")]), void 0 !== i10.errorMessage.global ? (Vi(), qi(a8, { key: 0, errorMessage: i10.errorMessage.global }, null, 8, ["errorMessage"])) : cr("v-if", true), or(l8, { type: "primary", dataAction: "sign_up", fullWidth: true, onClick: i10.signupHandler, isLoading: i10.signupLoading }, { default: un(() => [ar(A5(o8.ButtonText), 1)]), _: 1 }, 8, ["onClick", "isLoading"]), rr("p", pu, [ar(A5(i10.i18n.$t("already_have_account")) + " ", 1), rr("span", { class: "link", onClick: t10[2] || (t10[2] = (...e8) => i10.switchPageLogin && i10.switchPageLogin(...e8)), "data-action": "switch_to_login" }, A5(i10.i18n.$t("sign_in_instead")), 1)])], 32)]);
        }], ["styles", ["\n.btn-wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n  justify-content: center;\n}\n@media screen and (min-width: 576px) {\n.btn-wrapper {\n    flex-direction: row;\n}\n}\n\n"]]]), mu = { sign_up: "Sign up", name: "Name", already_have_account: "You already have an account?", sign_in_instead: "Sign in.", missing_username: "Please enter a username", missing_full_name: "Please enter a name", login: "Login", back: "Back", welcome_back: "Welcome back! Please enter your details", continue: "Continue", email_address: "Email address", dont_have_account: "Don't have an account yet?", email_magic_link: "Email magic link", open_gmail: "Open in Gmail", open_yahoo: "Open in Yahoo", open_outlook: "Open in Outlook", resend_email: "Send email again", resend_countdown: "Send email again ({{sec}} sec)", cancel: "Cancel", check_inbox: "Check your email", other_login_options: "Other login options", login_passwordless: "Login passwordless with", continue_with_biometric_method: "Continue with", password: "Password", activate: "Activate", login_faster: "Login even faster with Touch ID, Face ID or PIN", maybe_later: "Maybe later", tired_of_passwords: "Tired of passwords?", account_not_confirmed: 'It seems like your account has not been confirmed. Please check the mail sent to <span class="username">[username]</span>.', email_was_sent_to: 'An email was sent to <span class="username">[username]</span>.', invalid_email_link: "Invalid link. Please copy the link from email.", processing: "Processing...", email_link_expired: "Your email magic link has expired or is invalid.", passkey_cancelled: 'Unable to login with your passkey. Please login with the email magic link sent to <span class="username">[username]</span>.', passkey_deleted: 'Your selected passkey has been deleted from the server. To still access your account, use another passkey or click on the magic link we just sent to <span class="username">[username]</span> to log in.', passkey_deleted_headline: "Selected passkey has been deleted", connectionTimeout: "There was a timeout between you and our server. Please try again later.", tooManyRequests: "You generated too many requests. Please try again later.", showDetails: "Show details", hideDetails: "Hide details", invalid_logintoken_link: "Could not find logintoken in the current url.", logintoken_link_expired: "Your logintoken is either expired or not existing." }, hu = { sign_up: "Registrieren", name: "Name", already_have_account: "Haben Sie schon ein Konto?", sign_in_instead: "Anmelden.", missing_username: "Bitte geben Sie den Benutzernamen an", missing_full_name: "Bitte geben Sie den Namen an", login: "Login", back: "Zur\xFCck", welcome_back: "Willkommen! Bitte geben Sie Ihre Zugangsdaten ein", continue: "Weiter", email_address: "E-Mail-Adresse", dont_have_account: "Sie haben noch kein Konto?", email_magic_link: "E-Mail Magic Link", open_gmail: "In Gmail \xF6ffnen", open_yahoo: "In Yahoo \xF6ffnen", open_outlook: "In Outlook \xF6ffnen", resend_email: "E-Mail erneut senden", resend_countdown: "E-Mail erneut senden ({{sec}} Sek)", cancel: "Abbrechen", check_inbox: "Bitte \xFCberpr\xFCfen Sie Ihren Posteingang", other_login_options: "Weitere M\xF6glichkeiten zum Einloggen", login_passwordless: "Ohne Passwort einloggen per:", continue_with_biometric_method: "Weiter mit", password: "Passwort", activate: "Aktivieren", login_faster: "Loggen Sie sich noch schneller mit Touch ID, Face ID oder PIN ein", maybe_later: "Vielleicht sp\xE4ter", tired_of_passwords: "Schon wieder ein Passwort?", account_not_confirmed: 'Es scheint, dass Ihr Konto noch nicht best\xE4tigt wurde. Bitte \xFCberpr\xFCfen Sie Ihren Posteingang <span class="username">[username]</span>.', email_was_sent_to: 'Eine E-Mail wurde verschickt an <span class="username">[username]</span>.', invalid_email_link: "Ung\xFCltiger Link. Bitte kopieren Sie den Link aus der E-Mail.", processing: "Verarbeiten...", email_link_expired: "Der Link ist ung\xFCltig oder abgelaufen.", passkey_cancelled: 'Login mit Passkey nicht m\xF6glich. Bitte mit dem E-Mail Magic Link einloggen, der an folgende E-Mail-Adresse geschickt wurde <span class="username">[username]</span>.', passkey_deleted: 'Der gew\xE4hlte Passkey wurde vom Server gel\xF6scht. Um weiterhin auf dein Konto zuzugreifen, verwende einen anderen Passkey oder melde dich mit dem Email Magic Link an, den wir gerade an <span class="username">[username]</span> gesendet haben.', passkey_deleted_headline: "Gew\xE4hlter Passkeys wurde gel\xF6scht", connectionTimeout: "Ihre Verbindung zum Server wurde unterbrochen. Probieren Sie es sp\xE4ter erneut.", tooManyRequests: "Sie haben zu viele Anfragen gestellt. Bitte probieren Sie es sp\xE4ter erneut.", showDetails: "Zeige details", hideDetails: "Details ausblenden", invalid_logintoken_link: "Der Logintoken konnte nicht aus der Adresse gelesen werden.", logintoken_link_expired: "Der Logintoken ist ung\xFCltig oder wurde bereits eingel\xF6st." }, yu = { sign_up: "S'inscrire", name: "Nom", already_have_account: "Vous avez d\xE9j\xE0 un compte?", sign_in_instead: "Connectez-vous.", missing_username: "Merci d'entrer un nom d'utilisateur", missing_full_name: "Veuillez entrer un nom", login: "Se connecter", back: "Retour", welcome_back: "Bienvenue! Veuillez entrer votre adresse e-mail", continue: "Continuer", email_address: "Adresse e-mail", dont_have_account: "Vous n'avez pas de compte?", email_magic_link: "Lien magique par e-mail", open_gmail: "Ouvrir dans Gmail", open_yahoo: "Ouvrir dans Yahoo", open_outlook: "Ouvrir dans Outlook", resend_email: "Renvoyer l'e-mail", resend_countdown: "Renvoyer l'e-mail ({{sec}} sec)", cancel: "Annuler", check_inbox: "Veuillez v\xE9rifier votre bo\xEEte de r\xE9ception", other_login_options: "Autres options de connexion", login_passwordless: "Se connecter sans mot de passe via:", continue_with_biometric_method: "Continuer avec", password: "Mot de passe", activate: "Activer", login_faster: "Connectez-vous plus rapidement avec Touch ID, Face ID ou un code PIN", maybe_later: "Peut-\xEAtre plus tard", tired_of_passwords: "Encore un mot de passe?", account_not_confirmed: `Il semble que votre compte n'ait pas encore \xE9t\xE9 confirm\xE9. Veuillez v\xE9rifier votre bo\xEEte de r\xE9ception <span class="username">[username]</span>.`, email_was_sent_to: 'Un e-mail a \xE9t\xE9 envoy\xE9 \xE0 <span class="username">[username]</span>.', invalid_email_link: "Lien invalide. Veuillez copier le lien depuis l'e-mail.", processing: "Traitement...", email_link_expired: "Le lien est invalide ou a expir\xE9.", passkey_cancelled: `Connexion avec le code d'acc\xE8s impossible. Veuillez vous connecter avec le lien magique par e-mail envoy\xE9 \xE0 l'adresse suivante <span class="username">[username]</span>.`, passkey_deleted: `Le passkey que vous avez choisi a \xE9t\xE9 supprim\xE9 du serveur. Pour continuer \xE0 acc\xE9der \xE0 votre compte, utilisez un autre passkey ou cliquez sur le lien magique que nous venons d'envoyer \xE0 <span class="username">[username]</span> pour vous connecter.`, passkey_deleted_headline: "Le passkey s\xE9lectionn\xE9 a \xE9t\xE9 supprim\xE9", connectionTimeout: "Votre connexion au serveur a \xE9t\xE9 interrompue. Veuillez r\xE9essayer plus tard.", tooManyRequests: "Vous avez fait trop de demandes. Veuillez r\xE9essayer plus tard.", showDetails: "Afficher les d\xE9tails", hideDetails: "Masquer les d\xE9tails", invalid_logintoken_link: "Le jeton de connexion ne peut pas \xEAtre lu depuis l'adresse.", logintoken_link_expired: "Le jeton de connexion est invalide ou a d\xE9j\xE0 \xE9t\xE9 utilis\xE9." }, Iu = (e7) => (ln("data-v-046d03e3"), e7 = e7(), cn2(), e7), wu = { key: 0, class: "error-handler" }, Nu = { key: 0 }, ju = { class: "headline" }, bu = { class: "row" }, Du = Iu(() => rr("div", { class: "col-xs-3" }, " Message: ", -1)), xu = ["href"], Lu = { key: 1 }, vu = { key: 0, class: "row" }, Tu = Iu(() => rr("div", { class: "col-xs-3" }, " Type: ", -1)), zu = { class: "col-xs-9" }, Cu = { class: "row" }, Su = { key: 0, class: "col-xs-3" }, Eu = ["href"], ku = Iu(() => rr("br", null, null, -1)), Ou = { key: 1, class: "row" }, Pu = Iu(() => rr("div", { class: "col-xs-3" }, " RequestID: ", -1)), Uu = { class: "col-xs-9" }, Qu = ["href"], Ru = Iu(() => rr("span", { id: "details" }, " See browser console for more details ", -1)), Yu = { key: 1, id: "info", style: { display: "flex", "align-items": "center" } }, Zu = Iu(() => rr("span", null, "Error only shown because project is in development mode!", -1)), Bu = { key: 2, class: "error-message" }, Wu = Iu(() => rr("br", null, null, -1)), Gu = Iu(() => rr("br", null, null, -1)), Hu = Iu(() => rr("br", null, null, -1)), _u = Iu(() => rr("br", null, null, -1)), Vu = Iu(() => rr("br", null, null, -1)), Fu = [rr("p", null, [ar(" It seems like you have set up "), rr("a", { href: "https://docs.corbado.com/helpful-guides/webhooks", target: "_blank" }, "Corbado webhooks"), ar(" to make Corbado exchange user information with your backend. ")], -1), rr("p", null, [ar(" Unfortunately, your backend is not reachable or the "), rr("a", { href: "https://docs.corbado.com/helpful-guides/corbado-cli", target: "_blank" }, "Corbado CLI"), ar(" is not set up correctly (e.g. when you're testing locally). ")], -1), rr("p", null, [ar(" Please remove webhooks URL, webhooks username and webhooks password in the "), rr("a", { href: "https://app.corbado.com/app/settings/webhooks" }, "developer panel"), ar(" if you don't have existing users in your backend that you need to connect to Corbado (e.g. you're building an entirely new application). ")], -1)], Ju = {}, Xu = ["width", "height", "viewBox"], Ku = ["d"], qu = { mdi: { size: 24, viewbox: "0 0 24 24" }, "simple-icons": { size: 24, viewbox: "0 0 24 24" }, default: { size: 0, viewbox: "0 0 0 0" } }, $u = { name: "icon", props: { type: String, path: { type: String, required: true }, size: { type: [String, Number], default: 24 }, viewbox: String, flip: { type: String, validator: (e7) => ["horizontal", "vertical", "both", "none"].includes(e7) }, rotate: { type: Number, default: 0 } }, computed: { styles() {
          return { "--sx": ["both", "horizontal"].includes(this.flip) ? "-1" : "1", "--sy": ["both", "vertical"].includes(this.flip) ? "-1" : "1", "--r": isNaN(this.rotate) ? this.rotate : this.rotate + "deg" };
        }, defaults() {
          return qu[this.type] || qu.default;
        }, sizeValue() {
          return this.size || this.defaults.size;
        }, viewboxValue() {
          return this.viewbox || this.defaults.viewbox;
        } } }, ed = { name: "ErrorHandler", components: { WebhookError: (0, Fl.Z)(Ju, [["render", function(e7, t10) {
          return Vi(), Ki("div", null, Fu);
        }]]), StyledBtn: ic, SvgIcon: (0, Fl.Z)($u, [["render", function(e7, t10, n8, i10, r9, s10) {
          return Vi(), Ki("svg", { width: s10.sizeValue, height: s10.sizeValue, viewBox: s10.viewboxValue, style: o7(s10.styles) }, [rr("path", { d: n8.path }, null, 8, Ku)], 12, Xu);
        }], ["styles", ["\nsvg[data-v-8dea8908] {\r\n	transform: rotate(var(--r, 0deg)) scale(var(--sx, 1), var(--sy, 1));\n}\npath[data-v-8dea8908] {\r\n	fill: currentColor;\n}\r\n"]], ["__scopeId", "data-v-8dea8908"]]) }, setup() {
          const e7 = fn("errorHandler"), t10 = function(e8) {
            let t11 = fn(sc);
            return t11 || (t11 = ac(e8)), t11;
          }(yt2({ locale: "en", messages: { en: mu, de: hu, fr: yu } })), n8 = vr(() => e7.value.errorMessage), i10 = vr(() => e7.value.errorLinks), r9 = vr(() => e7.value.errorRequestLink), o8 = vr(() => e7.value.errorRequestID), s10 = vr(() => e7.value.errorSide), a8 = vr(() => e7.value.errorType), l8 = vr(() => (console.log(e7.value.forceShowError), e7.value.forceShowError)), c9 = vr(() => e7.value.errorDetailLink), u7 = yt2(false), d7 = vr(() => "" !== e7.value.errorMessage || u7.value), A6 = yt2({ message: true, link: true });
          Fn((e8) => (ml.error("Fetched error", e8), u7.value = true, false));
          const g8 = vr(() => Sl.state.projectConfig.environment);
          return { showError: d7, errorStore: n8, errorRequestID: o8, store: Sl, i18n: t10, errorLinks: i10, errorRequestLink: r9, errorSide: s10, errorType: a8, environment: g8, mdiContentCopy: "M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z", mdiInformationOutline: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", mdiAlertCircleOutline: "M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z", copyRequestID: () => {
            navigator.clipboard.writeText(o8.value);
          }, showAll: (e8) => {
            A6.value[e8] = false;
          }, showTruncatedData: A6, forceShowError: l8, errorDetailLink: c9 };
        } }, td = (0, Fl.Z)(ed, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("svg-icon");
          return i10.showError ? (Vi(), Ki("div", wu, ["dev" === i10.environment || i10.forceShowError ? (Vi(), Ki("div", Nu, [rr("h3", ju, " Integration error (" + A5(i10.errorSide) + " side) ", 1), rr("div", bu, [Du, rr("div", { class: c8(i10.showTruncatedData.message ? ["col-xs-9", "truncate"] : ["col-xs-9"]), onClick: t10[0] || (t10[0] = (e8) => i10.showAll("message")) }, ["" !== i10.errorDetailLink ? (Vi(), Ki("a", { key: 0, href: i10.errorDetailLink, target: "_blank", class: "link" }, A5(i10.errorStore), 9, xu)) : (Vi(), Ki("span", Lu, A5(i10.errorStore), 1))], 2)]), "" !== i10.errorType ? (Vi(), Ki("div", vu, [Tu, rr("div", zu, A5(i10.errorType), 1)])) : cr("v-if", true), rr("div", Cu, [i10.errorLinks.length > 0 ? (Vi(), Ki("div", Su, " Links: ")) : cr("v-if", true), rr("div", { class: c8(["col-xs-9 truncate", i10.showTruncatedData.link ? ["col-xs-9", "truncate"] : ["col-xs-9"]]), onClick: t10[1] || (t10[1] = (e8) => i10.showAll("link")) }, [(Vi(true), Ki(Zi, null, ii(i10.errorLinks, (e8) => (Vi(), Ki(Zi, null, [rr("a", { class: "link", href: e8, target: "_blank" }, A5(e8), 9, Eu), ku], 64))), 256))], 2)]), "" !== i10.errorRequestID ? (Vi(), Ki("div", Ou, [Pu, rr("div", Uu, [rr("a", { class: "link", href: i10.errorRequestLink, target: "_blank" }, A5(i10.errorRequestID), 9, Qu), ar(), or(s10, { onClick: i10.copyRequestID, style: { "vertical-align": "text-top", cursor: "pointer" }, type: "mdi", size: "14", path: i10.mdiContentCopy }, null, 8, ["onClick", "path"])])])) : cr("v-if", true), Ru])) : cr("v-if", true), "dev" === i10.environment || i10.forceShowError ? (Vi(), Ki("p", Yu, [or(s10, { type: "mdi", size: "28", style: { "vertical-align": "text-top", "margin-right": "5px" }, path: i10.mdiInformationOutline }, null, 8, ["path"]), Zu])) : cr("v-if", true), "prod" !== i10.environment || i10.forceShowError ? cr("v-if", true) : (Vi(), Ki("div", Bu, [or(s10, { type: "mdi", style: { "vertical-align": "text-top" }, size: "48", path: i10.mdiAlertCircleOutline }, null, 8, ["path"]), Wu, Gu, ar(" An error occurred."), Hu, ar(" Please try again later."), _u, Vu, "" !== i10.errorRequestID ? (Vi(), Ki(Zi, { key: 0 }, [ar("RequestID: " + A5(i10.errorRequestID), 1)], 64)) : cr("v-if", true)]))])) : ri(e7.$slots, "default", { key: 1 }, void 0, true);
        }], ["styles", ["\na[data-v-046d03e3], .link[data-v-046d03e3] {\n  text-decoration: underline;\n  font-weight: normal;\n  color: #ff0000;\n  cursor: pointer;\n}\n.col-xs-3[data-v-046d03e3] {\n  padding-right: 3px;\n}\n.col-xs-9[data-v-046d03e3] {\n  padding-left: 3px;\n}\n.truncate[data-v-046d03e3] {\n  width: 250px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.error-handler[data-v-046d03e3] {\n  background-color: #fae4ab;\n  border: 2px solid #ff0000;\n  font-size: 14px;\n  color: #ff0000;\n  min-height: 245px;\n  position: relative;\n  padding-bottom: 50px;\n  max-width: 30rem;\n}\n.headline[data-v-046d03e3] {\n  background-color: #f00;\n  padding: 0.5rem 1.3rem;\n  color: #fff;\n  font-size: 16px;\n  margin: 0 0 0.8rem;\n}\n.row div[data-v-046d03e3]:first-child {\n  text-align: right;\n  color: #936c3e;\n  font-weight: bold;\n}\n.row[data-v-046d03e3] {\n  margin-bottom: 0.5rem;\n}\n.row div[data-v-046d03e3] {\n  color: #ff0000;\n}\n#details[data-v-046d03e3] {\n  display: block;\n  color: #ff0000;\n  margin: 1rem auto;\n  border: 2px solid #ff0000;\n  width: 250px;\n  font-weight: bold;\n  padding: 10px 15px;\n}\n#info[data-v-046d03e3] {\n  color: #936c3e;\n  font-size: 12px;\n  padding: 0 10px;\n  position: absolute;\n  bottom: 0;\n}\n.error-message[data-v-046d03e3] {\n  font-size: 18px;\n  color: #ff0000;\n  text-align: center;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 30px;\n}\n\n\n"]], ["__scopeId", "data-v-046d03e3"]]), nd = { class: "text-center" }, id = rr("h1", { style: { "font-size": "28px" } }, "Connection timed out", -1), rd = rr("br", null, null, -1), od = rr("br", null, null, -1), sd = rr("p", null, " Please try again later. ", -1), ad = { components: { StyledBtn: ic }, setup() {
          const e7 = lc(), t10 = fn("errorHandler");
          return { i18n: e7, backBtn: () => {
            Sl.commit("switchPage", Ol.PAGE_LOGIN), t10.resetError();
          }, url: aa.defaults.baseURL };
        } }, ld = (0, Fl.Z)(ad, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn");
          return Vi(), Ki(Zi, null, [rr("div", nd, [id, rr("p", null, [ar(" This site cannot be reached"), rd, ar(" because the server at " + A5(i10.url), 1), od, ar(" is taking too long to respond. ")]), sd]), or(s10, { onClick: i10.backBtn, "data-action": "back", isLoading: false }, { default: un(() => [ar(A5(i10.i18n.$t("back")), 1)]), _: 1 }, 8, ["onClick"])], 64);
        }], ["styles", ["\n.underline, .underline:active, .underline:hover, .underline:visited {\n  text-decoration: underline;\n  font-weight: normal;\n  color: currentColor;\n}\n"]]]), cd = rr("div", { class: "text-center" }, [rr("h1", null, "Too many requests"), rr("p", null, [ar(" We have lost the connection to the"), rr("br"), ar(" server due to many requests"), rr("br"), ar(" from your account. ")]), rr("p", null, [ar(" Please try again later or go to "), rr("a", { class: "underline", href: "https://api.corbado.com/docs/api/#section/Error-types/rate_limited" }, "docs"), rr("br"), ar(" for more information. ")])], -1), ud = { components: { StyledBtn: ic }, setup() {
          const e7 = lc(), t10 = fn("errorHandler");
          return { i18n: e7, backBtn: () => {
            Sl.commit("switchPage", Ol.PAGE_LOGIN), t10.resetError();
          } };
        } }, dd = (0, Fl.Z)(ud, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn");
          return Vi(), Ki(Zi, null, [cd, or(s10, { onClick: i10.backBtn, "data-action": "back", isLoading: false }, { default: un(() => [ar(A5(i10.i18n.$t("back")), 1)]), _: 1 }, 8, ["onClick"])], 64);
        }], ["styles", ["\n.underline, .underline:active, .underline:hover, .underline:visited {\n  text-decoration: underline;\n  font-weight: normal;\n  color: currentColor;\n}\n"]]]), Ad = { class: "text-center" }, gd = class {
          _filterUndefined = (e7) => {
            const t10 = {};
            return Object.keys(e7).forEach((n8) => {
              void 0 !== e7[n8] && (t10[n8] = e7[n8]);
            }), t10;
          };
          _errorMessage = "";
          _errorDetailLink = "";
          _errorLinks = "";
          _errorRequestLink = "";
          _errorRequestID = "";
          _errorSide = "";
          _errorType = "";
          _forceShowError = "";
          set error({ message: e7, detailLink: t10, requestID: n8, requestLink: i10, links: r9, errorSide: o8, errorType: s10, forceShowError: a8 }) {
            ml.error(e7, this._filterUndefined({ detailLink: t10, requestID: n8, requestLink: i10, links: r9, errorSide: o8, errorType: s10 })), this._errorMessage = e7, this._errorDetailLink = t10 ?? "", this._errorRequestLink = i10 ?? "", this._errorLinks = r9 ?? [], this._errorRequestID = n8 ?? "", this._errorSide = o8 ?? "server", this._errorType = s10 ?? "", this._forceShowError = a8 ?? false, console.log(this);
          }
          resetError() {
            this._errorMessage = "", this._errorDetailLink = "", this._errorRequestID = "", this._errorRequestLink = "", this._errorLinks = [], this._errorSide = "", this._errorType = "", this._forceShowError = false;
          }
          get errorMessage() {
            return this._errorMessage;
          }
          get errorDetailLink() {
            return this._errorDetailLink;
          }
          get errorLinks() {
            return this._errorLinks;
          }
          get errorRequestLink() {
            return this._errorRequestLink;
          }
          get errorRequestID() {
            return this._errorRequestID;
          }
          get errorSide() {
            return this._errorSide;
          }
          get errorType() {
            return this._errorType;
          }
          get forceShowError() {
            return this._forceShowError;
          }
        }, pd = { setup() {
          const e7 = yt2(""), t10 = yt2(new gd());
          return Mn("errorHandler", t10), { message: e7, userSvc: new $a(t10), i18n: lc() };
        }, beforeMount() {
          const e7 = lc(), t10 = new URLSearchParams(window.location.search), n8 = Object.fromEntries(t10.entries());
          void 0 === n8.corbadoLoginToken ? this.message = e7.$t("invalid_logintoken_link") : (this.message = e7.$t("processing"), this.userSvc.LoginToken(n8.corbadoLoginToken).then(({ redirectURL: e8, sessionToken: t11, authMethods: n9 }) => {
            Sl.state.browser.webauthnSupported && !n9.includes("webauthn") && Sl.state.projectConfig.showPasskeyAppend ? (Sl.commit("setSessionToken", t11), Sl.commit("setRedirectURL", e8), Sl.commit("switchPage", Ol.PAGE_APPEND_PASSKEY)) : window.location = e8;
          }).catch((t11) => {
            400 === t11.response?.data?.httpStatusCode ? this.message = e7.$t("logintoken_link_expired") : this.message = "Login failed with " + t11.message;
          }));
        } }, Md = (0, Fl.Z)(pd, [["render", function(e7, t10, n8, i10, r9, o8) {
          return Vi(), Ki("p", Ad, A5(i10.message), 1);
        }]]), fd = {}, md = (0, Fl.Z)(fd, [["render", function(e7, t10) {
          return ri(e7.$slots, "default");
        }], ["styles", ["\n.container {\n  min-height: 295px;\n}\n.container-fluid,\n.container {\n  margin-right: auto;\n  margin-left: auto;\n}\n.container-fluid {\n  padding-right: 2rem;\n  padding-left: 2rem;\n}\n.row {\n  box-sizing: border-box;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 0;\n  -ms-flex: 0 1 auto;\n  flex: 0 1 auto;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  -ms-flex-direction: row;\n  flex-direction: row;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n  margin-right: -0.5rem;\n  margin-left: -0.5rem;\n}\n.row.reverse {\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: reverse;\n  -ms-flex-direction: row-reverse;\n  flex-direction: row-reverse;\n}\n.col.reverse {\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: reverse;\n  -ms-flex-direction: column-reverse;\n  flex-direction: column-reverse;\n}\n.col-xs,\n.col-xs-1,\n.col-xs-2,\n.col-xs-3,\n.col-xs-4,\n.col-xs-5,\n.col-xs-6,\n.col-xs-7,\n.col-xs-8,\n.col-xs-9,\n.col-xs-10,\n.col-xs-11,\n.col-xs-12,\n.col-xs-offset-0,\n.col-xs-offset-1,\n.col-xs-offset-2,\n.col-xs-offset-3,\n.col-xs-offset-4,\n.col-xs-offset-5,\n.col-xs-offset-6,\n.col-xs-offset-7,\n.col-xs-offset-8,\n.col-xs-offset-9,\n.col-xs-offset-10,\n.col-xs-offset-11,\n.col-xs-offset-12 {\n  box-sizing: border-box;\n  -webkit-box-flex: 0;\n  -ms-flex: 0 0 auto;\n  flex: 0 0 auto;\n  padding-right: 0.5rem;\n  padding-left: 0.5rem;\n}\n.col-xs {\n  -webkit-box-flex: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -ms-flex-preferred-size: 0;\n  flex-basis: 0;\n  max-width: 100%;\n}\n.col-xs-1 {\n  -ms-flex-preferred-size: 8.33333333%;\n  flex-basis: 8.33333333%;\n  max-width: 8.33333333%;\n}\n.col-xs-2 {\n  -ms-flex-preferred-size: 16.66666667%;\n  flex-basis: 16.66666667%;\n  max-width: 16.66666667%;\n}\n.col-xs-3 {\n  -ms-flex-preferred-size: 25%;\n  flex-basis: 25%;\n  max-width: 25%;\n}\n.col-xs-4 {\n  -ms-flex-preferred-size: 33.33333333%;\n  flex-basis: 33.33333333%;\n  max-width: 33.33333333%;\n}\n.col-xs-5 {\n  -ms-flex-preferred-size: 41.66666667%;\n  flex-basis: 41.66666667%;\n  max-width: 41.66666667%;\n}\n.col-xs-6 {\n  -ms-flex-preferred-size: 50%;\n  flex-basis: 50%;\n  max-width: 50%;\n}\n.col-xs-7 {\n  -ms-flex-preferred-size: 58.33333333%;\n  flex-basis: 58.33333333%;\n  max-width: 58.33333333%;\n}\n.col-xs-8 {\n  -ms-flex-preferred-size: 66.66666667%;\n  flex-basis: 66.66666667%;\n  max-width: 66.66666667%;\n}\n.col-xs-9 {\n  -ms-flex-preferred-size: 75%;\n  flex-basis: 75%;\n  max-width: 75%;\n}\n.col-xs-10 {\n  -ms-flex-preferred-size: 83.33333333%;\n  flex-basis: 83.33333333%;\n  max-width: 83.33333333%;\n}\n.col-xs-11 {\n  -ms-flex-preferred-size: 91.66666667%;\n  flex-basis: 91.66666667%;\n  max-width: 91.66666667%;\n}\n.col-xs-12 {\n  -ms-flex-preferred-size: 100%;\n  flex-basis: 100%;\n  max-width: 100%;\n}\n.col-xs-offset-0 {\n  margin-left: 0;\n}\n.col-xs-offset-1 {\n  margin-left: 8.33333333%;\n}\n.col-xs-offset-2 {\n  margin-left: 16.66666667%;\n}\n.col-xs-offset-3 {\n  margin-left: 25%;\n}\n.col-xs-offset-4 {\n  margin-left: 33.33333333%;\n}\n.col-xs-offset-5 {\n  margin-left: 41.66666667%;\n}\n.col-xs-offset-6 {\n  margin-left: 50%;\n}\n.col-xs-offset-7 {\n  margin-left: 58.33333333%;\n}\n.col-xs-offset-8 {\n  margin-left: 66.66666667%;\n}\n.col-xs-offset-9 {\n  margin-left: 75%;\n}\n.col-xs-offset-10 {\n  margin-left: 83.33333333%;\n}\n.col-xs-offset-11 {\n  margin-left: 91.66666667%;\n}\n.start-xs {\n  -webkit-box-pack: start;\n  -ms-flex-pack: start;\n  justify-content: flex-start;\n  text-align: start;\n}\n.center-xs {\n  -webkit-box-pack: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  text-align: center;\n}\n.end-xs {\n  -webkit-box-pack: end;\n  -ms-flex-pack: end;\n  justify-content: flex-end;\n  text-align: end;\n}\n.top-xs {\n  -webkit-box-align: start;\n  -ms-flex-align: start;\n  align-items: flex-start;\n}\n.middle-xs {\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.bottom-xs {\n  -webkit-box-align: end;\n  -ms-flex-align: end;\n  align-items: flex-end;\n}\n.around-xs {\n  -ms-flex-pack: distribute;\n  justify-content: space-around;\n}\n.between-xs {\n  -webkit-box-pack: justify;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n}\n.first-xs {\n  -webkit-box-ordinal-group: 0;\n  -ms-flex-order: -1;\n  order: -1;\n}\n.last-xs {\n  -webkit-box-ordinal-group: 2;\n  -ms-flex-order: 1;\n  order: 1;\n}\n@media only screen and (min-width: 48em) {\n.col-sm,\n  .col-sm-1,\n  .col-sm-2,\n  .col-sm-3,\n  .col-sm-4,\n  .col-sm-5,\n  .col-sm-6,\n  .col-sm-7,\n  .col-sm-8,\n  .col-sm-9,\n  .col-sm-10,\n  .col-sm-11,\n  .col-sm-12,\n  .col-sm-offset-0,\n  .col-sm-offset-1,\n  .col-sm-offset-2,\n  .col-sm-offset-3,\n  .col-sm-offset-4,\n  .col-sm-offset-5,\n  .col-sm-offset-6,\n  .col-sm-offset-7,\n  .col-sm-offset-8,\n  .col-sm-offset-9,\n  .col-sm-offset-10,\n  .col-sm-offset-11,\n  .col-sm-offset-12 {\n    box-sizing: border-box;\n    -webkit-box-flex: 0;\n    -ms-flex: 0 0 auto;\n    flex: 0 0 auto;\n    padding-right: 0.5rem;\n    padding-left: 0.5rem;\n}\n.col-sm {\n    -webkit-box-flex: 1;\n    -ms-flex-positive: 1;\n    flex-grow: 1;\n    -ms-flex-preferred-size: 0;\n    flex-basis: 0;\n    max-width: 100%;\n}\n.col-sm-1 {\n    -ms-flex-preferred-size: 8.33333333%;\n    flex-basis: 8.33333333%;\n    max-width: 8.33333333%;\n}\n.col-sm-2 {\n    -ms-flex-preferred-size: 16.66666667%;\n    flex-basis: 16.66666667%;\n    max-width: 16.66666667%;\n}\n.col-sm-3 {\n    -ms-flex-preferred-size: 25%;\n    flex-basis: 25%;\n    max-width: 25%;\n}\n.col-sm-4 {\n    -ms-flex-preferred-size: 33.33333333%;\n    flex-basis: 33.33333333%;\n    max-width: 33.33333333%;\n}\n.col-sm-5 {\n    -ms-flex-preferred-size: 41.66666667%;\n    flex-basis: 41.66666667%;\n    max-width: 41.66666667%;\n}\n.col-sm-6 {\n    -ms-flex-preferred-size: 50%;\n    flex-basis: 50%;\n    max-width: 50%;\n}\n.col-sm-7 {\n    -ms-flex-preferred-size: 58.33333333%;\n    flex-basis: 58.33333333%;\n    max-width: 58.33333333%;\n}\n.col-sm-8 {\n    -ms-flex-preferred-size: 66.66666667%;\n    flex-basis: 66.66666667%;\n    max-width: 66.66666667%;\n}\n.col-sm-9 {\n    -ms-flex-preferred-size: 75%;\n    flex-basis: 75%;\n    max-width: 75%;\n}\n.col-sm-10 {\n    -ms-flex-preferred-size: 83.33333333%;\n    flex-basis: 83.33333333%;\n    max-width: 83.33333333%;\n}\n.col-sm-11 {\n    -ms-flex-preferred-size: 91.66666667%;\n    flex-basis: 91.66666667%;\n    max-width: 91.66666667%;\n}\n.col-sm-12 {\n    -ms-flex-preferred-size: 100%;\n    flex-basis: 100%;\n    max-width: 100%;\n}\n.col-sm-offset-0 {\n    margin-left: 0;\n}\n.col-sm-offset-1 {\n    margin-left: 8.33333333%;\n}\n.col-sm-offset-2 {\n    margin-left: 16.66666667%;\n}\n.col-sm-offset-3 {\n    margin-left: 25%;\n}\n.col-sm-offset-4 {\n    margin-left: 33.33333333%;\n}\n.col-sm-offset-5 {\n    margin-left: 41.66666667%;\n}\n.col-sm-offset-6 {\n    margin-left: 50%;\n}\n.col-sm-offset-7 {\n    margin-left: 58.33333333%;\n}\n.col-sm-offset-8 {\n    margin-left: 66.66666667%;\n}\n.col-sm-offset-9 {\n    margin-left: 75%;\n}\n.col-sm-offset-10 {\n    margin-left: 83.33333333%;\n}\n.col-sm-offset-11 {\n    margin-left: 91.66666667%;\n}\n.start-sm {\n    -webkit-box-pack: start;\n    -ms-flex-pack: start;\n    justify-content: flex-start;\n    text-align: start;\n}\n.center-sm {\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    text-align: center;\n}\n.end-sm {\n    -webkit-box-pack: end;\n    -ms-flex-pack: end;\n    justify-content: flex-end;\n    text-align: end;\n}\n.top-sm {\n    -webkit-box-align: start;\n    -ms-flex-align: start;\n    align-items: flex-start;\n}\n.middle-sm {\n    -webkit-box-align: center;\n    -ms-flex-align: center;\n    align-items: center;\n}\n.bottom-sm {\n    -webkit-box-align: end;\n    -ms-flex-align: end;\n    align-items: flex-end;\n}\n.around-sm {\n    -ms-flex-pack: distribute;\n    justify-content: space-around;\n}\n.between-sm {\n    -webkit-box-pack: justify;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n}\n.first-sm {\n    -webkit-box-ordinal-group: 0;\n    -ms-flex-order: -1;\n    order: -1;\n}\n.last-sm {\n    -webkit-box-ordinal-group: 2;\n    -ms-flex-order: 1;\n    order: 1;\n}\n}\n@media only screen and (min-width: 64em) {\n.col-md,\n  .col-md-1,\n  .col-md-2,\n  .col-md-3,\n  .col-md-4,\n  .col-md-5,\n  .col-md-6,\n  .col-md-7,\n  .col-md-8,\n  .col-md-9,\n  .col-md-10,\n  .col-md-11,\n  .col-md-12,\n  .col-md-offset-0,\n  .col-md-offset-1,\n  .col-md-offset-2,\n  .col-md-offset-3,\n  .col-md-offset-4,\n  .col-md-offset-5,\n  .col-md-offset-6,\n  .col-md-offset-7,\n  .col-md-offset-8,\n  .col-md-offset-9,\n  .col-md-offset-10,\n  .col-md-offset-11,\n  .col-md-offset-12 {\n    box-sizing: border-box;\n    -webkit-box-flex: 0;\n    -ms-flex: 0 0 auto;\n    flex: 0 0 auto;\n    padding-right: 0.5rem;\n    padding-left: 0.5rem;\n}\n.col-md {\n    -webkit-box-flex: 1;\n    -ms-flex-positive: 1;\n    flex-grow: 1;\n    -ms-flex-preferred-size: 0;\n    flex-basis: 0;\n    max-width: 100%;\n}\n.col-md-1 {\n    -ms-flex-preferred-size: 8.33333333%;\n    flex-basis: 8.33333333%;\n    max-width: 8.33333333%;\n}\n.col-md-2 {\n    -ms-flex-preferred-size: 16.66666667%;\n    flex-basis: 16.66666667%;\n    max-width: 16.66666667%;\n}\n.col-md-3 {\n    -ms-flex-preferred-size: 25%;\n    flex-basis: 25%;\n    max-width: 25%;\n}\n.col-md-4 {\n    -ms-flex-preferred-size: 33.33333333%;\n    flex-basis: 33.33333333%;\n    max-width: 33.33333333%;\n}\n.col-md-5 {\n    -ms-flex-preferred-size: 41.66666667%;\n    flex-basis: 41.66666667%;\n    max-width: 41.66666667%;\n}\n.col-md-6 {\n    -ms-flex-preferred-size: 50%;\n    flex-basis: 50%;\n    max-width: 50%;\n}\n.col-md-7 {\n    -ms-flex-preferred-size: 58.33333333%;\n    flex-basis: 58.33333333%;\n    max-width: 58.33333333%;\n}\n.col-md-8 {\n    -ms-flex-preferred-size: 66.66666667%;\n    flex-basis: 66.66666667%;\n    max-width: 66.66666667%;\n}\n.col-md-9 {\n    -ms-flex-preferred-size: 75%;\n    flex-basis: 75%;\n    max-width: 75%;\n}\n.col-md-10 {\n    -ms-flex-preferred-size: 83.33333333%;\n    flex-basis: 83.33333333%;\n    max-width: 83.33333333%;\n}\n.col-md-11 {\n    -ms-flex-preferred-size: 91.66666667%;\n    flex-basis: 91.66666667%;\n    max-width: 91.66666667%;\n}\n.col-md-12 {\n    -ms-flex-preferred-size: 100%;\n    flex-basis: 100%;\n    max-width: 100%;\n}\n.col-md-offset-0 {\n    margin-left: 0;\n}\n.col-md-offset-1 {\n    margin-left: 8.33333333%;\n}\n.col-md-offset-2 {\n    margin-left: 16.66666667%;\n}\n.col-md-offset-3 {\n    margin-left: 25%;\n}\n.col-md-offset-4 {\n    margin-left: 33.33333333%;\n}\n.col-md-offset-5 {\n    margin-left: 41.66666667%;\n}\n.col-md-offset-6 {\n    margin-left: 50%;\n}\n.col-md-offset-7 {\n    margin-left: 58.33333333%;\n}\n.col-md-offset-8 {\n    margin-left: 66.66666667%;\n}\n.col-md-offset-9 {\n    margin-left: 75%;\n}\n.col-md-offset-10 {\n    margin-left: 83.33333333%;\n}\n.col-md-offset-11 {\n    margin-left: 91.66666667%;\n}\n.start-md {\n    -webkit-box-pack: start;\n    -ms-flex-pack: start;\n    justify-content: flex-start;\n    text-align: start;\n}\n.center-md {\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    text-align: center;\n}\n.end-md {\n    -webkit-box-pack: end;\n    -ms-flex-pack: end;\n    justify-content: flex-end;\n    text-align: end;\n}\n.top-md {\n    -webkit-box-align: start;\n    -ms-flex-align: start;\n    align-items: flex-start;\n}\n.middle-md {\n    -webkit-box-align: center;\n    -ms-flex-align: center;\n    align-items: center;\n}\n.bottom-md {\n    -webkit-box-align: end;\n    -ms-flex-align: end;\n    align-items: flex-end;\n}\n.around-md {\n    -ms-flex-pack: distribute;\n    justify-content: space-around;\n}\n.between-md {\n    -webkit-box-pack: justify;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n}\n.first-md {\n    -webkit-box-ordinal-group: 0;\n    -ms-flex-order: -1;\n    order: -1;\n}\n.last-md {\n    -webkit-box-ordinal-group: 2;\n    -ms-flex-order: 1;\n    order: 1;\n}\n}\n@media only screen and (min-width: 75em) {\n.col-lg,\n  .col-lg-1,\n  .col-lg-2,\n  .col-lg-3,\n  .col-lg-4,\n  .col-lg-5,\n  .col-lg-6,\n  .col-lg-7,\n  .col-lg-8,\n  .col-lg-9,\n  .col-lg-10,\n  .col-lg-11,\n  .col-lg-12,\n  .col-lg-offset-0,\n  .col-lg-offset-1,\n  .col-lg-offset-2,\n  .col-lg-offset-3,\n  .col-lg-offset-4,\n  .col-lg-offset-5,\n  .col-lg-offset-6,\n  .col-lg-offset-7,\n  .col-lg-offset-8,\n  .col-lg-offset-9,\n  .col-lg-offset-10,\n  .col-lg-offset-11,\n  .col-lg-offset-12 {\n    box-sizing: border-box;\n    -webkit-box-flex: 0;\n    -ms-flex: 0 0 auto;\n    flex: 0 0 auto;\n    padding-right: 0.5rem;\n    padding-left: 0.5rem;\n}\n.col-lg {\n    -webkit-box-flex: 1;\n    -ms-flex-positive: 1;\n    flex-grow: 1;\n    -ms-flex-preferred-size: 0;\n    flex-basis: 0;\n    max-width: 100%;\n}\n.col-lg-1 {\n    -ms-flex-preferred-size: 8.33333333%;\n    flex-basis: 8.33333333%;\n    max-width: 8.33333333%;\n}\n.col-lg-2 {\n    -ms-flex-preferred-size: 16.66666667%;\n    flex-basis: 16.66666667%;\n    max-width: 16.66666667%;\n}\n.col-lg-3 {\n    -ms-flex-preferred-size: 25%;\n    flex-basis: 25%;\n    max-width: 25%;\n}\n.col-lg-4 {\n    -ms-flex-preferred-size: 33.33333333%;\n    flex-basis: 33.33333333%;\n    max-width: 33.33333333%;\n}\n.col-lg-5 {\n    -ms-flex-preferred-size: 41.66666667%;\n    flex-basis: 41.66666667%;\n    max-width: 41.66666667%;\n}\n.col-lg-6 {\n    -ms-flex-preferred-size: 50%;\n    flex-basis: 50%;\n    max-width: 50%;\n}\n.col-lg-7 {\n    -ms-flex-preferred-size: 58.33333333%;\n    flex-basis: 58.33333333%;\n    max-width: 58.33333333%;\n}\n.col-lg-8 {\n    -ms-flex-preferred-size: 66.66666667%;\n    flex-basis: 66.66666667%;\n    max-width: 66.66666667%;\n}\n.col-lg-9 {\n    -ms-flex-preferred-size: 75%;\n    flex-basis: 75%;\n    max-width: 75%;\n}\n.col-lg-10 {\n    -ms-flex-preferred-size: 83.33333333%;\n    flex-basis: 83.33333333%;\n    max-width: 83.33333333%;\n}\n.col-lg-11 {\n    -ms-flex-preferred-size: 91.66666667%;\n    flex-basis: 91.66666667%;\n    max-width: 91.66666667%;\n}\n.col-lg-12 {\n    -ms-flex-preferred-size: 100%;\n    flex-basis: 100%;\n    max-width: 100%;\n}\n.col-lg-offset-0 {\n    margin-left: 0;\n}\n.col-lg-offset-1 {\n    margin-left: 8.33333333%;\n}\n.col-lg-offset-2 {\n    margin-left: 16.66666667%;\n}\n.col-lg-offset-3 {\n    margin-left: 25%;\n}\n.col-lg-offset-4 {\n    margin-left: 33.33333333%;\n}\n.col-lg-offset-5 {\n    margin-left: 41.66666667%;\n}\n.col-lg-offset-6 {\n    margin-left: 50%;\n}\n.col-lg-offset-7 {\n    margin-left: 58.33333333%;\n}\n.col-lg-offset-8 {\n    margin-left: 66.66666667%;\n}\n.col-lg-offset-9 {\n    margin-left: 75%;\n}\n.col-lg-offset-10 {\n    margin-left: 83.33333333%;\n}\n.col-lg-offset-11 {\n    margin-left: 91.66666667%;\n}\n.start-lg {\n    -webkit-box-pack: start;\n    -ms-flex-pack: start;\n    justify-content: flex-start;\n    text-align: start;\n}\n.center-lg {\n    -webkit-box-pack: center;\n    -ms-flex-pack: center;\n    justify-content: center;\n    text-align: center;\n}\n.end-lg {\n    -webkit-box-pack: end;\n    -ms-flex-pack: end;\n    justify-content: flex-end;\n    text-align: end;\n}\n.top-lg {\n    -webkit-box-align: start;\n    -ms-flex-align: start;\n    align-items: flex-start;\n}\n.middle-lg {\n    -webkit-box-align: center;\n    -ms-flex-align: center;\n    align-items: center;\n}\n.bottom-lg {\n    -webkit-box-align: end;\n    -ms-flex-align: end;\n    align-items: flex-end;\n}\n.around-lg {\n    -ms-flex-pack: distribute;\n    justify-content: space-around;\n}\n.between-lg {\n    -webkit-box-pack: justify;\n    -ms-flex-pack: justify;\n    justify-content: space-between;\n}\n.first-lg {\n    -webkit-box-ordinal-group: 0;\n    -ms-flex-order: -1;\n    order: -1;\n}\n.last-lg {\n    -webkit-box-ordinal-group: 2;\n    -ms-flex-order: 1;\n    order: 1;\n}\n}\n.container {\n  margin: 0 auto;\n  padding: 2.5rem 1.3rem;\n  border-radius: 0.5rem;\n  border-width: var(--border-container-width, 1px);\n  border-style: solid;\n  border-color: var(--border-color, rgba(143, 155, 191, 0.5))\n}\n@media screen and (min-width: 576px) {\n.container {\n    padding: 2.5rem 2rem;\n}\n}\ndiv, p {\n  font-family: var(--secondary-font, sans-serif);\n  color: var(--text-color, #535e80);\n}\nh1,h2,h3,h4,h5,h6 {\n  font-family: var(--primary-font, sans-serif);\n  color: var(--heading-color, #090f1f);\n}\nh1 {\n  margin-bottom: 0.8rem;\n  margin-top: 0;\n  font-size: 28px;\n}\n.text-small {\n  font-size: 0.85rem;\n}\nhr.text-small:after {\n  font-size: 0.85rem;\n}\n.text-xsmall {\n  font-size: 0.75rem;\n}\n.text-center {\n  text-align: var(--text-align, center);\n}\na, .link {\n  text-decoration: none;\n  font-weight: bold;\n  color: var(--light-color, #1953ff);\n  cursor: pointer;\n}\n.line:after {\n  content: '';\n  display: block;\n  border-bottom: 1px solid #0b2e13;\n  margin-top: -8px;\n  z-index: -1;\n}\n.pointer {\n  cursor: pointer;\n}\n.mt-4 {\n  margin-top: 16px;\n}\n.mt-8 {\n  margin-top: 32px;\n}\n"]]]), hd = (e7) => (ln("data-v-52f7ab29"), e7 = e7(), cn2(), e7), yd = { key: 0, class: "dialog" }, Id = { class: "dialog-content" }, wd = hd(() => rr("div", { class: "dialog-header" }, "You already have a passkey on this device", -1)), Nd = hd(() => rr("div", { class: "dialog-body" }, "Everything is done on this device.", -1)), jd = { class: "dialog-footer" }, bd = { key: 1, id: "corbado-passkey-append" }, Dd = { style: { "margin-top": "1rem" } }, xd = crypto, Ld = (e7) => e7 instanceof CryptoKey, vd = new TextEncoder(), Td = new TextDecoder();
        const zd = (e7) => {
          let t10 = e7;
          t10 instanceof Uint8Array && (t10 = Td.decode(t10)), t10 = t10.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
          try {
            return ((e8) => {
              const t11 = atob(e8), n8 = new Uint8Array(t11.length);
              for (let e9 = 0; e9 < t11.length; e9++)
                n8[e9] = t11.charCodeAt(e9);
              return n8;
            })(t10);
          } catch (e8) {
            throw new TypeError("The input to be decoded is not correctly encoded.");
          }
        };
        class Cd extends Error {
          static get code() {
            return "ERR_JOSE_GENERIC";
          }
          constructor(e7) {
            var t10;
            super(e7), this.code = "ERR_JOSE_GENERIC", this.name = this.constructor.name, null === (t10 = Error.captureStackTrace) || void 0 === t10 || t10.call(Error, this, this.constructor);
          }
        }
        class Sd extends Cd {
          static get code() {
            return "ERR_JWT_CLAIM_VALIDATION_FAILED";
          }
          constructor(e7, t10 = "unspecified", n8 = "unspecified") {
            super(e7), this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED", this.claim = t10, this.reason = n8;
          }
        }
        class Ed extends Cd {
          static get code() {
            return "ERR_JWT_EXPIRED";
          }
          constructor(e7, t10 = "unspecified", n8 = "unspecified") {
            super(e7), this.code = "ERR_JWT_EXPIRED", this.claim = t10, this.reason = n8;
          }
        }
        class kd extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
          }
          static get code() {
            return "ERR_JOSE_ALG_NOT_ALLOWED";
          }
        }
        class Od extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JOSE_NOT_SUPPORTED";
          }
          static get code() {
            return "ERR_JOSE_NOT_SUPPORTED";
          }
        }
        class Pd extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JWS_INVALID";
          }
          static get code() {
            return "ERR_JWS_INVALID";
          }
        }
        class Ud extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JWT_INVALID";
          }
          static get code() {
            return "ERR_JWT_INVALID";
          }
        }
        class Qd extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JWKS_INVALID";
          }
          static get code() {
            return "ERR_JWKS_INVALID";
          }
        }
        class Rd extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JWKS_NO_MATCHING_KEY", this.message = "no applicable key found in the JSON Web Key Set";
          }
          static get code() {
            return "ERR_JWKS_NO_MATCHING_KEY";
          }
        }
        class Yd extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS", this.message = "multiple matching keys found in the JSON Web Key Set";
          }
          static get code() {
            return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
          }
        }
        Symbol.asyncIterator;
        class Zd extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JWKS_TIMEOUT", this.message = "request timed out";
          }
          static get code() {
            return "ERR_JWKS_TIMEOUT";
          }
        }
        class Bd extends Cd {
          constructor() {
            super(...arguments), this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED", this.message = "signature verification failed";
          }
          static get code() {
            return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
          }
        }
        xd.getRandomValues.bind(xd);
        const Wd = (e7) => Ld(e7), Gd = ["CryptoKey"], Hd = async (e7) => {
          var t10, n8;
          if (!e7.alg)
            throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
          const { algorithm: i10, keyUsages: r9 } = function(e8) {
            let t11, n9;
            switch (e8.kty) {
              case "oct":
                switch (e8.alg) {
                  case "HS256":
                  case "HS384":
                  case "HS512":
                    t11 = { name: "HMAC", hash: `SHA-${e8.alg.slice(-3)}` }, n9 = ["sign", "verify"];
                    break;
                  case "A128CBC-HS256":
                  case "A192CBC-HS384":
                  case "A256CBC-HS512":
                    throw new Od(`${e8.alg} keys cannot be imported as CryptoKey instances`);
                  case "A128GCM":
                  case "A192GCM":
                  case "A256GCM":
                  case "A128GCMKW":
                  case "A192GCMKW":
                  case "A256GCMKW":
                    t11 = { name: "AES-GCM" }, n9 = ["encrypt", "decrypt"];
                    break;
                  case "A128KW":
                  case "A192KW":
                  case "A256KW":
                    t11 = { name: "AES-KW" }, n9 = ["wrapKey", "unwrapKey"];
                    break;
                  case "PBES2-HS256+A128KW":
                  case "PBES2-HS384+A192KW":
                  case "PBES2-HS512+A256KW":
                    t11 = { name: "PBKDF2" }, n9 = ["deriveBits"];
                    break;
                  default:
                    throw new Od('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
              case "RSA":
                switch (e8.alg) {
                  case "PS256":
                  case "PS384":
                  case "PS512":
                    t11 = { name: "RSA-PSS", hash: `SHA-${e8.alg.slice(-3)}` }, n9 = e8.d ? ["sign"] : ["verify"];
                    break;
                  case "RS256":
                  case "RS384":
                  case "RS512":
                    t11 = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${e8.alg.slice(-3)}` }, n9 = e8.d ? ["sign"] : ["verify"];
                    break;
                  case "RSA-OAEP":
                  case "RSA-OAEP-256":
                  case "RSA-OAEP-384":
                  case "RSA-OAEP-512":
                    t11 = { name: "RSA-OAEP", hash: `SHA-${parseInt(e8.alg.slice(-3), 10) || 1}` }, n9 = e8.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
                    break;
                  default:
                    throw new Od('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
              case "EC":
                switch (e8.alg) {
                  case "ES256":
                    t11 = { name: "ECDSA", namedCurve: "P-256" }, n9 = e8.d ? ["sign"] : ["verify"];
                    break;
                  case "ES384":
                    t11 = { name: "ECDSA", namedCurve: "P-384" }, n9 = e8.d ? ["sign"] : ["verify"];
                    break;
                  case "ES512":
                    t11 = { name: "ECDSA", namedCurve: "P-521" }, n9 = e8.d ? ["sign"] : ["verify"];
                    break;
                  case "ECDH-ES":
                  case "ECDH-ES+A128KW":
                  case "ECDH-ES+A192KW":
                  case "ECDH-ES+A256KW":
                    t11 = { name: "ECDH", namedCurve: e8.crv }, n9 = e8.d ? ["deriveBits"] : [];
                    break;
                  default:
                    throw new Od('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
              case "OKP":
                switch (e8.alg) {
                  case "EdDSA":
                    t11 = { name: e8.crv }, n9 = e8.d ? ["sign"] : ["verify"];
                    break;
                  case "ECDH-ES":
                  case "ECDH-ES+A128KW":
                  case "ECDH-ES+A192KW":
                  case "ECDH-ES+A256KW":
                    t11 = { name: e8.crv }, n9 = e8.d ? ["deriveBits"] : [];
                    break;
                  default:
                    throw new Od('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
              default:
                throw new Od('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
            }
            return { algorithm: t11, keyUsages: n9 };
          }(e7), o8 = [i10, null !== (t10 = e7.ext) && void 0 !== t10 && t10, null !== (n8 = e7.key_ops) && void 0 !== n8 ? n8 : r9];
          if ("PBKDF2" === i10.name)
            return xd.subtle.importKey("raw", zd(e7.k), ...o8);
          const s10 = { ...e7 };
          return delete s10.alg, delete s10.use, xd.subtle.importKey("jwk", s10, ...o8);
        };
        function _d(e7) {
          if ("object" != typeof (t10 = e7) || null === t10 || "[object Object]" !== Object.prototype.toString.call(e7))
            return false;
          var t10;
          if (null === Object.getPrototypeOf(e7))
            return true;
          let n8 = e7;
          for (; null !== Object.getPrototypeOf(n8); )
            n8 = Object.getPrototypeOf(n8);
          return Object.getPrototypeOf(e7) === n8;
        }
        function Vd(e7, t10, ...n8) {
          if (n8.length > 2) {
            const t11 = n8.pop();
            e7 += `one of type ${n8.join(", ")}, or ${t11}.`;
          } else
            2 === n8.length ? e7 += `one of type ${n8[0]} or ${n8[1]}.` : e7 += `of type ${n8[0]}.`;
          return null == t10 ? e7 += ` Received ${t10}` : "function" == typeof t10 && t10.name ? e7 += ` Received function ${t10.name}` : "object" == typeof t10 && null != t10 && t10.constructor && t10.constructor.name && (e7 += ` Received an instance of ${t10.constructor.name}`), e7;
        }
        const Fd = (e7, ...t10) => Vd("Key must be ", e7, ...t10);
        function Jd(e7, t10, ...n8) {
          return Vd(`Key for the ${e7} algorithm must be `, t10, ...n8);
        }
        function Xd(e7, t10 = "algorithm.name") {
          return new TypeError(`CryptoKey does not support this operation, its ${t10} must be ${e7}`);
        }
        function Kd(e7, t10) {
          return e7.name === t10;
        }
        function qd(e7) {
          return parseInt(e7.name.slice(4), 10);
        }
        function $d(e7, t10, ...n8) {
          switch (t10) {
            case "HS256":
            case "HS384":
            case "HS512": {
              if (!Kd(e7.algorithm, "HMAC"))
                throw Xd("HMAC");
              const n9 = parseInt(t10.slice(2), 10);
              if (qd(e7.algorithm.hash) !== n9)
                throw Xd(`SHA-${n9}`, "algorithm.hash");
              break;
            }
            case "RS256":
            case "RS384":
            case "RS512": {
              if (!Kd(e7.algorithm, "RSASSA-PKCS1-v1_5"))
                throw Xd("RSASSA-PKCS1-v1_5");
              const n9 = parseInt(t10.slice(2), 10);
              if (qd(e7.algorithm.hash) !== n9)
                throw Xd(`SHA-${n9}`, "algorithm.hash");
              break;
            }
            case "PS256":
            case "PS384":
            case "PS512": {
              if (!Kd(e7.algorithm, "RSA-PSS"))
                throw Xd("RSA-PSS");
              const n9 = parseInt(t10.slice(2), 10);
              if (qd(e7.algorithm.hash) !== n9)
                throw Xd(`SHA-${n9}`, "algorithm.hash");
              break;
            }
            case "EdDSA":
              if ("Ed25519" !== e7.algorithm.name && "Ed448" !== e7.algorithm.name)
                throw Xd("Ed25519 or Ed448");
              break;
            case "ES256":
            case "ES384":
            case "ES512": {
              if (!Kd(e7.algorithm, "ECDSA"))
                throw Xd("ECDSA");
              const n9 = function(e8) {
                switch (e8) {
                  case "ES256":
                    return "P-256";
                  case "ES384":
                    return "P-384";
                  case "ES512":
                    return "P-521";
                  default:
                    throw new Error("unreachable");
                }
              }(t10);
              if (e7.algorithm.namedCurve !== n9)
                throw Xd(n9, "algorithm.namedCurve");
              break;
            }
            default:
              throw new TypeError("CryptoKey does not support this operation");
          }
          !function(e8, t11) {
            if (t11.length && !t11.some((t12) => e8.usages.includes(t12))) {
              let e9 = "CryptoKey does not support this operation, its usages must include ";
              if (t11.length > 2) {
                const n9 = t11.pop();
                e9 += `one of ${t11.join(", ")}, or ${n9}.`;
              } else
                2 === t11.length ? e9 += `one of ${t11[0]} or ${t11[1]}.` : e9 += `${t11[0]}.`;
              throw new TypeError(e9);
            }
          }(e7, n8);
        }
        Symbol();
        async function eA(e7, t10, n8) {
          if (e7 instanceof Uint8Array && (e7 = Td.decode(e7)), "string" != typeof e7)
            throw new Pd("Compact JWS must be a string or Uint8Array");
          const { 0: i10, 1: r9, 2: o8, length: s10 } = e7.split(".");
          if (3 !== s10)
            throw new Pd("Invalid Compact JWS");
          const a8 = await async function(e8, t11, n9) {
            var i11;
            if (!_d(e8))
              throw new Pd("Flattened JWS must be an object");
            if (void 0 === e8.protected && void 0 === e8.header)
              throw new Pd('Flattened JWS must have either of the "protected" or "header" members');
            if (void 0 !== e8.protected && "string" != typeof e8.protected)
              throw new Pd("JWS Protected Header incorrect type");
            if (void 0 === e8.payload)
              throw new Pd("JWS Payload missing");
            if ("string" != typeof e8.signature)
              throw new Pd("JWS Signature missing or incorrect type");
            if (void 0 !== e8.header && !_d(e8.header))
              throw new Pd("JWS Unprotected Header incorrect type");
            let r10 = {};
            if (e8.protected)
              try {
                const t12 = zd(e8.protected);
                r10 = JSON.parse(Td.decode(t12));
              } catch (e9) {
                throw new Pd("JWS Protected Header is invalid");
              }
            if (!((...e9) => {
              const t12 = e9.filter(Boolean);
              if (0 === t12.length || 1 === t12.length)
                return true;
              let n10;
              for (const e10 of t12) {
                const t13 = Object.keys(e10);
                if (n10 && 0 !== n10.size)
                  for (const e11 of t13) {
                    if (n10.has(e11))
                      return false;
                    n10.add(e11);
                  }
                else
                  n10 = new Set(t13);
              }
              return true;
            })(r10, e8.header))
              throw new Pd("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
            const o9 = { ...r10, ...e8.header };
            let s11 = true;
            if (function(e9, t12, n10, i12, r11) {
              if (void 0 !== r11.crit && void 0 === i12.crit)
                throw new e9('"crit" (Critical) Header Parameter MUST be integrity protected');
              if (!i12 || void 0 === i12.crit)
                return /* @__PURE__ */ new Set();
              if (!Array.isArray(i12.crit) || 0 === i12.crit.length || i12.crit.some((e10) => "string" != typeof e10 || 0 === e10.length))
                throw new e9('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
              let o10;
              o10 = void 0 !== n10 ? new Map([...Object.entries(n10), ...t12.entries()]) : t12;
              for (const t13 of i12.crit) {
                if (!o10.has(t13))
                  throw new Od(`Extension Header Parameter "${t13}" is not recognized`);
                if (void 0 === r11[t13])
                  throw new e9(`Extension Header Parameter "${t13}" is missing`);
                if (o10.get(t13) && void 0 === i12[t13])
                  throw new e9(`Extension Header Parameter "${t13}" MUST be integrity protected`);
              }
              return new Set(i12.crit);
            }(Pd, /* @__PURE__ */ new Map([["b64", true]]), null == n9 ? void 0 : n9.crit, r10, o9).has("b64") && (s11 = r10.b64, "boolean" != typeof s11))
              throw new Pd('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            const { alg: a9 } = o9;
            if ("string" != typeof a9 || !a9)
              throw new Pd('JWS "alg" (Algorithm) Header Parameter missing or invalid');
            const l9 = n9 && ((e9, t12) => {
              if (void 0 !== t12 && (!Array.isArray(t12) || t12.some((e10) => "string" != typeof e10)))
                throw new TypeError(`"${e9}" option must be an array of strings`);
              if (t12)
                return new Set(t12);
            })("algorithms", n9.algorithms);
            if (l9 && !l9.has(a9))
              throw new kd('"alg" (Algorithm) Header Parameter not allowed');
            if (s11) {
              if ("string" != typeof e8.payload)
                throw new Pd("JWS Payload must be a string");
            } else if ("string" != typeof e8.payload && !(e8.payload instanceof Uint8Array))
              throw new Pd("JWS Payload must be a string or an Uint8Array instance");
            let c9 = false;
            "function" == typeof t11 && (t11 = await t11(r10, e8), c9 = true), ((e9, t12, n10) => {
              e9.startsWith("HS") || "dir" === e9 || e9.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(e9) ? ((e10, t13) => {
                if (!(t13 instanceof Uint8Array)) {
                  if (!Wd(t13))
                    throw new TypeError(Jd(e10, t13, ...Gd, "Uint8Array"));
                  if ("secret" !== t13.type)
                    throw new TypeError(`${Gd.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
                }
              })(e9, t12) : ((e10, t13, n11) => {
                if (!Wd(t13))
                  throw new TypeError(Jd(e10, t13, ...Gd));
                if ("secret" === t13.type)
                  throw new TypeError(`${Gd.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
                if ("sign" === n11 && "public" === t13.type)
                  throw new TypeError(`${Gd.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
                if ("decrypt" === n11 && "public" === t13.type)
                  throw new TypeError(`${Gd.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
                if (t13.algorithm && "verify" === n11 && "private" === t13.type)
                  throw new TypeError(`${Gd.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
                if (t13.algorithm && "encrypt" === n11 && "private" === t13.type)
                  throw new TypeError(`${Gd.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
              })(e9, t12, n10);
            })(a9, t11, "verify");
            const u7 = function(...e9) {
              const t12 = e9.reduce((e10, { length: t13 }) => e10 + t13, 0), n10 = new Uint8Array(t12);
              let i12 = 0;
              return e9.forEach((e10) => {
                n10.set(e10, i12), i12 += e10.length;
              }), n10;
            }(vd.encode(null !== (i11 = e8.protected) && void 0 !== i11 ? i11 : ""), vd.encode("."), "string" == typeof e8.payload ? vd.encode(e8.payload) : e8.payload), d7 = zd(e8.signature);
            if (!await (async (e9, t12, n10, i12) => {
              const r11 = await function(e10, t13, n11) {
                if (Ld(t13))
                  return $d(t13, e10, n11), t13;
                if (t13 instanceof Uint8Array) {
                  if (!e10.startsWith("HS"))
                    throw new TypeError(Fd(t13, ...Gd));
                  return xd.subtle.importKey("raw", t13, { hash: `SHA-${e10.slice(-3)}`, name: "HMAC" }, false, [n11]);
                }
                throw new TypeError(Fd(t13, ...Gd, "Uint8Array"));
              }(e9, t12, "verify");
              ((e10, t13) => {
                if (e10.startsWith("RS") || e10.startsWith("PS")) {
                  const { modulusLength: n11 } = t13.algorithm;
                  if ("number" != typeof n11 || n11 < 2048)
                    throw new TypeError(`${e10} requires key modulusLength to be 2048 bits or larger`);
                }
              })(e9, r11);
              const o10 = function(e10, t13) {
                const n11 = `SHA-${e10.slice(-3)}`;
                switch (e10) {
                  case "HS256":
                  case "HS384":
                  case "HS512":
                    return { hash: n11, name: "HMAC" };
                  case "PS256":
                  case "PS384":
                  case "PS512":
                    return { hash: n11, name: "RSA-PSS", saltLength: e10.slice(-3) >> 3 };
                  case "RS256":
                  case "RS384":
                  case "RS512":
                    return { hash: n11, name: "RSASSA-PKCS1-v1_5" };
                  case "ES256":
                  case "ES384":
                  case "ES512":
                    return { hash: n11, name: "ECDSA", namedCurve: t13.namedCurve };
                  case "EdDSA":
                    return { name: t13.name };
                  default:
                    throw new Od(`alg ${e10} is not supported either by JOSE or your javascript runtime`);
                }
              }(e9, r11.algorithm);
              try {
                return await xd.subtle.verify(o10, r11, n10, i12);
              } catch (e10) {
                return false;
              }
            })(a9, t11, d7, u7))
              throw new Bd();
            let A6;
            A6 = s11 ? zd(e8.payload) : "string" == typeof e8.payload ? vd.encode(e8.payload) : e8.payload;
            const g8 = { payload: A6 };
            return void 0 !== e8.protected && (g8.protectedHeader = r10), void 0 !== e8.header && (g8.unprotectedHeader = e8.header), c9 ? { ...g8, key: t11 } : g8;
          }({ payload: r9, protected: i10, signature: o8 }, t10, n8), l8 = { payload: a8.payload, protectedHeader: a8.protectedHeader };
          return "function" == typeof t10 ? { ...l8, key: a8.key } : l8;
        }
        const tA = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i, nA = (e7) => {
          const t10 = tA.exec(e7);
          if (!t10)
            throw new TypeError("Invalid time period format");
          const n8 = parseFloat(t10[1]);
          switch (t10[2].toLowerCase()) {
            case "sec":
            case "secs":
            case "second":
            case "seconds":
            case "s":
              return Math.round(n8);
            case "minute":
            case "minutes":
            case "min":
            case "mins":
            case "m":
              return Math.round(60 * n8);
            case "hour":
            case "hours":
            case "hr":
            case "hrs":
            case "h":
              return Math.round(3600 * n8);
            case "day":
            case "days":
            case "d":
              return Math.round(86400 * n8);
            case "week":
            case "weeks":
            case "w":
              return Math.round(604800 * n8);
            default:
              return Math.round(31557600 * n8);
          }
        }, iA = (e7) => e7.toLowerCase().replace(/^application\//, ""), rA = (e7, t10, n8 = {}) => {
          const { typ: i10 } = n8;
          if (i10 && ("string" != typeof e7.typ || iA(e7.typ) !== iA(i10)))
            throw new Sd('unexpected "typ" JWT header value', "typ", "check_failed");
          let r9;
          try {
            r9 = JSON.parse(Td.decode(t10));
          } catch (e8) {
          }
          if (!_d(r9))
            throw new Ud("JWT Claims Set must be a top-level JSON object");
          const { requiredClaims: o8 = [], issuer: s10, subject: a8, audience: l8, maxTokenAge: c9 } = n8;
          void 0 !== c9 && o8.push("iat"), void 0 !== l8 && o8.push("aud"), void 0 !== a8 && o8.push("sub"), void 0 !== s10 && o8.push("iss");
          for (const e8 of new Set(o8.reverse()))
            if (!(e8 in r9))
              throw new Sd(`missing required "${e8}" claim`, e8, "missing");
          if (s10 && !(Array.isArray(s10) ? s10 : [s10]).includes(r9.iss))
            throw new Sd('unexpected "iss" claim value', "iss", "check_failed");
          if (a8 && r9.sub !== a8)
            throw new Sd('unexpected "sub" claim value', "sub", "check_failed");
          if (l8 && (d7 = "string" == typeof l8 ? [l8] : l8, !("string" == typeof (u7 = r9.aud) ? d7.includes(u7) : Array.isArray(u7) && d7.some(Set.prototype.has.bind(new Set(u7))))))
            throw new Sd('unexpected "aud" claim value', "aud", "check_failed");
          var u7, d7;
          let A6;
          switch (typeof n8.clockTolerance) {
            case "string":
              A6 = nA(n8.clockTolerance);
              break;
            case "number":
              A6 = n8.clockTolerance;
              break;
            case "undefined":
              A6 = 0;
              break;
            default:
              throw new TypeError("Invalid clockTolerance option type");
          }
          const { currentDate: g8 } = n8, p6 = (M5 = g8 || /* @__PURE__ */ new Date(), Math.floor(M5.getTime() / 1e3));
          var M5;
          if ((void 0 !== r9.iat || c9) && "number" != typeof r9.iat)
            throw new Sd('"iat" claim must be a number', "iat", "invalid");
          if (void 0 !== r9.nbf) {
            if ("number" != typeof r9.nbf)
              throw new Sd('"nbf" claim must be a number', "nbf", "invalid");
            if (r9.nbf > p6 + A6)
              throw new Sd('"nbf" claim timestamp check failed', "nbf", "check_failed");
          }
          if (void 0 !== r9.exp) {
            if ("number" != typeof r9.exp)
              throw new Sd('"exp" claim must be a number', "exp", "invalid");
            if (r9.exp <= p6 - A6)
              throw new Ed('"exp" claim timestamp check failed', "exp", "check_failed");
          }
          if (c9) {
            const e8 = p6 - r9.iat;
            if (e8 - A6 > ("number" == typeof c9 ? c9 : nA(c9)))
              throw new Ed('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
            if (e8 < 0 - A6)
              throw new Sd('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
          }
          return r9;
        };
        function oA(e7) {
          return e7 && "object" == typeof e7 && Array.isArray(e7.keys) && e7.keys.every(sA);
        }
        function sA(e7) {
          return _d(e7);
        }
        class aA {
          constructor(e7) {
            if (this._cached = /* @__PURE__ */ new WeakMap(), !oA(e7))
              throw new Qd("JSON Web Key Set malformed");
            var t10;
            this._jwks = (t10 = e7, "function" == typeof structuredClone ? structuredClone(t10) : JSON.parse(JSON.stringify(t10)));
          }
          async getKey(e7, t10) {
            const { alg: n8, kid: i10 } = { ...e7, ...null == t10 ? void 0 : t10.header }, r9 = function(e8) {
              switch ("string" == typeof e8 && e8.slice(0, 2)) {
                case "RS":
                case "PS":
                  return "RSA";
                case "ES":
                  return "EC";
                case "Ed":
                  return "OKP";
                default:
                  throw new Od('Unsupported "alg" value for a JSON Web Key Set');
              }
            }(n8), o8 = this._jwks.keys.filter((e8) => {
              let t11 = r9 === e8.kty;
              if (t11 && "string" == typeof i10 && (t11 = i10 === e8.kid), t11 && "string" == typeof e8.alg && (t11 = n8 === e8.alg), t11 && "string" == typeof e8.use && (t11 = "sig" === e8.use), t11 && Array.isArray(e8.key_ops) && (t11 = e8.key_ops.includes("verify")), t11 && "EdDSA" === n8 && (t11 = "Ed25519" === e8.crv || "Ed448" === e8.crv), t11)
                switch (n8) {
                  case "ES256":
                    t11 = "P-256" === e8.crv;
                    break;
                  case "ES256K":
                    t11 = "secp256k1" === e8.crv;
                    break;
                  case "ES384":
                    t11 = "P-384" === e8.crv;
                    break;
                  case "ES512":
                    t11 = "P-521" === e8.crv;
                }
              return t11;
            }), { 0: s10, length: a8 } = o8;
            if (0 === a8)
              throw new Rd();
            if (1 !== a8) {
              const e8 = new Yd(), { _cached: t11 } = this;
              throw e8[Symbol.asyncIterator] = async function* () {
                for (const e9 of o8)
                  try {
                    yield await lA(t11, e9, n8);
                  } catch (e10) {
                    continue;
                  }
              }, e8;
            }
            return lA(this._cached, s10, n8);
          }
        }
        async function lA(e7, t10, n8) {
          const i10 = e7.get(t10) || e7.set(t10, {}).get(t10);
          if (void 0 === i10[n8]) {
            const e8 = await async function(e9, t11, n9) {
              var i11;
              if (!_d(e9))
                throw new TypeError("JWK must be an object");
              switch (t11 || (t11 = e9.alg), e9.kty) {
                case "oct":
                  if ("string" != typeof e9.k || !e9.k)
                    throw new TypeError('missing "k" (Key Value) Parameter value');
                  return null != n9 || (n9 = true !== e9.ext), n9 ? Hd({ ...e9, alg: t11, ext: null !== (i11 = e9.ext) && void 0 !== i11 && i11 }) : zd(e9.k);
                case "RSA":
                  if (void 0 !== e9.oth)
                    throw new Od('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
                case "EC":
                case "OKP":
                  return Hd({ ...e9, alg: t11 });
                default:
                  throw new Od('Unsupported "kty" (Key Type) Parameter value');
              }
            }({ ...t10, ext: true }, n8);
            if (e8 instanceof Uint8Array || "public" !== e8.type)
              throw new Qd("JSON Web Key Set members must be public keys");
            i10[n8] = e8;
          }
          return i10[n8];
        }
        class cA extends aA {
          constructor(e7, t10) {
            if (super({ keys: [] }), this._jwks = void 0, !(e7 instanceof URL))
              throw new TypeError("url must be an instance of URL");
            this._url = new URL(e7.href), this._options = { agent: null == t10 ? void 0 : t10.agent, headers: null == t10 ? void 0 : t10.headers }, this._timeoutDuration = "number" == typeof (null == t10 ? void 0 : t10.timeoutDuration) ? null == t10 ? void 0 : t10.timeoutDuration : 5e3, this._cooldownDuration = "number" == typeof (null == t10 ? void 0 : t10.cooldownDuration) ? null == t10 ? void 0 : t10.cooldownDuration : 3e4, this._cacheMaxAge = "number" == typeof (null == t10 ? void 0 : t10.cacheMaxAge) ? null == t10 ? void 0 : t10.cacheMaxAge : 6e5;
          }
          coolingDown() {
            return "number" == typeof this._jwksTimestamp && Date.now() < this._jwksTimestamp + this._cooldownDuration;
          }
          fresh() {
            return "number" == typeof this._jwksTimestamp && Date.now() < this._jwksTimestamp + this._cacheMaxAge;
          }
          async getKey(e7, t10) {
            this._jwks && this.fresh() || await this.reload();
            try {
              return await super.getKey(e7, t10);
            } catch (n8) {
              if (n8 instanceof Rd && false === this.coolingDown())
                return await this.reload(), super.getKey(e7, t10);
              throw n8;
            }
          }
          async reload() {
            this._pendingFetch && ("undefined" != typeof WebSocketPair || "undefined" != typeof navigator && "Cloudflare-Workers" === navigator.userAgent || "undefined" != typeof EdgeRuntime && "vercel" === EdgeRuntime) && (this._pendingFetch = void 0), this._pendingFetch || (this._pendingFetch = (async (e7, t10, n8) => {
              let i10, r9, o8 = false;
              "function" == typeof AbortController && (i10 = new AbortController(), r9 = setTimeout(() => {
                o8 = true, i10.abort();
              }, t10));
              const s10 = await fetch(e7.href, { signal: i10 ? i10.signal : void 0, redirect: "manual", headers: n8.headers }).catch((e8) => {
                if (o8)
                  throw new Zd();
                throw e8;
              });
              if (void 0 !== r9 && clearTimeout(r9), 200 !== s10.status)
                throw new Cd("Expected 200 OK from the JSON Web Key Set HTTP response");
              try {
                return await s10.json();
              } catch (e8) {
                throw new Cd("Failed to parse the JSON Web Key Set HTTP response as JSON");
              }
            })(this._url, this._timeoutDuration, this._options).then((e7) => {
              if (!oA(e7))
                throw new Qd("JSON Web Key Set malformed");
              this._jwks = { keys: e7.keys }, this._jwksTimestamp = Date.now(), this._pendingFetch = void 0;
            }).catch((e7) => {
              throw this._pendingFetch = void 0, e7;
            })), await this._pendingFetch;
          }
        }
        class uA {
          constructor(e7, t10, n8, i10, r9) {
            this.userID = e7, this.userIdentifier = t10, this.userFullName = n8, this.email = i10, this.phoneNumber = r9;
          }
        }
        class dA {
          #e;
          #t;
          constructor() {
            const e7 = new Blob(["const timeoutIds = {}\n\nconst assertNumber = (value) => {\n    assertDefined(value)\n\n    if (!value.toString().match(/^\\d+$/)) {\n        throw new Error('Not number ' + value);\n    }\n}\n\nconst assertDefined = (value) => {\n    if (value === undefined) {\n        throw new Error('Undefined number');\n    }\n}\n\nself.onmessage = e => {\n\n    switch (e.data.event) {\n        case 'timeout':\n\n            assertDefined(e.data.payload?.id)\n            assertNumber(e.data.payload?.ms)\n\n            timeoutIds[e.data.payload.id] = setTimeout(() => {\n                self.postMessage({\n                    id: e.data.payload.id\n                })\n            }, e.data.payload.ms)\n\n            break\n\n        case 'resetInterval': {\n            assertDefined(e.data.payload?.id)\n\n            clearInterval(timeoutIds[e.data.payload.id])\n            break\n        }\n\n        case 'interval':\n\n            assertDefined(e.data.payload?.id)\n            assertNumber(e.data.payload?.ms)\n\n            timeoutIds[e.data.payload.id] = setInterval(() => {\n                self.postMessage({\n                    id: e.data.payload.id\n                })\n            }, e.data.payload.ms)\n\n            break\n    }\n    \n}\n"], { type: "application/javascript" }), t10 = URL.createObjectURL(e7);
            this.#e = new Worker(t10, { name: "wc-timer" }), this.#e.onmessage = (e8) => {
              this.#n(e8);
            }, this.#t = {};
          }
          #n(e7) {
            const t10 = e7.data.id;
            this.#t[t10]();
          }
          async timeout(e7) {
            const t10 = this.#i();
            return new Promise((n8, i10) => {
              try {
                this.#t[t10] = () => {
                  this.#t[t10] = void 0, n8();
                }, this.#e.postMessage({ event: "timeout", payload: { id: t10, ms: e7 } });
              } catch (e8) {
                i10(e8);
              }
            });
          }
          #i() {
            return Math.random() * Math.random();
          }
          async interval(e7, t10) {
            const n8 = this.#i();
            return this.#t[n8] = () => {
              try {
                t10(n8);
              } catch (e8) {
                console.error(e8);
              }
            }, this.#e.postMessage({ event: "interval", payload: { id: n8, ms: e7 } }), n8;
          }
          clearInterval(e7) {
            this.#e.postMessage({ event: "resetInterval", payload: { id: e7 } });
          }
        }
        class AA {
          async timeout(e7) {
            return new Promise((t10, n8) => {
              try {
                setTimeout(() => {
                  t10();
                }, e7);
              } catch (e8) {
                n8(e8);
              }
            });
          }
          async interval(e7, t10) {
            return setInterval(() => {
              try {
                t10();
              } catch (e8) {
                console.error(e8);
              }
            }, e7);
          }
          clearInterval(e7) {
            clearInterval(e7);
          }
        }
        class gA {
          #r;
          constructor() {
            window.Worker ? this.#r = new dA() : this.#r = new AA();
          }
          timeout(e7) {
            return this.#r.timeout(e7);
          }
          interval(e7, t10) {
            return this.#r.interval(e7, t10);
          }
          clearInterval(e7) {
            return this.#r.clearInterval(e7);
          }
        }
        class pA {
          #o = null;
          error;
          #s;
          #a;
          #l = null;
          #c = false;
          #u = null;
          #d = null;
          #A = null;
          #g;
          #p;
          constructor(e7, t10 = "") {
            this.#a = e7, "" === t10 && (t10 = "https://" + e7 + ".frontendapi.corbado.io"), this.#s = t10, this.#g = new gA();
            const n8 = { cacheMaxAge: 6e5, cooldownDuration: 3e4, timeoutDuration: 5e3 };
            "" !== this.#a && (n8.headers = { "X-Corbado-ProjectID": this.#a }), this.#p = function(e8, t11) {
              const n9 = new cA(e8, t11);
              return async function(e9, t12) {
                return n9.getKey(e9, t12);
              };
            }(new URL(this.#s + "/.well-known/jwks"), n8), Va.configure((n9) => (n9.defaults.baseURL = t10, n9.defaults.timeout = 6e4, n9.defaults.withCredentials = true, "" !== e7 && (n9.defaults.headers.common["X-Corbado-ProjectID"] = e7), n9.defaults.headers.common["X-Corbado-Client-Timezone"] = Intl.DateTimeFormat().resolvedOptions().timeZone, n9)), document.addEventListener("visibilitychange", () => {
              this.#M();
            });
          }
          #M() {
            window.hidden || this.#f().catch((e7) => {
              null !== e7 && console.error(e7);
            });
          }
          #m = async (e7) => {
            const { payload: t10, protectedHeader: n8 } = await async function(e8, t11, n9) {
              var i10;
              const r9 = await eA(e8, t11, n9);
              if ((null === (i10 = r9.protectedHeader.crit) || void 0 === i10 ? void 0 : i10.includes("b64")) && false === r9.protectedHeader.b64)
                throw new Ud("JWTs MUST NOT use unencoded payload");
              const o8 = { payload: rA(r9.protectedHeader, r9.payload, n9), protectedHeader: r9.protectedHeader };
              return "function" == typeof t11 ? { ...o8, key: r9.key } : o8;
            }(e7, this.#p, {});
            return { protectedHeader: n8, payload: t10 };
          };
          #f = () => Va.get().put("/v1/sessions/refresh").then((e7) => (Ka(e7.data), e7.data)).catch((e7) => {
            if ("AxiosError" !== e7.name)
              throw e7;
            if ("ERR_NETWORK" === e7.code)
              throw this.error = "Network error - please check cors settings", this.#h(), null;
            if (e7.response && 401 === e7.response.status)
              throw this.#o = null, this.#y(null), function() {
                if (localStorage)
                  return localStorage.removeItem("cbo_long_session");
                console.error("No localstorage available");
              }(), null;
            throw e7;
          });
          #h = () => {
            null === this.#d && (this.#d = this.#g.interval(1e5).then((e7) => {
              this.#f().then(() => {
                this.#g.clearInterval(e7), this.#d = null;
              }).catch((e8) => {
                null !== e8 && console.error(e8);
              });
            }));
          };
          #I = () => {
            this.#f().then((e7) => {
              null !== e7 && this.#w();
            }).catch((e7) => {
              null !== e7 && console.error(e7);
            });
          };
          #w = () => {
            this.#m(qa("cbo_short_session")).then((e7) => {
              if (this.#c)
                return void (this.#c = false);
              const t10 = Math.floor(e7.payload.exp - (/* @__PURE__ */ new Date()).getTime() / 1e3);
              console.log("jwt expires in " + t10 + " sec"), this.#o = new uA(e7.payload.sub, e7.payload.orig, e7.payload.name, e7.payload.email ?? "", e7.payload.phone_number ?? ""), this.#y(this.#o), t10 <= 10 ? this.#I() : this.#l = this.#g.timeout(1e3 * (t10 - 10)).then(() => {
                this.#I();
              });
            });
          };
          #y = (e7) => {
            null !== this.#A && this.#A(e7);
          };
          #N = () => "" !== qa("cbo_short_session");
          refresh(e7) {
            if (this.#A = e7, null !== this.#u)
              return;
            let t10 = false;
            this.#N() ? (t10 = true, this.#w()) : this.#f().catch((e8) => {
              null !== e8 && console.error(e8);
            }), this.#u = this.#g.interval(200, () => {
              const e8 = this.#N();
              if (e8 && null === this.#l) {
                if (t10)
                  return void (t10 = false);
                this.#w();
              } else
                e8 || null === this.#l || (this.#c = true, this.#l = null, this.#y(null));
            });
          }
          async isAuthenticated() {
            return new Promise((e7, t10) => {
              this.#N() ? this.#m(qa("cbo_short_session")).then((t11) => {
                e7(true);
              }).catch((t11) => {
                null !== t11 && console.error("err", t11), e7(false);
              }) : this.#f().then((t11) => {
                e7(null !== t11);
              }).catch((t11) => {
                null !== t11 && console.error(t11), e7(false);
              });
            });
          }
          get currentUser() {
            return this.#o;
          }
          isAuthed() {
            return null !== this.#o;
          }
          logout() {
            return Va.get().delete("/v1/sessions/logout").then((e7) => {
              Ka(e7.data);
            }).catch((e7) => {
              console.error(e7);
            });
          }
        }
        const MA = { name: "PasskeyAppend", components: { ErrorHandler: td, StyledBtn: ic, Layout: md }, props: { "project-id": { type: String, required: true }, endpoint: { default: "", type: String } }, setup(e7, t10) {
          const n8 = yt2(false), i10 = yt2(new gd());
          Mn("errorHandler", i10);
          const r9 = new yl(i10), o8 = yt2(false), s10 = yt2(false);
          try {
            vl(e7.projectId);
            const t11 = "" !== e7.endpoint ? e7.endpoint : "https://" + e7.projectId + ".frontendapi.corbado.io";
            Tl(t11), Va.configure((n9) => (n9.defaults.baseURL = t11, n9.defaults.headers.common["X-Corbado-ProjectID"] = e7.projectId, n9)), new pA(e7.projectId, t11).isAuthenticated().then((e8) => {
              o8.value = e8;
            });
          } catch (e8) {
            return i10.value.error = { message: e8.message, links: "client" === e8.type ? [e8.link] : "", errorSide: "client" === e8.type ? "client" : "server", forceShowError: "client" === e8.type && e8.forceShowError }, {};
          }
          return { appendHandler: (e8) => {
            e8.preventDefault(), n8.value = true, s10.value = false, ml.debug("Initiate webauthn signup"), r9.CheckDevicePasskeyReadiness().then((e9) => {
              e9 ? r9.Append("").then((e10) => {
                ml.debug("Performed webauthn signup", { redirectURL: e10 }), n8.value = false, t10.emit("PASSKEY_CREATION_SUCCESSFUL");
              }).catch((e10) => {
                n8.value = false, null !== e10 && (s10.value = true, t10.emit("PASSKEY_CREATION_FAILED", { data: { err: e10 } }));
              }) : (n8.value = false, ml.error("Device not ready for webauthn signup"), t10.emit("DEVICE_NOT_PASSKEY_READY"));
            });
          }, appendLoading: n8, authed: o8, showDialog: s10 };
        } }, fA = (0, Fl.Z)(MA, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn"), a8 = qn("error-handler");
          return Vi(), Ki(Zi, null, [i10.showDialog ? (Vi(), Ki("div", yd, [rr("div", Id, [wd, Nd, rr("div", jd, [or(s10, { class: "btn-outline", onClick: t10[0] || (t10[0] = (e8) => i10.showDialog = false), style: { padding: "0.6rem 3.6rem" } }, { default: un(() => [ar("Ok ")]), _: 1 })])])])) : cr("v-if", true), i10.authed ? (Vi(), Ki("div", bd, [or(a8, null, { default: un(() => [rr("div", Dd, [or(s10, { type: "primary", dataAction: "sign_up", fullWidth: true, onClick: i10.appendHandler, isLoading: i10.appendLoading }, { default: un(() => [ar(" Create passkey ")]), _: 1 }, 8, ["onClick", "isLoading"])])]), _: 1 })])) : cr("v-if", true)], 64);
        }], ["styles", ["\n.dialog[data-v-52f7ab29] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  background: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.dialog-content[data-v-52f7ab29] {\n  padding: 20px;\n  background: #2A334C;\n  border-radius: 10px;\n}\n.dialog-header[data-v-52f7ab29] {\n  font-weight: bold;\n  margin-bottom: 10px;\n  color: white;\n}\n.dialog-body[data-v-52f7ab29] {\n  margin-bottom: 20px;\n  color: white;\n}\n.dialog-footer[data-v-52f7ab29] {\n  display: flex;\n  justify-content: space-between;\n}\n"]], ["__scopeId", "data-v-52f7ab29"]]), mA = { components: { PasskeyAppend: fA, Layout: md, TooManyRequests: dd, ConnectionTimeout: ld, ErrorHandler: td, InputField: $l, Register: fu, EmailLinkPending: uu, EmailLinkConfirm: lu, AppendPassKey: ru, Login: uc, LoginToken: Md }, setup(e7, t10) {
          const n8 = yt2(new gd());
          Mn("errorHandler", n8);
          const i10 = ac(yt2({ locale: "en", messages: { en: mu, de: hu, fr: yu } })), r9 = yt2(false), o8 = new $a(n8);
          try {
            !function(e8) {
              zl.forEach((t11) => {
                t11(e8);
              });
            }(e7), Sl.commit("setRequiredFromProps", e7), Va.configure((e8) => (e8.defaults.baseURL = Sl.state.webComponent.endpoint, e8.defaults.timeout = 6e4, e8.defaults.withCredentials = true, e8.defaults.headers.common["X-Corbado-Client-Timezone"] = Sl.state.webComponent.timeZone, "" !== Sl.state.webComponent.projectID && (e8.defaults.headers.common["X-Corbado-ProjectID"] = Sl.state.webComponent.projectID), e8)), function(e8) {
              Cl.forEach((t11) => {
                t11(e8);
              });
            }(e7), Sl.commit("setOptionalFromProps", e7), o8.ProjectConfig().then((e8) => {
              Sl.commit("setFromProjectConfig", ((e9) => ({ autoDetectLanguage: e9.autoDetectLanguage, fallbackLanguage: e9.fallbackLanguage, allowUserRegistration: e9.allowUserRegistration, passkeyAppendInterval: e9.passkeyAppendInterval, userFullNameRequired: e9.userFullNameRequired, webComponentDebug: e9.webComponentDebug, environment: e9.environment }))(e8)), i10.changeLocale(false === Sl.state.projectConfig.autoDetectLanguage ? Sl.state.projectConfig.fallbackLanguage : function(e9, t11) {
                const n9 = navigator.language.split("-")[0];
                return ["de", "en", "fr"].includes(n9) ? n9 : t11;
              }(0, Sl.state.projectConfig.fallbackLanguage)), r9.value = true;
            }).catch(() => {
              r9.value = true;
            });
          } catch (e8) {
            return n8.value.error = { message: e8.message, links: "client" === e8.type ? [e8.link] : "", errorSide: "client" === e8.type ? "client" : "server", forceShowError: "client" === e8.type && e8.forceShowError }, { renderPage: "", i18n: i10, loaded: r9 };
          }
          Sl.commit("setUsername", "" !== e7.username ? e7.username : localStorage.getItem("username") ?? ""), Sl.commit("setUserFullName", "" !== e7.userFullName ? e7.userFullName : ""), localStorage.getItem("username");
          const s10 = document.getElementById("corbado-username"), a8 = vr(() => {
            switch (Sl.state.pages.currentPage ?? e7.page) {
              case Ol.PAGE_LOGIN:
                switch (null !== s10 && s10.setAttribute("disabled", ""), Sl.state.user.currentLoginMethod) {
                  case Ul:
                    return vc;
                  case Pl:
                    return Pc;
                  case Ql:
                    return Jc;
                  case Rl:
                    return eu;
                }
                return null !== s10 && s10.removeAttribute("disabled"), uc;
              case Ol.PAGE_REGISTER:
                return null !== s10 && s10.removeAttribute("disabled"), false === Sl.state.projectConfig.allowUserRegistration ? uc : fu;
              case Ol.PAGE_EMAIL_PENDING:
                return uu;
              case Ol.PAGE_EMAIL_LINK_CONFIRM:
                return lu;
              case Ol.PAGE_APPEND_PASSKEY:
                return ru;
              case Ol.PAGE_TIMEOUT:
                return ld;
              case Ol.PAGE_TOO_MANY_REQUESTS:
                return dd;
              case Ol.PAGE_LOGIN_TOKEN:
                return Md;
              default:
                return "error";
            }
          });
          return Sl.commit("setCompanyImageUrl", e7.companyimageurl), null !== s10 && "yes" === e7.conditional && (s10.value = Sl.state.user.username, s10.addEventListener("focusin", () => {
            Sl.commit("setUserFieldFocus", true);
          }), s10.addEventListener("focusout", () => {
            Sl.commit("setUserFieldFocus", false);
          })), { renderPage: a8, i18n: i10, loaded: r9 };
        }, props: { endpoint: { default: "", type: String }, project_id: { default: "", type: String }, "project-id": { default: "", type: String }, conditional: { default: "no", type: String }, companyimageurl: { default: "", type: String }, "company-image-url": { default: "", type: String }, page: { default: Ol.PAGE_LOGIN, type: String }, register_title: { default: null, type: String }, "register-title": { default: null, type: String }, register_btn: { default: null, type: String }, "register-btn": { default: null, type: String }, login_title: { default: null, type: String }, "login-title": { default: null, type: String }, login_btn: { default: null, type: String }, "login-btn": { default: null, type: String }, sub_title: { default: null, type: String }, "sub-title": { default: null, type: String }, "passkey-append-title": { default: null, type: String }, "passkey-append-text": { default: null, type: String }, debug: { default: "no", type: String }, username: { default: "", type: String }, userFullName: { default: "", type: String }, mode: { default: "normal", type: String }, "disable-input-animation": { default: "no", type: String } }, beforeCreate() {
          Sl.dispatch("detectWebauthnSupported");
        } }, hA = (0, Fl.Z)(mA, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("error-handler");
          return Vi(), Ki("div", Mo, [or(s10, { style: { margin: "-2.5rem -2rem" } }, { default: un(() => [i10.loaded ? (Vi(), Ki(Zi, { key: 0 }, ["yes" === n8.conditional ? (Vi(), qi(ei(i10.renderPage), { key: 0 }, { usernameField: un(() => [ri(e7.$slots, "default")]), signupFields: un(() => [ri(e7.$slots, "signupFields")]), _: 3 })) : cr("v-if", true), "yes" !== n8.conditional ? (Vi(), qi(ei(i10.renderPage), { key: 1 })) : cr("v-if", true)], 64)) : cr("v-if", true)]), _: 3 })]);
        }], ["styles", ["\n#corbado-auth {\n  max-width: 384px;\n  box-sizing: border-box;\n  box-shadow: var(--box-shadow, none);\n  margin-top: var(--margin-top, inherit);\n}\n.container {\n  max-width: 30rem;\n}\n\n"]]]), yA = { class: "checkbox-container" }, IA = ["name", "id"], wA = ["for"], NA = { name: "CheckBoxField", components: { ErrorField: Jl }, props: { name: String, errorMessage: String }, setup({ name: e7, errorMessage: t10 }) {
          const n8 = yt2(""), i10 = yt2(false);
          return Sl.commit("addField", { name: e7, validate: function() {
            return n8.value = "", true !== i10.value && (n8.value = t10), "" === n8.value;
          } }), { errorMsg: n8, checked: i10 };
        } }, jA = (0, Fl.Z)(NA, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("error-field");
          return Vi(), Ki("div", null, [rr("div", yA, [Jn(rr("input", { type: "checkbox", name: n8.name, id: n8.name, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.checked = e8) }, null, 8, IA), [[lo, i10.checked]]), rr("label", { for: n8.name }, [ri(e7.$slots, "default", {}, void 0, true)], 8, wA)]), "" !== i10.errorMsg && void 0 !== i10.errorMsg ? (Vi(), qi(s10, { key: 0, "error-message": i10.errorMsg }, null, 8, ["error-message"])) : cr("v-if", true)]);
        }], ["styles", ["\n.checkbox-container[data-v-2edae24e] {\n  display: flex;\n  align-items: flex-start;\n}\nlabel[data-v-2edae24e] {\n  word-break: break-all;\n}\n"]], ["__scopeId", "data-v-2edae24e"]]), bA = { key: 0 }, DA = { key: 1 }, xA = { name: "AuthProvider", components: { ErrorHandler: td, Layout: md }, props: { endpoint: { default: "", type: String }, "project-id": { type: String } }, setup(e7, t10) {
          const n8 = yt2(new gd());
          Mn("errorHandler", n8);
          try {
            vl(e7.projectId), "" !== e7.endpoint && Tl(e7.endpoint);
            const t11 = "" !== e7.endpoint ? e7.endpoint : "https://" + e7.projectId + ".frontendapi.corbado.io", n9 = new pA(e7.projectId, t11), i10 = yt2(false);
            return n9.refresh((e8) => {
              i10.value = null !== e8;
            }), { authed: i10 };
          } catch (e8) {
            return n8.value.error = { message: e8.message, links: "client" === e8.type ? [e8.link] : "", errorSide: "client" === e8.type ? "client" : "server", forceShowError: "client" === e8.type && e8.forceShowError }, {};
          }
        } }, LA = (0, Fl.Z)(xA, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("error-handler");
          return Vi(), Ki("div", null, [or(s10, null, { default: un(() => [e7.authed ? (Vi(), Ki("div", bA, [ri(e7.$slots, "authed")])) : cr("v-if", true), e7.authed ? cr("v-if", true) : (Vi(), Ki("div", DA, [ri(e7.$slots, "unauthed")])), ri(e7.$slots, "default")]), _: 3 })]);
        }]]), vA = { id: "corbado-passkey-associate", style: { display: "flex", "justify-content": "center", "flex-direction": "column", "align-items": "center" } }, TA = { style: { "margin-top": "1rem" } }, zA = { name: "PasskeyAssociate", components: { ErrorHandler: td, StyledBtn: ic, Layout: md }, props: { "project-id": { type: String, required: true }, endpoint: { default: "", type: String }, associationToken: { type: String, required: true } }, setup(e7, t10) {
          const n8 = yt2(false), i10 = yt2(new gd());
          Mn("errorHandler", i10);
          const r9 = new yl(i10);
          try {
            vl(e7.projectId), function(e8) {
              if (void 0 === e8)
                throw new xl('Missing attribute "association-token"', "https://docs.corbado.com/web-app-integrations/web-component", true);
              if (!e8.startsWith("ast1_"))
                throw new xl('Invalid attribute "association-token": It must start with "ast1_"', "https://docs.corbado.com/web-app-integrations/web-component", true);
              if (35 !== e8.length)
                throw new xl('Invalid attribute "association-token": The length must be exactly 35 chars', "https://docs.corbado.com/web-app-integrations/web-component", true);
            }(e7.associationToken);
            const t11 = "" !== e7.endpoint ? e7.endpoint : "https://" + e7.projectId + ".frontendapi.corbado.io";
            Tl(t11), Va.configure((n9) => (n9.defaults.baseURL = t11, n9.defaults.headers.common["X-Corbado-ProjectID"] = e7.projectId, n9));
          } catch (e8) {
            return i10.value.error = { message: e8.message, links: "client" === e8.type ? [e8.link] : "", errorSide: "client" === e8.type ? "client" : "server", forceShowError: "client" === e8.type && e8.forceShowError }, {};
          }
          return { associateHandler: (i11) => {
            i11.preventDefault(), n8.value = true, ml.debug("Initiate webauthn signup"), r9.CheckDevicePasskeyReadiness().then((i12) => {
              i12 ? r9.AssociateStart(e7.associationToken).then((e8) => {
                ml.debug("Performed webauthn signup", { redirectURL: e8 }), n8.value = false, t10.emit("PASSKEY_CREATION_SUCCESSFUL");
              }).catch((e8) => {
                n8.value = false, null !== e8 && (ml.error("Associate register failed", e8), t10.emit("PASSKEY_CREATION_FAILED", { data: { err: e8 } }));
              }) : (n8.value = false, ml.error("Device not ready for webauthn signup"), t10.emit("DEVICE_NOT_PASSKEY_READY"));
            });
          }, associateLoading: n8 };
        } }, CA = (0, Fl.Z)(zA, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn"), a8 = qn("error-handler");
          return Vi(), Ki("div", vA, [or(a8, null, { default: un(() => [rr("div", TA, [or(s10, { type: "primary", dataAction: "sign_up", fullWidth: true, onClick: i10.associateHandler, isLoading: i10.associateLoading }, { default: un(() => [ar(" Create passkey ")]), _: 1 }, 8, ["onClick", "isLoading"])])]), _: 1 })]);
        }], ["styles", ["\nsvg[data-v-195a8eda] {\n    margin-top: 0.3rem;\n}\n*[data-v-195a8eda] {\n    color: #5D6785;\n}\n#corbado-passkey-associate[data-v-195a8eda] {\n     max-width: 384px;\n     box-sizing: border-box;\n     box-shadow: var(--box-shadow, none);\n     margin-top: var(--margin-top, inherit);\n}\n"]], ["__scopeId", "data-v-195a8eda"]]), SA = { id: "corbado-passkey-associate-login", class: "container", style: { display: "flex", "justify-content": "center", "flex-direction": "column", "align-items": "center" } }, EA = { class: "input-group" }, kA = "PASSKEY_NOT_EXISTS", OA = { components: { StyledBtn: ic, InputField: $l }, props: { "project-id": { type: String, required: true }, endpoint: { default: "", type: String }, loginButtonClass: { default: "", type: String } }, setup(e7, t10) {
          const n8 = yt2(false), i10 = yt2(""), r9 = yt2({}), o8 = yt2(new gd());
          Mn("errorHandler", o8);
          const s10 = new yl(o8), a8 = new $a(o8);
          vl(e7.projectId);
          const l8 = "" !== e7.endpoint ? e7.endpoint : "https://" + e7.projectId + ".frontendapi.corbado.io";
          return Tl(l8), ml.debug("Setup PasskeyAssociateLogin", { props: e7, endpoint: l8 }), Va.configure((t11) => (t11.defaults.baseURL = l8, t11.defaults.headers.common["X-Corbado-ProjectID"] = e7.projectId, t11)), n8.value = false, { loginLoading: n8, errorMessage: r9, associateLoginHandler: (e8) => {
            e8.preventDefault(), r9.value = {}, 0 !== i10.value.trim().length ? (n8.value = true, a8.DevicePasskey(i10.value, "email").then((e9) => {
              if (ml.debug("Device has passkey:", { rsp: e9 }), !e9.data.exists)
                return n8.value = false, void t10.emit(kA);
              ml.debug("Start webauthn signin"), s10.AssociateLogin(i10.value).then((e10) => {
                ml.debug("Finish webauthn signin", { redirectURL: e10 }), t10.emit("PASSKEY_LOGIN_SUCCESSFUL", { data: { redirectURL: e10 } }), n8.value = false, window.location = e10;
              }).catch((e10) => {
                null !== e10 && (n8.value = false, ml.debug("Webauthn signin failed with error", { err: e10 }), r9.value = e10, t10.emit("PASSKEY_LOGIN_FAILED", { data: { err: e10 } }));
              });
            }).catch((e9) => {
              null !== e9 && (n8.value = false, ml.debug("Device passkey failed with error", { err: e9 }), r9.value = e9, t10.emit(kA, { data: { err: e9 } }));
            })) : r9.value = { username: "Please enter a username" };
          }, username: i10 };
        } }, PA = (0, Fl.Z)(OA, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("input-field"), a8 = qn("styled-btn");
          return Vi(), Ki("div", SA, [rr("form", { onSubmit: t10[1] || (t10[1] = (...e8) => i10.associateLoginHandler && i10.associateLoginHandler(...e8)) }, [rr("div", EA, [or(s10, gr({ id: "username", type: "email", name: "username", autocomplete: "username webauthn", label: "Email", value: i10.username, modelValue: i10.username, "onUpdate:modelValue": t10[0] || (t10[0] = (e8) => i10.username = e8), "error-message": i10.errorMessage.username }, { class: n8.loginButtonClass }), null, 16, ["value", "modelValue", "error-message"])]), or(a8, { onClick: i10.associateLoginHandler, type: "primary", dataAction: "continue", fullWidth: true, isLoading: i10.loginLoading }, { default: un(() => [ar("Continue ")]), _: 1 }, 8, ["onClick", "isLoading"])], 32)]);
        }], ["styles", ["\n#corbado-passkey-associate-login[data-v-09d7c68a] {\n  max-width: 384px;\n  box-sizing: border-box;\n  box-shadow: var(--box-shadow, none);\n  margin-top: var(--margin-top, inherit);\n}\n"]], ["__scopeId", "data-v-09d7c68a"]]), UA = { name: "LogoutHandler", props: { endpoint: { type: String, default: "" }, "redirect-url": { type: String }, "project-id": { type: String } }, setup(e7) {
          vl(e7.projectId), "" !== e7.endpoint && Tl(e7.endpoint);
          const t10 = "" !== e7.endpoint ? e7.endpoint : "https://" + e7.projectId + ".frontendapi.corbado.io", n8 = new pA(e7.projectId, t10);
          return { logout: () => n8.logout().then(() => {
            "" !== e7.redirectUrl && (window.location = e7.redirectUrl);
          }) };
        } }, QA = (0, Fl.Z)(UA, [["render", function(e7, t10, n8, i10, r9, o8) {
          return Vi(), Ki("div", { onClick: t10[0] || (t10[0] = (...e8) => i10.logout && i10.logout(...e8)) }, [ri(e7.$slots, "default")]);
        }]]), RA = (e7) => (ln("data-v-7ee4117c"), e7 = e7(), cn2(), e7), YA = { key: 0, class: "dialog" }, ZA = { class: "dialog-content" }, BA = RA(() => rr("div", { class: "dialog-header" }, "Delete passkey", -1)), WA = RA(() => rr("div", { class: "dialog-body" }, "Are you sure you want to delete the passkey?", -1)), GA = { class: "dialog-footer" }, HA = { key: 0 }, _A = { key: 0 }, VA = { style: { "margin-bottom": "20px", display: "flex" } }, FA = { class: "v-col container", style: { width: "100%", "padding-top": "0px", "padding-bottom": "0px", "min-height": "0" } }, JA = { class: "row", style: { "flex-wrap": "nowrap", "margin-right": "0px", "margin-left": "0px" } }, XA = { class: "passkey-icon-container col-sm-1" }, KA = { key: 0 }, qA = ["innerHTML"], $A = { class: "col-sm-10" }, eg = { class: "row passkey-attribute" }, tg = { class: "col-sm-12", style: { display: "flex", "align-items": "center" } }, ng = { style: { color: "#fff" } }, ig = { key: 0, class: "passkey-type-badge" }, rg = { class: "row passkey-attribute" }, og = { class: "col-sm-12 col-md-12 col-lg-12" }, sg = RA(() => rr("b", null, "Credential ID:", -1)), ag = { class: "row passkey-attribute" }, lg = { class: "col-sm-12 col-md-12 col-lg-12" }, cg = RA(() => rr("b", null, "Created:", -1)), ug = { class: "row passkey-attribute" }, dg = { class: "col-sm-12 col-md-12 col-lg-12" }, Ag = RA(() => rr("b", null, "Last used:", -1)), gg = { class: "row passkey-attribute" }, pg = { class: "col-sm-12 col-md-12 col-lg-12" }, Mg = RA(() => rr("b", null, "Status:", -1)), fg = ["onClick"], mg = [RA(() => rr("svg", { xmlns: "http://www.w3.org/2000/svg", height: "30", viewBox: "0 0 24 24", width: "30" }, [rr("path", { d: "M0 0h24v24H0z", fill: "none" }), rr("path", { d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z", fill: "white" })], -1))], hg = { key: 1 }, yg = { key: 0 }, Ig = [RA(() => rr("div", { class: "row" }, [rr("div", { class: "col-sm-12 col-md-12 col-lg-12" }, [rr("p", null, "No passkeys found")])], -1))];
        var wg = n7(238);
        const Ng = { "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4": { name: "Google Password Manager", icon_dark: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE5MiAxOTIiIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDE5MiAxOTIiIHdpZHRoPSIyNHB4Ij48cmVjdCBmaWxsPSJub25lIiBoZWlnaHQ9IjE5MiIgd2lkdGg9IjE5MiIgeT0iMCIvPjxnPjxwYXRoIGQ9Ik02OS4yOSwxMDZjLTMuNDYsNS45Ny05LjkxLDEwLTE3LjI5LDEwYy0xMS4wMywwLTIwLTguOTctMjAtMjBzOC45Ny0yMCwyMC0yMCBjNy4zOCwwLDEzLjgzLDQuMDMsMTcuMjksMTBoMjUuNTVDOTAuMyw2Ni41NCw3Mi44Miw1Miw1Miw1MkMyNy43NCw1Miw4LDcxLjc0LDgsOTZzMTkuNzQsNDQsNDQsNDRjMjAuODIsMCwzOC4zLTE0LjU0LDQyLjg0LTM0IEg2OS4yOXoiIGZpbGw9IiM0Mjg1RjQiLz48cmVjdCBmaWxsPSIjRkJCQzA0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iNDQiIHg9Ijk0IiB5PSI4NCIvPjxwYXRoIGQ9Ik05NC4zMiw4NEg2OHYwLjA1YzIuNSwzLjM0LDQsNy40Nyw0LDExLjk1cy0xLjUsOC42MS00LDExLjk1VjEwOGgyNi4zMiBjMS4wOC0zLjgyLDEuNjgtNy44NCwxLjY4LTEyUzk1LjQxLDg3LjgyLDk0LjMyLDg0eiIgZmlsbD0iI0VBNDMzNSIvPjxwYXRoIGQ9Ik0xODQsMTA2djI2aC0xNnYtOGMwLTQuNDItMy41OC04LTgtOHMtOCwzLjU4LTgsOHY4aC0xNnYtMjZIMTg0eiIgZmlsbD0iIzM0QTg1MyIvPjxyZWN0IGZpbGw9IiMxODgwMzgiIGhlaWdodD0iMjQiIHdpZHRoPSI0OCIgeD0iMTM2IiB5PSI4NCIvPjwvZz48L3N2Zz4=", icon_light: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE5MiAxOTIiIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDE5MiAxOTIiIHdpZHRoPSIyNHB4Ij48cmVjdCBmaWxsPSJub25lIiBoZWlnaHQ9IjE5MiIgd2lkdGg9IjE5MiIgeT0iMCIvPjxnPjxwYXRoIGQ9Ik02OS4yOSwxMDZjLTMuNDYsNS45Ny05LjkxLDEwLTE3LjI5LDEwYy0xMS4wMywwLTIwLTguOTctMjAtMjBzOC45Ny0yMCwyMC0yMCBjNy4zOCwwLDEzLjgzLDQuMDMsMTcuMjksMTBoMjUuNTVDOTAuMyw2Ni41NCw3Mi44Miw1Miw1Miw1MkMyNy43NCw1Miw4LDcxLjc0LDgsOTZzMTkuNzQsNDQsNDQsNDRjMjAuODIsMCwzOC4zLTE0LjU0LDQyLjg0LTM0IEg2OS4yOXoiIGZpbGw9IiM0Mjg1RjQiLz48cmVjdCBmaWxsPSIjRkJCQzA0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iNDQiIHg9Ijk0IiB5PSI4NCIvPjxwYXRoIGQ9Ik05NC4zMiw4NEg2OHYwLjA1YzIuNSwzLjM0LDQsNy40Nyw0LDExLjk1cy0xLjUsOC42MS00LDExLjk1VjEwOGgyNi4zMiBjMS4wOC0zLjgyLDEuNjgtNy44NCwxLjY4LTEyUzk1LjQxLDg3LjgyLDk0LjMyLDg0eiIgZmlsbD0iI0VBNDMzNSIvPjxwYXRoIGQ9Ik0xODQsMTA2djI2aC0xNnYtOGMwLTQuNDItMy41OC04LTgtOHMtOCwzLjU4LTgsOHY4aC0xNnYtMjZIMTg0eiIgZmlsbD0iIzM0QTg1MyIvPjxyZWN0IGZpbGw9IiMxODgwMzgiIGhlaWdodD0iMjQiIHdpZHRoPSI0OCIgeD0iMTM2IiB5PSI4NCIvPjwvZz48L3N2Zz4=" }, "adce0002-35bc-c60a-648b-0b25f1f05503": { name: "Chrome on Mac", icon_dark: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNDggNDgiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMy4yMTczIiB5MT0iMTUiIHgyPSI0NC43ODEyIiB5Mj0iMTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZDkzMDI1Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2VhNDMzNSIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjIwLjcyMTkiIHkxPSI0Ny42NzkxIiB4Mj0iNDEuNTAzOSIgeTI9IjExLjY4MzciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmNjOTM0Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2ZiYmMwNCIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjI2LjU5ODEiIHkxPSI0Ni41MDE1IiB4Mj0iNS44MTYxIiB5Mj0iMTAuNTA2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzFlOGUzZSIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNGE4NTMiLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAKICAgIDxwYXRoIGlkPSJwIiBkPSJNMTMuNjA4NiAzMC4wMDMxIDMuMjE4IDEyLjAwNkEyMy45OTQgMjMuOTk0IDAgMCAwIDI0LjAwMjUgNDhsMTAuMzkwNi0xNy45OTcxLS4wMDY3LS4wMDY4YTExLjk4NTIgMTEuOTg1MiAwIDAgMS0yMC43Nzc4LjAwN1oiLz4KICA8L2RlZnM+CiAgCiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNhKSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDI0IDI0KSIvPgogIDx1c2UgeGxpbms6aHJlZj0iI3AiIGZpbGw9InVybCgjYikiIHRyYW5zZm9ybT0icm90YXRlKC0xMjAgMjQgMjQpIi8+CiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNjKSIvPgogIAogIDxjaXJjbGUgY3g9IjI0IiBjeT0iMjQiIHI9IjEyIiBzdHlsZT0iZmlsbDojZmZmIi8+CiAgPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iOS41IiBzdHlsZT0iZmlsbDojMWE3M2U4Ii8+Cjwvc3ZnPg==", icon_light: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNDggNDgiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMy4yMTczIiB5MT0iMTUiIHgyPSI0NC43ODEyIiB5Mj0iMTUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZDkzMDI1Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2VhNDMzNSIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjIwLjcyMTkiIHkxPSI0Ny42NzkxIiB4Mj0iNDEuNTAzOSIgeTI9IjExLjY4MzciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmNjOTM0Ii8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2ZiYmMwNCIvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjI2LjU5ODEiIHkxPSI0Ni41MDE1IiB4Mj0iNS44MTYxIiB5Mj0iMTAuNTA2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzFlOGUzZSIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNGE4NTMiLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAKICAgIDxwYXRoIGlkPSJwIiBkPSJNMTMuNjA4NiAzMC4wMDMxIDMuMjE4IDEyLjAwNkEyMy45OTQgMjMuOTk0IDAgMCAwIDI0LjAwMjUgNDhsMTAuMzkwNi0xNy45OTcxLS4wMDY3LS4wMDY4YTExLjk4NTIgMTEuOTg1MiAwIDAgMS0yMC43Nzc4LjAwN1oiLz4KICA8L2RlZnM+CiAgCiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNhKSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDI0IDI0KSIvPgogIDx1c2UgeGxpbms6aHJlZj0iI3AiIGZpbGw9InVybCgjYikiIHRyYW5zZm9ybT0icm90YXRlKC0xMjAgMjQgMjQpIi8+CiAgPHVzZSB4bGluazpocmVmPSIjcCIgZmlsbD0idXJsKCNjKSIvPgogIAogIDxjaXJjbGUgY3g9IjI0IiBjeT0iMjQiIHI9IjEyIiBzdHlsZT0iZmlsbDojZmZmIi8+CiAgPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iOS41IiBzdHlsZT0iZmlsbDojMWE3M2U4Ii8+Cjwvc3ZnPg==" }, "08987058-cadc-4b81-b6e1-30de50dcbe96": { name: "Windows Hello", icon_dark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==", icon_light: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==" }, "9ddd1817-af5a-4672-a2b9-3e3dd95000a9": { name: "Windows Hello", icon_dark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==", icon_light: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==" }, "6028b017-b1d4-4c02-b4b3-afcdafc96bb2": { name: "Windows Hello", icon_dark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==", icon_light: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiMwMDc4ZDQ7c3Ryb2tlLXdpZHRoOjBweDt9PC9zdHlsZT48L2RlZnM+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIyNC4yNSIgeT0iMjQuMjUiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMTMzLjQiIHk9IjI0LjI1IiB3aWR0aD0iOTguMzUiIGhlaWdodD0iOTguMzUiLz48cmVjdCBjbGFzcz0iY2xzLTEiIHg9IjI0LjI1IiB5PSIxMzMuNCIgd2lkdGg9Ijk4LjM1IiBoZWlnaHQ9Ijk4LjM1Ii8+PHJlY3QgY2xhc3M9ImNscy0xIiB4PSIxMzMuNCIgeT0iMTMzLjQiIHdpZHRoPSI5OC4zNSIgaGVpZ2h0PSI5OC4zNSIvPjwvc3ZnPg==" }, "dd4ec289-e01d-41c9-bb89-70fa845d4bf2": { name: "Apple iCloud Keychain (Managed)" }, "531126d6-e717-415c-9320-3d9aa6981239": { name: "Dashlane", icon_dark: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIGZpbGw9IiNGRkZGRkYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01NS45MzE1IDIwLjk0MDVDNTUuOTMxNSAyMC41NTYxIDU1LjU0NzEgMjAuMTcxNyA1NS4wMDc5IDIwLjAxNzlMNDguNTQ0NiAxNy42MzU4QzQ3LjQ2ODMgMTcuMTc0NSA0Ni4yMzcyIDE3LjcxMjcgNDYuMjM3MiAxOC40ODI1VjQ1LjU2MjRDNDYuMjM3MiA0NS45NDY4IDQ2LjYyMTUgNDYuNDA4MSA0Ny4wMDU5IDQ2LjU2MThMNTMuNjIzIDQ4Ljk0NEM1NC42MjM1IDQ5LjMyODQgNTUuOTMxNSA0OC43OTAyIDU1LjkzMTUgNDcuOTQzNVYyMC45NDA1Wk00My44NTE3IDExLjQ3NzlDNDMuODUxNyAxMS4wOTI0IDQzLjQ2NzMgMTAuNzA4IDQyLjkyODEgMTAuNTU0MkwzNi40NjU5IDguMTcyMDZDMzUuMzg4NSA3LjcxMDc4IDM0LjE1NzQgOC4yNDg5NCAzNC4xNTc0IDkuMDE4ODFWMjUuNDgwN0MzNC4xNTc0IDI1Ljg2NTEgMzQuNTQxOCAyNi4zMjY0IDM0LjkyNjIgMjYuNDgxMkw0MS41NDMyIDI4Ljg2MzRDNDIuNTQzNyAyOS4yNDg5IDQzLjg1MTcgMjguNzA5NiA0My44NTE3IDI3Ljg2NFYxMS40Nzc5Wk00My44NTE3IDQxLjA5OTFDNDMuODUxNyA0MC43MTQ3IDQzLjQ2NzMgNDAuMzMwMyA0Mi45MjgxIDQwLjE3NjVMMzYuNDY1OSAzNy43OTQ0QzM1LjM4ODUgMzcuMzMzMSAzNC4xNTc0IDM3Ljg3MTIgMzQuMTU3NCAzOC42NDExVjU1LjEwM0MzNC4xNTc0IDU1LjQ4NzQgMzQuNTQxOCA1NS45NDg3IDM0LjkyNjIgNTYuMTAyNEw0MS41NDMyIDU4LjQ4NDZDNDIuNTQzNyA1OC44NzAxIDQzLjg1MTcgNTguMzMwOCA0My44NTE3IDU3LjQ4NDFWNDEuMDk5MVpNMzEuNzcyIDQ0LjQwODFDMzEuNzcyIDQ0LjAyMzcgMzEuMzg3NiA0My42MzgzIDMwLjg0ODMgNDMuNDg0NUwyNC4zODYyIDQxLjEwMjNDMjMuMzAzMyA0MC42NDEgMjIuMDc3NiA0MS4xNzkyIDIyLjA3NzYgNDEuOTQ5MVY1OS40OTA1QzIyLjA3NzYgNTkuODc0OSAyMi40NjIgNjAuMzM3MyAyMi44NDY0IDYwLjQ5MUwyOS40NjM0IDYyLjg3MzJDMzAuNDYzOSA2My4yNTg3IDMxLjc3MiA2Mi43MTk0IDMxLjc3MiA2MS44NzM4VjQ0LjQwODFaTTMxLjc3MiA0LjQ3NTM2QzMxLjc3MiA0LjA5MDk3IDMxLjM4NzYgMy43MDY1NyAzMC44NDgzIDMuNTUyODFMMjQuMzg2MiAxLjE3MDY0QzIzLjMwMzMgMC43MDkzNjkgMjIuMDc3NiAxLjI0NzUyIDIyLjA3NzYgMi4wMTc0VjE5LjU1ODhDMjIuMDc3NiAxOS45NDQzIDIyLjQ2MiAyMC40MDU2IDIyLjg0NjQgMjAuNTU5M0wyOS40NjM0IDIyLjk0MTVDMzAuNDYzOSAyMy4zMjU5IDMxLjc3MiAyMi43ODc4IDMxLjc3MiAyMS45NDFWNC40NzUzNlpNMTkuNjk0NCA1LjE2ODM2QzE5LjY5NDQgNC43ODM5NiAxOS4zMSA0LjM5ODQ4IDE4Ljc3MDcgNC4yNDQ3M0wxMi4zMDg1IDEuODYyNTZDMTEuMjMxMiAxLjQwMTI4IDEwIDEuOTM5NDQgMTAgMi43MDkzMVY1OC44NzMzQzEwIDU5LjI1NzcgMTAuMzg0NCA1OS43MTkgMTAuNzY5OSA1OS44NzI3TDE3LjM4NTggNjIuMjU0OUMxOC4zODYzIDYyLjYzOTMgMTkuNjk0NCA2Mi4xMDEyIDE5LjY5NDQgNjEuMjU0NFY1LjE2ODM2WiIgLz4KPC9zdmc+Cg==", icon_light: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIGZpbGw9IiMwRTM1M0QiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01NS45MzE1IDIwLjk0MDVDNTUuOTMxNSAyMC41NTYxIDU1LjU0NzEgMjAuMTcxNyA1NS4wMDc5IDIwLjAxNzlMNDguNTQ0NiAxNy42MzU4QzQ3LjQ2ODMgMTcuMTc0NSA0Ni4yMzcyIDE3LjcxMjcgNDYuMjM3MiAxOC40ODI1VjQ1LjU2MjRDNDYuMjM3MiA0NS45NDY4IDQ2LjYyMTUgNDYuNDA4MSA0Ny4wMDU5IDQ2LjU2MThMNTMuNjIzIDQ4Ljk0NEM1NC42MjM1IDQ5LjMyODQgNTUuOTMxNSA0OC43OTAyIDU1LjkzMTUgNDcuOTQzNVYyMC45NDA1Wk00My44NTE3IDExLjQ3NzlDNDMuODUxNyAxMS4wOTI0IDQzLjQ2NzMgMTAuNzA4IDQyLjkyODEgMTAuNTU0MkwzNi40NjU5IDguMTcyMDZDMzUuMzg4NSA3LjcxMDc4IDM0LjE1NzQgOC4yNDg5NCAzNC4xNTc0IDkuMDE4ODFWMjUuNDgwN0MzNC4xNTc0IDI1Ljg2NTEgMzQuNTQxOCAyNi4zMjY0IDM0LjkyNjIgMjYuNDgxMkw0MS41NDMyIDI4Ljg2MzRDNDIuNTQzNyAyOS4yNDg5IDQzLjg1MTcgMjguNzA5NiA0My44NTE3IDI3Ljg2NFYxMS40Nzc5Wk00My44NTE3IDQxLjA5OTFDNDMuODUxNyA0MC43MTQ3IDQzLjQ2NzMgNDAuMzMwMyA0Mi45MjgxIDQwLjE3NjVMMzYuNDY1OSAzNy43OTQ0QzM1LjM4ODUgMzcuMzMzMSAzNC4xNTc0IDM3Ljg3MTIgMzQuMTU3NCAzOC42NDExVjU1LjEwM0MzNC4xNTc0IDU1LjQ4NzQgMzQuNTQxOCA1NS45NDg3IDM0LjkyNjIgNTYuMTAyNEw0MS41NDMyIDU4LjQ4NDZDNDIuNTQzNyA1OC44NzAxIDQzLjg1MTcgNTguMzMwOCA0My44NTE3IDU3LjQ4NDFWNDEuMDk5MVpNMzEuNzcyIDQ0LjQwODFDMzEuNzcyIDQ0LjAyMzcgMzEuMzg3NiA0My42MzgzIDMwLjg0ODMgNDMuNDg0NUwyNC4zODYyIDQxLjEwMjNDMjMuMzAzMyA0MC42NDEgMjIuMDc3NiA0MS4xNzkyIDIyLjA3NzYgNDEuOTQ5MVY1OS40OTA1QzIyLjA3NzYgNTkuODc0OSAyMi40NjIgNjAuMzM3MyAyMi44NDY0IDYwLjQ5MUwyOS40NjM0IDYyLjg3MzJDMzAuNDYzOSA2My4yNTg3IDMxLjc3MiA2Mi43MTk0IDMxLjc3MiA2MS44NzM4VjQ0LjQwODFaTTMxLjc3MiA0LjQ3NTM2QzMxLjc3MiA0LjA5MDk3IDMxLjM4NzYgMy43MDY1NyAzMC44NDgzIDMuNTUyODFMMjQuMzg2MiAxLjE3MDY0QzIzLjMwMzMgMC43MDkzNjkgMjIuMDc3NiAxLjI0NzUyIDIyLjA3NzYgMi4wMTc0VjE5LjU1ODhDMjIuMDc3NiAxOS45NDQzIDIyLjQ2MiAyMC40MDU2IDIyLjg0NjQgMjAuNTU5M0wyOS40NjM0IDIyLjk0MTVDMzAuNDYzOSAyMy4zMjU5IDMxLjc3MiAyMi43ODc4IDMxLjc3MiAyMS45NDFWNC40NzUzNlpNMTkuNjk0NCA1LjE2ODM2QzE5LjY5NDQgNC43ODM5NiAxOS4zMSA0LjM5ODQ4IDE4Ljc3MDcgNC4yNDQ3M0wxMi4zMDg1IDEuODYyNTZDMTEuMjMxMiAxLjQwMTI4IDEwIDEuOTM5NDQgMTAgMi43MDkzMVY1OC44NzMzQzEwIDU5LjI1NzcgMTAuMzg0NCA1OS43MTkgMTAuNzY5OSA1OS44NzI3TDE3LjM4NTggNjIuMjU0OUMxOC4zODYzIDYyLjYzOTMgMTkuNjk0NCA2Mi4xMDEyIDE5LjY5NDQgNjEuMjU0NFY1LjE2ODM2WiIgLz4KPC9zdmc+Cg==" }, "bada5566-a7aa-401f-bd96-45619a55120d": { name: "1Password", icon_dark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQwIiBoZWlnaHQ9IjI0MCIgdmlld0JveD0iMCAwIDI0MCAyNDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjM5LjI1NyAxMjAuNDE3QzIzOS4yNTcgNTQuNDE5MyAxODUuNzU1IDAuOTE2NTA0IDExOS43NTcgMC45MTY1MDRDNTMuNzYwMSAwLjkxNjUwNCAwLjI1NzMyNCA1NC40MTkzIDAuMjU3MzI0IDEyMC40MTdDMC4yNTczMjQgMTg2LjQxNyA1My43NjAxIDIzOS45MTcgMTE5Ljc1NyAyMzkuOTE3QzE4NS43NTUgMjM5LjkxNyAyMzkuMjU3IDE4Ni40MTcgMjM5LjI1NyAxMjAuNDE3Wk05OC4wMDY5IDU0LjAyNzZDOTcuMDY3NCA1NS44NzE0IDk3LjA2NzQgNTguMjg1MSA5Ny4wNjc0IDYzLjExMjZWOTAuNDcyOUM5Ny4wNjc0IDkxLjY3ODggOTcuMDY3NCA5Mi4yODE3IDk3LjIxOTYgOTIuODM5MkM5Ny4zNTQ1IDkzLjMzMzEgOTcuNTc2MyA5My43OTkgOTcuODc0NiA5NC4yMTVDOTguMjExMyA5NC42ODQ3IDk4LjY3OTIgOTUuMDY0OCA5OS42MTUyIDk1LjgyNTFMMTA2LjUzNiAxMDEuNDQ3QzEwNy42NjQgMTAyLjM2NCAxMDguMjI4IDEwMi44MjIgMTA4LjQzMyAxMDMuMzc0QzEwOC42MTMgMTAzLjg1NyAxMDguNjEzIDEwNC4zOSAxMDguNDMzIDEwNC44NzNDMTA4LjIyOCAxMDUuNDI1IDEwNy42NjQgMTA1Ljg4MyAxMDYuNTM2IDEwNi44TDk5LjYxNTIgMTEyLjQyMkM5OC42NzkzIDExMy4xODIgOTguMjExMyAxMTMuNTYyIDk3Ljg3NDYgMTE0LjAzMkM5Ny41NzYzIDExNC40NDggOTcuMzU0NSAxMTQuOTE0IDk3LjIxOTYgMTE1LjQwOEM5Ny4wNjc0IDExNS45NjUgOTcuMDY3NCAxMTYuNTY4IDk3LjA2NzQgMTE3Ljc3NFYxNzcuNzE5Qzk3LjA2NzQgMTgyLjU0NyA5Ny4wNjc0IDE4NC45NjEgOTguMDA2OSAxODYuODA1Qzk4LjgzMzMgMTg4LjQyNiAxMDAuMTUyIDE4OS43NDUgMTAxLjc3NCAxOTAuNTcxQzEwMy42MTggMTkxLjUxMSAxMDYuMDMxIDE5MS41MTEgMTEwLjg1OSAxOTEuNTExSDEyOC42NTZDMTMzLjQ4MyAxOTEuNTExIDEzNS44OTcgMTkxLjUxMSAxMzcuNzQxIDE5MC41NzFDMTM5LjM2MyAxODkuNzQ1IDE0MC42ODEgMTg4LjQyNiAxNDEuNTA4IDE4Ni44MDVDMTQyLjQ0NyAxODQuOTYxIDE0Mi40NDcgMTgyLjU0NyAxNDIuNDQ3IDE3Ny43MTlWMTUwLjM1OUMxNDIuNDQ3IDE0OS4xNTMgMTQyLjQ0NyAxNDguNTUgMTQyLjI5NSAxNDcuOTkzQzE0Mi4xNiAxNDcuNDk5IDE0MS45MzggMTQ3LjAzMyAxNDEuNjQgMTQ2LjYxN0MxNDEuMzAzIDE0Ni4xNDcgMTQwLjgzNSAxNDUuNzY3IDEzOS44OTkgMTQ1LjAwN0wxMzIuOTc4IDEzOS4zODVDMTMxLjg1IDEzOC40NjggMTMxLjI4NiAxMzguMDEgMTMxLjA4MiAxMzcuNDU5QzEzMC45MDIgMTM2Ljk3NSAxMzAuOTAyIDEzNi40NDMgMTMxLjA4MiAxMzUuOTU5QzEzMS4yODYgMTM1LjQwNyAxMzEuODUgMTM0Ljk0OSAxMzIuOTc4IDEzNC4wMzNMMTM5Ljg5OSAxMjguNDFDMTQwLjgzNSAxMjcuNjUgMTQxLjMwMyAxMjcuMjcgMTQxLjY0IDEyNi44QzE0MS45MzggMTI2LjM4NCAxNDIuMTYgMTI1LjkxOCAxNDIuMjk1IDEyNS40MjRDMTQyLjQ0NyAxMjQuODY3IDE0Mi40NDcgMTI0LjI2NCAxNDIuNDQ3IDEyMy4wNThWNjMuMTEyNkMxNDIuNDQ3IDU4LjI4NTEgMTQyLjQ0NyA1NS44NzE0IDE0MS41MDggNTQuMDI3NkMxNDAuNjgxIDUyLjQwNTcgMTM5LjM2MyA1MS4wODcgMTM3Ljc0MSA1MC4yNjA2QzEzNS44OTcgNDkuMzIxMSAxMzMuNDgzIDQ5LjMyMTEgMTI4LjY1NiA0OS4zMjExSDExMC44NTlDMTA2LjAzMSA0OS4zMjExIDEwMy42MTggNDkuMzIxMSAxMDEuNzc0IDUwLjI2MDZDMTAwLjE1MiA1MS4wODcgOTguODMzMyA1Mi40MDU3IDk4LjAwNjkgNTQuMDI3NloiIGZpbGw9IiNGRkZFRkIiLz4KPC9zdmc+Cg==", icon_light: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQwIiBoZWlnaHQ9IjI0MCIgdmlld0JveD0iMCAwIDI0MCAyNDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjM5LjExNiAxMjAuNDE3QzIzOS4xMTYgNTQuNDE5MyAxODUuNjEzIDAuOTE2NTA0IDExOS42MTYgMC45MTY1MDRDNTMuNjE5IDAuOTE2NTA0IDAuMTE2MjExIDU0LjQxOTMgMC4xMTYyMTEgMTIwLjQxN0MwLjExNjIxMSAxODYuNDE3IDUzLjYxOSAyMzkuOTE3IDExOS42MTYgMjM5LjkxN0MxODUuNjEzIDIzOS45MTcgMjM5LjExNiAxODYuNDE3IDIzOS4xMTYgMTIwLjQxN1pNOTcuODY1OCA1NC4wMjc2Qzk2LjkyNjMgNTUuODcxNCA5Ni45MjYzIDU4LjI4NTEgOTYuOTI2MyA2My4xMTI2VjkwLjQ3MjlDOTYuOTI2MyA5MS42Nzg4IDk2LjkyNjMgOTIuMjgxNyA5Ny4wNzg1IDkyLjgzOTJDOTcuMjEzNCA5My4zMzMxIDk3LjQzNTIgOTMuNzk5IDk3LjczMzUgOTQuMjE1Qzk4LjA3MDIgOTQuNjg0NyA5OC41MzgxIDk1LjA2NDggOTkuNDc0MSA5NS44MjUxTDEwNi4zOTUgMTAxLjQ0N0MxMDcuNTIzIDEwMi4zNjQgMTA4LjA4NyAxMDIuODIyIDEwOC4yOTIgMTAzLjM3NEMxMDguNDcxIDEwMy44NTcgMTA4LjQ3MSAxMDQuMzkgMTA4LjI5MiAxMDQuODczQzEwOC4wODcgMTA1LjQyNSAxMDcuNTIzIDEwNS44ODMgMTA2LjM5NSAxMDYuOEw5OS40NzQxIDExMi40MjJDOTguNTM4MiAxMTMuMTgyIDk4LjA3MDIgMTEzLjU2MiA5Ny43MzM1IDExNC4wMzJDOTcuNDM1MiAxMTQuNDQ4IDk3LjIxMzQgMTE0LjkxNCA5Ny4wNzg1IDExNS40MDhDOTYuOTI2MyAxMTUuOTY1IDk2LjkyNjMgMTE2LjU2OCA5Ni45MjYzIDExNy43NzRWMTc3LjcxOUM5Ni45MjYzIDE4Mi41NDcgOTYuOTI2MyAxODQuOTYxIDk3Ljg2NTggMTg2LjgwNUM5OC42OTIyIDE4OC40MjYgMTAwLjAxMSAxODkuNzQ1IDEwMS42MzMgMTkwLjU3MUMxMDMuNDc3IDE5MS41MTEgMTA1Ljg5IDE5MS41MTEgMTEwLjcxOCAxOTEuNTExSDEyOC41MTVDMTMzLjM0MiAxOTEuNTExIDEzNS43NTYgMTkxLjUxMSAxMzcuNiAxOTAuNTcxQzEzOS4yMjEgMTg5Ljc0NSAxNDAuNTQgMTg4LjQyNiAxNDEuMzY3IDE4Ni44MDVDMTQyLjMwNiAxODQuOTYxIDE0Mi4zMDYgMTgyLjU0NyAxNDIuMzA2IDE3Ny43MTlWMTUwLjM1OUMxNDIuMzA2IDE0OS4xNTMgMTQyLjMwNiAxNDguNTUgMTQyLjE1NCAxNDcuOTkzQzE0Mi4wMTkgMTQ3LjQ5OSAxNDEuNzk3IDE0Ny4wMzMgMTQxLjQ5OSAxNDYuNjE3QzE0MS4xNjIgMTQ2LjE0NyAxNDAuNjk0IDE0NS43NjcgMTM5Ljc1OCAxNDUuMDA3TDEzMi44MzcgMTM5LjM4NUMxMzEuNzA5IDEzOC40NjggMTMxLjE0NSAxMzguMDEgMTMwLjk0IDEzNy40NTlDMTMwLjc2MSAxMzYuOTc1IDEzMC43NjEgMTM2LjQ0MyAxMzAuOTQgMTM1Ljk1OUMxMzEuMTQ1IDEzNS40MDcgMTMxLjcwOSAxMzQuOTQ5IDEzMi44MzcgMTM0LjAzM0wxMzkuNzU4IDEyOC40MUMxNDAuNjk0IDEyNy42NSAxNDEuMTYyIDEyNy4yNyAxNDEuNDk5IDEyNi44QzE0MS43OTcgMTI2LjM4NCAxNDIuMDE5IDEyNS45MTggMTQyLjE1NCAxMjUuNDI0QzE0Mi4zMDYgMTI0Ljg2NyAxNDIuMzA2IDEyNC4yNjQgMTQyLjMwNiAxMjMuMDU4VjYzLjExMjZDMTQyLjMwNiA1OC4yODUxIDE0Mi4zMDYgNTUuODcxNCAxNDEuMzY3IDU0LjAyNzZDMTQwLjU0IDUyLjQwNTcgMTM5LjIyMSA1MS4wODcgMTM3LjYgNTAuMjYwNkMxMzUuNzU2IDQ5LjMyMTEgMTMzLjM0MiA0OS4zMjExIDEyOC41MTUgNDkuMzIxMUgxMTAuNzE4QzEwNS44OSA0OS4zMjExIDEwMy40NzcgNDkuMzIxMSAxMDEuNjMzIDUwLjI2MDZDMTAwLjAxMSA1MS4wODcgOTguNjkyMiA1Mi40MDU3IDk3Ljg2NTggNTQuMDI3NloiIGZpbGw9IiMxQTI4NUYiLz4KPC9zdmc+Cg==" }, "b84e4048-15dc-4dd0-8640-f4f60813c8af": { name: "NordPass", icon_dark: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODAgODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03LjYxMzQgNzBDMi44MjQzNSA2My4zNTIgMCA1NS4xNzIyIDAgNDYuMzI3M0MwIDI0LjA1NTIgMTcuOTA4NiA2IDQwIDZDNjIuMDkxNCA2IDgwIDI0LjA1NTIgODAgNDYuMzI3M0M4MCA1NS4xNzIxIDc3LjE3NTcgNjMuMzUxOCA3Mi4zODY3IDY5Ljk5OTlMNTMuMTc0NyAzOC41NDY2TDUxLjMxOTUgNDEuNzA0Nkw1My4yMDE4IDUwLjQ4NzdMNDAgMjcuNzE0N0wzMS44MzM0IDQxLjYxNjFMMzMuNzM0NiA1MC40ODc3TDI2LjgxNDcgMzguNTY0Nkw3LjYxMzQgNzBaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K", icon_light: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODAgODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03LjYxMzQgNzBDMi44MjQzNSA2My4zNTIgMCA1NS4xNzIyIDAgNDYuMzI3M0MwIDI0LjA1NTIgMTcuOTA4NiA2IDQwIDZDNjIuMDkxNCA2IDgwIDI0LjA1NTIgODAgNDYuMzI3M0M4MCA1NS4xNzIxIDc3LjE3NTcgNjMuMzUxOCA3Mi4zODY3IDY5Ljk5OTlMNTMuMTc0NyAzOC41NDY2TDUxLjMxOTUgNDEuNzA0Nkw1My4yMDE4IDUwLjQ4NzdMNDAgMjcuNzE0N0wzMS44MzM0IDQxLjYxNjFMMzMuNzM0NiA1MC40ODc3TDI2LjgxNDcgMzguNTY0Nkw3LjYxMzQgNzBaIiBmaWxsPSIjMENBQUFCIi8+Cjwvc3ZnPgo=" }, "0ea242b4-43c4-4a1b-8b17-dd6d0b6baec6": { name: "Keeper", icon_dark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzYwMzRfMzM2MjcpIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTIiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMiAxMkMyMiAxNy41MjI4IDE3LjUyMjggMjIgMTIgMjJDNi40NzcxNSAyMiAyIDE3LjUyMjggMiAxMkMyIDYuNDc3MTUgNi40NzcxNSAyIDEyIDJDMTcuNTIyOCAyIDIyIDYuNDc3MTUgMjIgMTJaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNMTAuMTIxOCAzLjI3MzI1SDExLjY2NjZWOS41MTUyN0gxNC44NTc1TDE4LjY5NiA2LjQ2MzE3TDE5LjY2MDcgNy42NjgyMUwxNS4zOTg5IDExLjA1NjRIMTAuMTIxOFYzLjI3MzI1WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTMuMTQzOCAzLjQ4MzY2TDE0LjY4ODcgMy44NzY5NFY2LjAzNDkyTDE2LjQxNzMgNC42MTgxMUwxNy43MDA4IDUuNTYwOTdMMTQuNDA3IDguMjYwMTNMMTMuMTQzOCA4LjI1MzQxVjMuNDgzNjZaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik00LjAzODcgMTUuMDg0OUw1LjU4MzU0IDE2LjM5NThWNy44MTQyN0w0LjAzODcgOS4yMjc3MlYxNS4wODQ5WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNOC42MTI1NyAxOC4yNDExTDcuMDY2MDQgMTkuNTgwNlY0LjQ5NDg1TDguNjEyNTcgNS44MzQzNFYxOC4yNDExWiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTQuNjg4NyAxOC4xMTc0TDE2LjQxNzMgMTkuNTM0MkwxNy43MDA4IDE4LjU4OTdMMTQuNDA3IDE1Ljg5MjJMMTMuMTQzOCAxNS44OTg5VjIwLjY2ODdMMTQuNjg4NyAyMC4yNzU0VjE4LjExNzRaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik0xOC42OTYgMTcuNDc4NkwxNC44NTc1IDE0LjQyNDhIMTEuNjY2NlYyMC42NjY4SDEwLjEyMThWMTIuODg1M0gxNS4zOTg5TDE5LjY2MDcgMTYuMjczNUwxOC42OTYgMTcuNDc4NloiIGZpbGw9IiNGRkM3MDAiLz4KPHBhdGggZD0iTTE2LjczNzYgMTEuOTcwNkwxOS44OTgxIDE0LjU3MDZMMjAuODgzIDEzLjM4MjNMMTkuMTY2MSAxMS45NzA2TDIwLjg4MyAxMC41NTg4TDE5Ljg5ODEgOS4zNzA1NkwxNi43Mzc2IDExLjk3MDZaIiBmaWxsPSIjRkZDNzAwIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfNjAzNF8zMzYyNyI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K", icon_light: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzYwMzRfMzM2MjcpIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTIiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMiAxMkMyMiAxNy41MjI4IDE3LjUyMjggMjIgMTIgMjJDNi40NzcxNSAyMiAyIDE3LjUyMjggMiAxMkMyIDYuNDc3MTUgNi40NzcxNSAyIDEyIDJDMTcuNTIyOCAyIDIyIDYuNDc3MTUgMjIgMTJaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNMTAuMTIxOCAzLjI3MzI1SDExLjY2NjZWOS41MTUyN0gxNC44NTc1TDE4LjY5NiA2LjQ2MzE3TDE5LjY2MDcgNy42NjgyMUwxNS4zOTg5IDExLjA1NjRIMTAuMTIxOFYzLjI3MzI1WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTMuMTQzOCAzLjQ4MzY2TDE0LjY4ODcgMy44NzY5NFY2LjAzNDkyTDE2LjQxNzMgNC42MTgxMUwxNy43MDA4IDUuNTYwOTdMMTQuNDA3IDguMjYwMTNMMTMuMTQzOCA4LjI1MzQxVjMuNDgzNjZaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik00LjAzODcgMTUuMDg0OUw1LjU4MzU0IDE2LjM5NThWNy44MTQyN0w0LjAzODcgOS4yMjc3MlYxNS4wODQ5WiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNOC42MTI1NyAxOC4yNDExTDcuMDY2MDQgMTkuNTgwNlY0LjQ5NDg1TDguNjEyNTcgNS44MzQzNFYxOC4yNDExWiIgZmlsbD0iI0ZGQzcwMCIvPgo8cGF0aCBkPSJNMTQuNjg4NyAxOC4xMTc0TDE2LjQxNzMgMTkuNTM0MkwxNy43MDA4IDE4LjU4OTdMMTQuNDA3IDE1Ljg5MjJMMTMuMTQzOCAxNS44OTg5VjIwLjY2ODdMMTQuNjg4NyAyMC4yNzU0VjE4LjExNzRaIiBmaWxsPSIjRkZDNzAwIi8+CjxwYXRoIGQ9Ik0xOC42OTYgMTcuNDc4NkwxNC44NTc1IDE0LjQyNDhIMTEuNjY2NlYyMC42NjY4SDEwLjEyMThWMTIuODg1M0gxNS4zOTg5TDE5LjY2MDcgMTYuMjczNUwxOC42OTYgMTcuNDc4NloiIGZpbGw9IiNGRkM3MDAiLz4KPHBhdGggZD0iTTE2LjczNzYgMTEuOTcwNkwxOS44OTgxIDE0LjU3MDZMMjAuODgzIDEzLjM4MjNMMTkuMTY2MSAxMS45NzA2TDIwLjg4MyAxMC41NTg4TDE5Ljg5ODEgOS4zNzA1NkwxNi43Mzc2IDExLjk3MDZaIiBmaWxsPSIjRkZDNzAwIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfNjAzNF8zMzYyNyI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K" }, "f3809540-7f14-49c1-a8b3-8f813b225541": { name: "Enpass", icon_dark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNTYuNDgzIDI4LjA1NTRDMzEzLjg5OSAyOC4wNTU0IDM3MS4zMTUgMjcuODg1NiA0MjguNzQ1IDI4LjE0MDVDNDQwLjY4IDI3LjkwNzYgNDUyLjUyMSAzMC4yODg5IDQ2My40NDEgMzUuMTE3OUM0NzQuMzYyIDM5Ljk0NjkgNDg0LjA5OSA0Ny4xMDczIDQ5MS45NzEgNTYuMDk4NEM1MDQuMDYyIDY5LjY5NjIgNTExLjEzMiA4Ny4wMzg3IDUxMiAxMDUuMjNDNTEyLjAyOCAxMjEuOTMzIDUxMC4wMzUgMTM4LjU3OCA1MDYuMDYzIDE1NC44MDFDNDk4LjQ0NCAxOTguNzA2IDQ5MC41MTUgMjQyLjUyNyA0ODIuNzI2IDI4Ni4zNzZDNDc2LjAxMiAzMjQuMTM0IDQ2OS41ODEgMzYxLjk1IDQ2Mi41MTMgMzk5LjY4QzQ1Ny42NzIgNDIwLjk2OSA0NDYuNTQ1IDQ0MC4zMDMgNDMwLjU4IDQ1NS4xNjVDNDE0LjYxNiA0NzAuMDI3IDM5NC41NTUgNDc5LjcyNyAzNzMuMDExIDQ4My4wMDJDMzY3Ljc1MiA0ODMuNjI5IDM2Mi40NjIgNDgzLjk0NiAzNTcuMTY2IDQ4My45NUMyOTAuMDUzIDQ4NC4wMTcgMjIyLjk0IDQ4NC4wMTcgMTU1LjgyOCA0ODMuOTVDMTMwLjQ2NiA0ODMuOSAxMDUuOTMgNDc0LjkxNSA4Ni41MTMyIDQ1OC41NjZDNjcuMDk2NSA0NDIuMjE4IDU0LjAzNjIgNDE5LjU0OCA0OS42MTggMzk0LjUyNUMzNi4xODA0IDMxOS4xNzcgMjIuNjI5NyAyNDMuODUzIDguOTY1OTcgMTY4LjU1M0M2LjI4MDM0IDE1My42MzkgMy4zMTIgMTM4LjgxMSAxLjIwNTkgMTIzLjc4NEMtMi40NjEwNSAxMDIuNzI5IDIuMzEwOTMgODEuMDc0NCAxNC40ODUyIDYzLjUyNDRDMjYuNjU5NiA0NS45NzQ1IDQ1LjI1MjkgMzMuOTQ2MiA2Ni4yMjY2IDMwLjA1MjVDNzMuMDU1NyAyOC43NDUxIDc5Ljk5NTkgMjguMTA5NCA4Ni45NDg0IDI4LjE1NDZDMTQzLjQ2IDI3Ljk5NDEgMTk5Ljk3MSAyNy45NjEgMjU2LjQ4MyAyOC4wNTU0Wk0yMTAuOTI2IDMzOS42NDNDMjEwLjkyNiAzNTQuNjcgMjEwLjkyNiAzNjkuNjk3IDIxMC45MjYgMzg0LjczOEMyMTAuNzczIDM4OC4yMDUgMjExLjM0MyAzOTEuNjY1IDIxMi41OTcgMzk0Ljg5OUMyMTMuODUyIDM5OC4xMzQgMjE1Ljc2NCA0MDEuMDcxIDIxOC4yMTMgNDAzLjUyNUMyMjAuNjYyIDQwNS45NzkgMjIzLjU5MyA0MDcuODk1IDIyNi44MjEgNDA5LjE1MkMyMzAuMDQ5IDQxMC40MDkgMjMzLjUwMyA0MTAuOTc5IDIzNi45NjIgNDEwLjgyNkMyNDkuMzg3IDQxMC44MjYgMjYxLjgxMiA0MTAuODI2IDI3NC4yMzYgNDEwLjgyNkMyNzcuOTIyIDQxMS4xODMgMjgxLjY0MiA0MTAuNzE3IDI4NS4xMjcgNDA5LjQ2MkMyODguNjEyIDQwOC4yMDggMjkxLjc3NyA0MDYuMTk2IDI5NC4zOTQgNDAzLjU3QzI5Ny4wMTIgNDAwLjk0NSAyOTkuMDE3IDM5Ny43NzIgMzAwLjI2NSAzOTQuMjc4QzMwMS41MTQgMzkwLjc4NSAzMDEuOTc1IDM4Ny4wNTggMzAxLjYxNSAzODMuMzY0QzMwMS42MTUgMzUzLjkxOSAzMDEuNjE2IDMyNC40NiAzMDEuNDc0IDI5NS4wMTVDMzAxLjMxMSAyOTMuMzMxIDMwMS42NyAyOTEuNjM3IDMwMi41MDIgMjkwLjE2NUMzMDMuMzM0IDI4OC42OTIgMzA0LjU5OSAyODcuNTEyIDMwNi4xMjUgMjg2Ljc4NkMzMjMuNzkgMjc2LjI5OCAzMzcuNTUxIDI2MC4zMTQgMzQ1LjMxMyAyNDEuMjY2QzM1My4wNzUgMjIyLjIxOSAzNTQuNDEzIDIwMS4xNTEgMzQ5LjEyMyAxODEuMjcyQzM0Mi4zNTYgMTU2Ljg1MyAzMjYuMjg2IDEzNi4wNzUgMzA0LjM3NiAxMjMuNDE0QzI4Mi40NjYgMTEwLjc1NCAyNTYuNDY5IDEwNy4yMjUgMjMxLjk4NyAxMTMuNTg2QzIxNy42NjkgMTE2LjU0NCAyMDQuMjg5IDEyMi45NTkgMTkzLjAwNyAxMzIuMjc0QzE4MS43MjYgMTQxLjU4OCAxNzIuODg0IDE1My41MjIgMTY3LjI0OSAxNjcuMDM4QzE1OS4wMjcgMTg4LjY4NiAxNTguNTQ4IDIxMi41MjEgMTY1Ljg5MyAyMzQuNDg0QzE3My4yMzggMjU2LjQ0NyAxODcuOTU0IDI3NS4xODEgMjA3LjUzMyAyODcuNDk1QzIwOC42NyAyODguMDM4IDIwOS42MTMgMjg4LjkxNyAyMTAuMjM3IDI5MC4wMTNDMjEwLjg2MSAyOTEuMTA5IDIxMS4xMzYgMjkyLjM3IDIxMS4wMjUgMjkzLjYyN0MyMTAuODQxIDMwOS4wMDggMjEwLjkyNiAzMjQuMzMzIDIxMC45MjYgMzM5LjY3MVYzMzkuNjQzWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==", icon_light: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNTYuNDgzIDI4LjA1NTRDMzEzLjg5OSAyOC4wNTU0IDM3MS4zMTUgMjcuODg1NiA0MjguNzQ1IDI4LjE0MDVDNDQwLjY4IDI3LjkwNzYgNDUyLjUyMSAzMC4yODg5IDQ2My40NDEgMzUuMTE3OUM0NzQuMzYyIDM5Ljk0NjkgNDg0LjA5OSA0Ny4xMDczIDQ5MS45NzEgNTYuMDk4NEM1MDQuMDYyIDY5LjY5NjIgNTExLjEzMiA4Ny4wMzg3IDUxMiAxMDUuMjNDNTEyLjAyOCAxMjEuOTMzIDUxMC4wMzUgMTM4LjU3OCA1MDYuMDYzIDE1NC44MDFDNDk4LjQ0NCAxOTguNzA2IDQ5MC41MTUgMjQyLjUyNyA0ODIuNzI2IDI4Ni4zNzZDNDc2LjAxMiAzMjQuMTM0IDQ2OS41ODEgMzYxLjk1IDQ2Mi41MTMgMzk5LjY4QzQ1Ny42NzIgNDIwLjk2OSA0NDYuNTQ1IDQ0MC4zMDMgNDMwLjU4IDQ1NS4xNjVDNDE0LjYxNiA0NzAuMDI3IDM5NC41NTUgNDc5LjcyNyAzNzMuMDExIDQ4My4wMDJDMzY3Ljc1MiA0ODMuNjI5IDM2Mi40NjIgNDgzLjk0NiAzNTcuMTY2IDQ4My45NUMyOTAuMDUzIDQ4NC4wMTcgMjIyLjk0IDQ4NC4wMTcgMTU1LjgyOCA0ODMuOTVDMTMwLjQ2NiA0ODMuOSAxMDUuOTMgNDc0LjkxNSA4Ni41MTMyIDQ1OC41NjZDNjcuMDk2NSA0NDIuMjE4IDU0LjAzNjIgNDE5LjU0OCA0OS42MTggMzk0LjUyNUMzNi4xODA0IDMxOS4xNzcgMjIuNjI5NyAyNDMuODUzIDguOTY1OTcgMTY4LjU1M0M2LjI4MDM0IDE1My42MzkgMy4zMTIgMTM4LjgxMSAxLjIwNTkgMTIzLjc4NEMtMi40NjEwNSAxMDIuNzI5IDIuMzEwOTMgODEuMDc0NCAxNC40ODUyIDYzLjUyNDRDMjYuNjU5NiA0NS45NzQ1IDQ1LjI1MjkgMzMuOTQ2MiA2Ni4yMjY2IDMwLjA1MjVDNzMuMDU1NyAyOC43NDUxIDc5Ljk5NTkgMjguMTA5NCA4Ni45NDg0IDI4LjE1NDZDMTQzLjQ2IDI3Ljk5NDEgMTk5Ljk3MSAyNy45NjEgMjU2LjQ4MyAyOC4wNTU0Wk0yMTAuOTI2IDMzOS42NDNDMjEwLjkyNiAzNTQuNjcgMjEwLjkyNiAzNjkuNjk3IDIxMC45MjYgMzg0LjczOEMyMTAuNzczIDM4OC4yMDUgMjExLjM0MyAzOTEuNjY1IDIxMi41OTcgMzk0Ljg5OUMyMTMuODUyIDM5OC4xMzQgMjE1Ljc2NCA0MDEuMDcxIDIxOC4yMTMgNDAzLjUyNUMyMjAuNjYyIDQwNS45NzkgMjIzLjU5MyA0MDcuODk1IDIyNi44MjEgNDA5LjE1MkMyMzAuMDQ5IDQxMC40MDkgMjMzLjUwMyA0MTAuOTc5IDIzNi45NjIgNDEwLjgyNkMyNDkuMzg3IDQxMC44MjYgMjYxLjgxMiA0MTAuODI2IDI3NC4yMzYgNDEwLjgyNkMyNzcuOTIyIDQxMS4xODMgMjgxLjY0MiA0MTAuNzE3IDI4NS4xMjcgNDA5LjQ2MkMyODguNjEyIDQwOC4yMDggMjkxLjc3NyA0MDYuMTk2IDI5NC4zOTQgNDAzLjU3QzI5Ny4wMTIgNDAwLjk0NSAyOTkuMDE3IDM5Ny43NzIgMzAwLjI2NSAzOTQuMjc4QzMwMS41MTQgMzkwLjc4NSAzMDEuOTc1IDM4Ny4wNTggMzAxLjYxNSAzODMuMzY0QzMwMS42MTUgMzUzLjkxOSAzMDEuNjE2IDMyNC40NiAzMDEuNDc0IDI5NS4wMTVDMzAxLjMxMSAyOTMuMzMxIDMwMS42NyAyOTEuNjM3IDMwMi41MDIgMjkwLjE2NUMzMDMuMzM0IDI4OC42OTIgMzA0LjU5OSAyODcuNTEyIDMwNi4xMjUgMjg2Ljc4NkMzMjMuNzkgMjc2LjI5OCAzMzcuNTUxIDI2MC4zMTQgMzQ1LjMxMyAyNDEuMjY2QzM1My4wNzUgMjIyLjIxOSAzNTQuNDEzIDIwMS4xNTEgMzQ5LjEyMyAxODEuMjcyQzM0Mi4zNTYgMTU2Ljg1MyAzMjYuMjg2IDEzNi4wNzUgMzA0LjM3NiAxMjMuNDE0QzI4Mi40NjYgMTEwLjc1NCAyNTYuNDY5IDEwNy4yMjUgMjMxLjk4NyAxMTMuNTg2QzIxNy42NjkgMTE2LjU0NCAyMDQuMjg5IDEyMi45NTkgMTkzLjAwNyAxMzIuMjc0QzE4MS43MjYgMTQxLjU4OCAxNzIuODg0IDE1My41MjIgMTY3LjI0OSAxNjcuMDM4QzE1OS4wMjcgMTg4LjY4NiAxNTguNTQ4IDIxMi41MjEgMTY1Ljg5MyAyMzQuNDg0QzE3My4yMzggMjU2LjQ0NyAxODcuOTU0IDI3NS4xODEgMjA3LjUzMyAyODcuNDk1QzIwOC42NyAyODguMDM4IDIwOS42MTMgMjg4LjkxNyAyMTAuMjM3IDI5MC4wMTNDMjEwLjg2MSAyOTEuMTA5IDIxMS4xMzYgMjkyLjM3IDIxMS4wMjUgMjkzLjYyN0MyMTAuODQxIDMwOS4wMDggMjEwLjkyNiAzMjQuMzMzIDIxMC45MjYgMzM5LjY3MVYzMzkuNjQzWiIgZmlsbD0iIzBEMzM4RiIvPgo8L3N2Zz4K" }, "b5397666-4885-aa6b-cebf-e52262a439a2": { name: "Chromium Browser" }, "771b48fd-d3d4-4f74-9232-fc157ab0507a": { name: "Edge on Mac", icon_dark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50KTt9LmNscy0ye29wYWNpdHk6MC4zNTtmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50KTt9LmNscy0yLC5jbHMtNHtpc29sYXRpb246aXNvbGF0ZTt9LmNscy0ze2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtMik7fS5jbHMtNHtvcGFjaXR5OjAuNDE7ZmlsbDp1cmwoI3JhZGlhbC1ncmFkaWVudC0yKTt9LmNscy01e2ZpbGw6dXJsKCNyYWRpYWwtZ3JhZGllbnQtMyk7fS5jbHMtNntmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50LTQpO308L3N0eWxlPjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50IiB4MT0iNjMuMzMiIHkxPSI4NC4wMyIgeDI9IjI0MS42NyIgeTI9Ijg0LjAzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMGM1OWE0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTE0YThiIi8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudCIgY3g9IjE2MS44MyIgY3k9IjY4LjkxIiByPSI5NS4zOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMC45NSwgMCwgMjQ4Ljg0KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMC43MiIgc3RvcC1vcGFjaXR5PSIwIi8+PHN0b3Agb2Zmc2V0PSIwLjk1IiBzdG9wLW9wYWNpdHk9IjAuNTMiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50LTIiIHgxPSIxNTcuMzUiIHkxPSIxNjEuMzkiIHgyPSI0NS45NiIgeTI9IjQwLjA2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMWI5ZGUyIi8+PHN0b3Agb2Zmc2V0PSIwLjE2IiBzdG9wLWNvbG9yPSIjMTU5NWRmIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMDY4MGQ3Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDA3OGQ0Ii8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC0yIiBjeD0iLTM0MC4yOSIgY3k9IjYyLjk5IiByPSIxNDMuMjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMC4xNSwgLTAuOTksIC0wLjgsIC0wLjEyLCAxNzYuNjQsIC0xMjUuNCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAuNzYiIHN0b3Atb3BhY2l0eT0iMCIvPjxzdG9wIG9mZnNldD0iMC45NSIgc3RvcC1vcGFjaXR5PSIwLjUiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0icmFkaWFsLWdyYWRpZW50LTMiIGN4PSIxMTMuMzciIGN5PSI1NzAuMjEiIHI9IjIwMi40MyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgtMC4wNCwgMSwgMi4xMywgMC4wOCwgLTExNzkuNTQsIC0xMDYuNjkpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMzVjMWYxIi8+PHN0b3Agb2Zmc2V0PSIwLjExIiBzdG9wLWNvbG9yPSIjMzRjMWVkIi8+PHN0b3Agb2Zmc2V0PSIwLjIzIiBzdG9wLWNvbG9yPSIjMmZjMmRmIi8+PHN0b3Agb2Zmc2V0PSIwLjMxIiBzdG9wLWNvbG9yPSIjMmJjM2QyIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMzZjNzUyIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC00IiBjeD0iMzc2LjUyIiBjeT0iNTY3Ljk3IiByPSI5Ny4zNCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgwLjI4LCAwLjk2LCAwLjc4LCAtMC4yMywgLTMwMy43NiwgLTE0OC41KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIgc3RvcC1vcGFjaXR5PSIwIi8+PC9yYWRpYWxHcmFkaWVudD48L2RlZnM+PHRpdGxlPkVkZ2VfTG9nb18yNjV4MjY1PC90aXRsZT48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0xMTAuMzQsMjQ2LjM0QTc5LjIsNzkuMiwwLDAsMSw4Ny42LDIyNSw4MC43Miw4MC43MiwwLDAsMSwxMTcuMTMsMTA1YzMuMTItMS40Nyw4LjQ1LTQuMTMsMTUuNTQtNGEzMi4zNSwzMi4zNSwwLDAsMSwyNS42OSwxMywzMS44OCwzMS44OCwwLDAsMSw2LjM2LDE4LjY2YzAtLjIxLDI0LjQ2LTc5LjYtODAtNzkuNi00My45LDAtODAsNDEuNjYtODAsNzguMjFhMTMwLjE1LDEzMC4xNSwwLDAsMCwxMi4xMSw1NiwxMjgsMTI4LDAsMCwwLDE1Ni4zOCw2Ny4xMSw3NS41NSw3NS41NSwwLDAsMS02Mi43OC04WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMTEwLjM0LDI0Ni4zNEE3OS4yLDc5LjIsMCwwLDEsODcuNiwyMjUsODAuNzIsODAuNzIsMCwwLDEsMTE3LjEzLDEwNWMzLjEyLTEuNDcsOC40NS00LjEzLDE1LjU0LTRhMzIuMzUsMzIuMzUsMCwwLDEsMjUuNjksMTMsMzEuODgsMzEuODgsMCwwLDEsNi4zNiwxOC42NmMwLS4yMSwyNC40Ni03OS42LTgwLTc5LjYtNDMuOSwwLTgwLDQxLjY2LTgwLDc4LjIxYTEzMC4xNSwxMzAuMTUsMCwwLDAsMTIuMTEsNTYsMTI4LDEyOCwwLDAsMCwxNTYuMzgsNjcuMTEsNzUuNTUsNzUuNTUsMCwwLDEtNjIuNzgtOFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjYzIC00LjkyKSIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTE1Ni45NCwxNTMuNzhjLS44MSwxLjA1LTMuMywyLjUtMy4zLDUuNjYsMCwyLjYxLDEuNyw1LjEyLDQuNzIsNy4yMywxNC4zOCwxMCw0MS40OSw4LjY4LDQxLjU2LDguNjhBNTkuNTYsNTkuNTYsMCwwLDAsMjMwLjE5LDE2N2E2MS4zOCw2MS4zOCwwLDAsMCwzMC40My01Mi44OGMuMjYtMjIuNDEtOC0zNy4zMS0xMS4zNC00My45MUMyMjguMDksMjguNzYsMTgyLjM1LDQuOTIsMTMyLjYxLDQuOTJhMTI4LDEyOCwwLDAsMC0xMjgsMTI2LjJjLjQ4LTM2LjU0LDM2LjgtNjYuMDUsODAtNjYuMDUsMy41LDAsMjMuNDYuMzQsNDIsMTAuMDcsMTYuMzQsOC41OCwyNC45LDE4Ljk0LDMwLjg1LDI5LjIxLDYuMTgsMTAuNjcsNy4yOCwyNC4xNSw3LjI4LDI5LjUyUzE2MiwxNDcuMiwxNTYuOTQsMTUzLjc4WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy02IiBkPSJNMTU2Ljk0LDE1My43OGMtLjgxLDEuMDUtMy4zLDIuNS0zLjMsNS42NiwwLDIuNjEsMS43LDUuMTIsNC43Miw3LjIzLDE0LjM4LDEwLDQxLjQ5LDguNjgsNDEuNTYsOC42OEE1OS41Niw1OS41NiwwLDAsMCwyMzAuMTksMTY3YTYxLjM4LDYxLjM4LDAsMCwwLDMwLjQzLTUyLjg4Yy4yNi0yMi40MS04LTM3LjMxLTExLjM0LTQzLjkxQzIyOC4wOSwyOC43NiwxODIuMzUsNC45MiwxMzIuNjEsNC45MmExMjgsMTI4LDAsMCwwLTEyOCwxMjYuMmMuNDgtMzYuNTQsMzYuOC02Ni4wNSw4MC02Ni4wNSwzLjUsMCwyMy40Ni4zNCw0MiwxMC4wNywxNi4zNCw4LjU4LDI0LjksMTguOTQsMzAuODUsMjkuMjEsNi4xOCwxMC42Nyw3LjI4LDI0LjE1LDcuMjgsMjkuNTJTMTYyLDE0Ny4yLDE1Ni45NCwxNTMuNzhaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48L3N2Zz4=", icon_light: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50KTt9LmNscy0ye29wYWNpdHk6MC4zNTtmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50KTt9LmNscy0yLC5jbHMtNHtpc29sYXRpb246aXNvbGF0ZTt9LmNscy0ze2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtMik7fS5jbHMtNHtvcGFjaXR5OjAuNDE7ZmlsbDp1cmwoI3JhZGlhbC1ncmFkaWVudC0yKTt9LmNscy01e2ZpbGw6dXJsKCNyYWRpYWwtZ3JhZGllbnQtMyk7fS5jbHMtNntmaWxsOnVybCgjcmFkaWFsLWdyYWRpZW50LTQpO308L3N0eWxlPjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50IiB4MT0iNjMuMzMiIHkxPSI4NC4wMyIgeDI9IjI0MS42NyIgeTI9Ijg0LjAzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMGM1OWE0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTE0YThiIi8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudCIgY3g9IjE2MS44MyIgY3k9IjY4LjkxIiByPSI5NS4zOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMC45NSwgMCwgMjQ4Ljg0KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMC43MiIgc3RvcC1vcGFjaXR5PSIwIi8+PHN0b3Agb2Zmc2V0PSIwLjk1IiBzdG9wLW9wYWNpdHk9IjAuNTMiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyLWdyYWRpZW50LTIiIHgxPSIxNTcuMzUiIHkxPSIxNjEuMzkiIHgyPSI0NS45NiIgeTI9IjQwLjA2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAwLCAyNjYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMWI5ZGUyIi8+PHN0b3Agb2Zmc2V0PSIwLjE2IiBzdG9wLWNvbG9yPSIjMTU5NWRmIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMDY4MGQ3Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDA3OGQ0Ii8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC0yIiBjeD0iLTM0MC4yOSIgY3k9IjYyLjk5IiByPSIxNDMuMjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMC4xNSwgLTAuOTksIC0wLjgsIC0wLjEyLCAxNzYuNjQsIC0xMjUuNCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAuNzYiIHN0b3Atb3BhY2l0eT0iMCIvPjxzdG9wIG9mZnNldD0iMC45NSIgc3RvcC1vcGFjaXR5PSIwLjUiLz48c3RvcCBvZmZzZXQ9IjEiLz48L3JhZGlhbEdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0icmFkaWFsLWdyYWRpZW50LTMiIGN4PSIxMTMuMzciIGN5PSI1NzAuMjEiIHI9IjIwMi40MyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgtMC4wNCwgMSwgMi4xMywgMC4wOCwgLTExNzkuNTQsIC0xMDYuNjkpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjMzVjMWYxIi8+PHN0b3Agb2Zmc2V0PSIwLjExIiBzdG9wLWNvbG9yPSIjMzRjMWVkIi8+PHN0b3Agb2Zmc2V0PSIwLjIzIiBzdG9wLWNvbG9yPSIjMmZjMmRmIi8+PHN0b3Agb2Zmc2V0PSIwLjMxIiBzdG9wLWNvbG9yPSIjMmJjM2QyIi8+PHN0b3Agb2Zmc2V0PSIwLjY3IiBzdG9wLWNvbG9yPSIjMzZjNzUyIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9InJhZGlhbC1ncmFkaWVudC00IiBjeD0iMzc2LjUyIiBjeT0iNTY3Ljk3IiByPSI5Ny4zNCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgwLjI4LCAwLjk2LCAwLjc4LCAtMC4yMywgLTMwMy43NiwgLTE0OC41KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY2ZWI2ZSIgc3RvcC1vcGFjaXR5PSIwIi8+PC9yYWRpYWxHcmFkaWVudD48L2RlZnM+PHRpdGxlPkVkZ2VfTG9nb18yNjV4MjY1PC90aXRsZT48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0yMzUuNjgsMTk1LjQ2YTkzLjczLDkzLjczLDAsMCwxLTEwLjU0LDQuNzEsMTAxLjg3LDEwMS44NywwLDAsMS0zNS45LDYuNDZjLTQ3LjMyLDAtODguNTQtMzIuNTUtODguNTQtNzQuMzJBMzEuNDgsMzEuNDgsMCwwLDEsMTE3LjEzLDEwNWMtNDIuOCwxLjgtNTMuOCw0Ni40LTUzLjgsNzIuNTMsMCw3My44OCw2OC4wOSw4MS4zNyw4Mi43Niw4MS4zNyw3LjkxLDAsMTkuODQtMi4zLDI3LTQuNTZsMS4zMS0uNDRBMTI4LjM0LDEyOC4zNCwwLDAsMCwyNDEsMjAxLjEsNCw0LDAsMCwwLDIzNS42OCwxOTUuNDZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0xMTAuMzQsMjQ2LjM0QTc5LjIsNzkuMiwwLDAsMSw4Ny42LDIyNSw4MC43Miw4MC43MiwwLDAsMSwxMTcuMTMsMTA1YzMuMTItMS40Nyw4LjQ1LTQuMTMsMTUuNTQtNGEzMi4zNSwzMi4zNSwwLDAsMSwyNS42OSwxMywzMS44OCwzMS44OCwwLDAsMSw2LjM2LDE4LjY2YzAtLjIxLDI0LjQ2LTc5LjYtODAtNzkuNi00My45LDAtODAsNDEuNjYtODAsNzguMjFhMTMwLjE1LDEzMC4xNSwwLDAsMCwxMi4xMSw1NiwxMjgsMTI4LDAsMCwwLDE1Ni4zOCw2Ny4xMSw3NS41NSw3NS41NSwwLDAsMS02Mi43OC04WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMTEwLjM0LDI0Ni4zNEE3OS4yLDc5LjIsMCwwLDEsODcuNiwyMjUsODAuNzIsODAuNzIsMCwwLDEsMTE3LjEzLDEwNWMzLjEyLTEuNDcsOC40NS00LjEzLDE1LjU0LTRhMzIuMzUsMzIuMzUsMCwwLDEsMjUuNjksMTMsMzEuODgsMzEuODgsMCwwLDEsNi4zNiwxOC42NmMwLS4yMSwyNC40Ni03OS42LTgwLTc5LjYtNDMuOSwwLTgwLDQxLjY2LTgwLDc4LjIxYTEzMC4xNSwxMzAuMTUsMCwwLDAsMTIuMTEsNTYsMTI4LDEyOCwwLDAsMCwxNTYuMzgsNjcuMTEsNzUuNTUsNzUuNTUsMCwwLDEtNjIuNzgtOFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjYzIC00LjkyKSIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTE1Ni45NCwxNTMuNzhjLS44MSwxLjA1LTMuMywyLjUtMy4zLDUuNjYsMCwyLjYxLDEuNyw1LjEyLDQuNzIsNy4yMywxNC4zOCwxMCw0MS40OSw4LjY4LDQxLjU2LDguNjhBNTkuNTYsNTkuNTYsMCwwLDAsMjMwLjE5LDE2N2E2MS4zOCw2MS4zOCwwLDAsMCwzMC40My01Mi44OGMuMjYtMjIuNDEtOC0zNy4zMS0xMS4zNC00My45MUMyMjguMDksMjguNzYsMTgyLjM1LDQuOTIsMTMyLjYxLDQuOTJhMTI4LDEyOCwwLDAsMC0xMjgsMTI2LjJjLjQ4LTM2LjU0LDM2LjgtNjYuMDUsODAtNjYuMDUsMy41LDAsMjMuNDYuMzQsNDIsMTAuMDcsMTYuMzQsOC41OCwyNC45LDE4Ljk0LDMwLjg1LDI5LjIxLDYuMTgsMTAuNjcsNy4yOCwyNC4xNSw3LjI4LDI5LjUyUzE2MiwxNDcuMiwxNTYuOTQsMTUzLjc4WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNjMgLTQuOTIpIi8+PHBhdGggY2xhc3M9ImNscy02IiBkPSJNMTU2Ljk0LDE1My43OGMtLjgxLDEuMDUtMy4zLDIuNS0zLjMsNS42NiwwLDIuNjEsMS43LDUuMTIsNC43Miw3LjIzLDE0LjM4LDEwLDQxLjQ5LDguNjgsNDEuNTYsOC42OEE1OS41Niw1OS41NiwwLDAsMCwyMzAuMTksMTY3YTYxLjM4LDYxLjM4LDAsMCwwLDMwLjQzLTUyLjg4Yy4yNi0yMi40MS04LTM3LjMxLTExLjM0LTQzLjkxQzIyOC4wOSwyOC43NiwxODIuMzUsNC45MiwxMzIuNjEsNC45MmExMjgsMTI4LDAsMCwwLTEyOCwxMjYuMmMuNDgtMzYuNTQsMzYuOC02Ni4wNSw4MC02Ni4wNSwzLjUsMCwyMy40Ni4zNCw0MiwxMC4wNywxNi4zNCw4LjU4LDI0LjksMTguOTQsMzAuODUsMjkuMjEsNi4xOCwxMC42Nyw3LjI4LDI0LjE1LDcuMjgsMjkuNTJTMTYyLDE0Ny4yLDE1Ni45NCwxNTMuNzhaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42MyAtNC45MikiLz48L3N2Zz4=" }, "39a5647e-1853-446c-a1f6-a79bae9f5bc7": { name: "IDmelon", icon_dark: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2YxNWI1Yzt9LmNscy0ye2ZpbGw6IzkyMWIxZDt9LmNscy0ze2ZpbGw6I2VlMzAyNTt9LmNscy00e2ZpbGw6I2JiMjAyNjt9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMzQxLjg3LDEwMC4ybC00LjI5LTEuNjRjLTMyLjMxLTExLjgxLTY1LjM2LTEzLjI3LTc2LjkyLTEzLjRsLS44OSwwSDEyMC4xMkEyMy40MywyMy40MywwLDAsMCwxMTEuNiw4N2MtLjQxLjIxLS44MS40Mi0xLjE3LjY0bC0xLjg1LDEuNzYsMTMzLjM1LDY1LjgsMTAzLjM4LTUyLjg5WiIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjI5NC41OCIgeTE9IjEzNy4wNyIgeDI9IjI5Ni45OSIgeTI9IjEzOC4yNyIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjIzOS41MyIgeTE9IjE1Mi4xMSIgeDI9IjI0MS45MyIgeTI9IjE1My4zMSIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTEwNi43NCw5MXEtMi42Miw0LjItMi4zNSwxMS4yNnQuMjYsMTMuMzdWNDIzLjIxcTAsNS43Ni0uMjYsMTQuNDF0MS4zMSwxMi44NGExNC41NSwxNC41NSwwLDAsMCwxLjE0LDIuMTlsMTM2LTI5OS41NkwxMTAuNDMsODcuNjVBMTEuMjQsMTEuMjQsMCwwLDAsMTA2Ljc0LDkxWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTM2MS44NiwxMTEuNTNjLTIuMzItMS41NS00LjctMy4xLTcuMTMtNC42OGE5My45Miw5My45MiwwLDAsMC0xMi02LjMyYy0uMjctLjExLS41NS0uMjMtLjgzLS4zM2wtOTksNTIuODlMMzg3LjYzLDQwMi4zMUExNjQuMDcsMTY0LjA3LDAsMCwwLDM5NywzODguMTJxMjkuODItNTEuMjEsMjkuODItMTI1YTI4NC44MywyODQuODMsMCwwLDAtNy4wOC02MS4yNSwxNjQuMTYsMTY0LjE2LDAsMCwwLTI2LjUzLTU5Ljc1LDEzNC45LDEzNC45LDAsMCwwLTkuMDUtMTEuMzhBMTUzLjIsMTUzLjIsMCwwLDAsMzYxLjg2LDExMS41M1oiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0xMDYuNjUsNDUyLjM0YTEwLjA3LDEwLjA3LDAsMCwwLDcuNjksNS4xOWwxLjc0LjJoMTU2YzUwLjI3LDAsODguNjQtMTguNjksMTE1LjUyLTU1LjQyTDI0Mi44OSwxNTMuMDlaIi8+PC9zdmc+", icon_light: "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2YxNWI1Yzt9LmNscy0ye2ZpbGw6IzkyMWIxZDt9LmNscy0ze2ZpbGw6I2VlMzAyNTt9LmNscy00e2ZpbGw6I2JiMjAyNjt9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMzQxLjg3LDEwMC4ybC00LjI5LTEuNjRjLTMyLjMxLTExLjgxLTY1LjM2LTEzLjI3LTc2LjkyLTEzLjRsLS44OSwwSDEyMC4xMkEyMy40MywyMy40MywwLDAsMCwxMTEuNiw4N2MtLjQxLjIxLS44MS40Mi0xLjE3LjY0bC0xLjg1LDEuNzYsMTMzLjM1LDY1LjgsMTAzLjM4LTUyLjg5WiIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjI5NC41OCIgeTE9IjEzNy4wNyIgeDI9IjI5Ni45OSIgeTI9IjEzOC4yNyIvPjxsaW5lIGNsYXNzPSJjbHMtMiIgeDE9IjIzOS41MyIgeTE9IjE1Mi4xMSIgeDI9IjI0MS45MyIgeTI9IjE1My4zMSIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTEwNi43NCw5MXEtMi42Miw0LjItMi4zNSwxMS4yNnQuMjYsMTMuMzdWNDIzLjIxcTAsNS43Ni0uMjYsMTQuNDF0MS4zMSwxMi44NGExNC41NSwxNC41NSwwLDAsMCwxLjE0LDIuMTlsMTM2LTI5OS41NkwxMTAuNDMsODcuNjVBMTEuMjQsMTEuMjQsMCwwLDAsMTA2Ljc0LDkxWiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTM2MS44NiwxMTEuNTNjLTIuMzItMS41NS00LjctMy4xLTcuMTMtNC42OGE5My45Miw5My45MiwwLDAsMC0xMi02LjMyYy0uMjctLjExLS41NS0uMjMtLjgzLS4zM2wtOTksNTIuODlMMzg3LjYzLDQwMi4zMUExNjQuMDcsMTY0LjA3LDAsMCwwLDM5NywzODguMTJxMjkuODItNTEuMjEsMjkuODItMTI1YTI4NC44MywyODQuODMsMCwwLDAtNy4wOC02MS4yNSwxNjQuMTYsMTY0LjE2LDAsMCwwLTI2LjUzLTU5Ljc1LDEzNC45LDEzNC45LDAsMCwwLTkuMDUtMTEuMzhBMTUzLjIsMTUzLjIsMCwwLDAsMzYxLjg2LDExMS41M1oiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0xMDYuNjUsNDUyLjM0YTEwLjA3LDEwLjA3LDAsMCwwLDcuNjksNS4xOWwxLjc0LjJoMTU2YzUwLjI3LDAsODguNjQtMTguNjksMTE1LjUyLTU1LjQyTDI0Mi44OSwxNTMuMDlaIi8+PC9zdmc+" }, "6e8248d5-b479-40db-a3d8-11116f7e8349": { name: "Bitwarden", icon_dark: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMywgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9Ikljb24iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiMxNzVEREM7fQoJLnN0MXtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8cmVjdCBpZD0iQmFja2dyb3VuZCIgY2xhc3M9InN0MCIgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIvPgo8cGF0aCBpZD0iSWRlbnRpdHkiIGNsYXNzPSJzdDEiIGQ9Ik04MjkuOCwxMjguNmMtNi41LTYuNS0xNC4yLTkuNy0yMy05LjdIMjE3LjJjLTguOSwwLTE2LjUsMy4yLTIzLDkuN3MtOS43LDE0LjItOS43LDIzdjM5My4xCgljMCwyOS4zLDUuNyw1OC40LDE3LjEsODcuM2MxMS40LDI4LjgsMjUuNiw1NC40LDQyLjUsNzYuOGMxNi45LDIyLjMsMzcsNDQuMSw2MC40LDY1LjNzNDUsMzguNyw2NC43LDUyLjcKCWMxOS44LDE0LDQwLjQsMjcuMiw2MS45LDM5LjdzMzYuOCwyMC45LDQ1LjgsMjUuM2M5LDQuNCwxNi4zLDcuOSwyMS43LDEwLjJjNC4xLDIsOC41LDMuMSwxMy4zLDMuMWM0LjgsMCw5LjItMSwxMy4zLTMuMQoJYzUuNS0yLjQsMTIuNy01LjgsMjEuOC0xMC4yYzktNC40LDI0LjMtMTIuOSw0NS44LTI1LjNjMjEuNS0xMi41LDQyLjEtMjUuNyw2MS45LTM5LjdjMTkuOC0xNCw0MS40LTMxLjYsNjQuOC01Mi43CgljMjMuNC0yMS4yLDQzLjUtNDIuOSw2MC40LTY1LjNjMTYuOS0yMi40LDMxLTQ3LjksNDIuNS03Ni44YzExLjQtMjguOCwxNy4xLTU3LjksMTcuMS04Ny4zdi0zOTMKCUM4MzkuNiwxNDIuOCw4MzYuMywxMzUuMSw4MjkuOCwxMjguNnogTTc1My44LDU0OC40YzAsMTQyLjMtMjQxLjgsMjY0LjktMjQxLjgsMjY0LjlWMjAzaDI0MS44Qzc1My44LDIwMyw3NTMuOCw0MDYuMSw3NTMuOCw1NDguNHoKCSIvPgo8L3N2Zz4K", icon_light: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMywgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9Ikljb24iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiMxNzVEREM7fQoJLnN0MXtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8cmVjdCBpZD0iQmFja2dyb3VuZCIgY2xhc3M9InN0MCIgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIvPgo8cGF0aCBpZD0iSWRlbnRpdHkiIGNsYXNzPSJzdDEiIGQ9Ik04MjkuOCwxMjguNmMtNi41LTYuNS0xNC4yLTkuNy0yMy05LjdIMjE3LjJjLTguOSwwLTE2LjUsMy4yLTIzLDkuN3MtOS43LDE0LjItOS43LDIzdjM5My4xCgljMCwyOS4zLDUuNyw1OC40LDE3LjEsODcuM2MxMS40LDI4LjgsMjUuNiw1NC40LDQyLjUsNzYuOGMxNi45LDIyLjMsMzcsNDQuMSw2MC40LDY1LjNzNDUsMzguNyw2NC43LDUyLjcKCWMxOS44LDE0LDQwLjQsMjcuMiw2MS45LDM5LjdzMzYuOCwyMC45LDQ1LjgsMjUuM2M5LDQuNCwxNi4zLDcuOSwyMS43LDEwLjJjNC4xLDIsOC41LDMuMSwxMy4zLDMuMWM0LjgsMCw5LjItMSwxMy4zLTMuMQoJYzUuNS0yLjQsMTIuNy01LjgsMjEuOC0xMC4yYzktNC40LDI0LjMtMTIuOSw0NS44LTI1LjNjMjEuNS0xMi41LDQyLjEtMjUuNyw2MS45LTM5LjdjMTkuOC0xNCw0MS40LTMxLjYsNjQuOC01Mi43CgljMjMuNC0yMS4yLDQzLjUtNDIuOSw2MC40LTY1LjNjMTYuOS0yMi40LDMxLTQ3LjksNDIuNS03Ni44YzExLjQtMjguOCwxNy4xLTU3LjksMTcuMS04Ny4zdi0zOTMKCUM4MzkuNiwxNDIuOCw4MzYuMywxMzUuMSw4MjkuOCwxMjguNnogTTc1My44LDU0OC40YzAsMTQyLjMtMjQxLjgsMjY0LjktMjQxLjgsMjY0LjlWMjAzaDI0MS44Qzc1My44LDIwMyw3NTMuOCw0MDYuMSw3NTMuOCw1NDguNHoKCSIvPgo8L3N2Zz4K" } }, jg = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 -960 960 960", style: { width: "50px", height: "50px", margin: "20px 0 20px 0" }, fill: "#ffffff" }, bg = [rr("path", { d: "M120-160v-112q0-34 17.5-62.5T184-378q62-31 126-46.5T440-440q20 0 40 1.5t40 4.5q-4 58 21 109.5t73 84.5v80H120ZM760-40l-60-60v-186q-44-13-72-49.5T600-420q0-58 41-99t99-41q58 0 99 41t41 99q0 45-25.5 80T790-290l50 50-60 60 60 60-80 80ZM440-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Zm300 80q17 0 28.5-11.5T780-440q0-17-11.5-28.5T740-480q-17 0-28.5 11.5T700-440q0 17 11.5 28.5T740-400Z" }, null, -1)], Dg = { name: "DefaultPasskeyIcon" }, xg = { components: { ErrorHandler: td, Layout: md, StyledBtn: ic, DefaultPasskeyIcon: (0, Fl.Z)(Dg, [["render", function(e7, t10, n8, i10, r9, o8) {
          return Vi(), Ki("svg", jg, bg);
        }]]) }, props: { "project-id": String, endpoint: { type: String, default: "" } }, setup(e7) {
          const t10 = yt2(false), n8 = yt2([]), i10 = yt2({}), r9 = yt2(false), o8 = yt2(null), s10 = yt2(new gd());
          Mn("errorHandler", s10);
          const a8 = new class {
            constructor(e8) {
              this._errorHandler = e8;
            }
            ListPassKeys(e8) {
              return El(Va.get().get("/v1/me/passkeys", {}, "" !== e8 && void 0 !== e8 ? { headers: { Authorization: `Bearer ${e8}` } } : {}), this._errorHandler).then((e9) => ({ passkeys: e9.data.data.passkeys, paging: e9.data.data.paging }));
            }
          }(s10), l8 = new yl(s10);
          try {
            vl(e7.projectId);
            const r10 = "" !== e7.endpoint ? e7.endpoint : "https://" + e7.projectId + ".frontendapi.corbado.io";
            Tl(r10), Va.configure((t11) => (t11.defaults.baseURL = r10, t11.defaults.headers.common["X-Corbado-ProjectID"] = e7.projectId, t11)), new pA(e7.projectId, e7.endpoint).refresh((e8) => {
              t10.value = null !== e8, null !== e8 && a8.ListPassKeys(Sl.state.user.sessionToken).then((e9) => {
                i10.value = e9.paging, n8.value = e9.passkeys;
              });
            });
          } catch (e8) {
            return s10.value.error = { message: e8.message, links: "client" === e8.type ? [e8.link] : "", errorSide: "client" === e8.type ? "client" : "server", forceShowError: "client" === e8.type && e8.forceShowError }, {};
          }
          return { deletePassKey: (e8) => {
            o8.value = e8, r9.value = true;
          }, confirmDeletePasskey: () => {
            console.log(`Deleting passkey ${o8.value.id}`), l8.DeletePasskey(o8.value.id).then((e8) => {
              n8.value = n8.value.filter((e9) => e9.id !== o8.value.id);
            }).catch((e8) => {
              console.log(e8);
            }), r9.value = false;
          }, currentAuthState: t10, passkeys: n8, showDialog: r9, getAaguidName: (e8) => Ng[e8]?.name || "Passkey", getAaguidIcon: (e8) => {
            const t11 = Ng[e8];
            return t11 && t11.icon_dark ? `<img src="${t11.icon_dark}" alt="${t11.name}" style="width: 50px; height: 50px; margin: 20px 0 20px 0;"/>` : null;
          }, hasAaguidIcon: (e8) => {
            const t11 = Ng[e8];
            return !(!t11 || !t11.icon_dark);
          }, getParsedUA: (e8) => {
            const { browser: t11, os: n9 } = (0, wg.UAParser)(e8);
            return t11.name + " on " + n9.name;
          } };
        } }, Lg = (0, Fl.Z)(xg, [["render", function(e7, t10, n8, i10, r9, o8) {
          const s10 = qn("styled-btn"), a8 = qn("DefaultPasskeyIcon"), l8 = qn("error-handler"), c9 = qn("Layout");
          return Vi(), Ki(Zi, null, [i10.showDialog ? (Vi(), Ki("div", YA, [rr("div", ZA, [BA, WA, rr("div", GA, [or(s10, { class: "btn-danger", dataAction: "delete_passkey", "full-width": "", onClick: i10.confirmDeletePasskey }, { default: un(() => [ar("Yes, delete ")]), _: 1 }, 8, ["onClick"]), or(s10, { class: "btn-outline", "full-width": "", onClick: t10[0] || (t10[0] = (e8) => i10.showDialog = false) }, { default: un(() => [ar("Cancel ")]), _: 1 })])])])) : cr("v-if", true), or(c9, null, { default: un(() => [or(l8, null, { default: un(() => [(i10.currentAuthState, Vi(), Ki("div", HA, [i10.passkeys.length ? (Vi(), Ki("div", _A, [(Vi(true), Ki(Zi, null, ii(i10.passkeys, (e8) => (Vi(), Ki("div", VA, [rr("div", FA, [rr("div", JA, [rr("div", XA, [i10.hasAaguidIcon(e8.aaguid) ? (Vi(), Ki("div", KA, [rr("div", { innerHTML: i10.getAaguidIcon(e8.aaguid) }, null, 8, qA)])) : (Vi(), qi(a8, { key: 1 }))]), rr("div", $A, [rr("div", eg, [rr("div", tg, [rr("h3", ng, A5(i10.getAaguidName(e8.aaguid)), 1), e8.backupState ? (Vi(), Ki("span", ig, "Synced")) : cr("v-if", true)])]), rr("div", rg, [rr("div", og, [sg, ar(" " + A5(e8.credentialHash), 1)])]), rr("div", ag, [rr("div", lg, [cg, ar(" " + A5(e8.created) + " with " + A5(i10.getParsedUA(e8.userAgent)), 1)])]), rr("div", ug, [rr("div", dg, [Ag, ar(" " + A5(e8.lastUsed), 1)])]), rr("div", gg, [rr("div", pg, [Mg, ar(" " + A5(e8.status), 1)])])]), rr("div", { class: "icon-container col-sm-1", onClick: (t11) => i10.deletePassKey(e8) }, mg, 8, fg)])])]))), 256))])) : (Vi(), Ki("div", hg, [0 == i10.passkeys.length ? (Vi(), Ki("div", yg, Ig)) : cr("v-if", true)]))]))]), _: 1 })]), _: 1 })], 64);
        }], ["styles", ["\n.container[data-v-7ee4117c] {\n  box-sizing: border-box;\n  background-color: #2A334C;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n.icon-container[data-v-7ee4117c] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n}\n.row > div[data-v-7ee4117c] {\n  color: white;\n}\n.row[data-v-7ee4117c] {\n  margin-bottom: 10px;\n}\n.dialog[data-v-7ee4117c] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  background: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.dialog-content[data-v-7ee4117c] {\n  padding: 20px;\n  background: #2A334C;\n  border-radius: 10px;\n}\n.dialog-header[data-v-7ee4117c] {\n  font-size: 24px;\n  font-weight: bold;\n  margin-bottom: 10px;\n  color: white;\n}\n.dialog-body[data-v-7ee4117c] {\n  margin-bottom: 20px;\n  color: white;\n}\n.dialog-footer[data-v-7ee4117c] {\n  display: flex;\n  justify-content: space-between;\n}\n.btn[data-v-7ee4117c] {\n  border: none;\n  padding: 10px 20px;\n  border-radius: 20px;\n  cursor: pointer;\n}\n.btn-danger[data-v-7ee4117c] {\n  background: red;\n  margin-right: 10px;\n  color: white;\n}\n.btn-outline[data-v-7ee4117c] {\n  border: 1px solid white;\n  background: transparent;\n  color: white;\n}\n.btn-danger[data-v-7ee4117c]:hover {\n  background: #ff4d4d;\n}\n.btn-outline[data-v-7ee4117c]:hover {\n  background: rgba(255, 255, 255, 0.3);\n}\n.passkey-type-badge[data-v-7ee4117c] {\n  background: transparent;\n  border: 1px solid white;\n  color: white;\n  border-radius: 5px;\n  padding: 2px 5px;\n  font-size: 12px;\n  margin-left: 5px;\n  height: 15px;\n}\n.passkey-icon-container[data-v-7ee4117c] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.passkey-attribute[data-v-7ee4117c] {\n  margin-left: 0px;\n  margin-right: 0px;\n}\n\n"]], ["__scopeId", "data-v-7ee4117c"]]);
        function vg({ styles: e7 = [], components: t10 = {} }) {
          return n8 = [...e7, ...Object.values(t10).flatMap(vg)], [...new Set(n8)];
          var n8;
        }
        [{ element: hA, name: "corbado-auth" }, { element: jA, name: "corbado-checkbox" }, { element: LA, name: "corbado-auth-provider" }, { element: QA, name: "corbado-logout-handler" }, { element: CA, name: "corbado-passkey-associate" }, { element: PA, name: "corbado-passkey-associate-login" }, { element: Lg, name: "corbado-passkey-list" }, { element: fA, name: "corbado-passkey-append" }].forEach((e7) => {
          if (t10 = e7.name, void 0 !== window && void 0 !== window.customElements && void 0 !== window.customElements.get(t10))
            return;
          var t10;
          e7.element.styles = vg(e7.element);
          const n8 = Gr(e7.element);
          customElements.define(e7.name, n8);
        });
        const Tg = { Session: pA };
      })(), i9;
    })());
  }
});

// node_modules/@simplewebauthn/browser/dist/bundle/index.js
var BaseWebAuthnAbortService, WebAuthnAbortService;
var init_bundle = __esm({
  "node_modules/@simplewebauthn/browser/dist/bundle/index.js"() {
    BaseWebAuthnAbortService = class {
      createNewAbortSignal() {
        if (this.controller) {
          const abortError = new Error("Cancelling existing WebAuthn API call for new one");
          abortError.name = "AbortError";
          this.controller.abort(abortError);
        }
        const newController = new AbortController();
        this.controller = newController;
        return newController.signal;
      }
      cancelCeremony() {
        if (this.controller) {
          const abortError = new Error("Manually cancelling existing WebAuthn API call");
          abortError.name = "AbortError";
          this.controller.abort(abortError);
          this.controller = void 0;
        }
      }
    };
    WebAuthnAbortService = new BaseWebAuthnAbortService();
  }
});

// node_modules/nanoid/non-secure/index.js
var urlAlphabet, customAlphabet, nanoid;
var init_non_secure = __esm({
  "node_modules/nanoid/non-secure/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i9 = size;
        while (i9--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    nanoid = (size = 21) => {
      let id = "";
      let i9 = size;
      while (i9--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
  }
});

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors, candidateSelector, NoElement, matches, getRootNode, isInert, isContentEditable, getCandidates, getCandidatesIteratively, hasTabIndex, getTabIndex, getSortOrderTabIndex, sortOrderedTabbables, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isNodeAttached, isZeroArea, isHidden, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isValidShadowRootTabbable, sortByOrder, tabbable, focusable, isTabbable, focusableCandidateSelector, isFocusable;
var init_index_esm = __esm({
  "node_modules/tabbable/dist/index.esm.js"() {
    candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      var _element$getRootNode;
      return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
    } : function(element) {
      return element === null || element === void 0 ? void 0 : element.ownerDocument;
    };
    isInert = function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    };
    isContentEditable = function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    getCandidates = function getCandidates2(el, includeContainer, filter) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter);
      return candidates;
    };
    getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options3) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element = elementsToCheck.shift();
        if (isInert(element, false)) {
          continue;
        }
        if (element.tagName === "SLOT") {
          var assigned = element.assignedElements();
          var content = assigned.length ? assigned : element.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options3);
          if (options3.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches.call(element, candidateSelector);
          if (validCandidate && options3.filter(element) && (includeContainer || !elements.includes(element))) {
            candidates.push(element);
          }
          var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
          typeof options3.getShadowRoot === "function" && options3.getShadowRoot(element);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options3.shadowRootFilter || options3.shadowRootFilter(element));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options3);
            if (options3.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element.children);
          }
        }
      }
      return candidates;
    };
    hasTabIndex = function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    getTabIndex = function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    sortOrderedTabbables = function sortOrderedTabbables2(a7, b5) {
      return a7.tabIndex === b5.tabIndex ? a7.documentOrder - b5.documentOrder : a7.tabIndex - b5.tabIndex;
    };
    isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r8 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r8;
    };
    getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i9 = 0; i9 < nodes.length; i9++) {
        if (nodes[i9].checked && nodes[i9].form === form) {
          return nodes[i9];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name2) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    isNodeAttached = function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i9 = 0; i9 < parentNode.children.length; i9++) {
              var child = parentNode.children.item(i9);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options3, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options3) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options3, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options3, node)) {
        return false;
      }
      return true;
    };
    isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i9) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
          orderedTabbables.push({
            documentOrder: i9,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    tabbable = function tabbable2(container, options3) {
      options3 = options3 || {};
      var candidates;
      if (options3.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options3.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options3),
          flatten: false,
          getShadowRoot: options3.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options3.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options3));
      }
      return sortByOrder(candidates);
    };
    focusable = function focusable2(container, options3) {
      options3 = options3 || {};
      var candidates;
      if (options3.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options3.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options3),
          flatten: true,
          getShadowRoot: options3.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options3.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options3));
      }
      return candidates;
    };
    isTabbable = function isTabbable2(node, options3) {
      options3 = options3 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options3, node);
    };
    focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    isFocusable = function isFocusable2(node, options3) {
      options3 = options3 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options3, node);
    };
  }
});

// node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(e5, r8) {
  var t8 = Object.keys(e5);
  if (Object.getOwnPropertySymbols) {
    var o7 = Object.getOwnPropertySymbols(e5);
    r8 && (o7 = o7.filter(function(r9) {
      return Object.getOwnPropertyDescriptor(e5, r9).enumerable;
    })), t8.push.apply(t8, o7);
  }
  return t8;
}
function _objectSpread2(e5) {
  for (var r8 = 1; r8 < arguments.length; r8++) {
    var t8 = null != arguments[r8] ? arguments[r8] : {};
    r8 % 2 ? ownKeys(Object(t8), true).forEach(function(r9) {
      _defineProperty(e5, r9, t8[r9]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t8)) : ownKeys(Object(t8)).forEach(function(r9) {
      Object.defineProperty(e5, r9, Object.getOwnPropertyDescriptor(t8, r9));
    });
  }
  return e5;
}
function _defineProperty(obj, key3, value) {
  key3 = _toPropertyKey(key3);
  if (key3 in obj) {
    Object.defineProperty(obj, key3, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key3] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key3 = _toPrimitive(arg, "string");
  return typeof key3 === "symbol" ? key3 : String(key3);
}
var activeFocusTraps, isSelectableInput, isEscapeEvent, isTabEvent, isKeyForward, isKeyBackward, delay, findIndex, valueOrHandler, getActualTarget, internalTrapStack, createFocusTrap;
var init_focus_trap_esm = __esm({
  "node_modules/focus-trap/dist/focus-trap.esm.js"() {
    init_index_esm();
    activeFocusTraps = {
      activateTrap: function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
          trapStack.push(trap);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
          trapStack[trapStack.length - 1].unpause();
        }
      }
    };
    isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    isEscapeEvent = function isEscapeEvent2(e5) {
      return (e5 === null || e5 === void 0 ? void 0 : e5.key) === "Escape" || (e5 === null || e5 === void 0 ? void 0 : e5.key) === "Esc" || (e5 === null || e5 === void 0 ? void 0 : e5.keyCode) === 27;
    };
    isTabEvent = function isTabEvent2(e5) {
      return (e5 === null || e5 === void 0 ? void 0 : e5.key) === "Tab" || (e5 === null || e5 === void 0 ? void 0 : e5.keyCode) === 9;
    };
    isKeyForward = function isKeyForward2(e5) {
      return isTabEvent(e5) && !e5.shiftKey;
    };
    isKeyBackward = function isKeyBackward2(e5) {
      return isTabEvent(e5) && e5.shiftKey;
    };
    delay = function delay2(fn) {
      return setTimeout(fn, 0);
    };
    findIndex = function findIndex2(arr2, fn) {
      var idx = -1;
      arr2.every(function(value, i9) {
        if (fn(value)) {
          idx = i9;
          return false;
        }
        return true;
      });
      return idx;
    };
    valueOrHandler = function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    };
    getActualTarget = function getActualTarget2(event) {
      return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
    };
    internalTrapStack = [];
    createFocusTrap = function createFocusTrap2(elements, userOptions) {
      var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
      };
      var findContainerIndex = function findContainerIndex2(element, event) {
        var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element;
          });
        });
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
          if (findContainerIndex(doc.activeElement) >= 0) {
            node = doc.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config.tabbableOptions);
          var focusableNodes = focusable(container, config.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: function nextTabbableNode(node) {
              var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
            }
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
          return group.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g7) {
          return g7.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      };
      var getActiveElement = function getActiveElement2(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
          return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
          return getActiveElement2(activeElement.shadowRoot);
        }
        return activeElement;
      };
      var tryFocus = function tryFocus2(node) {
        if (node === false) {
          return;
        }
        if (node === getActiveElement(document)) {
          return;
        }
        if (!node || !node.focus) {
          tryFocus2(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      };
      var findNextNavNode = function findNextNavNode2(_ref2) {
        var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target = target || getActualTarget(event);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target, event);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var firstTabbableNode = _ref3.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target, false);
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
              var lastTabbableNode = _ref4.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      };
      var checkPointerDown = function checkPointerDown2(e5) {
        var target = getActualTarget(e5);
        if (findContainerIndex(target, e5) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e5)) {
          trap.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e5)) {
          return;
        }
        e5.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(event) {
        var target = getActualTarget(event);
        var targetContained = findContainerIndex(target, event) >= 0;
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          event.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g7) {
                return g7.tabbableNodes.some(function(n7) {
                  return getTabIndex(n7) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            tryFocus(nextNode);
          } else {
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      };
      var checkKeyNav = function checkKeyNav2(event) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event;
        var destinationNode = findNextNavNode({
          event,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event)) {
            event.preventDefault();
          }
          tryFocus(destinationNode);
        }
      };
      var checkKey = function checkKey2(event) {
        if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
          event.preventDefault();
          trap.deactivate();
          return;
        }
        if (config.isKeyForward(event) || config.isKeyBackward(event)) {
          checkKeyNav(event, config.isKeyBackward(event));
        }
      };
      var checkClick = function checkClick2(e5) {
        var target = getActualTarget(e5);
        if (findContainerIndex(target, e5) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e5)) {
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e5)) {
          return;
        }
        e5.preventDefault();
        e5.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap);
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
          tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc.addEventListener("focusin", checkFocusIn, true);
        doc.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc.addEventListener("keydown", checkKey, {
          capture: true,
          passive: false
        });
        return trap;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc.removeEventListener("focusin", checkFocusIn, true);
        doc.removeEventListener("mousedown", checkPointerDown, true);
        doc.removeEventListener("touchstart", checkPointerDown, true);
        doc.removeEventListener("click", checkClick, true);
        doc.removeEventListener("keydown", checkKey, true);
        return trap;
      };
      var checkDomRemoval = function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          tryFocus(getInitialFocusNode());
        }
      };
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      };
      trap = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc.activeElement;
          onActivate === null || onActivate === void 0 || onActivate();
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 || onPostActivate();
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options3 = _objectSpread2({
            onDeactivate: config.onDeactivate,
            onPostDeactivate: config.onPostDeactivate,
            checkCanReturnFocus: config.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap);
          var onDeactivate = getOption(options3, "onDeactivate");
          var onPostDeactivate = getOption(options3, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options3, "checkCanReturnFocus");
          var returnFocus = getOption(options3, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 || onDeactivate();
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause(pauseOptions) {
          if (state.paused || !state.active) {
            return this;
          }
          var onPause = getOption(pauseOptions, "onPause");
          var onPostPause = getOption(pauseOptions, "onPostPause");
          state.paused = true;
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
          return this;
        },
        unpause: function unpause(unpauseOptions) {
          if (!state.paused || !state.active) {
            return this;
          }
          var onUnpause = getOption(unpauseOptions, "onUnpause");
          var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
          state.paused = false;
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element) {
            return typeof element === "string" ? doc.querySelector(element) : element;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }
      };
      trap.updateContainerElements(elements);
      return trap;
    };
  }
});

// node_modules/just-clone/index.mjs
var init_just_clone = __esm({
  "node_modules/just-clone/index.mjs"() {
  }
});

// node_modules/ts-deepmerge/esm/index.js
var isObject3, merge, defaultOptions3;
var init_esm = __esm({
  "node_modules/ts-deepmerge/esm/index.js"() {
    isObject3 = (obj) => {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          const prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    };
    merge = (...objects) => objects.reduce((result, current) => {
      if (Array.isArray(current)) {
        throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
      }
      Object.keys(current).forEach((key3) => {
        if (["__proto__", "constructor", "prototype"].includes(key3)) {
          return;
        }
        if (Array.isArray(result[key3]) && Array.isArray(current[key3])) {
          result[key3] = merge.options.mergeArrays ? merge.options.uniqueArrayItems ? Array.from(new Set(result[key3].concat(current[key3]))) : [...result[key3], ...current[key3]] : current[key3];
        } else if (isObject3(result[key3]) && isObject3(current[key3])) {
          result[key3] = merge(result[key3], current[key3]);
        } else {
          result[key3] = current[key3] === void 0 ? merge.options.allowUndefinedOverrides ? current[key3] : result[key3] : current[key3];
        }
      });
      return result;
    }, {});
    defaultOptions3 = {
      allowUndefinedOverrides: true,
      mergeArrays: true,
      uniqueArrayItems: true
    };
    merge.options = defaultOptions3;
    merge.withOptions = (options3, ...objects) => {
      merge.options = Object.assign(Object.assign({}, defaultOptions3), options3);
      const result = merge(...objects);
      merge.options = defaultOptions3;
      return result;
    };
  }
});

// node_modules/@mozilla/readability/Readability.js
var require_Readability = __commonJS({
  "node_modules/@mozilla/readability/Readability.js"(exports, module2) {
    function Readability(doc, options3) {
      if (options3 && options3.documentElement) {
        doc = options3;
        options3 = arguments[2];
      } else if (!doc || !doc.documentElement) {
        throw new Error("First argument to Readability constructor should be a document object.");
      }
      options3 = options3 || {};
      this._doc = doc;
      this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
      this._articleTitle = null;
      this._articleByline = null;
      this._articleDir = null;
      this._articleSiteName = null;
      this._attempts = [];
      this._debug = !!options3.debug;
      this._maxElemsToParse = options3.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
      this._nbTopCandidates = options3.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
      this._charThreshold = options3.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
      this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options3.classesToPreserve || []);
      this._keepClasses = !!options3.keepClasses;
      this._serializer = options3.serializer || function(el) {
        return el.innerHTML;
      };
      this._disableJSONLD = !!options3.disableJSONLD;
      this._allowedVideoRegex = options3.allowedVideoRegex || this.REGEXPS.videos;
      this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
      if (this._debug) {
        let logNode = function(node) {
          if (node.nodeType == node.TEXT_NODE) {
            return `${node.nodeName} ("${node.textContent}")`;
          }
          let attrPairs = Array.from(node.attributes || [], function(attr2) {
            return `${attr2.name}="${attr2.value}"`;
          }).join(" ");
          return `<${node.localName} ${attrPairs}>`;
        };
        this.log = function() {
          if (typeof console !== "undefined") {
            let args = Array.from(arguments, (arg) => {
              if (arg && arg.nodeType == this.ELEMENT_NODE) {
                return logNode(arg);
              }
              return arg;
            });
            args.unshift("Reader: (Readability)");
            console.log.apply(console, args);
          } else if (typeof dump !== "undefined") {
            var msg = Array.prototype.map.call(arguments, function(x4) {
              return x4 && x4.nodeName ? logNode(x4) : x4;
            }).join(" ");
            dump("Reader: (Readability) " + msg + "\n");
          }
        };
      } else {
        this.log = function() {
        };
      }
    }
    Readability.prototype = {
      FLAG_STRIP_UNLIKELYS: 1,
      FLAG_WEIGHT_CLASSES: 2,
      FLAG_CLEAN_CONDITIONALLY: 4,
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
      ELEMENT_NODE: 1,
      TEXT_NODE: 3,
      // Max number of nodes supported by this parser. Default: 0 (no limit)
      DEFAULT_MAX_ELEMS_TO_PARSE: 0,
      // The number of top candidates to consider when analysing how
      // tight the competition is among candidates.
      DEFAULT_N_TOP_CANDIDATES: 5,
      // Element tags to score by default.
      DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
      // The default number of chars an article must have in order to return a result
      DEFAULT_CHAR_THRESHOLD: 500,
      // All of the regular expressions in use within readability.
      // Defined up here so we don't instantiate them repeatedly in loops.
      REGEXPS: {
        // NOTE: These two regular expressions are duplicated in
        // Readability-readerable.js. Please keep both copies in sync.
        unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
        okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
        positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
        negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,
        extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
        byline: /byline|author|dateline|writtenby|p-author/i,
        replaceFonts: /<(\/?)font[^>]*>/gi,
        normalize: /\s{2,}/g,
        videos: /\/\/(www\.)?((dailymotion|youtube|youtube-nocookie|player\.vimeo|v\.qq)\.com|(archive|upload\.wikimedia)\.org|player\.twitch\.tv)/i,
        shareElements: /(\b|_)(share|sharedaddy)(\b|_)/i,
        nextLink: /(next|weiter|continue|>([^\|]|$)|([^\|]|$))/i,
        prevLink: /(prev|earl|old|new|<|)/i,
        tokenize: /\W+/g,
        whitespace: /^\s*$/,
        hasContent: /\S$/,
        hashUrl: /^#.+/,
        srcsetUrl: /(\S+)(\s+[\d.]+[xw])?(\s*(?:,|$))/g,
        b64DataUrl: /^data:\s*([^\s;,]+)\s*;\s*base64\s*,/i,
        // Commas as used in Latin, Sindhi, Chinese and various other scripts.
        // see: https://en.wikipedia.org/wiki/Comma#Comma_variants
        commas: /\u002C|\u060C|\uFE50|\uFE10|\uFE11|\u2E41|\u2E34|\u2E32|\uFF0C/g,
        // See: https://schema.org/Article
        jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/
      },
      UNLIKELY_ROLES: ["menu", "menubar", "complementary", "navigation", "alert", "alertdialog", "dialog"],
      DIV_TO_P_ELEMS: /* @__PURE__ */ new Set(["BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL"]),
      ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],
      PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],
      DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
      // The commented out elements qualify as phrasing content but tend to be
      // removed by readability when put into paragraphs, so we ignore them here.
      PHRASING_ELEMS: [
        // "CANVAS", "IFRAME", "SVG", "VIDEO",
        "ABBR",
        "AUDIO",
        "B",
        "BDO",
        "BR",
        "BUTTON",
        "CITE",
        "CODE",
        "DATA",
        "DATALIST",
        "DFN",
        "EM",
        "EMBED",
        "I",
        "IMG",
        "INPUT",
        "KBD",
        "LABEL",
        "MARK",
        "MATH",
        "METER",
        "NOSCRIPT",
        "OBJECT",
        "OUTPUT",
        "PROGRESS",
        "Q",
        "RUBY",
        "SAMP",
        "SCRIPT",
        "SELECT",
        "SMALL",
        "SPAN",
        "STRONG",
        "SUB",
        "SUP",
        "TEXTAREA",
        "TIME",
        "VAR",
        "WBR"
      ],
      // These are the classes that readability sets itself.
      CLASSES_TO_PRESERVE: ["page"],
      // These are the list of HTML entities that need to be escaped.
      HTML_ESCAPE_MAP: {
        "lt": "<",
        "gt": ">",
        "amp": "&",
        "quot": '"',
        "apos": "'"
      },
      /**
       * Run any post-process modifications to article content as necessary.
       *
       * @param Element
       * @return void
      **/
      _postProcessContent: function(articleContent) {
        this._fixRelativeUris(articleContent);
        this._simplifyNestedElements(articleContent);
        if (!this._keepClasses) {
          this._cleanClasses(articleContent);
        }
      },
      /**
       * Iterates over a NodeList, calls `filterFn` for each node and removes node
       * if function returned `true`.
       *
       * If function is not passed, removes all the nodes in node list.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param Function filterFn the function to use as a filter
       * @return void
       */
      _removeNodes: function(nodeList, filterFn) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _removeNodes");
        }
        for (var i9 = nodeList.length - 1; i9 >= 0; i9--) {
          var node = nodeList[i9];
          var parentNode = node.parentNode;
          if (parentNode) {
            if (!filterFn || filterFn.call(this, node, i9, nodeList)) {
              parentNode.removeChild(node);
            }
          }
        }
      },
      /**
       * Iterates over a NodeList, and calls _setNodeTag for each node.
       *
       * @param NodeList nodeList The nodes to operate on
       * @param String newTagName the new tag name to use
       * @return void
       */
      _replaceNodeTags: function(nodeList, newTagName) {
        if (this._docJSDOMParser && nodeList._isLiveNodeList) {
          throw new Error("Do not pass live node lists to _replaceNodeTags");
        }
        for (const node of nodeList) {
          this._setNodeTag(node, newTagName);
        }
      },
      /**
       * Iterate over a NodeList, which doesn't natively fully implement the Array
       * interface.
       *
       * For convenience, the current object context is applied to the provided
       * iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return void
       */
      _forEachNode: function(nodeList, fn) {
        Array.prototype.forEach.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, and return the first node that passes
       * the supplied test function
       *
       * For convenience, the current object context is applied to the provided
       * test function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The test function.
       * @return void
       */
      _findNode: function(nodeList, fn) {
        return Array.prototype.find.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, return true if any of the provided iterate
       * function calls returns true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _someNode: function(nodeList, fn) {
        return Array.prototype.some.call(nodeList, fn, this);
      },
      /**
       * Iterate over a NodeList, return true if all of the provided iterate
       * function calls return true, false otherwise.
       *
       * For convenience, the current object context is applied to the
       * provided iterate function.
       *
       * @param  NodeList nodeList The NodeList.
       * @param  Function fn       The iterate function.
       * @return Boolean
       */
      _everyNode: function(nodeList, fn) {
        return Array.prototype.every.call(nodeList, fn, this);
      },
      /**
       * Concat all nodelists passed as arguments.
       *
       * @return ...NodeList
       * @return Array
       */
      _concatNodeLists: function() {
        var slice2 = Array.prototype.slice;
        var args = slice2.call(arguments);
        var nodeLists = args.map(function(list) {
          return slice2.call(list);
        });
        return Array.prototype.concat.apply([], nodeLists);
      },
      _getAllNodesWithTag: function(node, tagNames) {
        if (node.querySelectorAll) {
          return node.querySelectorAll(tagNames.join(","));
        }
        return [].concat.apply([], tagNames.map(function(tag) {
          var collection = node.getElementsByTagName(tag);
          return Array.isArray(collection) ? collection : Array.from(collection);
        }));
      },
      /**
       * Removes the class="" attribute from every element in the given
       * subtree, except those that match CLASSES_TO_PRESERVE and
       * the classesToPreserve array from the options object.
       *
       * @param Element
       * @return void
       */
      _cleanClasses: function(node) {
        var classesToPreserve = this._classesToPreserve;
        var className = (node.getAttribute("class") || "").split(/\s+/).filter(function(cls) {
          return classesToPreserve.indexOf(cls) != -1;
        }).join(" ");
        if (className) {
          node.setAttribute("class", className);
        } else {
          node.removeAttribute("class");
        }
        for (node = node.firstElementChild; node; node = node.nextElementSibling) {
          this._cleanClasses(node);
        }
      },
      /**
       * Converts each <a> and <img> uri in the given element to an absolute URI,
       * ignoring #ref URIs.
       *
       * @param Element
       * @return void
       */
      _fixRelativeUris: function(articleContent) {
        var baseURI = this._doc.baseURI;
        var documentURI = this._doc.documentURI;
        function toAbsoluteURI(uri) {
          if (baseURI == documentURI && uri.charAt(0) == "#") {
            return uri;
          }
          try {
            return new URL(uri, baseURI).href;
          } catch (ex) {
          }
          return uri;
        }
        var links = this._getAllNodesWithTag(articleContent, ["a"]);
        this._forEachNode(links, function(link) {
          var href = link.getAttribute("href");
          if (href) {
            if (href.indexOf("javascript:") === 0) {
              if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
                var text2 = this._doc.createTextNode(link.textContent);
                link.parentNode.replaceChild(text2, link);
              } else {
                var container = this._doc.createElement("span");
                while (link.firstChild) {
                  container.appendChild(link.firstChild);
                }
                link.parentNode.replaceChild(container, link);
              }
            } else {
              link.setAttribute("href", toAbsoluteURI(href));
            }
          }
        });
        var medias = this._getAllNodesWithTag(articleContent, [
          "img",
          "picture",
          "figure",
          "video",
          "audio",
          "source"
        ]);
        this._forEachNode(medias, function(media) {
          var src = media.getAttribute("src");
          var poster = media.getAttribute("poster");
          var srcset = media.getAttribute("srcset");
          if (src) {
            media.setAttribute("src", toAbsoluteURI(src));
          }
          if (poster) {
            media.setAttribute("poster", toAbsoluteURI(poster));
          }
          if (srcset) {
            var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_4, p1, p22, p32) {
              return toAbsoluteURI(p1) + (p22 || "") + p32;
            });
            media.setAttribute("srcset", newSrcset);
          }
        });
      },
      _simplifyNestedElements: function(articleContent) {
        var node = articleContent;
        while (node) {
          if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
            if (this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
              var child = node.children[0];
              for (var i9 = 0; i9 < node.attributes.length; i9++) {
                child.setAttribute(node.attributes[i9].name, node.attributes[i9].value);
              }
              node.parentNode.replaceChild(child, node);
              node = child;
              continue;
            }
          }
          node = this._getNextNode(node);
        }
      },
      /**
       * Get the article title as an H1.
       *
       * @return string
       **/
      _getArticleTitle: function() {
        var doc = this._doc;
        var curTitle = "";
        var origTitle = "";
        try {
          curTitle = origTitle = doc.title.trim();
          if (typeof curTitle !== "string")
            curTitle = origTitle = this._getInnerText(doc.getElementsByTagName("title")[0]);
        } catch (e5) {
        }
        var titleHadHierarchicalSeparators = false;
        function wordCount(str2) {
          return str2.split(/\s+/).length;
        }
        if (/ [\|\-\\\/>] /.test(curTitle)) {
          titleHadHierarchicalSeparators = / [\\\/>] /.test(curTitle);
          curTitle = origTitle.replace(/(.*)[\|\-\\\/>] .*/gi, "$1");
          if (wordCount(curTitle) < 3)
            curTitle = origTitle.replace(/[^\|\-\\\/>]*[\|\-\\\/>](.*)/gi, "$1");
        } else if (curTitle.indexOf(": ") !== -1) {
          var headings = this._concatNodeLists(
            doc.getElementsByTagName("h1"),
            doc.getElementsByTagName("h2")
          );
          var trimmedTitle = curTitle.trim();
          var match = this._someNode(headings, function(heading) {
            return heading.textContent.trim() === trimmedTitle;
          });
          if (!match) {
            curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
            if (wordCount(curTitle) < 3) {
              curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
            } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
              curTitle = origTitle;
            }
          }
        } else if (curTitle.length > 150 || curTitle.length < 15) {
          var hOnes = doc.getElementsByTagName("h1");
          if (hOnes.length === 1)
            curTitle = this._getInnerText(hOnes[0]);
        }
        curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
        var curTitleWordCount = wordCount(curTitle);
        if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>]+/g, "")) - 1)) {
          curTitle = origTitle;
        }
        return curTitle;
      },
      /**
       * Prepare the HTML document for readability to scrape it.
       * This includes things like stripping javascript, CSS, and handling terrible markup.
       *
       * @return void
       **/
      _prepDocument: function() {
        var doc = this._doc;
        this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));
        if (doc.body) {
          this._replaceBrs(doc.body);
        }
        this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
      },
      /**
       * Finds the next node, starting from the given node, and ignoring
       * whitespace in between. If the given node is an element, the same node is
       * returned.
       */
      _nextNode: function(node) {
        var next2 = node;
        while (next2 && next2.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next2.textContent)) {
          next2 = next2.nextSibling;
        }
        return next2;
      },
      /**
       * Replaces 2 or more successive <br> elements with a single <p>.
       * Whitespace between <br> elements are ignored. For example:
       *   <div>foo<br>bar<br> <br><br>abc</div>
       * will become:
       *   <div>foo<br>bar<p>abc</p></div>
       */
      _replaceBrs: function(elem) {
        this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br) {
          var next2 = br.nextSibling;
          var replaced = false;
          while ((next2 = this._nextNode(next2)) && next2.tagName == "BR") {
            replaced = true;
            var brSibling = next2.nextSibling;
            next2.parentNode.removeChild(next2);
            next2 = brSibling;
          }
          if (replaced) {
            var p5 = this._doc.createElement("p");
            br.parentNode.replaceChild(p5, br);
            next2 = p5.nextSibling;
            while (next2) {
              if (next2.tagName == "BR") {
                var nextElem = this._nextNode(next2.nextSibling);
                if (nextElem && nextElem.tagName == "BR")
                  break;
              }
              if (!this._isPhrasingContent(next2))
                break;
              var sibling = next2.nextSibling;
              p5.appendChild(next2);
              next2 = sibling;
            }
            while (p5.lastChild && this._isWhitespace(p5.lastChild)) {
              p5.removeChild(p5.lastChild);
            }
            if (p5.parentNode.tagName === "P")
              this._setNodeTag(p5.parentNode, "DIV");
          }
        });
      },
      _setNodeTag: function(node, tag) {
        this.log("_setNodeTag", node, tag);
        if (this._docJSDOMParser) {
          node.localName = tag.toLowerCase();
          node.tagName = tag.toUpperCase();
          return node;
        }
        var replacement = node.ownerDocument.createElement(tag);
        while (node.firstChild) {
          replacement.appendChild(node.firstChild);
        }
        node.parentNode.replaceChild(replacement, node);
        if (node.readability)
          replacement.readability = node.readability;
        for (var i9 = 0; i9 < node.attributes.length; i9++) {
          try {
            replacement.setAttribute(node.attributes[i9].name, node.attributes[i9].value);
          } catch (ex) {
          }
        }
        return replacement;
      },
      /**
       * Prepare the article node for display. Clean out any inline styles,
       * iframes, forms, strip extraneous <p> tags, etc.
       *
       * @param Element
       * @return void
       **/
      _prepArticle: function(articleContent) {
        this._cleanStyles(articleContent);
        this._markDataTables(articleContent);
        this._fixLazyImages(articleContent);
        this._cleanConditionally(articleContent, "form");
        this._cleanConditionally(articleContent, "fieldset");
        this._clean(articleContent, "object");
        this._clean(articleContent, "embed");
        this._clean(articleContent, "footer");
        this._clean(articleContent, "link");
        this._clean(articleContent, "aside");
        var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
        this._forEachNode(articleContent.children, function(topCandidate) {
          this._cleanMatchedNodes(topCandidate, function(node, matchString) {
            return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
          });
        });
        this._clean(articleContent, "iframe");
        this._clean(articleContent, "input");
        this._clean(articleContent, "textarea");
        this._clean(articleContent, "select");
        this._clean(articleContent, "button");
        this._cleanHeaders(articleContent);
        this._cleanConditionally(articleContent, "table");
        this._cleanConditionally(articleContent, "ul");
        this._cleanConditionally(articleContent, "div");
        this._replaceNodeTags(this._getAllNodesWithTag(articleContent, ["h1"]), "h2");
        this._removeNodes(this._getAllNodesWithTag(articleContent, ["p"]), function(paragraph) {
          var imgCount = paragraph.getElementsByTagName("img").length;
          var embedCount = paragraph.getElementsByTagName("embed").length;
          var objectCount = paragraph.getElementsByTagName("object").length;
          var iframeCount = paragraph.getElementsByTagName("iframe").length;
          var totalCount = imgCount + embedCount + objectCount + iframeCount;
          return totalCount === 0 && !this._getInnerText(paragraph, false);
        });
        this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function(br) {
          var next2 = this._nextNode(br.nextSibling);
          if (next2 && next2.tagName == "P")
            br.parentNode.removeChild(br);
        });
        this._forEachNode(this._getAllNodesWithTag(articleContent, ["table"]), function(table) {
          var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
          if (this._hasSingleTagInsideElement(tbody, "TR")) {
            var row = tbody.firstElementChild;
            if (this._hasSingleTagInsideElement(row, "TD")) {
              var cell = row.firstElementChild;
              cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV");
              table.parentNode.replaceChild(cell, table);
            }
          }
        });
      },
      /**
       * Initialize a node with the readability object. Also checks the
       * className/id for special names to add to its score.
       *
       * @param Element
       * @return void
      **/
      _initializeNode: function(node) {
        node.readability = { "contentScore": 0 };
        switch (node.tagName) {
          case "DIV":
            node.readability.contentScore += 5;
            break;
          case "PRE":
          case "TD":
          case "BLOCKQUOTE":
            node.readability.contentScore += 3;
            break;
          case "ADDRESS":
          case "OL":
          case "UL":
          case "DL":
          case "DD":
          case "DT":
          case "LI":
          case "FORM":
            node.readability.contentScore -= 3;
            break;
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
          case "TH":
            node.readability.contentScore -= 5;
            break;
        }
        node.readability.contentScore += this._getClassWeight(node);
      },
      _removeAndGetNext: function(node) {
        var nextNode = this._getNextNode(node, true);
        node.parentNode.removeChild(node);
        return nextNode;
      },
      /**
       * Traverse the DOM from node to node, starting at the node passed in.
       * Pass true for the second parameter to indicate this node itself
       * (and its kids) are going away, and we want the next node over.
       *
       * Calling this in a loop will traverse the DOM depth-first.
       */
      _getNextNode: function(node, ignoreSelfAndKids) {
        if (!ignoreSelfAndKids && node.firstElementChild) {
          return node.firstElementChild;
        }
        if (node.nextElementSibling) {
          return node.nextElementSibling;
        }
        do {
          node = node.parentNode;
        } while (node && !node.nextElementSibling);
        return node && node.nextElementSibling;
      },
      // compares second text to first one
      // 1 = same text, 0 = completely different text
      // works the way that it splits both texts into words and then finds words that are unique in second text
      // the result is given by the lower length of unique parts
      _textSimilarity: function(textA, textB) {
        var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
        if (!tokensA.length || !tokensB.length) {
          return 0;
        }
        var uniqTokensB = tokensB.filter((token) => !tokensA.includes(token));
        var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
        return 1 - distanceB;
      },
      _checkByline: function(node, matchString) {
        if (this._articleByline) {
          return false;
        }
        if (node.getAttribute !== void 0) {
          var rel = node.getAttribute("rel");
          var itemprop = node.getAttribute("itemprop");
        }
        if ((rel === "author" || itemprop && itemprop.indexOf("author") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
          this._articleByline = node.textContent.trim();
          return true;
        }
        return false;
      },
      _getNodeAncestors: function(node, maxDepth) {
        maxDepth = maxDepth || 0;
        var i9 = 0, ancestors = [];
        while (node.parentNode) {
          ancestors.push(node.parentNode);
          if (maxDepth && ++i9 === maxDepth)
            break;
          node = node.parentNode;
        }
        return ancestors;
      },
      /***
       * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
       *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
       *
       * @param page a document to run upon. Needs to be a full document, complete with body.
       * @return Element
      **/
      _grabArticle: function(page2) {
        this.log("**** grabArticle ****");
        var doc = this._doc;
        var isPaging = page2 !== null;
        page2 = page2 ? page2 : this._doc.body;
        if (!page2) {
          this.log("No body found in document. Abort.");
          return null;
        }
        var pageCacheHtml = page2.innerHTML;
        while (true) {
          this.log("Starting grabArticle loop");
          var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);
          var elementsToScore = [];
          var node = this._doc.documentElement;
          let shouldRemoveTitleHeader = true;
          while (node) {
            if (node.tagName === "HTML") {
              this._articleLang = node.getAttribute("lang");
            }
            var matchString = node.className + " " + node.id;
            if (!this._isProbablyVisible(node)) {
              this.log("Removing hidden node - " + matchString);
              node = this._removeAndGetNext(node);
              continue;
            }
            if (node.getAttribute("aria-modal") == "true" && node.getAttribute("role") == "dialog") {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (this._checkByline(node, matchString)) {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
              this.log("Removing header: ", node.textContent.trim(), this._articleTitle.trim());
              shouldRemoveTitleHeader = false;
              node = this._removeAndGetNext(node);
              continue;
            }
            if (stripUnlikelyCandidates) {
              if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
                this.log("Removing unlikely candidate - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
              if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
                this.log("Removing content with role " + node.getAttribute("role") + " - " + matchString);
                node = this._removeAndGetNext(node);
                continue;
              }
            }
            if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
              node = this._removeAndGetNext(node);
              continue;
            }
            if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
              elementsToScore.push(node);
            }
            if (node.tagName === "DIV") {
              var p5 = null;
              var childNode = node.firstChild;
              while (childNode) {
                var nextSibling = childNode.nextSibling;
                if (this._isPhrasingContent(childNode)) {
                  if (p5 !== null) {
                    p5.appendChild(childNode);
                  } else if (!this._isWhitespace(childNode)) {
                    p5 = doc.createElement("p");
                    node.replaceChild(p5, childNode);
                    p5.appendChild(childNode);
                  }
                } else if (p5 !== null) {
                  while (p5.lastChild && this._isWhitespace(p5.lastChild)) {
                    p5.removeChild(p5.lastChild);
                  }
                  p5 = null;
                }
                childNode = nextSibling;
              }
              if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
                var newNode = node.children[0];
                node.parentNode.replaceChild(newNode, node);
                node = newNode;
                elementsToScore.push(node);
              } else if (!this._hasChildBlockElement(node)) {
                node = this._setNodeTag(node, "P");
                elementsToScore.push(node);
              }
            }
            node = this._getNextNode(node);
          }
          var candidates = [];
          this._forEachNode(elementsToScore, function(elementToScore) {
            if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined")
              return;
            var innerText = this._getInnerText(elementToScore);
            if (innerText.length < 25)
              return;
            var ancestors2 = this._getNodeAncestors(elementToScore, 5);
            if (ancestors2.length === 0)
              return;
            var contentScore = 0;
            contentScore += 1;
            contentScore += innerText.split(this.REGEXPS.commas).length;
            contentScore += Math.min(Math.floor(innerText.length / 100), 3);
            this._forEachNode(ancestors2, function(ancestor, level) {
              if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined")
                return;
              if (typeof ancestor.readability === "undefined") {
                this._initializeNode(ancestor);
                candidates.push(ancestor);
              }
              if (level === 0)
                var scoreDivider = 1;
              else if (level === 1)
                scoreDivider = 2;
              else
                scoreDivider = level * 3;
              ancestor.readability.contentScore += contentScore / scoreDivider;
            });
          });
          var topCandidates = [];
          for (var c8 = 0, cl = candidates.length; c8 < cl; c8 += 1) {
            var candidate = candidates[c8];
            var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
            candidate.readability.contentScore = candidateScore;
            this.log("Candidate:", candidate, "with score " + candidateScore);
            for (var t8 = 0; t8 < this._nbTopCandidates; t8++) {
              var aTopCandidate = topCandidates[t8];
              if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
                topCandidates.splice(t8, 0, candidate);
                if (topCandidates.length > this._nbTopCandidates)
                  topCandidates.pop();
                break;
              }
            }
          }
          var topCandidate = topCandidates[0] || null;
          var neededToCreateTopCandidate = false;
          var parentOfTopCandidate;
          if (topCandidate === null || topCandidate.tagName === "BODY") {
            topCandidate = doc.createElement("DIV");
            neededToCreateTopCandidate = true;
            while (page2.firstChild) {
              this.log("Moving child out:", page2.firstChild);
              topCandidate.appendChild(page2.firstChild);
            }
            page2.appendChild(topCandidate);
            this._initializeNode(topCandidate);
          } else if (topCandidate) {
            var alternativeCandidateAncestors = [];
            for (var i9 = 1; i9 < topCandidates.length; i9++) {
              if (topCandidates[i9].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
                alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i9]));
              }
            }
            var MINIMUM_TOPCANDIDATES = 3;
            if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
              parentOfTopCandidate = topCandidate.parentNode;
              while (parentOfTopCandidate.tagName !== "BODY") {
                var listsContainingThisAncestor = 0;
                for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
                  listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
                }
                if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
                  topCandidate = parentOfTopCandidate;
                  break;
                }
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
              }
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
            parentOfTopCandidate = topCandidate.parentNode;
            var lastScore = topCandidate.readability.contentScore;
            var scoreThreshold = lastScore / 3;
            while (parentOfTopCandidate.tagName !== "BODY") {
              if (!parentOfTopCandidate.readability) {
                parentOfTopCandidate = parentOfTopCandidate.parentNode;
                continue;
              }
              var parentScore = parentOfTopCandidate.readability.contentScore;
              if (parentScore < scoreThreshold)
                break;
              if (parentScore > lastScore) {
                topCandidate = parentOfTopCandidate;
                break;
              }
              lastScore = parentOfTopCandidate.readability.contentScore;
              parentOfTopCandidate = parentOfTopCandidate.parentNode;
            }
            parentOfTopCandidate = topCandidate.parentNode;
            while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
              topCandidate = parentOfTopCandidate;
              parentOfTopCandidate = topCandidate.parentNode;
            }
            if (!topCandidate.readability) {
              this._initializeNode(topCandidate);
            }
          }
          var articleContent = doc.createElement("DIV");
          if (isPaging)
            articleContent.id = "readability-content";
          var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);
          parentOfTopCandidate = topCandidate.parentNode;
          var siblings = parentOfTopCandidate.children;
          for (var s9 = 0, sl = siblings.length; s9 < sl; s9++) {
            var sibling = siblings[s9];
            var append = false;
            this.log("Looking at sibling node:", sibling, sibling.readability ? "with score " + sibling.readability.contentScore : "");
            this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : "Unknown");
            if (sibling === topCandidate) {
              append = true;
            } else {
              var contentBonus = 0;
              if (sibling.className === topCandidate.className && topCandidate.className !== "")
                contentBonus += topCandidate.readability.contentScore * 0.2;
              if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
                append = true;
              } else if (sibling.nodeName === "P") {
                var linkDensity = this._getLinkDensity(sibling);
                var nodeContent = this._getInnerText(sibling);
                var nodeLength = nodeContent.length;
                if (nodeLength > 80 && linkDensity < 0.25) {
                  append = true;
                } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\.( |$)/) !== -1) {
                  append = true;
                }
              }
            }
            if (append) {
              this.log("Appending node:", sibling);
              if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
                this.log("Altering sibling:", sibling, "to div.");
                sibling = this._setNodeTag(sibling, "DIV");
              }
              articleContent.appendChild(sibling);
              siblings = parentOfTopCandidate.children;
              s9 -= 1;
              sl -= 1;
            }
          }
          if (this._debug)
            this.log("Article content pre-prep: " + articleContent.innerHTML);
          this._prepArticle(articleContent);
          if (this._debug)
            this.log("Article content post-prep: " + articleContent.innerHTML);
          if (neededToCreateTopCandidate) {
            topCandidate.id = "readability-page-1";
            topCandidate.className = "page";
          } else {
            var div = doc.createElement("DIV");
            div.id = "readability-page-1";
            div.className = "page";
            while (articleContent.firstChild) {
              div.appendChild(articleContent.firstChild);
            }
            articleContent.appendChild(div);
          }
          if (this._debug)
            this.log("Article content after paging: " + articleContent.innerHTML);
          var parseSuccessful = true;
          var textLength = this._getInnerText(articleContent, true).length;
          if (textLength < this._charThreshold) {
            parseSuccessful = false;
            page2.innerHTML = pageCacheHtml;
            if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
              this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
              this._attempts.push({ articleContent, textLength });
            } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
              this._removeFlag(this.FLAG_WEIGHT_CLASSES);
              this._attempts.push({ articleContent, textLength });
            } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
              this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
              this._attempts.push({ articleContent, textLength });
            } else {
              this._attempts.push({ articleContent, textLength });
              this._attempts.sort(function(a7, b5) {
                return b5.textLength - a7.textLength;
              });
              if (!this._attempts[0].textLength) {
                return null;
              }
              articleContent = this._attempts[0].articleContent;
              parseSuccessful = true;
            }
          }
          if (parseSuccessful) {
            var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));
            this._someNode(ancestors, function(ancestor) {
              if (!ancestor.tagName)
                return false;
              var articleDir = ancestor.getAttribute("dir");
              if (articleDir) {
                this._articleDir = articleDir;
                return true;
              }
              return false;
            });
            return articleContent;
          }
        }
      },
      /**
       * Check whether the input string could be a byline.
       * This verifies that the input is a string, and that the length
       * is less than 100 chars.
       *
       * @param possibleByline {string} - a string to check whether its a byline.
       * @return Boolean - whether the input string is a byline.
       */
      _isValidByline: function(byline) {
        if (typeof byline == "string" || byline instanceof String) {
          byline = byline.trim();
          return byline.length > 0 && byline.length < 100;
        }
        return false;
      },
      /**
       * Converts some of the common HTML entities in string to their corresponding characters.
       *
       * @param str {string} - a string to unescape.
       * @return string without HTML entity.
       */
      _unescapeHtmlEntities: function(str2) {
        if (!str2) {
          return str2;
        }
        var htmlEscapeMap = this.HTML_ESCAPE_MAP;
        return str2.replace(/&(quot|amp|apos|lt|gt);/g, function(_4, tag) {
          return htmlEscapeMap[tag];
        }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_4, hex, numStr) {
          var num = parseInt(hex || numStr, hex ? 16 : 10);
          return String.fromCharCode(num);
        });
      },
      /**
       * Try to extract metadata from JSON-LD object.
       * For now, only Schema.org objects of type Article or its subtypes are supported.
       * @return Object with any metadata that could be extracted (possibly none)
       */
      _getJSONLD: function(doc) {
        var scripts = this._getAllNodesWithTag(doc, ["script"]);
        var metadata;
        this._forEachNode(scripts, function(jsonLdElement) {
          if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
            try {
              var content = jsonLdElement.textContent.replace(/^\s*<!\[CDATA\[|\]\]>\s*$/g, "");
              var parsed = JSON.parse(content);
              if (!parsed["@context"] || !parsed["@context"].match(/^https?\:\/\/schema\.org$/)) {
                return;
              }
              if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
                parsed = parsed["@graph"].find(function(it2) {
                  return (it2["@type"] || "").match(
                    this.REGEXPS.jsonLdArticleTypes
                  );
                });
              }
              if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
                return;
              }
              metadata = {};
              if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
                var title = this._getArticleTitle();
                var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
                var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;
                if (headlineMatches && !nameMatches) {
                  metadata.title = parsed.headline;
                } else {
                  metadata.title = parsed.name;
                }
              } else if (typeof parsed.name === "string") {
                metadata.title = parsed.name.trim();
              } else if (typeof parsed.headline === "string") {
                metadata.title = parsed.headline.trim();
              }
              if (parsed.author) {
                if (typeof parsed.author.name === "string") {
                  metadata.byline = parsed.author.name.trim();
                } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
                  metadata.byline = parsed.author.filter(function(author) {
                    return author && typeof author.name === "string";
                  }).map(function(author) {
                    return author.name.trim();
                  }).join(", ");
                }
              }
              if (typeof parsed.description === "string") {
                metadata.excerpt = parsed.description.trim();
              }
              if (parsed.publisher && typeof parsed.publisher.name === "string") {
                metadata.siteName = parsed.publisher.name.trim();
              }
              if (typeof parsed.datePublished === "string") {
                metadata.datePublished = parsed.datePublished.trim();
              }
              return;
            } catch (err) {
              this.log(err.message);
            }
          }
        });
        return metadata ? metadata : {};
      },
      /**
       * Attempts to get excerpt and byline metadata for the article.
       *
       * @param {Object} jsonld  object containing any metadata that
       * could be extracted from JSON-LD object.
       *
       * @return Object with optional "excerpt" and "byline" properties
       */
      _getArticleMetadata: function(jsonld) {
        var metadata = {};
        var values = {};
        var metaElements = this._doc.getElementsByTagName("meta");
        var propertyPattern = /\s*(article|dc|dcterm|og|twitter)\s*:\s*(author|creator|description|published_time|title|site_name)\s*/gi;
        var namePattern = /^\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\s*[\.:]\s*)?(author|creator|description|title|site_name)\s*$/i;
        this._forEachNode(metaElements, function(element) {
          var elementName = element.getAttribute("name");
          var elementProperty = element.getAttribute("property");
          var content = element.getAttribute("content");
          if (!content) {
            return;
          }
          var matches2 = null;
          var name2 = null;
          if (elementProperty) {
            matches2 = elementProperty.match(propertyPattern);
            if (matches2) {
              name2 = matches2[0].toLowerCase().replace(/\s/g, "");
              values[name2] = content.trim();
            }
          }
          if (!matches2 && elementName && namePattern.test(elementName)) {
            name2 = elementName;
            if (content) {
              name2 = name2.toLowerCase().replace(/\s/g, "").replace(/\./g, ":");
              values[name2] = content.trim();
            }
          }
        });
        metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values["title"] || values["twitter:title"];
        if (!metadata.title) {
          metadata.title = this._getArticleTitle();
        }
        metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values["author"];
        metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values["description"] || values["twitter:description"];
        metadata.siteName = jsonld.siteName || values["og:site_name"];
        metadata.publishedTime = jsonld.datePublished || values["article:published_time"] || null;
        metadata.title = this._unescapeHtmlEntities(metadata.title);
        metadata.byline = this._unescapeHtmlEntities(metadata.byline);
        metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
        metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
        metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);
        return metadata;
      },
      /**
       * Check if node is image, or if node contains exactly only one image
       * whether as a direct child or as its descendants.
       *
       * @param Element
      **/
      _isSingleImage: function(node) {
        if (node.tagName === "IMG") {
          return true;
        }
        if (node.children.length !== 1 || node.textContent.trim() !== "") {
          return false;
        }
        return this._isSingleImage(node.children[0]);
      },
      /**
       * Find all <noscript> that are located after <img> nodes, and which contain only one
       * <img> element. Replace the first image with the image from inside the <noscript> tag,
       * and remove the <noscript> tag. This improves the quality of the images we use on
       * some sites (e.g. Medium).
       *
       * @param Element
      **/
      _unwrapNoscriptImages: function(doc) {
        var imgs = Array.from(doc.getElementsByTagName("img"));
        this._forEachNode(imgs, function(img) {
          for (var i9 = 0; i9 < img.attributes.length; i9++) {
            var attr2 = img.attributes[i9];
            switch (attr2.name) {
              case "src":
              case "srcset":
              case "data-src":
              case "data-srcset":
                return;
            }
            if (/\.(jpg|jpeg|png|webp)/i.test(attr2.value)) {
              return;
            }
          }
          img.parentNode.removeChild(img);
        });
        var noscripts = Array.from(doc.getElementsByTagName("noscript"));
        this._forEachNode(noscripts, function(noscript) {
          var tmp = doc.createElement("div");
          tmp.innerHTML = noscript.innerHTML;
          if (!this._isSingleImage(tmp)) {
            return;
          }
          var prevElement = noscript.previousElementSibling;
          if (prevElement && this._isSingleImage(prevElement)) {
            var prevImg = prevElement;
            if (prevImg.tagName !== "IMG") {
              prevImg = prevElement.getElementsByTagName("img")[0];
            }
            var newImg = tmp.getElementsByTagName("img")[0];
            for (var i9 = 0; i9 < prevImg.attributes.length; i9++) {
              var attr2 = prevImg.attributes[i9];
              if (attr2.value === "") {
                continue;
              }
              if (attr2.name === "src" || attr2.name === "srcset" || /\.(jpg|jpeg|png|webp)/i.test(attr2.value)) {
                if (newImg.getAttribute(attr2.name) === attr2.value) {
                  continue;
                }
                var attrName = attr2.name;
                if (newImg.hasAttribute(attrName)) {
                  attrName = "data-old-" + attrName;
                }
                newImg.setAttribute(attrName, attr2.value);
              }
            }
            noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
          }
        });
      },
      /**
       * Removes script tags from the document.
       *
       * @param Element
      **/
      _removeScripts: function(doc) {
        this._removeNodes(this._getAllNodesWithTag(doc, ["script", "noscript"]));
      },
      /**
       * Check if this node has only whitespace and a single element with given tag
       * Returns false if the DIV node contains non-empty text nodes
       * or if it contains no element with given tag or more than 1 element.
       *
       * @param Element
       * @param string tag of child element
      **/
      _hasSingleTagInsideElement: function(element, tag) {
        if (element.children.length != 1 || element.children[0].tagName !== tag) {
          return false;
        }
        return !this._someNode(element.childNodes, function(node) {
          return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
        });
      },
      _isElementWithoutContent: function(node) {
        return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
      },
      /**
       * Determine whether element has any children block level elements.
       *
       * @param Element
       */
      _hasChildBlockElement: function(element) {
        return this._someNode(element.childNodes, function(node) {
          return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
        });
      },
      /***
       * Determine if a node qualifies as phrasing content.
       * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
      **/
      _isPhrasingContent: function(node) {
        return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
      },
      _isWhitespace: function(node) {
        return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
      },
      /**
       * Get the inner text of a node - cross browser compatibly.
       * This also strips out any excess whitespace to be found.
       *
       * @param Element
       * @param Boolean normalizeSpaces (default: true)
       * @return string
      **/
      _getInnerText: function(e5, normalizeSpaces) {
        normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
        var textContent = e5.textContent.trim();
        if (normalizeSpaces) {
          return textContent.replace(this.REGEXPS.normalize, " ");
        }
        return textContent;
      },
      /**
       * Get the number of times a string s appears in the node e.
       *
       * @param Element
       * @param string - what to split on. Default is ","
       * @return number (integer)
      **/
      _getCharCount: function(e5, s9) {
        s9 = s9 || ",";
        return this._getInnerText(e5).split(s9).length - 1;
      },
      /**
       * Remove the style attribute on every e and under.
       * TODO: Test if getElementsByTagName(*) is faster.
       *
       * @param Element
       * @return void
      **/
      _cleanStyles: function(e5) {
        if (!e5 || e5.tagName.toLowerCase() === "svg")
          return;
        for (var i9 = 0; i9 < this.PRESENTATIONAL_ATTRIBUTES.length; i9++) {
          e5.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i9]);
        }
        if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e5.tagName) !== -1) {
          e5.removeAttribute("width");
          e5.removeAttribute("height");
        }
        var cur = e5.firstElementChild;
        while (cur !== null) {
          this._cleanStyles(cur);
          cur = cur.nextElementSibling;
        }
      },
      /**
       * Get the density of links as a percentage of the content
       * This is the amount of text that is inside a link divided by the total text in the node.
       *
       * @param Element
       * @return number (float)
      **/
      _getLinkDensity: function(element) {
        var textLength = this._getInnerText(element).length;
        if (textLength === 0)
          return 0;
        var linkLength = 0;
        this._forEachNode(element.getElementsByTagName("a"), function(linkNode) {
          var href = linkNode.getAttribute("href");
          var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
          linkLength += this._getInnerText(linkNode).length * coefficient;
        });
        return linkLength / textLength;
      },
      /**
       * Get an elements class/id weight. Uses regular expressions to tell if this
       * element looks good or bad.
       *
       * @param Element
       * @return number (Integer)
      **/
      _getClassWeight: function(e5) {
        if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))
          return 0;
        var weight = 0;
        if (typeof e5.className === "string" && e5.className !== "") {
          if (this.REGEXPS.negative.test(e5.className))
            weight -= 25;
          if (this.REGEXPS.positive.test(e5.className))
            weight += 25;
        }
        if (typeof e5.id === "string" && e5.id !== "") {
          if (this.REGEXPS.negative.test(e5.id))
            weight -= 25;
          if (this.REGEXPS.positive.test(e5.id))
            weight += 25;
        }
        return weight;
      },
      /**
       * Clean a node of all elements of type "tag".
       * (Unless it's a youtube/vimeo video. People love movies.)
       *
       * @param Element
       * @param string tag to clean
       * @return void
       **/
      _clean: function(e5, tag) {
        var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;
        this._removeNodes(this._getAllNodesWithTag(e5, [tag]), function(element) {
          if (isEmbed) {
            for (var i9 = 0; i9 < element.attributes.length; i9++) {
              if (this._allowedVideoRegex.test(element.attributes[i9].value)) {
                return false;
              }
            }
            if (element.tagName === "object" && this._allowedVideoRegex.test(element.innerHTML)) {
              return false;
            }
          }
          return true;
        });
      },
      /**
       * Check if a given node has one of its ancestor tag name matching the
       * provided one.
       * @param  HTMLElement node
       * @param  String      tagName
       * @param  Number      maxDepth
       * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
       * @return Boolean
       */
      _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {
        maxDepth = maxDepth || 3;
        tagName = tagName.toUpperCase();
        var depth = 0;
        while (node.parentNode) {
          if (maxDepth > 0 && depth > maxDepth)
            return false;
          if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))
            return true;
          node = node.parentNode;
          depth++;
        }
        return false;
      },
      /**
       * Return an object indicating how many rows and columns this table has.
       */
      _getRowAndColumnCount: function(table) {
        var rows = 0;
        var columns = 0;
        var trs = table.getElementsByTagName("tr");
        for (var i9 = 0; i9 < trs.length; i9++) {
          var rowspan = trs[i9].getAttribute("rowspan") || 0;
          if (rowspan) {
            rowspan = parseInt(rowspan, 10);
          }
          rows += rowspan || 1;
          var columnsInThisRow = 0;
          var cells = trs[i9].getElementsByTagName("td");
          for (var j4 = 0; j4 < cells.length; j4++) {
            var colspan = cells[j4].getAttribute("colspan") || 0;
            if (colspan) {
              colspan = parseInt(colspan, 10);
            }
            columnsInThisRow += colspan || 1;
          }
          columns = Math.max(columns, columnsInThisRow);
        }
        return { rows, columns };
      },
      /**
       * Look for 'data' (as opposed to 'layout') tables, for which we use
       * similar checks as
       * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
       */
      _markDataTables: function(root2) {
        var tables = root2.getElementsByTagName("table");
        for (var i9 = 0; i9 < tables.length; i9++) {
          var table = tables[i9];
          var role = table.getAttribute("role");
          if (role == "presentation") {
            table._readabilityDataTable = false;
            continue;
          }
          var datatable = table.getAttribute("datatable");
          if (datatable == "0") {
            table._readabilityDataTable = false;
            continue;
          }
          var summary = table.getAttribute("summary");
          if (summary) {
            table._readabilityDataTable = true;
            continue;
          }
          var caption = table.getElementsByTagName("caption")[0];
          if (caption && caption.childNodes.length > 0) {
            table._readabilityDataTable = true;
            continue;
          }
          var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
          var descendantExists = function(tag) {
            return !!table.getElementsByTagName(tag)[0];
          };
          if (dataTableDescendants.some(descendantExists)) {
            this.log("Data table because found data-y descendant");
            table._readabilityDataTable = true;
            continue;
          }
          if (table.getElementsByTagName("table")[0]) {
            table._readabilityDataTable = false;
            continue;
          }
          var sizeInfo = this._getRowAndColumnCount(table);
          if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
            table._readabilityDataTable = true;
            continue;
          }
          table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
        }
      },
      /* convert images and figures that have properties like data-src into images that can be loaded without JS */
      _fixLazyImages: function(root2) {
        this._forEachNode(this._getAllNodesWithTag(root2, ["img", "picture", "figure"]), function(elem) {
          if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
            var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
            if (parts[1] === "image/svg+xml") {
              return;
            }
            var srcCouldBeRemoved = false;
            for (var i9 = 0; i9 < elem.attributes.length; i9++) {
              var attr2 = elem.attributes[i9];
              if (attr2.name === "src") {
                continue;
              }
              if (/\.(jpg|jpeg|png|webp)/i.test(attr2.value)) {
                srcCouldBeRemoved = true;
                break;
              }
            }
            if (srcCouldBeRemoved) {
              var b64starts = elem.src.search(/base64\s*/i) + 7;
              var b64length = elem.src.length - b64starts;
              if (b64length < 133) {
                elem.removeAttribute("src");
              }
            }
          }
          if ((elem.src || elem.srcset && elem.srcset != "null") && elem.className.toLowerCase().indexOf("lazy") === -1) {
            return;
          }
          for (var j4 = 0; j4 < elem.attributes.length; j4++) {
            attr2 = elem.attributes[j4];
            if (attr2.name === "src" || attr2.name === "srcset" || attr2.name === "alt") {
              continue;
            }
            var copyTo = null;
            if (/\.(jpg|jpeg|png|webp)\s+\d/.test(attr2.value)) {
              copyTo = "srcset";
            } else if (/^\s*\S+\.(jpg|jpeg|png|webp)\S*\s*$/.test(attr2.value)) {
              copyTo = "src";
            }
            if (copyTo) {
              if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
                elem.setAttribute(copyTo, attr2.value);
              } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
                var img = this._doc.createElement("img");
                img.setAttribute(copyTo, attr2.value);
                elem.appendChild(img);
              }
            }
          }
        });
      },
      _getTextDensity: function(e5, tags) {
        var textLength = this._getInnerText(e5, true).length;
        if (textLength === 0) {
          return 0;
        }
        var childrenLength = 0;
        var children = this._getAllNodesWithTag(e5, tags);
        this._forEachNode(children, (child) => childrenLength += this._getInnerText(child, true).length);
        return childrenLength / textLength;
      },
      /**
       * Clean an element of all tags of type "tag" if they look fishy.
       * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
       *
       * @return void
       **/
      _cleanConditionally: function(e5, tag) {
        if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))
          return;
        this._removeNodes(this._getAllNodesWithTag(e5, [tag]), function(node) {
          var isDataTable = function(t8) {
            return t8._readabilityDataTable;
          };
          var isList = tag === "ul" || tag === "ol";
          if (!isList) {
            var listLength = 0;
            var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
            this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);
            isList = listLength / this._getInnerText(node).length > 0.9;
          }
          if (tag === "table" && isDataTable(node)) {
            return false;
          }
          if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
            return false;
          }
          if (this._hasAncestorTag(node, "code")) {
            return false;
          }
          var weight = this._getClassWeight(node);
          this.log("Cleaning Conditionally", node);
          var contentScore = 0;
          if (weight + contentScore < 0) {
            return true;
          }
          if (this._getCharCount(node, ",") < 10) {
            var p5 = node.getElementsByTagName("p").length;
            var img = node.getElementsByTagName("img").length;
            var li = node.getElementsByTagName("li").length - 100;
            var input = node.getElementsByTagName("input").length;
            var headingDensity = this._getTextDensity(node, ["h1", "h2", "h3", "h4", "h5", "h6"]);
            var embedCount = 0;
            var embeds = this._getAllNodesWithTag(node, ["object", "embed", "iframe"]);
            for (var i9 = 0; i9 < embeds.length; i9++) {
              for (var j4 = 0; j4 < embeds[i9].attributes.length; j4++) {
                if (this._allowedVideoRegex.test(embeds[i9].attributes[j4].value)) {
                  return false;
                }
              }
              if (embeds[i9].tagName === "object" && this._allowedVideoRegex.test(embeds[i9].innerHTML)) {
                return false;
              }
              embedCount++;
            }
            var linkDensity = this._getLinkDensity(node);
            var contentLength = this._getInnerText(node).length;
            var haveToRemove = img > 1 && p5 / img < 0.5 && !this._hasAncestorTag(node, "figure") || !isList && li > p5 || input > Math.floor(p5 / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || (embedCount === 1 && contentLength < 75 || embedCount > 1);
            if (isList && haveToRemove) {
              for (var x4 = 0; x4 < node.children.length; x4++) {
                let child = node.children[x4];
                if (child.children.length > 1) {
                  return haveToRemove;
                }
              }
              let li_count = node.getElementsByTagName("li").length;
              if (img == li_count) {
                return false;
              }
            }
            return haveToRemove;
          }
          return false;
        });
      },
      /**
       * Clean out elements that match the specified conditions
       *
       * @param Element
       * @param Function determines whether a node should be removed
       * @return void
       **/
      _cleanMatchedNodes: function(e5, filter) {
        var endOfSearchMarkerNode = this._getNextNode(e5, true);
        var next2 = this._getNextNode(e5);
        while (next2 && next2 != endOfSearchMarkerNode) {
          if (filter.call(this, next2, next2.className + " " + next2.id)) {
            next2 = this._removeAndGetNext(next2);
          } else {
            next2 = this._getNextNode(next2);
          }
        }
      },
      /**
       * Clean out spurious headers from an Element.
       *
       * @param Element
       * @return void
      **/
      _cleanHeaders: function(e5) {
        let headingNodes = this._getAllNodesWithTag(e5, ["h1", "h2"]);
        this._removeNodes(headingNodes, function(node) {
          let shouldRemove = this._getClassWeight(node) < 0;
          if (shouldRemove) {
            this.log("Removing header with low class weight:", node);
          }
          return shouldRemove;
        });
      },
      /**
       * Check if this node is an H1 or H2 element whose content is mostly
       * the same as the article title.
       *
       * @param Element  the node to check.
       * @return boolean indicating whether this is a title-like header.
       */
      _headerDuplicatesTitle: function(node) {
        if (node.tagName != "H1" && node.tagName != "H2") {
          return false;
        }
        var heading = this._getInnerText(node, false);
        this.log("Evaluating similarity of header:", heading, this._articleTitle);
        return this._textSimilarity(this._articleTitle, heading) > 0.75;
      },
      _flagIsActive: function(flag) {
        return (this._flags & flag) > 0;
      },
      _removeFlag: function(flag) {
        this._flags = this._flags & ~flag;
      },
      _isProbablyVisible: function(node) {
        return (!node.style || node.style.display != "none") && (!node.style || node.style.visibility != "hidden") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
      },
      /**
       * Runs readability.
       *
       * Workflow:
       *  1. Prep the document by removing script tags, css, etc.
       *  2. Build readability's DOM tree.
       *  3. Grab the article content from the current dom tree.
       *  4. Replace the current DOM tree with the new one.
       *  5. Read peacefully.
       *
       * @return void
       **/
      parse: function() {
        if (this._maxElemsToParse > 0) {
          var numTags = this._doc.getElementsByTagName("*").length;
          if (numTags > this._maxElemsToParse) {
            throw new Error("Aborting parsing document; " + numTags + " elements found");
          }
        }
        this._unwrapNoscriptImages(this._doc);
        var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
        this._removeScripts(this._doc);
        this._prepDocument();
        var metadata = this._getArticleMetadata(jsonLd);
        this._articleTitle = metadata.title;
        var articleContent = this._grabArticle();
        if (!articleContent)
          return null;
        this.log("Grabbed: " + articleContent.innerHTML);
        this._postProcessContent(articleContent);
        if (!metadata.excerpt) {
          var paragraphs = articleContent.getElementsByTagName("p");
          if (paragraphs.length > 0) {
            metadata.excerpt = paragraphs[0].textContent.trim();
          }
        }
        var textContent = articleContent.textContent;
        return {
          title: this._articleTitle,
          byline: metadata.byline || this._articleByline,
          dir: this._articleDir,
          lang: this._articleLang,
          content: this._serializer(articleContent),
          textContent,
          length: textContent.length,
          excerpt: metadata.excerpt,
          siteName: metadata.siteName || this._articleSiteName,
          publishedTime: metadata.publishedTime
        };
      }
    };
    if (typeof module2 === "object") {
      module2.exports = Readability;
    }
  }
});

// node_modules/@mozilla/readability/Readability-readerable.js
var require_Readability_readerable = __commonJS({
  "node_modules/@mozilla/readability/Readability-readerable.js"(exports, module2) {
    var REGEXPS = {
      // NOTE: These two regular expressions are duplicated in
      // Readability.js. Please keep both copies in sync.
      unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
      okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
    };
    function isNodeVisible(node) {
      return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
    }
    function isProbablyReaderable(doc, options3 = {}) {
      if (typeof options3 == "function") {
        options3 = { visibilityChecker: options3 };
      }
      var defaultOptions4 = { minScore: 20, minContentLength: 140, visibilityChecker: isNodeVisible };
      options3 = Object.assign(defaultOptions4, options3);
      var nodes = doc.querySelectorAll("p, pre, article");
      var brNodes = doc.querySelectorAll("div > br");
      if (brNodes.length) {
        var set2 = new Set(nodes);
        [].forEach.call(brNodes, function(node) {
          set2.add(node.parentNode);
        });
        nodes = Array.from(set2);
      }
      var score = 0;
      return [].some.call(nodes, function(node) {
        if (!options3.visibilityChecker(node)) {
          return false;
        }
        var matchString = node.className + " " + node.id;
        if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
          return false;
        }
        if (node.matches("li p")) {
          return false;
        }
        var textContentLength = node.textContent.trim().length;
        if (textContentLength < options3.minContentLength) {
          return false;
        }
        score += Math.sqrt(textContentLength - options3.minContentLength);
        if (score > options3.minScore) {
          return true;
        }
        return false;
      });
    }
    if (typeof module2 === "object") {
      module2.exports = isProbablyReaderable;
    }
  }
});

// node_modules/@mozilla/readability/index.js
var require_readability = __commonJS({
  "node_modules/@mozilla/readability/index.js"(exports, module2) {
    var Readability = require_Readability();
    var isProbablyReaderable = require_Readability_readerable();
    module2.exports = {
      Readability,
      isProbablyReaderable
    };
  }
});

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i9 = 1; i9 < arguments.length; i9++) {
    var source2 = arguments[i9];
    for (var key3 in source2) {
      if (source2.hasOwnProperty(key3))
        destination[key3] = source2[key3];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n")
    indexEnd--;
  return string.substring(0, indexEnd);
}
function isBlock(node) {
  return is(node, blockElements);
}
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options3) {
  this.options = options3;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options3.blankReplacement
  };
  this.keepReplacement = options3.keepReplacement;
  this.defaultRule = {
    replacement: options3.defaultReplacement
  };
  this.array = [];
  for (var key3 in options3.rules)
    this.array.push(options3.rules[key3]);
}
function findRule(rules2, node, options3) {
  for (var i9 = 0; i9 < rules2.length; i9++) {
    var rule = rules2[i9];
    if (filterValue(rule, node, options3))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node, options3) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options3))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options3) {
  var element = options3.element;
  var isBlock2 = options3.isBlock;
  var isVoid2 = options3.isVoid;
  var isPre = options3.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element))
    return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text2 = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text2[0] === " ") {
        text2 = text2.substr(1);
      }
      if (!text2) {
        node = remove2(node);
        continue;
      }
      node.data = text2;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove2(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove2(prevText);
    }
  }
}
function remove2(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
function canParseHTMLNatively() {
  var Parser3 = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser3().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e5) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser3 = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser3.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser3.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser3;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e5) {
    if (window.ActiveXObject)
      useActiveX = true;
  }
  return useActiveX;
}
function RootNode(input, options3) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options3.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node2(node, options3) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options3);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options3) {
  if (node.isBlock || options3.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options3)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options3)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m5 = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m5[1],
    // whole string for whitespace-only strings
    leadingAscii: m5[2],
    leadingNonAscii: m5[3],
    trailing: m5[4],
    // empty for whitespace-only strings
    trailingNonAscii: m5[5],
    trailingAscii: m5[6]
  };
}
function isFlankedByWhitespace(side, node, options3) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options3.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
function TurndownService(options3) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options3);
  var defaults4 = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults4, options3);
  this.rules = new Rules(this.options);
}
function process2(parentNode) {
  var self2 = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node2(node, self2.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self2.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self2, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self2 = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self2.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process2.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing)
    content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s22 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s22.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s22;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var blockElements, voidElements, meaningfulWhenBlankElements, rules, root, HTMLParser, _htmlParser, reduce, escapes, turndown_browser_es_default;
var init_turndown_browser_es = __esm({
  "node_modules/turndown/lib/turndown.browser.es.js"() {
    blockElements = [
      "ADDRESS",
      "ARTICLE",
      "ASIDE",
      "AUDIO",
      "BLOCKQUOTE",
      "BODY",
      "CANVAS",
      "CENTER",
      "DD",
      "DIR",
      "DIV",
      "DL",
      "DT",
      "FIELDSET",
      "FIGCAPTION",
      "FIGURE",
      "FOOTER",
      "FORM",
      "FRAMESET",
      "H1",
      "H2",
      "H3",
      "H4",
      "H5",
      "H6",
      "HEADER",
      "HGROUP",
      "HR",
      "HTML",
      "ISINDEX",
      "LI",
      "MAIN",
      "MENU",
      "NAV",
      "NOFRAMES",
      "NOSCRIPT",
      "OL",
      "OUTPUT",
      "P",
      "PRE",
      "SECTION",
      "TABLE",
      "TBODY",
      "TD",
      "TFOOT",
      "TH",
      "THEAD",
      "TR",
      "UL"
    ];
    voidElements = [
      "AREA",
      "BASE",
      "BR",
      "COL",
      "COMMAND",
      "EMBED",
      "HR",
      "IMG",
      "INPUT",
      "KEYGEN",
      "LINK",
      "META",
      "PARAM",
      "SOURCE",
      "TRACK",
      "WBR"
    ];
    meaningfulWhenBlankElements = [
      "A",
      "TABLE",
      "THEAD",
      "TBODY",
      "TFOOT",
      "TH",
      "TD",
      "IFRAME",
      "SCRIPT",
      "AUDIO",
      "VIDEO"
    ];
    rules = {};
    rules.paragraph = {
      filter: "p",
      replacement: function(content) {
        return "\n\n" + content + "\n\n";
      }
    };
    rules.lineBreak = {
      filter: "br",
      replacement: function(content, node, options3) {
        return options3.br + "\n";
      }
    };
    rules.heading = {
      filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
      replacement: function(content, node, options3) {
        var hLevel = Number(node.nodeName.charAt(1));
        if (options3.headingStyle === "setext" && hLevel < 3) {
          var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
          return "\n\n" + content + "\n" + underline + "\n\n";
        } else {
          return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
        }
      }
    };
    rules.blockquote = {
      filter: "blockquote",
      replacement: function(content) {
        content = content.replace(/^\n+|\n+$/g, "");
        content = content.replace(/^/gm, "> ");
        return "\n\n" + content + "\n\n";
      }
    };
    rules.list = {
      filter: ["ul", "ol"],
      replacement: function(content, node) {
        var parent = node.parentNode;
        if (parent.nodeName === "LI" && parent.lastElementChild === node) {
          return "\n" + content;
        } else {
          return "\n\n" + content + "\n\n";
        }
      }
    };
    rules.listItem = {
      filter: "li",
      replacement: function(content, node, options3) {
        content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
        var prefix = options3.bulletListMarker + "   ";
        var parent = node.parentNode;
        if (parent.nodeName === "OL") {
          var start = parent.getAttribute("start");
          var index7 = Array.prototype.indexOf.call(parent.children, node);
          prefix = (start ? Number(start) + index7 : index7 + 1) + ".  ";
        }
        return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
      }
    };
    rules.indentedCodeBlock = {
      filter: function(node, options3) {
        return options3.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
      },
      replacement: function(content, node, options3) {
        return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
      }
    };
    rules.fencedCodeBlock = {
      filter: function(node, options3) {
        return options3.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
      },
      replacement: function(content, node, options3) {
        var className = node.firstChild.getAttribute("class") || "";
        var language = (className.match(/language-(\S+)/) || [null, ""])[1];
        var code = node.firstChild.textContent;
        var fenceChar = options3.fence.charAt(0);
        var fenceSize = 3;
        var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
        var match;
        while (match = fenceInCodeRegex.exec(code)) {
          if (match[0].length >= fenceSize) {
            fenceSize = match[0].length + 1;
          }
        }
        var fence = repeat(fenceChar, fenceSize);
        return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
      }
    };
    rules.horizontalRule = {
      filter: "hr",
      replacement: function(content, node, options3) {
        return "\n\n" + options3.hr + "\n\n";
      }
    };
    rules.inlineLink = {
      filter: function(node, options3) {
        return options3.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
      },
      replacement: function(content, node) {
        var href = node.getAttribute("href");
        var title = cleanAttribute(node.getAttribute("title"));
        if (title)
          title = ' "' + title + '"';
        return "[" + content + "](" + href + title + ")";
      }
    };
    rules.referenceLink = {
      filter: function(node, options3) {
        return options3.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
      },
      replacement: function(content, node, options3) {
        var href = node.getAttribute("href");
        var title = cleanAttribute(node.getAttribute("title"));
        if (title)
          title = ' "' + title + '"';
        var replacement;
        var reference;
        switch (options3.linkReferenceStyle) {
          case "collapsed":
            replacement = "[" + content + "][]";
            reference = "[" + content + "]: " + href + title;
            break;
          case "shortcut":
            replacement = "[" + content + "]";
            reference = "[" + content + "]: " + href + title;
            break;
          default:
            var id = this.references.length + 1;
            replacement = "[" + content + "][" + id + "]";
            reference = "[" + id + "]: " + href + title;
        }
        this.references.push(reference);
        return replacement;
      },
      references: [],
      append: function(options3) {
        var references = "";
        if (this.references.length) {
          references = "\n\n" + this.references.join("\n") + "\n\n";
          this.references = [];
        }
        return references;
      }
    };
    rules.emphasis = {
      filter: ["em", "i"],
      replacement: function(content, node, options3) {
        if (!content.trim())
          return "";
        return options3.emDelimiter + content + options3.emDelimiter;
      }
    };
    rules.strong = {
      filter: ["strong", "b"],
      replacement: function(content, node, options3) {
        if (!content.trim())
          return "";
        return options3.strongDelimiter + content + options3.strongDelimiter;
      }
    };
    rules.code = {
      filter: function(node) {
        var hasSiblings = node.previousSibling || node.nextSibling;
        var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
        return node.nodeName === "CODE" && !isCodeBlock;
      },
      replacement: function(content) {
        if (!content)
          return "";
        content = content.replace(/\r?\n|\r/g, " ");
        var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
        var delimiter = "`";
        var matches2 = content.match(/`+/gm) || [];
        while (matches2.indexOf(delimiter) !== -1)
          delimiter = delimiter + "`";
        return delimiter + extraSpace + content + extraSpace + delimiter;
      }
    };
    rules.image = {
      filter: "img",
      replacement: function(content, node) {
        var alt = cleanAttribute(node.getAttribute("alt"));
        var src = node.getAttribute("src") || "";
        var title = cleanAttribute(node.getAttribute("title"));
        var titlePart = title ? ' "' + title + '"' : "";
        return src ? "![" + alt + "](" + src + titlePart + ")" : "";
      }
    };
    Rules.prototype = {
      add: function(key3, rule) {
        this.array.unshift(rule);
      },
      keep: function(filter) {
        this._keep.unshift({
          filter,
          replacement: this.keepReplacement
        });
      },
      remove: function(filter) {
        this._remove.unshift({
          filter,
          replacement: function() {
            return "";
          }
        });
      },
      forNode: function(node) {
        if (node.isBlank)
          return this.blankRule;
        var rule;
        if (rule = findRule(this.array, node, this.options))
          return rule;
        if (rule = findRule(this._keep, node, this.options))
          return rule;
        if (rule = findRule(this._remove, node, this.options))
          return rule;
        return this.defaultRule;
      },
      forEach: function(fn) {
        for (var i9 = 0; i9 < this.array.length; i9++)
          fn(this.array[i9], i9);
      }
    };
    root = typeof window !== "undefined" ? window : {};
    HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
    reduce = Array.prototype.reduce;
    escapes = [
      [/\\/g, "\\\\"],
      [/\*/g, "\\*"],
      [/^-/g, "\\-"],
      [/^\+ /g, "\\+ "],
      [/^(=+)/g, "\\$1"],
      [/^(#{1,6}) /g, "\\$1 "],
      [/`/g, "\\`"],
      [/^~~~/g, "\\~~~"],
      [/\[/g, "\\["],
      [/\]/g, "\\]"],
      [/^>/g, "\\>"],
      [/_/g, "\\_"],
      [/^(\d+)\. /g, "$1\\. "]
    ];
    TurndownService.prototype = {
      /**
       * The entry point for converting a string or DOM node to Markdown
       * @public
       * @param {String|HTMLElement} input The string or DOM node to convert
       * @returns A Markdown representation of the input
       * @type String
       */
      turndown: function(input) {
        if (!canConvert(input)) {
          throw new TypeError(
            input + " is not a string, or an element/document/fragment node."
          );
        }
        if (input === "")
          return "";
        var output = process2.call(this, new RootNode(input, this.options));
        return postProcess.call(this, output);
      },
      /**
       * Add one or more plugins
       * @public
       * @param {Function|Array} plugin The plugin or array of plugins to add
       * @returns The Turndown instance for chaining
       * @type Object
       */
      use: function(plugin) {
        if (Array.isArray(plugin)) {
          for (var i9 = 0; i9 < plugin.length; i9++)
            this.use(plugin[i9]);
        } else if (typeof plugin === "function") {
          plugin(this);
        } else {
          throw new TypeError("plugin must be a Function or an Array of Functions");
        }
        return this;
      },
      /**
       * Adds a rule
       * @public
       * @param {String} key The unique key of the rule
       * @param {Object} rule The rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      addRule: function(key3, rule) {
        this.rules.add(key3, rule);
        return this;
      },
      /**
       * Keep a node (as HTML) that matches the filter
       * @public
       * @param {String|Array|Function} filter The unique key of the rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      keep: function(filter) {
        this.rules.keep(filter);
        return this;
      },
      /**
       * Remove a node that matches the filter
       * @public
       * @param {String|Array|Function} filter The unique key of the rule
       * @returns The Turndown instance for chaining
       * @type Object
       */
      remove: function(filter) {
        this.rules.remove(filter);
        return this;
      },
      /**
       * Escapes Markdown syntax
       * @public
       * @param {String} string The string to escape
       * @returns A string with Markdown syntax escaped
       * @type String
       */
      escape: function(string) {
        return escapes.reduce(function(accumulator, escape5) {
          return accumulator.replace(escape5[0], escape5[1]);
        }, string);
      }
    };
    turndown_browser_es_default = TurndownService;
  }
});

// node_modules/tiktoken/tiktoken_bg.js
function __wbg_set_wasm(val) {
  wasm = val;
}
function getObject(idx) {
  return heap[idx];
}
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function getUint32Memory0() {
  if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
    cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachedUint32Memory0;
}
function getArrayU32FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function passArray32ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 4, 4) >>> 0;
  getUint32Memory0().set(arg, ptr / 4);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function get_encoding(encoding, extend_special_tokens) {
  if (wasm == null)
    throw new Error("tiktoken: WASM binary has not been propery initialized.");
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(encoding, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len0 = WASM_VECTOR_LEN;
    wasm.get_encoding(retptr, ptr0, len0, addHeapObject(extend_special_tokens));
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r23 = getInt32Memory0()[retptr / 4 + 2];
    if (r23) {
      throw takeObject(r1);
    }
    return Tiktoken.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
var wasm, heap, heap_next, WASM_VECTOR_LEN, cachedUint8Memory0, lTextEncoder, cachedTextEncoder, encodeString, cachedInt32Memory0, lTextDecoder, cachedTextDecoder, cachedUint32Memory0, TiktokenFinalization, Tiktoken;
var init_tiktoken_bg = __esm({
  "node_modules/tiktoken/tiktoken_bg.js"() {
    heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    heap_next = heap.length;
    WASM_VECTOR_LEN = 0;
    cachedUint8Memory0 = null;
    lTextEncoder = typeof TextEncoder === "undefined" ? (0, module.require)("util").TextEncoder : TextEncoder;
    cachedTextEncoder = new lTextEncoder("utf-8");
    encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    cachedInt32Memory0 = null;
    lTextDecoder = typeof TextDecoder === "undefined" ? (0, module.require)("util").TextDecoder : TextDecoder;
    cachedTextDecoder = new lTextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    cachedUint32Memory0 = null;
    TiktokenFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_tiktoken_free(ptr >>> 0));
    Tiktoken = class _Tiktoken {
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Tiktoken.prototype);
        obj.__wbg_ptr = ptr;
        TiktokenFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TiktokenFinalization.unregister(this);
        return ptr;
      }
      free() {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tiktoken_free(ptr);
      }
      /**
      * @param {string} tiktoken_bfe
      * @param {any} special_tokens
      * @param {string} pat_str
      */
      constructor(tiktoken_bfe, special_tokens, pat_str) {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ptr0 = passStringToWasm0(tiktoken_bfe, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(pat_str, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.tiktoken_new(ptr0, len0, addHeapObject(special_tokens), ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
      }
      /**
      * @returns {string | undefined}
      */
      get name() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.tiktoken_name(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_2(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} text
      * @param {any} allowed_special
      * @param {any} disallowed_special
      * @returns {Uint32Array}
      */
      encode(text2, allowed_special, disallowed_special) {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(text2, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_encode(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r23 = getInt32Memory0()[retptr / 4 + 2];
          var r32 = getInt32Memory0()[retptr / 4 + 3];
          if (r32) {
            throw takeObject(r23);
          }
          var v22 = getArrayU32FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_2(r0, r1 * 4, 4);
          return v22;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} text
      * @returns {Uint32Array}
      */
      encode_ordinary(text2) {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(text2, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_encode_ordinary(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var v22 = getArrayU32FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_2(r0, r1 * 4, 4);
          return v22;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {string} text
      * @param {any} allowed_special
      * @param {any} disallowed_special
      * @returns {any}
      */
      encode_with_unstable(text2, allowed_special, disallowed_special) {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(text2, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_encode_with_unstable(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r23 = getInt32Memory0()[retptr / 4 + 2];
          if (r23) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {Uint8Array} bytes
      * @returns {number}
      */
      encode_single_token(bytes) {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.tiktoken_encode_single_token(this.__wbg_ptr, ptr0, len0);
        return ret >>> 0;
      }
      /**
      * @param {Uint32Array} tokens
      * @returns {Uint8Array}
      */
      decode(tokens) {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passArray32ToWasm0(tokens, wasm.__wbindgen_export_0);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_decode(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var v22 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_2(r0, r1 * 1, 1);
          return v22;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {number} token
      * @returns {Uint8Array}
      */
      decode_single_token_bytes(token) {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.tiktoken_decode_single_token_bytes(retptr, this.__wbg_ptr, token);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var v1 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_2(r0, r1 * 1, 1);
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @returns {any}
      */
      token_byte_values() {
        if (wasm == null)
          throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ret = wasm.tiktoken_token_byte_values(this.__wbg_ptr);
        return takeObject(ret);
      }
    };
  }
});

// node_modules/tiktoken/tiktoken.js
import * as wasm2 from "./tiktoken_bg-MSIVLX7H.wasm";
var init_tiktoken = __esm({
  "node_modules/tiktoken/tiktoken.js"() {
    init_tiktoken_bg();
    init_tiktoken_bg();
    __wbg_set_wasm(wasm2);
  }
});

// .svelte-kit/output/server/entries/pages/(main)/_layout.svelte.js
var layout_svelte_exports2 = {};
__export(layout_svelte_exports2, {
  default: () => _layout
});
function fade(node, { delay: delay3 = 0, duration = 400, easing = linear } = {}) {
  const o7 = +getComputedStyle(node).opacity;
  return {
    delay: delay3,
    duration,
    easing,
    css: (t8) => `opacity: ${t8 * o7}`
  };
}
function TagCloud($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  const anchor_1 = create_anchor($$payload);
  const anchor_2 = create_anchor($$payload);
  const anchor_3 = create_anchor($$payload);
  const anchor_4 = create_anchor($$payload);
  $$payload.out += `<div class="flex flex-wrap gap-2">${anchor}`;
  Badge($$payload, {
    class: "rounded-full",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `#React`;
    }
  });
  $$payload.out += `${anchor} ${anchor_1}`;
  Badge($$payload, {
    class: "rounded-full",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `#JavaScript`;
    }
  });
  $$payload.out += `${anchor_1} ${anchor_2}`;
  Badge($$payload, {
    class: "rounded-full",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `#Web Development`;
    }
  });
  $$payload.out += `${anchor_2} ${anchor_3}`;
  Badge($$payload, {
    class: "rounded-full",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `#Frontend`;
    }
  });
  $$payload.out += `${anchor_3} ${anchor_4}`;
  Badge($$payload, {
    class: "rounded-full",
    children: ($$payload2, $$slotProps) => {
      $$payload2.out += `#Documentation`;
    }
  });
  $$payload.out += `${anchor_4}</div>`;
  pop();
}
function Input($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "value", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  let value = value_or_fallback($$props["value"], void 0);
  $$payload.out += `<input${spread_attributes(
    [
      {
        "class": cn("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", className)
      },
      { "value": value },
      $$restProps
    ],
    true,
    false,
    ""
  )}>`;
  bind_props($$props, { class: className, value });
  pop();
}
function Chevron_right($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "chevron-right" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function List_ordered($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    [
      "line",
      {
        "x1": "10",
        "x2": "21",
        "y1": "6",
        "y2": "6"
      }
    ],
    [
      "line",
      {
        "x1": "10",
        "x2": "21",
        "y1": "12",
        "y2": "12"
      }
    ],
    [
      "line",
      {
        "x1": "10",
        "x2": "21",
        "y1": "18",
        "y2": "18"
      }
    ],
    ["path", { "d": "M4 6h1v4" }],
    ["path", { "d": "M4 10h2" }],
    [
      "path",
      { "d": "M6 18H4c0-1 2-2 2-3s-1-1.5-2-1" }
    ]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "list-ordered" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function List2($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    [
      "line",
      { "x1": "8", "x2": "21", "y1": "6", "y2": "6" }
    ],
    [
      "line",
      {
        "x1": "8",
        "x2": "21",
        "y1": "12",
        "y2": "12"
      }
    ],
    [
      "line",
      {
        "x1": "8",
        "x2": "21",
        "y1": "18",
        "y2": "18"
      }
    ],
    [
      "line",
      {
        "x1": "3",
        "x2": "3.01",
        "y1": "6",
        "y2": "6"
      }
    ],
    [
      "line",
      {
        "x1": "3",
        "x2": "3.01",
        "y1": "12",
        "y2": "12"
      }
    ],
    [
      "line",
      {
        "x1": "3",
        "x2": "3.01",
        "y1": "18",
        "y2": "18"
      }
    ]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "list" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function Log_out($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    [
      "path",
      { "d": "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }
    ],
    [
      "polyline",
      { "points": "16 17 21 12 16 7" }
    ],
    [
      "line",
      {
        "x1": "21",
        "x2": "9",
        "y1": "12",
        "y2": "12"
      }
    ]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "log-out" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function Plus_circle($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    [
      "circle",
      { "cx": "12", "cy": "12", "r": "10" }
    ],
    ["path", { "d": "M8 12h8" }],
    ["path", { "d": "M12 8v8" }]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "plus-circle" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function Search($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    [
      "circle",
      { "cx": "11", "cy": "11", "r": "8" }
    ],
    ["path", { "d": "m21 21-4.3-4.3" }]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "search" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function X3($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    ["path", { "d": "M18 6 6 18" }],
    ["path", { "d": "m6 6 12 12" }]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "x" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function SearchForm($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  const anchor_1 = create_anchor($$payload);
  $$payload.out += `<form class="relative" method="POST" action="/test">${anchor}`;
  Search($$payload, {
    class: "absolute left-2.5 top-2.5 h-4 w-4 text-gray-300"
  });
  $$payload.out += `${anchor} ${anchor_1}`;
  Input($$payload, {
    class: "w-full appearance-none bg-white pl-8 shadow-none",
    placeholder: "Filter bookmarks by tags...",
    type: "search",
    name: "search"
  });
  $$payload.out += `${anchor_1}</form>`;
  pop();
}
function last(array2) {
  return array2[array2.length - 1];
}
function lightable(value) {
  function subscribe(run2) {
    run2(value);
    return () => {
    };
  }
  return { subscribe };
}
function builder(name2, args) {
  const { stores, action, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = (...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name2}`]: "",
              action: action ?? noop2
            });
          };
          fn.action = action ?? noop2;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name2}`]: "",
          action: action ?? noop2
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn?.();
      if (isFunctionWithParams(result)) {
        const resultFn = (...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name2}`]: "",
            action: action ?? noop2
          });
        };
        resultFn.action = action ?? noop2;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name2}`]: "",
        action: action ?? noop2
      }));
    }
  })();
  const actionFn = action ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
function createElHelpers(prefix) {
  const name2 = (part) => part ? `${prefix}-${part}` : prefix;
  const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ""}`;
  const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`;
  const getEl = (part) => document.querySelector(selector(part));
  return {
    name: name2,
    attribute,
    selector,
    getEl
  };
}
function omit(obj, ...keys) {
  const result = {};
  for (const key3 of Object.keys(obj)) {
    if (!keys.includes(key3)) {
      result[key3] = obj[key3];
    }
  }
  return result;
}
function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
function generateId() {
  return nanoid(10);
}
function generateIds(args) {
  return args.reduce((acc, curr) => {
    acc[curr] = generateId();
    return acc;
  }, {});
}
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body: body2 } = doc;
  const locked = body2.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop2;
  body2.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body2)[paddingProperty];
  const setStyle = () => assignStyle(body2, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = assignStyle(body2, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo(scrollX, scrollY);
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body2.removeAttribute(LOCK_CLASSNAME);
  };
}
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key3) => {
    const propertyKey = key3;
    const value = properties[propertyKey];
    result[propertyKey] = withGet(writable(value));
  });
  return result;
}
function getPortalParent(node) {
  let parent = node.parentElement;
  while (isHTMLElement(parent) && !parent.hasAttribute("data-portal")) {
    parent = parent.parentElement;
  }
  return parent || "body";
}
function getPortalDestination(node, portalProp) {
  const portalParent = getPortalParent(node);
  if (portalProp !== void 0)
    return portalProp;
  if (portalParent === "body")
    return document.body;
  return null;
}
async function handleFocus(args) {
  const { prop, defaultEl } = args;
  await Promise.all([sleep(1), tick]);
  if (prop === void 0) {
    defaultEl?.focus();
    return;
  }
  const returned = isFunction(prop) ? prop(defaultEl) : prop;
  if (typeof returned === "string") {
    const el = document.querySelector(returned);
    if (!isHTMLElement(el))
      return;
    el.focus();
  } else if (isHTMLElement(returned)) {
    returned.focus();
  }
}
function createFocusTrap3(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = (opts) => trap?.activate(opts);
  const deactivate = (opts) => {
    trap?.deactivate(opts);
  };
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  };
  const useFocusTrap = (node) => {
    trap = createFocusTrap(node, {
      ...focusTrapOptions,
      onActivate() {
        hasFocus.set(true);
        config.onActivate?.();
      },
      onDeactivate() {
        hasFocus.set(false);
        config.onDeactivate?.();
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  };
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}
function useInteractOutside(node, config) {
  let unsub = noop2;
  function update2(config2) {
    unsub();
    const { onInteractOutside, onInteractOutsideStart, enabled } = config2;
    if (!enabled)
      return;
    let isPointerDown = false;
    let ignoreEmulatedMouseEvents = false;
    function onPointerDown(e5) {
      if (onInteractOutside && isValidEvent(e5, node)) {
        onInteractOutsideStart?.(e5);
      }
      isPointerDown = true;
    }
    function triggerInteractOutside(e5) {
      onInteractOutside?.(e5);
    }
    const documentObj = getOwnerDocument(node);
    if (typeof PointerEvent !== "undefined") {
      const onPointerUp = (e5) => {
        if (isPointerDown && isValidEvent(e5, node)) {
          triggerInteractOutside(e5);
        }
        isPointerDown = false;
      };
      unsub = executeCallbacks(addEventListener(documentObj, "pointerdown", onPointerDown, true), addEventListener(documentObj, "pointerup", onPointerUp, true));
    } else {
      const onMouseUp = (e5) => {
        if (ignoreEmulatedMouseEvents) {
          ignoreEmulatedMouseEvents = false;
        } else if (isPointerDown && isValidEvent(e5, node)) {
          triggerInteractOutside(e5);
        }
        isPointerDown = false;
      };
      const onTouchEnd = (e5) => {
        ignoreEmulatedMouseEvents = true;
        if (isPointerDown && isValidEvent(e5, node)) {
          triggerInteractOutside(e5);
        }
        isPointerDown = false;
      };
      unsub = executeCallbacks(addEventListener(documentObj, "mousedown", onPointerDown, true), addEventListener(documentObj, "mouseup", onMouseUp, true), addEventListener(documentObj, "touchstart", onPointerDown, true), addEventListener(documentObj, "touchend", onTouchEnd, true));
    }
  }
  update2(config);
  return {
    update: update2,
    destroy: unsub
  };
}
function isValidEvent(e5, node) {
  if ("button" in e5 && e5.button > 0)
    return false;
  const target = e5.target;
  if (!isElement(target))
    return false;
  const ownerDocument = target.ownerDocument;
  if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {
    return false;
  }
  return node && !node.contains(target);
}
function getOwnerDocument(el) {
  return el?.ownerDocument ?? document;
}
function useModal(node, config) {
  let unsubInteractOutside = noop2;
  function removeNodeFromVisibleModals() {
    const index7 = visibleModals.indexOf(node);
    if (index7 >= 0) {
      visibleModals.splice(index7, 1);
    }
  }
  function update2(config2) {
    unsubInteractOutside();
    const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config2;
    sleep(100).then(() => {
      if (open) {
        visibleModals.push(node);
      } else {
        removeNodeFromVisibleModals();
      }
    });
    function isLastModal() {
      return last(visibleModals) === node;
    }
    function closeModal() {
      if (isLastModal() && onClose) {
        onClose();
      }
    }
    function onInteractOutsideStart(e5) {
      const target = e5.target;
      if (!isElement(target))
        return;
      if (target && isLastModal()) {
        e5.preventDefault();
        e5.stopPropagation();
        e5.stopImmediatePropagation();
      }
    }
    function onInteractOutside(e5) {
      if (shouldCloseOnInteractOutside?.(e5) && isLastModal()) {
        e5.preventDefault();
        e5.stopPropagation();
        e5.stopImmediatePropagation();
        closeModal();
      }
    }
    unsubInteractOutside = useInteractOutside(node, {
      onInteractOutsideStart,
      onInteractOutside: closeOnInteractOutside ? onInteractOutside : void 0,
      enabled: open
    }).destroy;
  }
  update2(config);
  return {
    update: update2,
    destroy() {
      removeNodeFromVisibleModals();
      unsubInteractOutside();
    }
  };
}
function createDialog(props) {
  const withDefaults = { ...defaults$1, ...props };
  const options3 = toWritableStores(omit(withDefaults, "ids"));
  const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible, openFocus, closeFocus, onOutsideClick } = options3;
  const activeTrigger = withGet.writable(null);
  const ids = toWritableStores({
    ...generateIds(dialogIdParts),
    ...withDefaults.ids
  });
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  let unsubScroll = noop2;
  function handleOpen(e5) {
    const el = e5.currentTarget;
    const triggerEl = e5.currentTarget;
    if (!isHTMLElement(el) || !isHTMLElement(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  function handleClose() {
    open.set(false);
    handleFocus({
      prop: closeFocus.get(),
      defaultEl: activeTrigger.get()
    });
  }
  const trigger = builder(name$1("trigger"), {
    stores: [open],
    returned: ([$open]) => {
      return {
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e5) => {
        handleOpen(e5);
      }), addMeltEventListener(node, "keydown", (e5) => {
        if (e5.key !== kbd.ENTER && e5.key !== kbd.SPACE)
          return;
        e5.preventDefault();
        handleOpen(e5);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = builder(name$1("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $isVisible ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = builder(name$1("content"), {
    stores: [isVisible, ids.content, ids.description, ids.title],
    returned: ([$isVisible, $contentId, $descriptionId, $titleId]) => {
      return {
        id: $contentId,
        role: role.get(),
        "aria-describedby": $descriptionId,
        "aria-labelledby": $titleId,
        "aria-modal": $isVisible ? "true" : void 0,
        "data-state": $isVisible ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop2;
      let deactivate = noop2;
      const destroy = executeCallbacks(effect([open], ([$open]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap3({
          immediate: false,
          escapeDeactivates: true,
          clickOutsideDeactivates: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac = focusTrap.useFocusTrap(node);
        if (ac && ac.destroy) {
          return ac.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useModal(node, {
          open: $open,
          closeOnInteractOutside: $closeOnOutsideClick,
          onClose() {
            handleClose();
          },
          shouldCloseOnInteractOutside(e5) {
            onOutsideClick.get()?.(e5);
            if (e5.defaultPrevented)
              return false;
            return true;
          }
        }).destroy;
      }), effect([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop2;
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          return escapeKeydown.destroy;
        }
        return noop2;
      }), effect([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy: () => {
          unsubScroll();
          destroy();
        }
      };
    }
  });
  const portalled = builder(name$1("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": $portal ? "" : void 0
    }),
    action: (node) => {
      const unsubPortal = effect([portal], ([$portal]) => {
        if (!$portal)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        const portalAction = usePortal(node, portalDestination);
        if (portalAction && portalAction.destroy) {
          return portalAction.destroy;
        } else {
          return noop2;
        }
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = builder(name$1("title"), {
    stores: [ids.title],
    returned: ([$titleId]) => ({
      id: $titleId
    })
  });
  const description = builder(name$1("description"), {
    stores: [ids.description],
    returned: ([$descriptionId]) => ({
      id: $descriptionId
    })
  });
  const close = builder(name$1("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e5) => {
        if (e5.key !== kbd.SPACE && e5.key !== kbd.ENTER)
          return;
        e5.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, preventScroll], ([$open, $preventScroll]) => {
    if (!isBrowser)
      return;
    if ($preventScroll && $open)
      unsubScroll = removeScroll();
    if ($open) {
      const contentEl = document.getElementById(ids.content.get());
      handleFocus({ prop: openFocus.get(), defaultEl: contentEl });
    }
    return () => {
      if (!forceVisible.get()) {
        unsubScroll();
      }
    };
  });
  return {
    ids,
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close,
      portalled
    },
    states: {
      open
    },
    options: options3
  };
}
function createBitAttrs(bit, parts) {
  const attrs = {};
  parts.forEach((part) => {
    attrs[part] = {
      [`data-${bit}-${part}`]: ""
    };
  });
  return (part) => attrs[part];
}
function createDispatcher() {
  const dispatch = createEventDispatcher();
  return (e5) => {
    const { originalEvent } = e5.detail;
    const { cancelable } = e5;
    const type = originalEvent.type;
    const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });
    if (!shouldContinue) {
      e5.preventDefault();
    }
  };
}
function removeUndefined(obj) {
  const result = {};
  for (const key3 in obj) {
    const value = obj[key3];
    if (value !== void 0) {
      result[key3] = value;
    }
  }
  return result;
}
function getOptionUpdater(options3) {
  return function(key3, value) {
    if (value === void 0)
      return;
    const store = options3[key3];
    if (store) {
      store.set(value);
    }
  };
}
function getDialogData() {
  const NAME2 = "dialog";
  const PARTS = [
    "close",
    "content",
    "description",
    "overlay",
    "portal",
    "title",
    "trigger"
  ];
  return {
    NAME: NAME2,
    PARTS
  };
}
function setCtx$1(props) {
  const { NAME: NAME2, PARTS } = getDialogData();
  const getAttrs2 = createBitAttrs(NAME2, PARTS);
  const dialog = {
    ...createDialog({ ...removeUndefined(props), role: "dialog", forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME2, dialog);
  return {
    ...dialog,
    updateOption: getOptionUpdater(dialog.options)
  };
}
function getCtx() {
  const { NAME: NAME2 } = getDialogData();
  return getContext(NAME2);
}
function Dialog($$payload, $$props) {
  push(false);
  const $$store_subs = {};
  let preventScroll = value_or_fallback($$props["preventScroll"], void 0);
  let closeOnEscape = value_or_fallback($$props["closeOnEscape"], void 0);
  let closeOnOutsideClick = value_or_fallback($$props["closeOnOutsideClick"], void 0);
  let portal = value_or_fallback($$props["portal"], void 0);
  let open = value_or_fallback($$props["open"], void 0);
  let onOpenChange = value_or_fallback($$props["onOpenChange"], void 0);
  let openFocus = value_or_fallback($$props["openFocus"], void 0);
  let closeFocus = value_or_fallback($$props["closeFocus"], void 0);
  let onOutsideClick = value_or_fallback($$props["onOutsideClick"], void 0);
  const {
    states: { open: localOpen },
    updateOption,
    ids
  } = setCtx$1({
    closeOnEscape,
    preventScroll,
    closeOnOutsideClick,
    portal,
    forceVisible: true,
    defaultOpen: open,
    openFocus,
    closeFocus,
    onOutsideClick,
    onOpenChange: ({ next: next2 }) => {
      if (open !== next2) {
        onOpenChange?.(next2);
        open = next2;
      }
      return next2;
    }
  });
  const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
    content: $contentId,
    description: $descriptionId,
    title: $titleId
  }));
  open !== void 0 && localOpen.set(open);
  updateOption("preventScroll", preventScroll);
  updateOption("closeOnEscape", closeOnEscape);
  updateOption("closeOnOutsideClick", closeOnOutsideClick);
  updateOption("portal", portal);
  updateOption("openFocus", openFocus);
  updateOption("closeFocus", closeFocus);
  updateOption("onOutsideClick", onOutsideClick);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  slot(
    $$payload,
    $$props.children,
    {
      get ids() {
        return store_get($$store_subs, "$idValues", idValues);
      }
    },
    null
  );
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, {
    preventScroll,
    closeOnEscape,
    closeOnOutsideClick,
    portal,
    open,
    onOpenChange,
    openFocus,
    closeFocus,
    onOutsideClick
  });
  pop();
}
function Dialog_title$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["level", "asChild", "id", "el", "$$props"]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let level = value_or_fallback($$props["level"], "h2");
  let asChild = value_or_fallback($$props["asChild"], false);
  let id = value_or_fallback($$props["id"], void 0);
  let el = value_or_fallback($$props["el"], void 0);
  const { elements: { title }, ids, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("title");
  if (id) {
    ids.title.set(id);
  }
  builder2 = store_get($$store_subs, "$title", title);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `${anchor_2}`;
    if (level) {
      const anchor_3 = create_anchor($$payload);
      $$payload.out += `<${level}${spread_attributes([builder2, $$restProps], true, false, "")}>`;
      if (!VoidElements.has(level)) {
        $$payload.out += `${anchor_3}`;
        const anchor_4 = create_anchor($$payload);
        $$payload.out += `${anchor_4}`;
        slot(
          $$payload,
          $$props.children,
          {
            get builder() {
              return builder2;
            }
          },
          null
        );
        $$payload.out += `${anchor_4}`;
        $$payload.out += `${anchor_3}</${level}>`;
      }
    }
    $$payload.out += `${anchor_2}`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, { level, asChild, id, el });
  pop();
}
function Dialog_close$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el", "$$props"]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let asChild = value_or_fallback($$props["asChild"], false);
  let el = value_or_fallback($$props["el"], void 0);
  const { elements: { close }, getAttrs: getAttrs2 } = getCtx();
  createDispatcher();
  const attrs = getAttrs2("close");
  builder2 = store_get($$store_subs, "$close", close);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `<button${spread_attributes([builder2, { "type": "button" }, $$restProps], true, false, "")}>${anchor_2}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_2}</button>`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Dialog_portal$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el", "$$props"]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let asChild = value_or_fallback($$props["asChild"], false);
  let el = value_or_fallback($$props["el"], void 0);
  const { elements: { portalled }, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("portal");
  builder2 = store_get($$store_subs, "$portalled", portalled);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_2}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_2}</div>`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Dialog_content$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "id",
    "el",
    "$$props"
  ]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let transition = value_or_fallback($$props["transition"], void 0);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], void 0);
  let inTransition = value_or_fallback($$props["inTransition"], void 0);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], void 0);
  let outTransition = value_or_fallback($$props["outTransition"], void 0);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], void 0);
  let asChild = value_or_fallback($$props["asChild"], false);
  let id = value_or_fallback($$props["id"], void 0);
  let el = value_or_fallback($$props["el"], void 0);
  const {
    elements: { content },
    states: { open },
    ids,
    getAttrs: getAttrs2
  } = getCtx();
  const attrs = getAttrs2("content");
  if (id) {
    ids.content.set(id);
  }
  builder2 = store_get($$store_subs, "$content", content);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild && store_get($$store_subs, "$open", open)) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `${anchor_2}`;
    if (transition && store_get($$store_subs, "$open", open)) {
      $$payload.out += "<!--ssr:if:true-->";
      const anchor_3 = create_anchor($$payload);
      $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_3}`;
      slot(
        $$payload,
        $$props.children,
        {
          get builder() {
            return builder2;
          }
        },
        null
      );
      $$payload.out += `${anchor_3}</div>`;
    } else {
      $$payload.out += "<!--ssr:if:false-->";
      const anchor_4 = create_anchor($$payload);
      $$payload.out += `${anchor_4}`;
      if (inTransition && outTransition && store_get($$store_subs, "$open", open)) {
        $$payload.out += "<!--ssr:if:true-->";
        const anchor_5 = create_anchor($$payload);
        $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_5}`;
        slot(
          $$payload,
          $$props.children,
          {
            get builder() {
              return builder2;
            }
          },
          null
        );
        $$payload.out += `${anchor_5}</div>`;
      } else {
        $$payload.out += "<!--ssr:if:false-->";
        const anchor_6 = create_anchor($$payload);
        $$payload.out += `${anchor_6}`;
        if (inTransition && store_get($$store_subs, "$open", open)) {
          $$payload.out += "<!--ssr:if:true-->";
          const anchor_7 = create_anchor($$payload);
          $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_7}`;
          slot(
            $$payload,
            $$props.children,
            {
              get builder() {
                return builder2;
              }
            },
            null
          );
          $$payload.out += `${anchor_7}</div>`;
        } else {
          $$payload.out += "<!--ssr:if:false-->";
          const anchor_8 = create_anchor($$payload);
          $$payload.out += `${anchor_8}`;
          if (outTransition && store_get($$store_subs, "$open", open)) {
            $$payload.out += "<!--ssr:if:true-->";
            const anchor_9 = create_anchor($$payload);
            $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_9}`;
            slot(
              $$payload,
              $$props.children,
              {
                get builder() {
                  return builder2;
                }
              },
              null
            );
            $$payload.out += `${anchor_9}</div>`;
          } else {
            $$payload.out += "<!--ssr:if:false-->";
            const anchor_10 = create_anchor($$payload);
            $$payload.out += `${anchor_10}`;
            if (store_get($$store_subs, "$open", open)) {
              $$payload.out += "<!--ssr:if:true-->";
              const anchor_11 = create_anchor($$payload);
              $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_11}`;
              slot(
                $$payload,
                $$props.children,
                {
                  get builder() {
                    return builder2;
                  }
                },
                null
              );
              $$payload.out += `${anchor_11}</div>`;
            } else {
              $$payload.out += "<!--ssr:if:false-->";
            }
            $$payload.out += `${anchor_10}`;
          }
          $$payload.out += `${anchor_8}`;
        }
        $$payload.out += `${anchor_6}`;
      }
      $$payload.out += `${anchor_4}`;
    }
    $$payload.out += `${anchor_2}`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    id,
    el
  });
  pop();
}
function Dialog_overlay$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "transition",
    "transitionConfig",
    "inTransition",
    "inTransitionConfig",
    "outTransition",
    "outTransitionConfig",
    "asChild",
    "el",
    "$$props"
  ]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let transition = value_or_fallback($$props["transition"], void 0);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], void 0);
  let inTransition = value_or_fallback($$props["inTransition"], void 0);
  let inTransitionConfig = value_or_fallback($$props["inTransitionConfig"], void 0);
  let outTransition = value_or_fallback($$props["outTransition"], void 0);
  let outTransitionConfig = value_or_fallback($$props["outTransitionConfig"], void 0);
  let asChild = value_or_fallback($$props["asChild"], false);
  let el = value_or_fallback($$props["el"], void 0);
  const {
    elements: { overlay },
    states: { open },
    getAttrs: getAttrs2
  } = getCtx();
  const attrs = getAttrs2("overlay");
  builder2 = store_get($$store_subs, "$overlay", overlay);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild && store_get($$store_subs, "$open", open)) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `${anchor_2}`;
    if (transition && store_get($$store_subs, "$open", open)) {
      $$payload.out += "<!--ssr:if:true-->";
      $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}></div>`;
    } else {
      $$payload.out += "<!--ssr:if:false-->";
      const anchor_3 = create_anchor($$payload);
      $$payload.out += `${anchor_3}`;
      if (inTransition && outTransition && store_get($$store_subs, "$open", open)) {
        $$payload.out += "<!--ssr:if:true-->";
        $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}></div>`;
      } else {
        $$payload.out += "<!--ssr:if:false-->";
        const anchor_4 = create_anchor($$payload);
        $$payload.out += `${anchor_4}`;
        if (inTransition && store_get($$store_subs, "$open", open)) {
          $$payload.out += "<!--ssr:if:true-->";
          $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}></div>`;
        } else {
          $$payload.out += "<!--ssr:if:false-->";
          const anchor_5 = create_anchor($$payload);
          $$payload.out += `${anchor_5}`;
          if (outTransition && store_get($$store_subs, "$open", open)) {
            $$payload.out += "<!--ssr:if:true-->";
            $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}></div>`;
          } else {
            $$payload.out += "<!--ssr:if:false-->";
            const anchor_6 = create_anchor($$payload);
            $$payload.out += `${anchor_6}`;
            if (store_get($$store_subs, "$open", open)) {
              $$payload.out += "<!--ssr:if:true-->";
              $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}></div>`;
            } else {
              $$payload.out += "<!--ssr:if:false-->";
            }
            $$payload.out += `${anchor_6}`;
          }
          $$payload.out += `${anchor_5}`;
        }
        $$payload.out += `${anchor_4}`;
      }
      $$payload.out += `${anchor_3}`;
    }
    $$payload.out += `${anchor_2}`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, {
    transition,
    transitionConfig,
    inTransition,
    inTransitionConfig,
    outTransition,
    outTransitionConfig,
    asChild,
    el
  });
  pop();
}
function Dialog_trigger($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "el", "$$props"]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let asChild = value_or_fallback($$props["asChild"], false);
  let el = value_or_fallback($$props["el"], void 0);
  const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx();
  createDispatcher();
  const attrs = getAttrs2("trigger");
  builder2 = store_get($$store_subs, "$trigger", trigger);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `<button${spread_attributes([builder2, { "type": "button" }, $$restProps], true, false, "")}>${anchor_2}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_2}</button>`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, el });
  pop();
}
function Dialog_description$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["asChild", "id", "el", "$$props"]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let asChild = value_or_fallback($$props["asChild"], false);
  let id = value_or_fallback($$props["id"], void 0);
  let el = value_or_fallback($$props["el"], void 0);
  const { elements: { description }, ids, getAttrs: getAttrs2 } = getCtx();
  const attrs = getAttrs2("description");
  if (id) {
    ids.description.set(id);
  }
  builder2 = store_get($$store_subs, "$description", description);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_2}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_2}</div>`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, { asChild, id, el });
  pop();
}
function getProgressData() {
  const NAME2 = "progress";
  const PARTS = ["root"];
  return {
    NAME: NAME2,
    PARTS
  };
}
function setCtx(props) {
  const { NAME: NAME2, PARTS } = getProgressData();
  const getAttrs2 = createBitAttrs(NAME2, PARTS);
  const progress = { ...createProgress(removeUndefined(props)), getAttrs: getAttrs2 };
  return {
    ...progress,
    updateOption: getOptionUpdater(progress.options)
  };
}
function Progress$1($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "max",
    "value",
    "onValueChange",
    "asChild",
    "el",
    "$$props"
  ]);
  push(false);
  const $$store_subs = {};
  let builder2;
  let max = value_or_fallback($$props["max"], void 0);
  let value = value_or_fallback($$props["value"], void 0);
  let onValueChange = value_or_fallback($$props["onValueChange"], void 0);
  let asChild = value_or_fallback($$props["asChild"], false);
  let el = value_or_fallback($$props["el"], void 0);
  const {
    elements: { root: root2 },
    states: { value: localValue },
    updateOption,
    getAttrs: getAttrs2
  } = setCtx({
    max,
    defaultValue: value,
    onValueChange: ({ next: next2 }) => {
      onValueChange?.(next2);
      value = next2;
      return next2;
    }
  });
  const attrs = getAttrs2("root");
  value !== void 0 && localValue.set(value);
  updateOption("max", max);
  builder2 = store_get($$store_subs, "$root", root2);
  Object.assign(builder2, attrs);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (asChild) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `<div${spread_attributes([builder2, $$restProps], true, false, "")}>${anchor_2}`;
    slot(
      $$payload,
      $$props.children,
      {
        get builder() {
          return builder2;
        }
      },
      null
    );
    $$payload.out += `${anchor_2}</div>`;
  }
  $$payload.out += `${anchor}`;
  unsubscribe_stores($$store_subs);
  bind_props($$props, { max, value, onValueChange, asChild, el });
  pop();
}
function BookmarkCompact($$payload, $$props) {
  push(false);
  const $$store_subs = {};
  let bookmarkList = [];
  initializeSession().then(() => {
    try {
      store_get($$store_subs, "$FAUNA", FAUNA).query(qe`bookmarks.all()`, { format: "simple" }).then((ret) => {
        bookmarkList = [...ret.data.data, ...bookmarkList];
        bookmarkList = bookmarkList.filter((a7) => a7);
      });
    } catch (error2) {
      console.error(error2);
    }
  });
  const anchor = create_anchor($$payload);
  const anchor_2 = create_anchor($$payload);
  const anchor_4 = create_anchor($$payload);
  const each_array = ensure_array_like(bookmarkList);
  $$payload.out += `<div class="mt-2 flex items-center justify-between">${anchor}`;
  Button($$payload, {
    size: "icon",
    variant: "secondary",
    children: ($$payload2, $$slotProps) => {
      const anchor_1 = create_anchor($$payload2);
      $$payload2.out += `${anchor_1}`;
      List_ordered($$payload2, { class: "h-4 w-4" });
      $$payload2.out += `${anchor_1} <span class="sr-only">Order by date</span>`;
    }
  });
  $$payload.out += `${anchor} ${anchor_2}`;
  Button($$payload, {
    class: "justify-start gap-2",
    size: "sm",
    variant: "secondary",
    children: ($$payload2, $$slotProps) => {
      const anchor_3 = create_anchor($$payload2);
      $$payload2.out += `${anchor_3}`;
      Star($$payload2, { class: "h-4 w-4" });
      $$payload2.out += `${anchor_3} Favorites`;
    }
  });
  $$payload.out += `${anchor_2}</div> <div class="mt-4 space-y-2">${anchor_4}`;
  for (let $$index = 0; $$index < each_array.length; $$index++) {
    const bookmark = each_array[$$index];
    const anchor_5 = create_anchor($$payload);
    const anchor_6 = create_anchor($$payload);
    $$payload.out += `${anchor_5}<a class="flex items-center justify-between text-sm text-white"${attr("href", `/b/${stringify(bookmark.id)}`, false)}><div><div class="font-medium">${escape2(bookmark.title)}</div> <div class="text-xs">Domain: ${escape2(new URL(bookmark.url).host)}</div> <div class="text-xs">Category: ${escape2(bookmark.category)}</div></div> ${anchor_6}`;
    Chevron_right($$payload, { class: "h-4 w-4" });
    $$payload.out += `${anchor_6}</a>${anchor_5}`;
  }
  $$payload.out += `${anchor_4}</div>`;
  unsubscribe_stores($$store_subs);
  pop();
}
function Corbado($$payload, $$props) {
  push(false);
  $$payload.out += `<corbado-auth${attr("isdevmode", dev, false)}${attr("project-id", PUBLIC_CORBADO_PROJECT_ID, false)} conditional="yes"><input name="username" id="corbado-username" required autocomplete="webauthn"></corbado-auth>`;
  pop();
}
function Auth($$payload, $$props) {
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_2 = create_anchor($$payload);
    $$payload.out += `${anchor_2}`;
    Corbado($$payload);
    $$payload.out += `${anchor_2}`;
  }
  $$payload.out += `${anchor}`;
  pop();
}
function Dialog_title($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Dialog_title$1($$payload, spread_props([
    {
      class: cn("text-lg font-semibold leading-none tracking-tight", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  bind_props($$props, { class: className });
  pop();
}
function Dialog_portal($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["$$props"]);
  push(false);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Dialog_portal$1($$payload, spread_props([
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function Dialog_footer($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<div${spread_attributes(
    [
      {
        "class": cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)
      },
      $$restProps
    ],
    true,
    false,
    ""
  )}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</div>`;
  bind_props($$props, { class: className });
  pop();
}
function Dialog_header($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<div${spread_attributes(
    [
      {
        "class": cn("flex flex-col space-y-1.5 text-center sm:text-left", className)
      },
      $$restProps
    ],
    true,
    false,
    ""
  )}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</div>`;
  bind_props($$props, { class: className });
  pop();
}
function Dialog_overlay($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "class",
    "transition",
    "transitionConfig",
    "$$props"
  ]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  let transition = value_or_fallback($$props["transition"], fade);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], { duration: 150 });
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Dialog_overlay$1($$payload, spread_props([
    {
      transition,
      transitionConfig,
      class: cn("fixed inset-0 z-50 bg-background/80 backdrop-blur-sm", className)
    },
    $$restProps
  ]));
  $$payload.out += `${anchor}`;
  bind_props($$props, {
    class: className,
    transition,
    transitionConfig
  });
  pop();
}
function Dialog_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "class",
    "transition",
    "transitionConfig",
    "$$props"
  ]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  let transition = value_or_fallback($$props["transition"], flyAndScale);
  let transitionConfig = value_or_fallback($$props["transitionConfig"], { duration: 200 });
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Dialog_portal($$payload, {
    children: ($$payload2, $$slotProps) => {
      const anchor_1 = create_anchor($$payload2);
      $$payload2.out += `${anchor_1}`;
      Dialog_content$1($$payload2, spread_props([
        {
          transition,
          transitionConfig,
          class: cn("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg sm:rounded-lg md:w-full", className)
        },
        $$restProps,
        {
          children: ($$payload3, $$slotProps2) => {
            const anchor_2 = create_anchor($$payload3);
            const anchor_3 = create_anchor($$payload3);
            $$payload3.out += `${anchor_2}`;
            slot($$payload3, $$props.children, {}, null);
            $$payload3.out += `${anchor_2} ${anchor_3}`;
            Dialog_close$1($$payload3, {
              class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
              children: ($$payload4, $$slotProps3) => {
                const anchor_4 = create_anchor($$payload4);
                $$payload4.out += `${anchor_4}`;
                X3($$payload4, { class: "h-4 w-4" });
                $$payload4.out += `${anchor_4} <span class="sr-only">Close</span>`;
              }
            });
            $$payload3.out += `${anchor_3}`;
          }
        }
      ]));
      $$payload2.out += `${anchor_1}`;
    }
  });
  $$payload.out += `${anchor}`;
  bind_props($$props, {
    class: className,
    transition,
    transitionConfig
  });
  pop();
}
function Dialog_description($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Dialog_description$1($$payload, spread_props([
    {
      class: cn("text-sm text-muted-foreground", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  bind_props($$props, { class: className });
  pop();
}
function Dialog_close($$payload, $$props) {
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Dialog_close$1($$payload, {
    children: ($$payload2, $$slotProps) => {
      const anchor_1 = create_anchor($$payload2);
      $$payload2.out += `${anchor_1}`;
      slot($$payload2, $$props.children, {}, null);
      $$payload2.out += `${anchor_1}`;
    }
  });
  $$payload.out += `${anchor}`;
  bind_props($$props, { class: className });
  pop();
}
function styleToString2(style) {
  return Object.keys(style).reduce((str2, key3) => {
    if (style[key3] === void 0)
      return str2;
    return str2 + `${key3}:${style[key3]};`;
  }, "");
}
function Progress($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "state",
    "class",
    "max",
    "value",
    "$$props"
  ]);
  push(false);
  let state = value_or_fallback($$props["state"], "IDLE");
  let className = value_or_fallback($$props["class"], void 0);
  let max = value_or_fallback($$props["max"], 100);
  let value = value_or_fallback($$props["value"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Progress$1($$payload, spread_props([
    {
      class: cn("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)
    },
    $$restProps,
    {
      children: ($$payload2, $$slotProps) => {
        $$payload2.out += `<div${attr("data-state", state, false)} class="progress-bar h-full w-full flex-1 transition-all"${attr("style", `transform: translateX(-${100 - 100 * (value ?? 0) / (max ?? 1)}%)`, false)}></div>`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  bind_props($$props, { state, class: className, max, value });
  pop();
}
function NewBookmark($$payload, $$props) {
  push(false);
  const $$store_subs = {};
  const PROGRESS = {
    IDLE: 0,
    ERROR: 50,
    LOADING: 25,
    PROCESSING: 50,
    OPENAI: 75,
    SUCCESS: 100,
    PREVIEW: 100
  };
  let FORM_DISABLED = () => !["IDLE", "SUCCESS", "ERROR"].includes(state);
  let urlInput;
  let state = "IDLE";
  let results = writable("");
  new DOMParser();
  new turndown_browser_es_default();
  get_encoding("cl100k_base");
  async function readFromStream(reader, id) {
    try {
      const { done, value } = await reader.read();
      if (done) {
        return;
      }
      store_set(results, store_get($$store_subs, "$results", results) + new TextDecoder().decode(value));
      readFromStream(reader, id);
    } catch (error2) {
      throw new Error(`${error2}`);
    }
  }
  let $$settled = true;
  let $$inner_payload;
  function $$render_inner($$payload2) {
    const anchor = create_anchor($$payload2);
    $$payload2.out += `${anchor}`;
    Root($$payload2, {
      children: ($$payload3, $$slotProps) => {
        const anchor_1 = create_anchor($$payload3);
        const anchor_3 = create_anchor($$payload3);
        const anchor_4 = create_anchor($$payload3);
        $$payload3.out += `${anchor_1}`;
        Trigger($$payload3, {
          class: "flex-inline flex h-full w-full flex-row items-center justify-center gap-4 rounded-none bg-green-500",
          children: ($$payload4, $$slotProps2) => {
            const anchor_2 = create_anchor($$payload4);
            $$payload4.out += `${anchor_2}`;
            Plus_circle($$payload4, {});
            $$payload4.out += `${anchor_2}New`;
          }
        });
        $$payload3.out += `${anchor_1} ${anchor_3}`;
        Dialog_overlay($$payload3, { class: "bg-background/20" });
        $$payload3.out += `${anchor_3} ${anchor_4}`;
        Dialog_content($$payload3, {
          class: `dialogContent top-[50%] ${stringify("w-[50%] sm:max-w-[525px]")} max-h-screen overflow-y-auto transition-all duration-300`,
          children: ($$payload4, $$slotProps2) => {
            const anchor_5 = create_anchor($$payload4);
            const anchor_8 = create_anchor($$payload4);
            const anchor_9 = create_anchor($$payload4);
            const anchor_11 = create_anchor($$payload4);
            const anchor_12 = create_anchor($$payload4);
            const anchor_13 = create_anchor($$payload4);
            const anchor_15 = create_anchor($$payload4);
            const anchor_17 = create_anchor($$payload4);
            $$payload4.out += `<div class="formElement svelte-1f6jiy4"${attr("data-state", state, false)}>${anchor_5}`;
            Dialog_header($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                const anchor_6 = create_anchor($$payload5);
                const anchor_7 = create_anchor($$payload5);
                $$payload5.out += `${anchor_6}`;
                Dialog_title($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `Create New Bookmark`;
                  }
                });
                $$payload5.out += `${anchor_6} ${anchor_7}`;
                Dialog_description($$payload5, {
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `Submit a URL to generate a new bookmark.`;
                  }
                });
                $$payload5.out += `${anchor_7}`;
              }
            });
            $$payload4.out += `${anchor_5} <div class="grid gap-4 py-4"><div class="items-center">${anchor_8}`;
            Input($$payload4, {
              id: "url",
              placeholder: "https://....",
              get value() {
                return urlInput;
              },
              set value($$value) {
                urlInput = $$value;
                $$settled = false;
              }
            });
            $$payload4.out += `${anchor_8}</div></div> ${anchor_9}`;
            Dialog_footer($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                const anchor_10 = create_anchor($$payload5);
                $$payload5.out += `${anchor_10}`;
                Button($$payload5, {
                  type: "submit",
                  disabled: FORM_DISABLED(),
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `Submit URL`;
                  }
                });
                $$payload5.out += `${anchor_10}`;
              }
            });
            $$payload4.out += `${anchor_9}</div> <div${attr("class", ["hidden"].filter(Boolean).join(" "), false)}>${anchor_11}`;
            Progress($$payload4, {
              value: PROGRESS[state],
              state,
              class: "drop-shadow-md"
            });
            $$payload4.out += `${anchor_11} ${anchor_12}`;
            {
              $$payload4.out += "<!--ssr:if:false-->";
            }
            $$payload4.out += `${anchor_12}</div> <div${attr(
              "class",
              [
                "hidden"
              ].filter(Boolean).join(" "),
              false
            )}><div class="float-right gap-4">${anchor_13}`;
            Dialog_close($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                const anchor_14 = create_anchor($$payload5);
                $$payload5.out += `${anchor_14}`;
                Button($$payload5, {
                  class: "bg-green-500",
                  disabled: state != "SUCCESS",
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `Save`;
                  }
                });
                $$payload5.out += `${anchor_14}`;
              }
            });
            $$payload4.out += `${anchor_13} ${anchor_15}`;
            Dialog_close($$payload4, {
              children: ($$payload5, $$slotProps3) => {
                const anchor_16 = create_anchor($$payload5);
                $$payload5.out += `${anchor_16}`;
                Button($$payload5, {
                  variant: "destructive",
                  children: ($$payload6, $$slotProps4) => {
                    $$payload6.out += `Close`;
                  }
                });
                $$payload5.out += `${anchor_16}`;
              }
            });
            $$payload4.out += `${anchor_15}</div> <div class="markdown-body h-auto w-full rounded-sm border-gray-700 p-5">${anchor_17}`;
            SvelteMarkdown($$payload4, {
              source: store_get($$store_subs, "$results", results)
            });
            $$payload4.out += `${anchor_17}</div></div>`;
          }
        });
        $$payload3.out += `${anchor_4}`;
      }
    });
    $$payload2.out += `${anchor}`;
  }
  do {
    $$settled = true;
    $$inner_payload = copy_payload($$payload);
    $$render_inner($$inner_payload);
  } while (!$$settled);
  assign_payload($$payload, $$inner_payload);
  unsubscribe_stores($$store_subs);
  bind_props($$props, { readFromStream });
  pop();
}
function _layout($$payload, $$props) {
  push(false);
  const corbadoSession = new import_webcomponent.default.Session(PUBLIC_CORBADO_PROJECT_ID);
  corbadoSession.refresh((user) => console.log(user));
  let session;
  let authenticated = false;
  initializeSession().then((sess) => {
    console.log("sess", sess);
    session = sess;
    authenticated = sess.isAuthenticated;
  });
  const anchor = create_anchor($$payload);
  head($$payload, ($$payload2) => {
    $$payload2.title = "<title>";
    $$payload2.title += `Bookmark Manager</title>`;
  });
  $$payload.out += `${anchor}`;
  if (authenticated) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    const anchor_3 = create_anchor($$payload);
    const anchor_4 = create_anchor($$payload);
    const anchor_5 = create_anchor($$payload);
    const anchor_6 = create_anchor($$payload);
    const anchor_7 = create_anchor($$payload);
    const anchor_9 = create_anchor($$payload);
    $$payload.out += `<div class="container grid gap-6 px-4 md:grid-cols-[250px_1fr] md:px-6"><div class="flex flex-col gap-4"><div class="mt-2 flex items-center justify-between overflow-hidden rounded-xl bg-white bg-opacity-50">${anchor_1}`;
    Button($$payload, {
      class: "flex-inline ml-auto flex w-full gap-4 rounded-none",
      size: "sm",
      variant: "secondary",
      href: "/",
      children: ($$payload2, $$slotProps) => {
        const anchor_2 = create_anchor($$payload2);
        $$payload2.out += `${anchor_2}`;
        List2($$payload2, {});
        $$payload2.out += `${anchor_2}List`;
      }
    });
    $$payload.out += `${anchor_1} ${anchor_3}`;
    NewBookmark($$payload, {});
    $$payload.out += `${anchor_3}</div> <div><h2 class="text-2xl font-bold text-white">Tags</h2> ${anchor_4}`;
    TagCloud($$payload);
    $$payload.out += `${anchor_4}</div> <div><h2 class="mt-4 text-2xl font-bold text-white">Search</h2> ${anchor_5}`;
    SearchForm($$payload);
    $$payload.out += `${anchor_5}</div> <div><h2 class="mt-4 text-2xl font-bold text-white">Bookmarks</h2> ${anchor_6}`;
    BookmarkCompact($$payload);
    $$payload.out += `${anchor_6}</div></div> <div class="flex flex-col gap-4"><div class="flex items-center justify-between"><h1 class="text-3xl font-bold tracking-tighter text-white sm:text-5xl">Bookmark Manager</h1> <div class="rounded-xl bg-white bg-opacity-50"><span class="px-3">${escape2(session.user.email || "")}</span> ${anchor_7}`;
    Button($$payload, {
      size: "icon",
      variant: "destructive",
      children: ($$payload2, $$slotProps) => {
        const anchor_8 = create_anchor($$payload2);
        $$payload2.out += `${anchor_8}`;
        Log_out($$payload2, { class: "h-4 w-4" });
        $$payload2.out += `${anchor_8}`;
      }
    });
    $$payload.out += `${anchor_7}</div></div> ${anchor_9}`;
    slot($$payload, $$props.children, {}, null);
    $$payload.out += `${anchor_9}</div></div>`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    const anchor_10 = create_anchor($$payload);
    $$payload.out += `${anchor_10}`;
    Auth($$payload);
    $$payload.out += `${anchor_10}`;
  }
  $$payload.out += `${anchor}`;
  pop();
}
var import_webcomponent, import_readability, dev, linear, hiddenAction, isFunctionWithParams, overridable, isDom, pt2, isTouchDevice, isMac, isApple, isIos, LOCK_CLASSNAME, usePortal, visibleModals, name$1, defaults$1, dialogIdParts, defaults3, name, createProgress, Root, Trigger, FetchStatus, legacyMode$1, legacyMode;
var init_layout_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/_layout.svelte.js"() {
    init_index3();
    init_github_markdown();
    init_SvelteMarkdown();
    init_browser();
    init_index2();
    import_webcomponent = __toESM(require_package(), 1);
    init_bundle();
    init_prod_ssr();
    init_index4();
    init_dist2();
    init_main_client();
    init_non_secure();
    init_focus_trap_esm();
    init_clsx();
    init_client();
    init_just_clone();
    init_esm();
    init_devalue();
    init_chunks();
    import_readability = __toESM(require_readability(), 1);
    init_turndown_browser_es();
    init_tiktoken();
    dev = DEV;
    linear = (x4) => x4;
    hiddenAction = (obj) => {
      return new Proxy(obj, {
        get(target, prop, receiver) {
          return Reflect.get(target, prop, receiver);
        },
        ownKeys(target) {
          return Reflect.ownKeys(target).filter((key3) => key3 !== "action");
        }
      });
    };
    isFunctionWithParams = (fn) => {
      return typeof fn === "function";
    };
    overridable = (_store, onChange) => {
      const store = withGet(_store);
      const update2 = (updater, sideEffect) => {
        store.update((curr) => {
          const next2 = updater(curr);
          let res = next2;
          if (onChange) {
            res = onChange({ curr, next: next2 });
          }
          sideEffect?.(res);
          return res;
        });
      };
      const set2 = (curr) => {
        update2(() => curr);
      };
      return {
        ...store,
        update: update2,
        set: set2
      };
    };
    isDom = () => typeof window !== "undefined";
    pt2 = (v5) => isDom() && v5.test(getPlatform().toLowerCase());
    isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
    isMac = () => pt2(/^mac/) && !isTouchDevice();
    isApple = () => pt2(/mac|iphone|ipad|ipod/i);
    isIos = () => isApple() && !isMac();
    LOCK_CLASSNAME = "data-melt-scroll-lock";
    usePortal = (el, target = "body") => {
      let targetEl;
      if (!isHTMLElement(target) && typeof target !== "string") {
        return {
          destroy: noop2
        };
      }
      async function update2(newTarget) {
        target = newTarget;
        if (typeof target === "string") {
          targetEl = document.querySelector(target);
          if (targetEl === null) {
            await tick();
            targetEl = document.querySelector(target);
          }
          if (targetEl === null) {
            throw new Error(`No element found matching css selector: "${target}"`);
          }
        } else if (target instanceof HTMLElement) {
          targetEl = target;
        } else {
          throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
        }
        el.dataset.portal = "";
        targetEl.appendChild(el);
        el.hidden = false;
      }
      function destroy() {
        el.remove();
      }
      update2(target);
      return {
        update: update2,
        destroy
      };
    };
    visibleModals = [];
    ({ name: name$1 } = createElHelpers("dialog"));
    defaults$1 = {
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      role: "dialog",
      defaultOpen: false,
      portal: "body",
      forceVisible: false,
      openFocus: void 0,
      closeFocus: void 0,
      onOutsideClick: void 0
    };
    dialogIdParts = ["content", "title", "description"];
    defaults3 = {
      defaultValue: 0,
      max: 100
    };
    ({ name } = createElHelpers("progress"));
    createProgress = (props) => {
      const withDefaults = { ...defaults3, ...props };
      const options3 = toWritableStores(omit(withDefaults, "value"));
      const { max } = options3;
      const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
      const value = overridable(valueWritable, withDefaults?.onValueChange);
      const root2 = builder(name(), {
        stores: [value, max],
        returned: ([$value, $max]) => {
          return {
            value: $value,
            max: $max,
            role: "meter",
            "aria-valuemin": 0,
            "aria-valuemax": $max,
            "aria-valuenow": $value,
            "data-value": $value,
            "data-state": $value === null ? "indeterminate" : $value === $max ? "complete" : "loading",
            "data-max": $max
          };
        }
      });
      return {
        elements: {
          root: root2
        },
        states: {
          value
        },
        options: options3
      };
    };
    Root = Dialog;
    Trigger = Dialog_trigger;
    (function(FetchStatus2) {
      FetchStatus2[FetchStatus2["Idle"] = 0] = "Idle";
      FetchStatus2[FetchStatus2["Submitting"] = 1] = "Submitting";
      FetchStatus2[FetchStatus2["Delayed"] = 2] = "Delayed";
      FetchStatus2[FetchStatus2["Timeout"] = 3] = "Timeout";
    })(FetchStatus || (FetchStatus = {}));
    legacyMode$1 = false;
    try {
      if (SUPERFORMS_LEGACY)
        legacyMode$1 = true;
    } catch {
    }
    legacyMode = false;
    try {
      if (SUPERFORMS_LEGACY)
        legacyMode = true;
    } catch {
    }
    styleToString2({
      position: "absolute",
      width: "25px",
      height: "25px",
      opacity: "0",
      margin: "0px",
      pointerEvents: "none",
      transform: "translateX(-100%)"
    });
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  stylesheets: () => stylesheets3
});
var index3, component_cache3, component3, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    index3 = 3;
    component3 = async () => component_cache3 ??= (await Promise.resolve().then(() => (init_layout_svelte2(), layout_svelte_exports2))).default;
    imports3 = ["_app/immutable/nodes/3.B5Ca7PHH.js", "_app/immutable/chunks/disclose-version.BDr9Qe-U.js", "_app/immutable/chunks/runtime.PSreMutw.js", "_app/immutable/chunks/render.CzD__4ML.js", "_app/immutable/chunks/github-markdown.CASm2bYB.js", "_app/immutable/chunks/index.ChcU8woL.js", "_app/immutable/chunks/main-client.PbirmUuu.js", "_app/immutable/chunks/SvelteMarkdown.B56muk3S.js", "_app/immutable/chunks/_commonjsHelpers.Cpj98o6Y.js", "_app/immutable/chunks/index.CncxOQDq.js", "_app/immutable/chunks/entry.DT7XnUlp.js"];
    stylesheets3 = ["_app/immutable/assets/3.DtwQMG9T.css", "_app/immutable/assets/github-markdown.BxKBDjno.css"];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/entries/pages/(main)/_page.server.ts.js
var page_server_ts_exports = {};
__export(page_server_ts_exports, {
  ssr: () => ssr2
});
var ssr2;
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/_page.server.ts.js"() {
    ssr2 = false;
  }
});

// .svelte-kit/output/server/entries/pages/(main)/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => _page
});
function _page($$payload, $$props) {
  push(false);
  pop();
}
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/_page.svelte.js"() {
    init_index3();
    init_github_markdown();
    init_clsx();
    init_marked_esm();
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  server: () => page_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, server_id, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_page_server_ts();
    index4 = 4;
    component4 = async () => component_cache4 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default;
    server_id = "src/routes/(main)/+page.server.ts";
    imports4 = ["_app/immutable/nodes/4.CxPXU4-E.js", "_app/immutable/chunks/disclose-version.BDr9Qe-U.js", "_app/immutable/chunks/runtime.PSreMutw.js", "_app/immutable/chunks/github-markdown.CASm2bYB.js", "_app/immutable/chunks/index.ChcU8woL.js", "_app/immutable/chunks/main-client.PbirmUuu.js"];
    stylesheets4 = ["_app/immutable/assets/github-markdown.BxKBDjno.css"];
    fonts4 = [];
  }
});

// .svelte-kit/output/server/entries/pages/(main)/b/_page.ts.js
var page_ts_exports = {};
var init_page_ts = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/b/_page.ts.js"() {
  }
});

// .svelte-kit/output/server/entries/pages/(main)/b/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => _page2
});
function _page2($$payload, $$props) {
  push(false);
  pop();
}
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/b/_page.svelte.js"() {
    init_index3();
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  stylesheets: () => stylesheets5,
  universal: () => page_ts_exports,
  universal_id: () => universal_id
});
var index5, component_cache5, component5, universal_id, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    init_page_ts();
    index5 = 5;
    component5 = async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default;
    universal_id = "src/routes/(main)/b/+page.ts";
    imports5 = ["_app/immutable/nodes/5.CWEPN4-x.js", "_app/immutable/chunks/disclose-version.BDr9Qe-U.js", "_app/immutable/chunks/runtime.PSreMutw.js"];
    stylesheets5 = [];
    fonts5 = [];
  }
});

// .svelte-kit/output/server/entries/pages/(main)/b/_id_/_page.ts.js
var page_ts_exports2 = {};
__export(page_ts_exports2, {
  load: () => load
});
var load;
var init_page_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/b/_id_/_page.ts.js"() {
    init_index2();
    init_index4();
    init_browser();
    load = async ({ params }) => {
      const bookmarkId = params.id;
      if (!get_store_value(faunaReady)) {
        console.log("no session");
        await initializeSession();
      }
      const bookmarkPromise = get_store_value(FAUNA).query(qe`bookmarks.byId(id)`, {
        arguments: { id: bookmarkId }
      }).then((ret) => {
        if (ret.data instanceof te) {
          throw new Error(`Bookmark ${bookmarkId} not found`);
        }
        console.log(ret.data);
        return ret.data;
      }).catch((error2) => {
        throw error2;
      });
      return { bookmark: bookmarkPromise };
    };
  }
});

// .svelte-kit/output/server/entries/pages/(main)/b/_id_/_page.server.ts.js
var page_server_ts_exports2 = {};
__export(page_server_ts_exports2, {
  ssr: () => ssr3
});
var ssr3;
var init_page_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/b/_id_/_page.server.ts.js"() {
    ssr3 = false;
  }
});

// node_modules/highlight.js/es/languages/javascript.js
function javascript(hljs) {
  const regex = hljs.regex;
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$1 = IDENT_RE;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m5;
      const afterMatch = match.input.substring(afterMatchIndex);
      if (m5 = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m5 = afterMatch.match(/^\s+extends\s+/)) {
        if (m5.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits = "[0-9](_?[0-9])*";
  const frac = `\\.(${decimalDigits})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1,
    contains: []
    // defined later
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1,
          /\s+/,
          /extends/,
          /\s+/,
          regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$1,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS,
        "super",
        "import"
      ]),
      IDENT_RE$1,
      regex.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex.concat(/\./, regex.lookahead(
      regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$1,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$1,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$1,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      regex.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$1 + regex.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT,
          hljs.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + IDENT_RE$1,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
var IDENT_RE, KEYWORDS, LITERALS, TYPES, ERROR_TYPES, BUILT_IN_GLOBALS, BUILT_IN_VARIABLES, BUILT_INS;
var init_javascript = __esm({
  "node_modules/highlight.js/es/languages/javascript.js"() {
    IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
    KEYWORDS = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends"
    ];
    LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    TYPES = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ];
    ERROR_TYPES = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ];
    BUILT_INS = [].concat(
      BUILT_IN_GLOBALS,
      TYPES,
      ERROR_TYPES
    );
  }
});

// node_modules/highlight.js/lib/core.js
var require_core = __commonJS({
  "node_modules/highlight.js/lib/core.js"(exports, module2) {
    function deepFreeze(obj) {
      if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function() {
          throw new Error("map is read-only");
        };
      } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function() {
          throw new Error("set is read-only");
        };
      }
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).forEach((name2) => {
        const prop = obj[name2];
        const type = typeof prop;
        if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
          deepFreeze(prop);
        }
      });
      return obj;
    }
    var Response3 = class {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        if (mode.data === void 0)
          mode.data = {};
        this.data = mode.data;
        this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    };
    function escapeHTML(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function inherit$1(original, ...objects) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key3 in original) {
        result[key3] = original[key3];
      }
      objects.forEach(function(obj) {
        for (const key3 in obj) {
          result[key3] = obj[key3];
        }
      });
      return (
        /** @type {T} */
        result
      );
    }
    var SPAN_CLOSE = "</span>";
    var emitsWrappingTags = (node) => {
      return !!node.scope;
    };
    var scopeToCSSClass = (name2, { prefix }) => {
      if (name2.startsWith("language:")) {
        return name2.replace("language:", "language-");
      }
      if (name2.includes(".")) {
        const pieces = name2.split(".");
        return [
          `${prefix}${pieces.shift()}`,
          ...pieces.map((x4, i9) => `${x4}${"_".repeat(i9 + 1)}`)
        ].join(" ");
      }
      return `${prefix}${name2}`;
    };
    var HTMLRenderer = class {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options3) {
        this.buffer = "";
        this.classPrefix = options3.classPrefix;
        parseTree.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text2) {
        this.buffer += escapeHTML(text2);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node))
          return;
        const className = scopeToCSSClass(
          node.scope,
          { prefix: this.classPrefix }
        );
        this.span(className);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node))
          return;
        this.buffer += SPAN_CLOSE;
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    };
    var newNode = (opts = {}) => {
      const result = { children: [] };
      Object.assign(result, opts);
      return result;
    };
    var TokenTree = class _TokenTree {
      constructor() {
        this.rootNode = newNode();
        this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }
      /** @param {string} scope */
      openNode(scope) {
        const node = newNode({ scope });
        this.add(node);
        this.stack.push(node);
      }
      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        return void 0;
      }
      closeAllNodes() {
        while (this.closeNode())
          ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder2) {
        return this.constructor._walk(builder2, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder2, node) {
        if (typeof node === "string") {
          builder2.addText(node);
        } else if (node.children) {
          builder2.openNode(node);
          node.children.forEach((child) => this._walk(builder2, child));
          builder2.closeNode(node);
        }
        return builder2;
      }
      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string")
          return;
        if (!node.children)
          return;
        if (node.children.every((el) => typeof el === "string")) {
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            _TokenTree._collapse(child);
          });
        }
      }
    };
    var TokenTreeEmitter = class extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options3) {
        super();
        this.options = options3;
      }
      /**
       * @param {string} text
       */
      addText(text2) {
        if (text2 === "") {
          return;
        }
        this.add(text2);
      }
      /** @param {string} scope */
      startScope(scope) {
        this.openNode(scope);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(emitter, name2) {
        const node = emitter.root;
        if (name2)
          node.scope = `language:${name2}`;
        this.add(node);
      }
      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }
      finalize() {
        this.closeAllNodes();
        return true;
      }
    };
    function source2(re3) {
      if (!re3)
        return null;
      if (typeof re3 === "string")
        return re3;
      return re3.source;
    }
    function lookahead(re3) {
      return concat4("(?=", re3, ")");
    }
    function anyNumberOfTimes(re3) {
      return concat4("(?:", re3, ")*");
    }
    function optional(re3) {
      return concat4("(?:", re3, ")?");
    }
    function concat4(...args) {
      const joined = args.map((x4) => source2(x4)).join("");
      return joined;
    }
    function stripOptionsFromArgs(args) {
      const opts = args[args.length - 1];
      if (typeof opts === "object" && opts.constructor === Object) {
        args.splice(args.length - 1, 1);
        return opts;
      } else {
        return {};
      }
    }
    function either(...args) {
      const opts = stripOptionsFromArgs(args);
      const joined = "(" + (opts.capture ? "" : "?:") + args.map((x4) => source2(x4)).join("|") + ")";
      return joined;
    }
    function countMatchGroups(re3) {
      return new RegExp(re3.toString() + "|").exec("").length - 1;
    }
    function startsWith(re3, lexeme) {
      const match = re3 && re3.exec(lexeme);
      return match && match.index === 0;
    }
    var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function _rewriteBackreferences(regexps, { joinWith }) {
      let numCaptures = 0;
      return regexps.map((regex) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re3 = source2(regex);
        let out = "";
        while (re3.length > 0) {
          const match = BACKREF_RE.exec(re3);
          if (!match) {
            out += re3;
            break;
          }
          out += re3.substring(0, match.index);
          re3 = re3.substring(match.index + match[0].length);
          if (match[0][0] === "\\" && match[1]) {
            out += "\\" + String(Number(match[1]) + offset);
          } else {
            out += match[0];
            if (match[0] === "(") {
              numCaptures++;
            }
          }
        }
        return out;
      }).map((re3) => `(${re3})`).join(joinWith);
    }
    var MATCH_NOTHING_RE = /\b\B/;
    var IDENT_RE2 = "[a-zA-Z]\\w*";
    var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
    var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
    var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
    var BINARY_NUMBER_RE = "\\b(0b[01]+)";
    var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
    var SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat4(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/
        );
      }
      return inherit$1({
        scope: "meta",
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m5, resp) => {
          if (m5.index !== 0)
            resp.ignoreMatch();
        }
      }, opts);
    };
    var BACKSLASH_ESCAPE = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    };
    var APOS_STRING_MODE = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var QUOTE_STRING_MODE = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    var COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit$1(
        {
          scope: "comment",
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const ENGLISH_WORD = either(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      mode.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: concat4(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            ENGLISH_WORD,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      );
      return mode;
    };
    var C_LINE_COMMENT_MODE = COMMENT("//", "$");
    var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
    var HASH_COMMENT_MODE = COMMENT("#", "$");
    var NUMBER_MODE = {
      scope: "number",
      begin: NUMBER_RE,
      relevance: 0
    };
    var C_NUMBER_MODE = {
      scope: "number",
      begin: C_NUMBER_RE,
      relevance: 0
    };
    var BINARY_NUMBER_MODE = {
      scope: "number",
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    var REGEXP_MODE = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    };
    var TITLE_MODE = {
      scope: "title",
      begin: IDENT_RE2,
      relevance: 0
    };
    var UNDERSCORE_TITLE_MODE = {
      scope: "title",
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(
        mode,
        {
          /** @type {ModeCallback} */
          "on:begin": (m5, resp) => {
            resp.data._beginMatch = m5[1];
          },
          /** @type {ModeCallback} */
          "on:end": (m5, resp) => {
            if (resp.data._beginMatch !== m5[1])
              resp.ignoreMatch();
          }
        }
      );
    };
    var MODES = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      APOS_STRING_MODE,
      BACKSLASH_ESCAPE,
      BINARY_NUMBER_MODE,
      BINARY_NUMBER_RE,
      COMMENT,
      C_BLOCK_COMMENT_MODE,
      C_LINE_COMMENT_MODE,
      C_NUMBER_MODE,
      C_NUMBER_RE,
      END_SAME_AS_BEGIN,
      HASH_COMMENT_MODE,
      IDENT_RE: IDENT_RE2,
      MATCH_NOTHING_RE,
      METHOD_GUARD,
      NUMBER_MODE,
      NUMBER_RE,
      PHRASAL_WORDS_MODE,
      QUOTE_STRING_MODE,
      REGEXP_MODE,
      RE_STARTERS_RE,
      SHEBANG,
      TITLE_MODE,
      UNDERSCORE_IDENT_RE,
      UNDERSCORE_TITLE_MODE
    });
    function skipIfHasPrecedingDot(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }
    function scopeClassName(mode, _parent) {
      if (mode.className !== void 0) {
        mode.scope = mode.className;
        delete mode.className;
      }
    }
    function beginKeywords(mode, parent) {
      if (!parent)
        return;
      if (!mode.beginKeywords)
        return;
      mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
      mode.__beforeBegin = skipIfHasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;
      if (mode.relevance === void 0)
        mode.relevance = 0;
    }
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal))
        return;
      mode.illegal = either(...mode.illegal);
    }
    function compileMatch(mode, _parent) {
      if (!mode.match)
        return;
      if (mode.begin || mode.end)
        throw new Error("begin & end are not supported with match");
      mode.begin = mode.match;
      delete mode.match;
    }
    function compileRelevance(mode, _parent) {
      if (mode.relevance === void 0)
        mode.relevance = 1;
    }
    var beforeMatchExt = (mode, parent) => {
      if (!mode.beforeMatch)
        return;
      if (mode.starts)
        throw new Error("beforeMatch cannot be used with starts");
      const originalMode = Object.assign({}, mode);
      Object.keys(mode).forEach((key3) => {
        delete mode[key3];
      });
      mode.keywords = originalMode.keywords;
      mode.begin = concat4(originalMode.beforeMatch, lookahead(originalMode.begin));
      mode.starts = {
        relevance: 0,
        contains: [
          Object.assign(originalMode, { endsParent: true })
        ]
      };
      mode.relevance = 0;
      delete originalMode.beforeMatch;
    };
    var COMMON_KEYWORDS = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ];
    var DEFAULT_KEYWORD_SCOPE = "keyword";
    function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
      const compiledKeywords = /* @__PURE__ */ Object.create(null);
      if (typeof rawKeywords === "string") {
        compileList(scopeName, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList(scopeName, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(scopeName2) {
          Object.assign(
            compiledKeywords,
            compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
          );
        });
      }
      return compiledKeywords;
      function compileList(scopeName2, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map((x4) => x4.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair = keyword.split("|");
          compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
        });
      }
    }
    function scoreForKeyword(keyword, providedScore) {
      if (providedScore) {
        return Number(providedScore);
      }
      return commonKeyword(keyword) ? 0 : 1;
    }
    function commonKeyword(keyword) {
      return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }
    var seenDeprecations = {};
    var error2 = (message2) => {
      console.error(message2);
    };
    var warn2 = (message2, ...args) => {
      console.log(`WARN: ${message2}`, ...args);
    };
    var deprecated = (version2, message2) => {
      if (seenDeprecations[`${version2}/${message2}`])
        return;
      console.log(`Deprecated as of ${version2}. ${message2}`);
      seenDeprecations[`${version2}/${message2}`] = true;
    };
    var MultiClassError = new Error();
    function remapScopeNames(mode, regexes, { key: key3 }) {
      let offset = 0;
      const scopeNames = mode[key3];
      const emit = {};
      const positions = {};
      for (let i9 = 1; i9 <= regexes.length; i9++) {
        positions[i9 + offset] = scopeNames[i9];
        emit[i9 + offset] = true;
        offset += countMatchGroups(regexes[i9 - 1]);
      }
      mode[key3] = positions;
      mode[key3]._emit = emit;
      mode[key3]._multi = true;
    }
    function beginMultiClass(mode) {
      if (!Array.isArray(mode.begin))
        return;
      if (mode.skip || mode.excludeBegin || mode.returnBegin) {
        error2("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
        error2("beginScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.begin, { key: "beginScope" });
      mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
    }
    function endMultiClass(mode) {
      if (!Array.isArray(mode.end))
        return;
      if (mode.skip || mode.excludeEnd || mode.returnEnd) {
        error2("skip, excludeEnd, returnEnd not compatible with endScope: {}");
        throw MultiClassError;
      }
      if (typeof mode.endScope !== "object" || mode.endScope === null) {
        error2("endScope must be object");
        throw MultiClassError;
      }
      remapScopeNames(mode, mode.end, { key: "endScope" });
      mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
    }
    function scopeSugar(mode) {
      if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
        mode.beginScope = mode.scope;
        delete mode.scope;
      }
    }
    function MultiClass(mode) {
      scopeSugar(mode);
      if (typeof mode.beginScope === "string") {
        mode.beginScope = { _wrap: mode.beginScope };
      }
      if (typeof mode.endScope === "string") {
        mode.endScope = { _wrap: mode.endScope };
      }
      beginMultiClass(mode);
      endMultiClass(mode);
    }
    function compileLanguage(language) {
      function langRe(value, global2) {
        return new RegExp(
          source2(value),
          "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
        );
      }
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }
        // @ts-ignore
        addRule(re3, opts) {
          opts.position = this.position++;
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re3]);
          this.matchAt += countMatchGroups(re3) + 1;
        }
        compile() {
          if (this.regexes.length === 0) {
            this.exec = () => null;
          }
          const terminators = this.regexes.map((el) => el[1]);
          this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
          this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(s9) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s9);
          if (!match) {
            return null;
          }
          const i9 = match.findIndex((el, i10) => i10 > 0 && el !== void 0);
          const matchData = this.matchIndexes[i9];
          match.splice(0, i9);
          return Object.assign(match, matchData);
        }
      }
      class ResumableMultiRegex {
        constructor() {
          this.rules = [];
          this.multiRegexes = [];
          this.count = 0;
          this.lastIndex = 0;
          this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(index7) {
          if (this.multiRegexes[index7])
            return this.multiRegexes[index7];
          const matcher = new MultiRegex();
          this.rules.slice(index7).forEach(([re3, opts]) => matcher.addRule(re3, opts));
          matcher.compile();
          this.multiRegexes[index7] = matcher;
          return matcher;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(re3, opts) {
          this.rules.push([re3, opts]);
          if (opts.type === "begin")
            this.count++;
        }
        /** @param {string} s */
        exec(s9) {
          const m5 = this.getMatcher(this.regexIndex);
          m5.lastIndex = this.lastIndex;
          let result = m5.exec(s9);
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex)
              ;
            else {
              const m22 = this.getMatcher(0);
              m22.lastIndex = this.lastIndex + 1;
              result = m22.exec(s9);
            }
          }
          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              this.considerAll();
            }
          }
          return result;
        }
      }
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();
        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }
        return mm;
      }
      function compileMode(mode, parent) {
        const cmode = (
          /** @type CompiledMode */
          mode
        );
        if (mode.isCompiled)
          return cmode;
        [
          scopeClassName,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch,
          MultiClass,
          beforeMatchExt
        ].forEach((ext) => ext(mode, parent));
        language.compilerExtensions.forEach((ext) => ext(mode, parent));
        mode.__beforeBegin = null;
        [
          beginKeywords,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal,
          // default to 1 relevance if not specified
          compileRelevance
        ].forEach((ext) => ext(mode, parent));
        mode.isCompiled = true;
        let keywordPattern = null;
        if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
          mode.keywords = Object.assign({}, mode.keywords);
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }
        keywordPattern = keywordPattern || /\w+/;
        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }
        cmode.keywordPatternRe = langRe(keywordPattern, true);
        if (parent) {
          if (!mode.begin)
            mode.begin = /\B|\b/;
          cmode.beginRe = langRe(cmode.begin);
          if (!mode.end && !mode.endsWithParent)
            mode.end = /\B|\b/;
          if (mode.end)
            cmode.endRe = langRe(cmode.end);
          cmode.terminatorEnd = source2(cmode.end) || "";
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
          }
        }
        if (mode.illegal)
          cmode.illegalRe = langRe(
            /** @type {RegExp | string} */
            mode.illegal
          );
        if (!mode.contains)
          mode.contains = [];
        mode.contains = [].concat(...mode.contains.map(function(c8) {
          return expandOrCloneMode(c8 === "self" ? mode : c8);
        }));
        mode.contains.forEach(function(c8) {
          compileMode(
            /** @type Mode */
            c8,
            cmode
          );
        });
        if (mode.starts) {
          compileMode(mode.starts, parent);
        }
        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }
      if (!language.compilerExtensions)
        language.compilerExtensions = [];
      if (language.contains && language.contains.includes("self")) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }
      language.classNameAliases = inherit$1(language.classNameAliases || {});
      return compileMode(
        /** @type Mode */
        language
      );
    }
    function dependencyOnParent(mode) {
      if (!mode)
        return false;
      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit$1(mode, { variants: null }, variant);
        });
      }
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }
      if (dependencyOnParent(mode)) {
        return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
      }
      if (Object.isFrozen(mode)) {
        return inherit$1(mode);
      }
      return mode;
    }
    var version = "11.9.0";
    var HTMLInjectionError = class extends Error {
      constructor(reason, html) {
        super(reason);
        this.name = "HTMLInjectionError";
        this.html = html;
      }
    };
    var escape5 = escapeHTML;
    var inherit = inherit$1;
    var NO_MATCH = Symbol("nomatch");
    var MAX_KEYWORD_HITS = 7;
    var HLJS = function(hljs) {
      const languages = /* @__PURE__ */ Object.create(null);
      const aliases = /* @__PURE__ */ Object.create(null);
      const plugins = [];
      let SAFE_MODE = true;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
      let options3 = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };
      function shouldNotHighlight(languageName) {
        return options3.noHighlightRe.test(languageName);
      }
      function blockLanguage(block2) {
        let classes = block2.className + " ";
        classes += block2.parentNode ? block2.parentNode.className : "";
        const match = options3.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn2(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn2("Falling back to no-highlight mode for this block.", block2);
          }
          return language ? match[1] : "no-highlight";
        }
        return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }
      function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrLanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
        } else {
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrLanguageName;
          code = optionsOrCode;
        }
        if (ignoreIllegals === void 0) {
          ignoreIllegals = true;
        }
        const context = {
          code,
          language: languageName
        };
        fire("before:highlight", context);
        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
        result.code = context.code;
        fire("after:highlight", result);
        return result;
      }
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        const keywordHits = /* @__PURE__ */ Object.create(null);
        function keywordData(mode, matchText) {
          return mode.keywords[matchText];
        }
        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }
          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";
          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
            const data = keywordData(top, word);
            if (data) {
              const [kind2, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";
              keywordHits[word] = (keywordHits[word] || 0) + 1;
              if (keywordHits[word] <= MAX_KEYWORD_HITS)
                relevance += keywordRelevance;
              if (kind2.startsWith("_")) {
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind2] || kind2;
                emitKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substring(lastIndex);
          emitter.addText(buf);
        }
        function processSubLanguage() {
          if (modeBuffer === "")
            return;
          let result2 = null;
          if (typeof top.subLanguage === "string") {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */
            result2._top;
          } else {
            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }
          if (top.relevance > 0) {
            relevance += result2.relevance;
          }
          emitter.__addSublanguage(result2._emitter, result2.language);
        }
        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = "";
        }
        function emitKeyword(keyword, scope) {
          if (keyword === "")
            return;
          emitter.startScope(scope);
          emitter.addText(keyword);
          emitter.endScope();
        }
        function emitMultiClass(scope, match) {
          let i9 = 1;
          const max = match.length - 1;
          while (i9 <= max) {
            if (!scope._emit[i9]) {
              i9++;
              continue;
            }
            const klass = language.classNameAliases[scope[i9]] || scope[i9];
            const text2 = match[i9];
            if (klass) {
              emitKeyword(text2, klass);
            } else {
              modeBuffer = text2;
              processKeywords();
              modeBuffer = "";
            }
            i9++;
          }
        }
        function startNewMode(mode, match) {
          if (mode.scope && typeof mode.scope === "string") {
            emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
          }
          if (mode.beginScope) {
            if (mode.beginScope._wrap) {
              emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
              modeBuffer = "";
            } else if (mode.beginScope._multi) {
              emitMultiClass(mode.beginScope, match);
              modeBuffer = "";
            }
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);
          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response3(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored)
                matched = false;
            }
            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            modeBuffer += lexeme[0];
            return 1;
          } else {
            resumeScanAtSamePosition = true;
            return 0;
          }
        }
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;
          const resp = new Response3(newMode);
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb)
              continue;
            cb(match, resp);
            if (resp.isMatchIgnored)
              return doIgnore(lexeme);
          }
          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode, match);
          return newMode.returnBegin ? 0 : lexeme.length;
        }
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substring(match.index);
          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) {
            return NO_MATCH;
          }
          const origin2 = top;
          if (top.endScope && top.endScope._wrap) {
            processBuffer();
            emitKeyword(lexeme, top.endScope._wrap);
          } else if (top.endScope && top.endScope._multi) {
            processBuffer();
            emitMultiClass(top.endScope, match);
          } else if (origin2.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin2.returnEnd || origin2.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin2.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.scope) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            startNewMode(endMode.starts, match);
          }
          return origin2.returnEnd ? 0 : lexeme.length;
        }
        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.scope) {
              list.unshift(current.scope);
            }
          }
          list.forEach((item) => emitter.openNode(item));
        }
        let lastMatch = {};
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];
          modeBuffer += textBeforeMatch;
          if (lexeme == null) {
            processBuffer();
            return 0;
          }
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              const err = new Error(`0 width match regex (${languageName})`);
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;
          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }
          if (match.type === "illegal" && lexeme === "") {
            return 1;
          }
          if (iterations > 1e5 && iterations > match.index * 3) {
            const err = new Error("potential infinite loop, way more iterations than matches");
            throw err;
          }
          modeBuffer += lexeme;
          return lexeme.length;
        }
        const language = getLanguage(languageName);
        if (!language) {
          error2(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }
        const md = compileLanguage(language);
        let result = "";
        let top = continuation || md;
        const continuations = {};
        const emitter = new options3.__emitter(options3);
        processContinuations();
        let modeBuffer = "";
        let relevance = 0;
        let index7 = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;
        try {
          if (!language.__emitTokens) {
            top.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top.matcher.considerAll();
              }
              top.matcher.lastIndex = index7;
              const match = top.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index7, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index7 = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index7));
          } else {
            language.__emitTokens(codeToHighlight, emitter);
          }
          emitter.finalize();
          result = emitter.toHTML();
          return {
            language: languageName,
            value: result,
            relevance,
            illegal: false,
            _emitter: emitter,
            _top: top
          };
        } catch (err) {
          if (err.message && err.message.includes("Illegal")) {
            return {
              language: languageName,
              value: escape5(codeToHighlight),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: err.message,
                index: index7,
                context: codeToHighlight.slice(index7 - 100, index7 + 100),
                mode: err.mode,
                resultSoFar: result
              },
              _emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              language: languageName,
              value: escape5(codeToHighlight),
              illegal: false,
              relevance: 0,
              errorRaised: err,
              _emitter: emitter,
              _top: top
            };
          } else {
            throw err;
          }
        }
      }
      function justTextHighlightResult(code) {
        const result = {
          value: escape5(code),
          illegal: false,
          relevance: 0,
          _top: PLAINTEXT_LANGUAGE,
          _emitter: new options3.__emitter(options3)
        };
        result._emitter.addText(code);
        return result;
      }
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options3.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);
        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
          (name2) => _highlight(name2, code, false)
        );
        results.unshift(plaintext);
        const sorted = results.sort((a7, b5) => {
          if (a7.relevance !== b5.relevance)
            return b5.relevance - a7.relevance;
          if (a7.language && b5.language) {
            if (getLanguage(a7.language).supersetOf === b5.language) {
              return 1;
            } else if (getLanguage(b5.language).supersetOf === a7.language) {
              return -1;
            }
          }
          return 0;
        });
        const [best, secondBest] = sorted;
        const result = best;
        result.secondBest = secondBest;
        return result;
      }
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang && aliases[currentLang] || resultLang;
        element.classList.add("hljs");
        element.classList.add(`language-${language}`);
      }
      function highlightElement(element) {
        let node = null;
        const language = blockLanguage(element);
        if (shouldNotHighlight(language))
          return;
        fire(
          "before:highlightElement",
          { el: element, language }
        );
        if (element.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element);
          return;
        }
        if (element.children.length > 0) {
          if (!options3.ignoreUnescapedHTML) {
            console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
            console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
            console.warn("The element with unescaped HTML:");
            console.warn(element);
          }
          if (options3.throwUnescapedHTML) {
            const err = new HTMLInjectionError(
              "One of your code blocks includes unescaped HTML.",
              element.innerHTML
            );
            throw err;
          }
        }
        node = element;
        const text2 = node.textContent;
        const result = language ? highlight2(text2, { language, ignoreIllegals: true }) : highlightAuto(text2);
        element.innerHTML = result.value;
        element.dataset.highlighted = "yes";
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relevance: result.relevance
        };
        if (result.secondBest) {
          element.secondBest = {
            language: result.secondBest.language,
            relevance: result.secondBest.relevance
          };
        }
        fire("after:highlightElement", { el: element, result, text: text2 });
      }
      function configure(userOptions) {
        options3 = inherit(options3, userOptions);
      }
      const initHighlighting = () => {
        highlightAll();
        deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function initHighlightingOnLoad() {
        highlightAll();
        deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let wantsHighlight = false;
      function highlightAll() {
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }
        const blocks = document.querySelectorAll(options3.cssSelector);
        blocks.forEach(highlightElement);
      }
      function boot() {
        if (wantsHighlight)
          highlightAll();
      }
      if (typeof window !== "undefined" && window.addEventListener) {
        window.addEventListener("DOMContentLoaded", boot, false);
      }
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error2("Language definition for '{}' could not be registered.".replace("{}", languageName));
          if (!SAFE_MODE) {
            throw error$1;
          } else {
            error2(error$1);
          }
          lang = PLAINTEXT_LANGUAGE;
        }
        if (!lang.name)
          lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);
        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }
      function listLanguages() {
        return Object.keys(languages);
      }
      function getLanguage(name2) {
        name2 = (name2 || "").toLowerCase();
        return languages[name2] || languages[aliases[name2]];
      }
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === "string") {
          aliasList = [aliasList];
        }
        aliasList.forEach((alias) => {
          aliases[alias.toLowerCase()] = languageName;
        });
      }
      function autoDetection(name2) {
        const lang = getLanguage(name2);
        return lang && !lang.disableAutodetect;
      }
      function upgradePluginAPI(plugin) {
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }
      function removePlugin(plugin) {
        const index7 = plugins.indexOf(plugin);
        if (index7 !== -1) {
          plugins.splice(index7, 1);
        }
      }
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }
      function deprecateHighlightBlock(el) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");
        return highlightElement(el);
      }
      Object.assign(hljs, {
        highlight: highlight2,
        highlightAuto,
        highlightAll,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        autoDetection,
        inherit,
        addPlugin,
        removePlugin
      });
      hljs.debugMode = function() {
        SAFE_MODE = false;
      };
      hljs.safeMode = function() {
        SAFE_MODE = true;
      };
      hljs.versionString = version;
      hljs.regex = {
        concat: concat4,
        lookahead,
        either,
        optional,
        anyNumberOfTimes
      };
      for (const key3 in MODES) {
        if (typeof MODES[key3] === "object") {
          deepFreeze(MODES[key3]);
        }
      }
      Object.assign(hljs, MODES);
      return hljs;
    };
    var highlight = HLJS({});
    highlight.newInstance = () => HLJS({});
    module2.exports = highlight;
    highlight.HighlightJS = highlight;
    highlight.default = highlight;
  }
});

// node_modules/highlight.js/es/core.js
var import_core, core_default;
var init_core = __esm({
  "node_modules/highlight.js/es/core.js"() {
    import_core = __toESM(require_core(), 1);
    core_default = import_core.default;
  }
});

// .svelte-kit/output/server/entries/pages/(main)/b/_id_/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => _page3
});
function File_pen($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    [
      "path",
      {
        "d": "M12 22h6a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v10"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      { "d": "M10.4 12.6a2 2 0 1 1 3 3L8 21l-4 1 1-4Z" }
    ]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "file-pen" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function Trash_2($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  push(false);
  const iconNode = [
    ["path", { "d": "M3 6h18" }],
    [
      "path",
      { "d": "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" }
    ],
    [
      "path",
      { "d": "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" }
    ],
    [
      "line",
      {
        "x1": "10",
        "x2": "10",
        "y1": "11",
        "y2": "17"
      }
    ],
    [
      "line",
      {
        "x1": "14",
        "x2": "14",
        "y1": "11",
        "y2": "17"
      }
    ]
  ];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Icon($$payload, spread_props([
    { name: "trash-2" },
    $$sanitized_props,
    {
      iconNode,
      children: ($$payload2, $$slotProps) => {
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        slot($$payload2, $$props.children, {}, null);
        $$payload2.out += `${anchor_1}`;
      }
    }
  ]));
  $$payload.out += `${anchor}`;
  pop();
}
function Card($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<div${spread_attributes(
    [
      {
        "class": cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)
      },
      $$restProps
    ],
    true,
    false,
    ""
  )}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</div>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_content($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<div${spread_attributes(
    [
      { "class": cn("p-6 pt-0", className) },
      $$restProps
    ],
    true,
    false,
    ""
  )}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</div>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_description($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<p${spread_attributes(
    [
      {
        "class": cn("text-sm text-muted-foreground", className)
      },
      $$restProps
    ],
    true,
    false,
    ""
  )}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</p>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_footer($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<div${spread_attributes(
    [
      {
        "class": cn("flex items-center p-6 pt-0", className)
      },
      $$restProps
    ],
    true,
    false,
    ""
  )}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</div>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_header($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  const anchor = create_anchor($$payload);
  $$payload.out += `<div${spread_attributes(
    [
      {
        "class": cn("flex flex-col space-y-1.5 p-6", className)
      },
      $$restProps
    ],
    true,
    false,
    ""
  )}>${anchor}`;
  slot($$payload, $$props.children, {}, null);
  $$payload.out += `${anchor}</div>`;
  bind_props($$props, { class: className });
  pop();
}
function Card_title($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["class", "tag", "$$props"]);
  push(false);
  let className = value_or_fallback($$props["class"], void 0);
  let tag = value_or_fallback($$props["tag"], "h3");
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  if (tag) {
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `<${tag}${spread_attributes(
      [
        {
          "class": cn("text-lg font-semibold leading-none tracking-tight", className)
        },
        $$restProps
      ],
      true,
      false,
      ""
    )}>`;
    if (!VoidElements.has(tag)) {
      $$payload.out += `${anchor_1}`;
      const anchor_2 = create_anchor($$payload);
      $$payload.out += `${anchor_2}`;
      slot($$payload, $$props.children, {}, null);
      $$payload.out += `${anchor_2}`;
      $$payload.out += `${anchor_1}</${tag}>`;
    }
  }
  $$payload.out += `${anchor}`;
  bind_props($$props, { class: className, tag });
  pop();
}
function LangTag($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, [
    "code",
    "highlighted",
    "languageName",
    "langtag",
    "$$props"
  ]);
  push(false);
  let code = $$props["code"];
  let highlighted = $$props["highlighted"];
  let languageName = value_or_fallback($$props["languageName"], "plaintext");
  let langtag = value_or_fallback($$props["langtag"], false);
  const anchor = create_anchor($$payload);
  $$payload.out += `<pre${spread_attributes(
    [
      { "data-language": languageName },
      $$restProps
    ],
    true,
    false,
    "svelte-1w9vok",
    {
      styles: null,
      classes: [langtag ? "langtag" : ""].filter(Boolean).join(" ")
    }
  )}><code${attr("class", ["hljs"].filter(Boolean).join(" "), false)}>${anchor}`;
  if (highlighted) {
    $$payload.out += "<!--ssr:if:true-->";
    const anchor_1 = create_anchor($$payload);
    $$payload.out += `${anchor_1}${highlighted}${anchor_1}`;
  } else {
    $$payload.out += "<!--ssr:if:false-->";
    $$payload.out += `${escape2(code)}`;
  }
  $$payload.out += `${anchor}</code></pre>`;
  bind_props($$props, { code, highlighted, languageName, langtag });
  pop();
}
function Highlight($$payload, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props($$sanitized_props, ["language", "code", "langtag", "$$props"]);
  push(false);
  let language = $$props["language"];
  let code = $$props["code"];
  let langtag = value_or_fallback($$props["langtag"], false);
  createEventDispatcher();
  let highlighted = "";
  {
    core_default.registerLanguage(language.name, language.register);
    highlighted = core_default.highlight(code, { language: language.name }).value;
  }
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  slot(
    $$payload,
    $$props.children,
    {
      get highlighted() {
        return highlighted;
      }
    },
    () => {
      const anchor_1 = create_anchor($$payload);
      $$payload.out += `${anchor_1}`;
      LangTag($$payload, spread_props([
        $$restProps,
        {
          languageName: language.name,
          langtag,
          highlighted,
          code
        }
      ]));
      $$payload.out += `${anchor_1}`;
    }
  );
  $$payload.out += `${anchor}`;
  bind_props($$props, { language, code, langtag });
  pop();
}
function Card_1($$payload, $$props) {
  push(false);
  let bookmark = $$props["bookmark"];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  Card($$payload, {
    class: "bg-gray-800 text-white",
    children: ($$payload2, $$slotProps) => {
      const anchor_1 = create_anchor($$payload2);
      const anchor_13 = create_anchor($$payload2);
      const anchor_26 = create_anchor($$payload2);
      $$payload2.out += `${anchor_1}`;
      Card_header($$payload2, {
        children: ($$payload3, $$slotProps2) => {
          const anchor_2 = create_anchor($$payload3);
          const anchor_3 = create_anchor($$payload3);
          const anchor_4 = create_anchor($$payload3);
          const anchor_5 = create_anchor($$payload3);
          const anchor_6 = create_anchor($$payload3);
          const anchor_7 = create_anchor($$payload3);
          const anchor_9 = create_anchor($$payload3);
          const anchor_11 = create_anchor($$payload3);
          $$payload3.out += `<div class="flex items-center justify-between"><div><div class="flex items-center gap-2">${anchor_2}`;
          Card_title($$payload3, {
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `${escape2(bookmark.title)}`;
            }
          });
          $$payload3.out += `${anchor_2} ${anchor_3}`;
          Card_description($$payload3, {
            class: "text-sm",
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `Domain: ${escape2(new URL(bookmark.url).host)}`;
            }
          });
          $$payload3.out += `${anchor_3}</div> ${anchor_4}`;
          Card_description($$payload3, {
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `Written by: React Team`;
            }
          });
          $$payload3.out += `${anchor_4} ${anchor_5}`;
          Card_description($$payload3, {
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `URL: <a${attr("href", bookmark.url, false)}>${escape2(bookmark.url)}</a>`;
            }
          });
          $$payload3.out += `${anchor_5} ${anchor_6}`;
          Card_description($$payload3, {
            children: ($$payload4, $$slotProps3) => {
              $$payload4.out += `Category: ${escape2(bookmark.category)}`;
            }
          });
          $$payload3.out += `${anchor_6}</div> <div class="flex"><img alt="Screenshot" class="rounded-lg object-cover object-center" height="100" src="/placeholder.svg"${attr("style", { aspectRatio: "100/100", objectFit: "cover" }, false)} width="100"> <div class="ml-4 flex">${anchor_7}`;
          Button($$payload3, {
            size: "icon",
            variant: "ghost",
            children: ($$payload4, $$slotProps3) => {
              const anchor_8 = create_anchor($$payload4);
              $$payload4.out += `${anchor_8}`;
              Star($$payload4, { class: "h-4 w-4" });
              $$payload4.out += `${anchor_8} <span class="sr-only">Star/Favorite</span>`;
            }
          });
          $$payload3.out += `${anchor_7} ${anchor_9}`;
          Button($$payload3, {
            size: "icon",
            variant: "ghost",
            children: ($$payload4, $$slotProps3) => {
              const anchor_10 = create_anchor($$payload4);
              $$payload4.out += `${anchor_10}`;
              File_pen($$payload4, { class: "h-4 w-4" });
              $$payload4.out += `${anchor_10} <span class="sr-only">Edit</span>`;
            }
          });
          $$payload3.out += `${anchor_9} ${anchor_11}`;
          Button($$payload3, {
            size: "icon",
            variant: "ghost",
            children: ($$payload4, $$slotProps3) => {
              const anchor_12 = create_anchor($$payload4);
              $$payload4.out += `${anchor_12}`;
              Trash_2($$payload4, { class: "h-4 w-4" });
              $$payload4.out += `${anchor_12} <span class="sr-only">Delete</span>`;
            }
          });
          $$payload3.out += `${anchor_11}</div></div></div>`;
        }
      });
      $$payload2.out += `${anchor_1} ${anchor_13}`;
      Card_content($$payload2, {
        children: ($$payload3, $$slotProps2) => {
          const anchor_14 = create_anchor($$payload3);
          const anchor_15 = create_anchor($$payload3);
          const anchor_16 = create_anchor($$payload3);
          const anchor_17 = create_anchor($$payload3);
          const anchor_20 = create_anchor($$payload3);
          const anchor_21 = create_anchor($$payload3);
          const anchor_23 = create_anchor($$payload3);
          $$payload3.out += `<div class="markdown-body h-auto w-full rounded-sm border-gray-700 p-5">${anchor_14}`;
          SvelteMarkdown($$payload3, { source: bookmark.results });
          $$payload3.out += `${anchor_14}</div> ${anchor_15}`;
          if (bookmark.summary) {
            $$payload3.out += "<!--ssr:if:true-->";
            $$payload3.out += `<div><h3 class="text-lg font-bold">Summary</h3> <p class="text-sm text-gray-400">${escape2(bookmark.summary)}</p></div>`;
          } else {
            $$payload3.out += "<!--ssr:if:false-->";
          }
          $$payload3.out += `${anchor_15} ${anchor_16}`;
          if (bookmark.description) {
            $$payload3.out += "<!--ssr:if:true-->";
            $$payload3.out += `<div><h3 class="mt-4 text-lg font-bold">Description</h3> <p class="text-sm text-gray-400">${escape2(bookmark.description)}</p></div>`;
          } else {
            $$payload3.out += "<!--ssr:if:false-->";
          }
          $$payload3.out += `${anchor_16} ${anchor_17}`;
          if (bookmark.bulletPoints) {
            $$payload3.out += "<!--ssr:if:true-->";
            const anchor_18 = create_anchor($$payload3);
            const each_array = ensure_array_like(bookmark.bulletPoints);
            $$payload3.out += `<div><h3 class="mt-4 text-lg font-bold">Bullet Points</h3> <ul class="list-inside list-disc text-sm text-gray-400">${anchor_18}`;
            for (let $$index = 0; $$index < each_array.length; $$index++) {
              const bulletPoint = each_array[$$index];
              const anchor_19 = create_anchor($$payload3);
              $$payload3.out += `${anchor_19}<li>${escape2(bulletPoint)}</li>${anchor_19}`;
            }
            $$payload3.out += `${anchor_18}</ul></div>`;
          } else {
            $$payload3.out += "<!--ssr:if:false-->";
          }
          $$payload3.out += `${anchor_17} ${anchor_20}`;
          if (bookmark.installationInstructions) {
            $$payload3.out += "<!--ssr:if:true-->";
            $$payload3.out += `<div><h3 class="mt-4 text-lg font-bold">Installation Instructions</h3> <p class="text-sm text-gray-400">${escape2(bookmark.installationInstructions)}</p></div>`;
          } else {
            $$payload3.out += "<!--ssr:if:false-->";
          }
          $$payload3.out += `${anchor_20} ${anchor_21}`;
          if (bookmark.codeExamples) {
            $$payload3.out += "<!--ssr:if:true-->";
            const anchor_22 = create_anchor($$payload3);
            $$payload3.out += `<div><h3 class="mt-4 text-lg font-bold">Code Examples</h3> ${anchor_22}`;
            Highlight($$payload3, {
              language: javascript$1,
              code: bookmark.codeExamples
            });
            $$payload3.out += `${anchor_22}</div>`;
          } else {
            $$payload3.out += "<!--ssr:if:false-->";
          }
          $$payload3.out += `${anchor_21} ${anchor_23}`;
          if (bookmark.relatedLinks) {
            $$payload3.out += "<!--ssr:if:true-->";
            const anchor_24 = create_anchor($$payload3);
            const each_array_1 = ensure_array_like(bookmark.relatedLinks);
            $$payload3.out += `<div><h3 class="mt-4 text-lg font-bold">Related Links</h3> <ul class="list-inside list-disc text-sm text-gray-400">${anchor_24}`;
            for (let $$index_1 = 0; $$index_1 < each_array_1.length; $$index_1++) {
              const relatedLink = each_array_1[$$index_1];
              const anchor_25 = create_anchor($$payload3);
              $$payload3.out += `${anchor_25}<li><a class="underline"${attr("href", relatedLink, false)}></a></li>${anchor_25}`;
            }
            $$payload3.out += `${anchor_24}</ul></div>`;
          } else {
            $$payload3.out += "<!--ssr:if:false-->";
          }
          $$payload3.out += `${anchor_23}`;
        }
      });
      $$payload2.out += `${anchor_13} ${anchor_26}`;
      Card_footer($$payload2, {
        children: ($$payload3, $$slotProps2) => {
          const anchor_27 = create_anchor($$payload3);
          $$payload3.out += `<div class="flex w-full items-center justify-between"><div class="w-3/4">${anchor_27}`;
          if (bookmark.tags) {
            $$payload3.out += "<!--ssr:if:true-->";
            const anchor_28 = create_anchor($$payload3);
            const each_array_2 = ensure_array_like(bookmark.tags);
            $$payload3.out += `<div class="flex flex-wrap gap-2">${anchor_28}`;
            for (let $$index_2 = 0; $$index_2 < each_array_2.length; $$index_2++) {
              const tag = each_array_2[$$index_2];
              const anchor_29 = create_anchor($$payload3);
              const anchor_30 = create_anchor($$payload3);
              $$payload3.out += `${anchor_29}${anchor_30}`;
              Badge($$payload3, {
                class: "rounded-full",
                href: `#/${stringify(tag)}`,
                children: ($$payload4, $$slotProps3) => {
                  $$payload4.out += `#${escape2(tag)}`;
                }
              });
              $$payload3.out += `${anchor_30}${anchor_29}`;
            }
            $$payload3.out += `${anchor_28}</div>`;
          } else {
            $$payload3.out += "<!--ssr:if:false-->";
          }
          $$payload3.out += `${anchor_27}</div> <div>Created on: ${escape2(new Date(bookmark.ts.isoString).toLocaleDateString())}</div></div>`;
        }
      });
      $$payload2.out += `${anchor_26}`;
    }
  });
  $$payload.out += `${anchor}`;
  bind_props($$props, { bookmark });
  pop();
}
function _page3($$payload, $$props) {
  push(false);
  let data = $$props["data"];
  const anchor = create_anchor($$payload);
  $$payload.out += `${anchor}`;
  await_block(
    data.bookmark,
    () => {
      $$payload.out += `<p>Loading...</p>`;
    },
    (bookmark) => {
      const anchor_1 = create_anchor($$payload);
      $$payload.out += `<div>${anchor_1}`;
      Card_1($$payload, { bookmark });
      $$payload.out += `${anchor_1}</div>`;
    }
  );
  $$payload.out += `${anchor}`;
  bind_props($$props, { data });
  pop();
}
var import_webcomponent2, javascript2, javascript$1;
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/(main)/b/_id_/_page.svelte.js"() {
    init_index3();
    init_client();
    init_dist();
    init_clsx();
    init_github_markdown();
    init_SvelteMarkdown();
    init_javascript();
    init_core();
    init_main_client();
    init_index2();
    init_browser();
    import_webcomponent2 = __toESM(require_package(), 1);
    javascript2 = { name: "javascript", register: javascript };
    javascript$1 = javascript2;
    ie({
      base: "relative w-full rounded-lg border p-4 [&>svg]:absolute [&>svg]:text-foreground [&>svg]:left-4 [&>svg]:top-4 [&>svg+div]:translate-y-[-3px] [&:has(svg)]:pl-11",
      variants: {
        variant: {
          default: "bg-background text-foreground",
          destructive: "text-destructive border-destructive/50 dark:border-destructive [&>svg]:text-destructive text-destructive"
        }
      },
      defaultVariants: {
        variant: "default"
      }
    });
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  server: () => page_server_ts_exports2,
  server_id: () => server_id2,
  stylesheets: () => stylesheets6,
  universal: () => page_ts_exports2,
  universal_id: () => universal_id2
});
var index6, component_cache6, component6, universal_id2, server_id2, imports6, stylesheets6, fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    init_page_ts2();
    init_page_server_ts2();
    index6 = 6;
    component6 = async () => component_cache6 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default;
    universal_id2 = "src/routes/(main)/b/[id]/+page.ts";
    server_id2 = "src/routes/(main)/b/[id]/+page.server.ts";
    imports6 = ["_app/immutable/nodes/6.yB_F2H2N.js", "_app/immutable/chunks/index.CncxOQDq.js", "_app/immutable/chunks/index.ChcU8woL.js", "_app/immutable/chunks/runtime.PSreMutw.js", "_app/immutable/chunks/disclose-version.BDr9Qe-U.js", "_app/immutable/chunks/render.CzD__4ML.js", "_app/immutable/chunks/entry.DT7XnUlp.js", "_app/immutable/chunks/SvelteMarkdown.B56muk3S.js", "_app/immutable/chunks/github-markdown.CASm2bYB.js", "_app/immutable/chunks/main-client.PbirmUuu.js"];
    stylesheets6 = ["_app/immutable/assets/6.DC0tRSs2.css", "_app/immutable/assets/github-markdown.BxKBDjno.css"];
    fonts6 = [];
  }
});

// node_modules/openai/version.mjs
var VERSION;
var init_version = __esm({
  "node_modules/openai/version.mjs"() {
    VERSION = "4.27.0";
  }
});

// node_modules/openai/_shims/registry.mjs
function setShims(shims, options3 = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options3.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
var auto, kind, fetch2, Request2, Response2, Headers2, FormData2, Blob2, File2, ReadableStream2, getMultipartRequestOptions, getDefaultAgent, fileFromPath, isFsReadStream;
var init_registry = __esm({
  "node_modules/openai/_shims/registry.mjs"() {
    auto = false;
    kind = void 0;
    fetch2 = void 0;
    Request2 = void 0;
    Response2 = void 0;
    Headers2 = void 0;
    FormData2 = void 0;
    Blob2 = void 0;
    File2 = void 0;
    ReadableStream2 = void 0;
    getMultipartRequestOptions = void 0;
    getDefaultAgent = void 0;
    fileFromPath = void 0;
    isFsReadStream = void 0;
  }
});

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody;
var init_MultipartBody = __esm({
  "node_modules/openai/_shims/MultipartBody.mjs"() {
    MultipartBody = class {
      constructor(body2) {
        this.body = body2;
      }
      get [Symbol.toStringTag]() {
        return "MultipartBody";
      }
    };
  }
});

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error2) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error2.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}
var init_web_runtime = __esm({
  "node_modules/openai/_shims/web-runtime.mjs"() {
    init_MultipartBody();
  }
});

// node_modules/openai/_shims/auto/runtime.mjs
var init_runtime3 = __esm({
  "node_modules/openai/_shims/auto/runtime.mjs"() {
    init_web_runtime();
  }
});

// node_modules/openai/_shims/index.mjs
var init_shims = __esm({
  "node_modules/openai/_shims/index.mjs"() {
    init_registry();
    init_runtime3();
    init_registry();
    if (!kind)
      setShims(getRuntime(), { auto: true });
  }
});

// node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  OpenAIError: () => OpenAIError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var OpenAIError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError;
var init_error = __esm({
  "node_modules/openai/error.mjs"() {
    init_core2();
    OpenAIError = class extends Error {
    };
    APIError = class _APIError extends OpenAIError {
      constructor(status, error2, message2, headers2) {
        super(`${_APIError.makeMessage(status, error2, message2)}`);
        this.status = status;
        this.headers = headers2;
        const data = error2;
        this.error = data;
        this.code = data?.["code"];
        this.param = data?.["param"];
        this.type = data?.["type"];
      }
      static makeMessage(status, error2, message2) {
        const msg = error2?.message ? typeof error2.message === "string" ? error2.message : JSON.stringify(error2.message) : error2 ? JSON.stringify(error2) : message2;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message2, headers2) {
        if (!status) {
          return new APIConnectionError({ cause: castToError(errorResponse) });
        }
        const error2 = errorResponse?.["error"];
        if (status === 400) {
          return new BadRequestError(status, error2, message2, headers2);
        }
        if (status === 401) {
          return new AuthenticationError(status, error2, message2, headers2);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error2, message2, headers2);
        }
        if (status === 404) {
          return new NotFoundError(status, error2, message2, headers2);
        }
        if (status === 409) {
          return new ConflictError(status, error2, message2, headers2);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error2, message2, headers2);
        }
        if (status === 429) {
          return new RateLimitError(status, error2, message2, headers2);
        }
        if (status >= 500) {
          return new InternalServerError(status, error2, message2, headers2);
        }
        return new _APIError(status, error2, message2, headers2);
      }
    };
    APIUserAbortError = class extends APIError {
      constructor({ message: message2 } = {}) {
        super(void 0, void 0, message2 || "Request was aborted.", void 0);
        this.status = void 0;
      }
    };
    APIConnectionError = class extends APIError {
      constructor({ message: message2, cause }) {
        super(void 0, void 0, message2 || "Connection error.", void 0);
        this.status = void 0;
        if (cause)
          this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message: message2 } = {}) {
        super({ message: message2 ?? "Request timed out." });
      }
    };
    BadRequestError = class extends APIError {
      constructor() {
        super(...arguments);
        this.status = 400;
      }
    };
    AuthenticationError = class extends APIError {
      constructor() {
        super(...arguments);
        this.status = 401;
      }
    };
    PermissionDeniedError = class extends APIError {
      constructor() {
        super(...arguments);
        this.status = 403;
      }
    };
    NotFoundError = class extends APIError {
      constructor() {
        super(...arguments);
        this.status = 404;
      }
    };
    ConflictError = class extends APIError {
      constructor() {
        super(...arguments);
        this.status = 409;
      }
    };
    UnprocessableEntityError = class extends APIError {
      constructor() {
        super(...arguments);
        this.status = 422;
      }
    };
    RateLimitError = class extends APIError {
      constructor() {
        super(...arguments);
        this.status = 429;
      }
    };
    InternalServerError = class extends APIError {
    };
  }
});

// node_modules/openai/streaming.mjs
function partition(str2, delimiter) {
  const index7 = str2.indexOf(delimiter);
  if (index7 !== -1) {
    return [str2.substring(0, index7), delimiter, str2.substring(index7 + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e5) {
        reader.releaseLock();
        throw e5;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var Stream, SSEDecoder, LineDecoder;
var init_streaming = __esm({
  "node_modules/openai/streaming.mjs"() {
    init_shims();
    init_error();
    init_error();
    Stream = class _Stream {
      constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
      }
      static fromSSEResponse(response, controller) {
        let consumed = false;
        const decoder2 = new SSEDecoder();
        async function* iterMessages() {
          if (!response.body) {
            controller.abort();
            throw new OpenAIError(`Attempted to iterate over a response with no body`);
          }
          const lineDecoder = new LineDecoder();
          const iter = readableStreamAsyncIterable(response.body);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              const sse = decoder2.decode(line);
              if (sse)
                yield sse;
            }
          }
          for (const line of lineDecoder.flush()) {
            const sse = decoder2.decode(line);
            if (sse)
              yield sse;
          }
        }
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const sse of iterMessages()) {
              if (done)
                continue;
              if (sse.data.startsWith("[DONE]")) {
                done = true;
                continue;
              }
              if (sse.event === null) {
                let data;
                try {
                  data = JSON.parse(sse.data);
                } catch (e5) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e5;
                }
                if (data && data.error) {
                  throw new APIError(void 0, data.error, void 0, void 0);
                }
                yield data;
              }
            }
            done = true;
          } catch (e5) {
            if (e5 instanceof Error && e5.name === "AbortError")
              return;
            throw e5;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller) {
        let consumed = false;
        async function* iterLines() {
          const lineDecoder = new LineDecoder();
          const iter = readableStreamAsyncIterable(readableStream);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              yield line;
            }
          }
          for (const line of lineDecoder.flush()) {
            yield line;
          }
        }
        async function* iterator() {
          if (consumed) {
            throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const line of iterLines()) {
              if (done)
                continue;
              if (line)
                yield JSON.parse(line);
            }
            done = true;
          } catch (e5) {
            if (e5 instanceof Error && e5.name === "AbortError")
              return;
            throw e5;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller);
      }
      [Symbol.asyncIterator]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue) => {
          return {
            next: () => {
              if (queue.length === 0) {
                const result = iterator.next();
                left.push(result);
                right.push(result);
              }
              return queue.shift();
            }
          };
        };
        return [
          new _Stream(() => teeIterator(left), this.controller),
          new _Stream(() => teeIterator(right), this.controller)
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self2 = this;
        let iter;
        const encoder5 = new TextEncoder();
        return new ReadableStream2({
          async start() {
            iter = self2[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done)
                return ctrl.close();
              const bytes = encoder5.encode(JSON.stringify(value) + "\n");
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            await iter.return?.();
          }
        });
      }
    };
    SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith("\r")) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length)
            return null;
          const sse = {
            event: this.event,
            data: this.data.join("\n"),
            raw: this.chunks
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(":")) {
          return null;
        }
        let [fieldname, _4, value] = partition(line, ":");
        if (value.startsWith(" ")) {
          value = value.substring(1);
        }
        if (fieldname === "event") {
          this.event = value;
        } else if (fieldname === "data") {
          this.data.push(value);
        }
        return null;
      }
    };
    LineDecoder = class _LineDecoder {
      constructor() {
        this.buffer = [];
        this.trailingCR = false;
      }
      decode(chunk) {
        let text2 = this.decodeText(chunk);
        if (this.trailingCR) {
          text2 = "\r" + text2;
          this.trailingCR = false;
        }
        if (text2.endsWith("\r")) {
          this.trailingCR = true;
          text2 = text2.slice(0, -1);
        }
        if (!text2) {
          return [];
        }
        const trailingNewline = _LineDecoder.NEWLINE_CHARS.has(text2[text2.length - 1] || "");
        let lines = text2.split(_LineDecoder.NEWLINE_REGEXP);
        if (lines.length === 1 && !trailingNewline) {
          this.buffer.push(lines[0]);
          return [];
        }
        if (this.buffer.length > 0) {
          lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
          this.buffer = [];
        }
        if (!trailingNewline) {
          this.buffer = [lines.pop() || ""];
        }
        return lines;
      }
      decodeText(bytes) {
        if (bytes == null)
          return "";
        if (typeof bytes === "string")
          return bytes;
        if (typeof Buffer !== "undefined") {
          if (bytes instanceof Buffer) {
            return bytes.toString();
          }
          if (bytes instanceof Uint8Array) {
            return Buffer.from(bytes).toString();
          }
          throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
        }
        if (typeof TextDecoder !== "undefined") {
          if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
            this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
            return this.textDecoder.decode(bytes);
          }
          throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
        }
        throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
      }
      flush() {
        if (!this.buffer.length && !this.trailingCR) {
          return [];
        }
        const lines = [this.buffer.join("")];
        this.buffer = [];
        this.trailingCR = false;
        return lines;
      }
    };
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
  }
});

// node_modules/openai/uploads.mjs
async function toFile(value, name2, options3 = {}) {
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name2 || (name2 = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    return new File2([blob], name2, options3);
  }
  const bits = await getBytes(value);
  name2 || (name2 = getName(value) ?? "unknown_file");
  if (!options3.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options3 = { ...options3, type };
    }
  }
  return new File2(bits, name2, options3);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p5) => `"${p5}"`).join(", ")}]`;
}
function getName(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
var isResponseLike, isFileLike, isBlobLike, isUploadable, getStringFromMaybeBuffer, isAsyncIterableIterator, isMultipartBody, multipartFormRequestOptions, createForm, addFormValue;
var init_uploads = __esm({
  "node_modules/openai/uploads.mjs"() {
    init_shims();
    init_shims();
    isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
    isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
    isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
    isUploadable = (value) => {
      return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
    };
    getStringFromMaybeBuffer = (x4) => {
      if (typeof x4 === "string")
        return x4;
      if (typeof Buffer !== "undefined" && x4 instanceof Buffer)
        return String(x4);
      return void 0;
    };
    isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
    isMultipartBody = (body2) => body2 && typeof body2 === "object" && body2.body && body2[Symbol.toStringTag] === "MultipartBody";
    multipartFormRequestOptions = async (opts) => {
      const form = await createForm(opts.body);
      return getMultipartRequestOptions(form, opts);
    };
    createForm = async (body2) => {
      const form = new FormData2();
      await Promise.all(Object.entries(body2 || {}).map(([key3, value]) => addFormValue(form, key3, value)));
      return form;
    };
    addFormValue = async (form, key3, value) => {
      if (value === void 0)
        return;
      if (value == null) {
        throw new TypeError(`Received null for "${key3}"; to pass null in FormData, you must use the string 'null'`);
      }
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        form.append(key3, String(value));
      } else if (isUploadable(value)) {
        const file = await toFile(value);
        form.append(key3, file);
      } else if (Array.isArray(value)) {
        await Promise.all(value.map((entry) => addFormValue(form, key3 + "[]", entry)));
      } else if (typeof value === "object") {
        await Promise.all(Object.entries(value).map(([name2, prop]) => addFormValue(form, `${key3}[${name2}]`, prop)));
      } else {
        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
      }
    };
  }
});

// node_modules/openai/core.mjs
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = contentType?.includes("application/json") || contentType?.includes("application/vnd.api+json");
  if (isJSON) {
    const json2 = await response.json();
    debug("response", response.status, response.url, response.headers, json2);
    return json2;
  }
  const text2 = await response.text();
  debug("response", response.status, response.url, response.headers, text2);
  return text2;
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: key3, pattern: pattern2 } of browserPatterns) {
    const match = pattern2.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key3, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key3) {
  return Object.prototype.hasOwnProperty.call(obj, key3);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k4 in newHeaders) {
    if (!hasOwn(newHeaders, k4))
      continue;
    const lowerKey = k4.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k4];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var __classPrivateFieldSet, __classPrivateFieldGet, _AbstractPage_client, APIPromise, APIClient, AbstractPage, PagePromise, createResponseHeaders, requestOptionsKeys, isRequestOptions, getPlatformProperties, normalizeArch, normalizePlatform, _platformHeaders, getPlatformHeaders, safeJSON, startsWithSchemeRegexp, isAbsoluteURL, sleep2, validatePositiveInteger, castToError, readEnv, uuid4, isRunningInBrowser;
var init_core2 = __esm({
  "node_modules/openai/core.mjs"() {
    init_version();
    init_streaming();
    init_error();
    init_shims();
    init_uploads();
    init_uploads();
    __classPrivateFieldSet = function(receiver, state, value, kind2, f5) {
      if (kind2 === "m")
        throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f5)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind2, f5) {
      if (kind2 === "a" && !f5)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f5 : kind2 === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
    };
    APIPromise = class _APIPromise extends Promise {
      constructor(responsePromise, parseResponse = defaultParseResponse) {
        super((resolve2) => {
          resolve2(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
      }
      _thenUnwrap(transform) {
        return new _APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from 'openai'`:
       * - `import 'openai/shims/node'` (if you're running on Node)
       * - `import 'openai/shims/web'` (otherwise)
       */
      asResponse() {
        return this.responsePromise.then((p5) => p5.response);
      }
      /**
       * Gets the parsed response data and the raw `Response` instance.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from 'openai'`:
       * - `import 'openai/shims/node'` (if you're running on Node)
       * - `import 'openai/shims/web'` (otherwise)
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    APIClient = class {
      constructor({
        baseURL,
        maxRetries = 2,
        timeout = 6e5,
        // 10 minutes
        httpAgent,
        fetch: overridenFetch
      }) {
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
        this.timeout = validatePositiveInteger("timeout", timeout);
        this.httpAgent = httpAgent;
        this.fetch = overridenFetch ?? fetch2;
      }
      authHeaders(opts) {
        return {};
      }
      /**
       * Override this to add your own default headers, for example:
       *
       *  {
       *    ...super.defaultHeaders(),
       *    Authorization: 'Bearer 123',
       *  }
       */
      defaultHeaders(opts) {
        return {
          Accept: "application/json",
          "Content-Type": "application/json",
          "User-Agent": this.getUserAgent(),
          ...getPlatformHeaders(),
          ...this.authHeaders(opts)
        };
      }
      /**
       * Override this to add your own headers validation:
       */
      validateHeaders(headers2, customHeaders) {
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
      }
      get(path2, opts) {
        return this.methodRequest("get", path2, opts);
      }
      post(path2, opts) {
        return this.methodRequest("post", path2, opts);
      }
      patch(path2, opts) {
        return this.methodRequest("patch", path2, opts);
      }
      put(path2, opts) {
        return this.methodRequest("put", path2, opts);
      }
      delete(path2, opts) {
        return this.methodRequest("delete", path2, opts);
      }
      methodRequest(method, path2, opts) {
        return this.request(Promise.resolve(opts).then((opts2) => ({ method, path: path2, ...opts2 })));
      }
      getAPIList(path2, Page2, opts) {
        return this.requestAPIList(Page2, { method: "get", path: path2, ...opts });
      }
      calculateContentLength(body2) {
        if (typeof body2 === "string") {
          if (typeof Buffer !== "undefined") {
            return Buffer.byteLength(body2, "utf8").toString();
          }
          if (typeof TextEncoder !== "undefined") {
            const encoder5 = new TextEncoder();
            const encoded = encoder5.encode(body2);
            return encoded.length.toString();
          }
        }
        return null;
      }
      buildRequest(options3) {
        const { method, path: path2, query, headers: headers2 = {} } = options3;
        const body2 = isMultipartBody(options3.body) ? options3.body.body : options3.body ? JSON.stringify(options3.body, null, 2) : null;
        const contentLength = this.calculateContentLength(body2);
        const url = this.buildURL(path2, query);
        if ("timeout" in options3)
          validatePositiveInteger("timeout", options3.timeout);
        const timeout = options3.timeout ?? this.timeout;
        const httpAgent = options3.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
        const minAgentTimeout = timeout + 1e3;
        if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
          httpAgent.options.timeout = minAgentTimeout;
        }
        if (this.idempotencyHeader && method !== "get") {
          if (!options3.idempotencyKey)
            options3.idempotencyKey = this.defaultIdempotencyKey();
          headers2[this.idempotencyHeader] = options3.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({ options: options3, headers: headers2, contentLength });
        const req = {
          method,
          ...body2 && { body: body2 },
          headers: reqHeaders,
          ...httpAgent && { agent: httpAgent },
          // @ts-ignore node-fetch uses a custom AbortSignal type that is
          // not compatible with standard web types
          signal: options3.signal ?? null
        };
        return { req, url, timeout };
      }
      buildHeaders({ options: options3, headers: headers2, contentLength }) {
        const reqHeaders = {};
        if (contentLength) {
          reqHeaders["content-length"] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options3);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers2);
        if (isMultipartBody(options3.body) && kind !== "node") {
          delete reqHeaders["content-type"];
        }
        this.validateHeaders(reqHeaders, headers2);
        return reqHeaders;
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options3) {
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url, options: options3 }) {
      }
      parseHeaders(headers2) {
        return !headers2 ? {} : Symbol.iterator in headers2 ? Object.fromEntries(Array.from(headers2).map((header) => [...header])) : { ...headers2 };
      }
      makeStatusError(status, error2, message2, headers2) {
        return APIError.generate(status, error2, message2, headers2);
      }
      request(options3, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options3, remainingRetries));
      }
      async makeRequest(optionsInput, retriesRemaining) {
        const options3 = await optionsInput;
        if (retriesRemaining == null) {
          retriesRemaining = options3.maxRetries ?? this.maxRetries;
        }
        await this.prepareOptions(options3);
        const { req, url, timeout } = this.buildRequest(options3);
        await this.prepareRequest(req, { url, options: options3 });
        debug("request", url, options3, req.headers);
        if (options3.signal?.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        if (response instanceof Error) {
          if (options3.signal?.aborted) {
            throw new APIUserAbortError();
          }
          if (retriesRemaining) {
            return this.retryRequest(options3, retriesRemaining);
          }
          if (response.name === "AbortError") {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
          if (retriesRemaining && this.shouldRetry(response)) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
            return this.retryRequest(options3, retriesRemaining, responseHeaders);
          }
          const errText = await response.text().catch((e5) => castToError(e5).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
          debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
          const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
          throw err;
        }
        return { response, options: options3, controller };
      }
      requestAPIList(Page2, options3) {
        const request = this.makeRequest(options3, null);
        return new PagePromise(this, request, Page2);
      }
      buildURL(path2, query) {
        const url = isAbsoluteURL(path2) ? new URL(path2) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url.search = this.stringifyQuery(query);
        }
        return url.toString();
      }
      stringifyQuery(query) {
        return Object.entries(query).filter(([_4, value]) => typeof value !== "undefined").map(([key3, value]) => {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            return `${encodeURIComponent(key3)}=${encodeURIComponent(value)}`;
          }
          if (value === null) {
            return `${encodeURIComponent(key3)}=`;
          }
          throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join("&");
      }
      async fetchWithTimeout(url, init3, ms, controller) {
        const { signal, ...options3 } = init3 || {};
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options3 }).finally(() => {
          clearTimeout(timeout);
        });
      }
      getRequestClient() {
        return { fetch: this.fetch };
      }
      shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options3, retriesRemaining, responseHeaders) {
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders?.["retry-after"];
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = options3.maxRetries ?? this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep2(timeoutMillis);
        return this.makeRequest(options3, retriesRemaining - 1);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
      }
    };
    AbstractPage = class {
      constructor(client, response, body2, options3) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options3;
        this.response = response;
        this.body = body2;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
          return false;
        return this.nextPageInfo() != null;
      }
      async getNextPage() {
        const nextInfo = this.nextPageInfo();
        if (!nextInfo) {
          throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        }
        const nextOptions = { ...this.options };
        if ("params" in nextInfo && typeof nextOptions.query === "object") {
          nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
        } else if ("url" in nextInfo) {
          const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
          for (const [key3, value] of params) {
            nextInfo.url.searchParams.set(key3, value);
          }
          nextOptions.query = void 0;
          nextOptions.path = nextInfo.url.toString();
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
      }
      async *iterPages() {
        let page2 = this;
        yield page2;
        while (page2.hasNextPage()) {
          page2 = await page2.getNextPage();
          yield page2;
        }
      }
      async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page2 of this.iterPages()) {
          for (const item of page2.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    PagePromise = class extends APIPromise {
      constructor(client, request, Page2) {
        super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page2 = await this;
        for await (const item of page2) {
          yield item;
        }
      }
    };
    createResponseHeaders = (headers2) => {
      return new Proxy(Object.fromEntries(
        // @ts-ignore
        headers2.entries()
      ), {
        get(target, name2) {
          const key3 = name2.toString();
          return target[key3.toLowerCase()] || target[key3];
        }
      });
    };
    requestOptionsKeys = {
      method: true,
      path: true,
      query: true,
      body: true,
      headers: true,
      maxRetries: true,
      stream: true,
      timeout: true,
      httpAgent: true,
      signal: true,
      idempotencyKey: true,
      __binaryResponse: true,
      __streamClass: true
    };
    isRequestOptions = (obj) => {
      return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k4) => hasOwn(requestOptionsKeys, k4));
    };
    getPlatformProperties = () => {
      if (typeof Deno !== "undefined" && Deno.build != null) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": Deno.version
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(process.platform),
          "X-Stainless-Arch": normalizeArch(process.arch),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
    };
    normalizeArch = (arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    };
    normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    };
    getPlatformHeaders = () => {
      return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
    };
    safeJSON = (text2) => {
      try {
        return JSON.parse(text2);
      } catch (err) {
        return void 0;
      }
    };
    startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
    isAbsoluteURL = (url) => {
      return startsWithSchemeRegexp.test(url);
    };
    sleep2 = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));
    validatePositiveInteger = (name2, n7) => {
      if (typeof n7 !== "number" || !Number.isInteger(n7)) {
        throw new OpenAIError(`${name2} must be an integer`);
      }
      if (n7 < 0) {
        throw new OpenAIError(`${name2} must be a positive integer`);
      }
      return n7;
    };
    castToError = (err) => {
      if (err instanceof Error)
        return err;
      return new Error(err);
    };
    readEnv = (env) => {
      if (typeof process !== "undefined") {
        return process.env?.[env]?.trim() ?? void 0;
      }
      if (typeof Deno !== "undefined") {
        return Deno.env?.get?.(env)?.trim();
      }
      return void 0;
    };
    uuid4 = () => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c8) => {
        const r8 = Math.random() * 16 | 0;
        const v5 = c8 === "x" ? r8 : r8 & 3 | 8;
        return v5.toString(16);
      });
    };
    isRunningInBrowser = () => {
      return (
        // @ts-ignore
        typeof window !== "undefined" && // @ts-ignore
        typeof window.document !== "undefined" && // @ts-ignore
        typeof navigator !== "undefined"
      );
    };
  }
});

// node_modules/openai/pagination.mjs
var Page, CursorPage;
var init_pagination = __esm({
  "node_modules/openai/pagination.mjs"() {
    init_core2();
    Page = class extends AbstractPage {
      constructor(client, response, body2, options3) {
        super(client, response, body2, options3);
        this.data = body2.data || [];
        this.object = body2.object;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      /**
       * This page represents a response that isn't actually paginated at the API level
       * so there will never be any next page params.
       */
      nextPageParams() {
        return null;
      }
      nextPageInfo() {
        return null;
      }
    };
    CursorPage = class extends AbstractPage {
      constructor(client, response, body2, options3) {
        super(client, response, body2, options3);
        this.data = body2.data || [];
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        const data = this.getPaginatedItems();
        if (!data.length) {
          return null;
        }
        const id = data[data.length - 1]?.id;
        if (!id) {
          return null;
        }
        return { params: { after: id } };
      }
    };
  }
});

// node_modules/openai/resource.mjs
var APIResource;
var init_resource = __esm({
  "node_modules/openai/resource.mjs"() {
    APIResource = class {
      constructor(client) {
        this._client = client;
      }
    };
  }
});

// node_modules/openai/resources/chat/completions.mjs
var Completions;
var init_completions = __esm({
  "node_modules/openai/resources/chat/completions.mjs"() {
    init_resource();
    Completions = class extends APIResource {
      create(body2, options3) {
        return this._client.post("/chat/completions", { body: body2, ...options3, stream: body2.stream ?? false });
      }
    };
    /* @__PURE__ */ (function(Completions4) {
    })(Completions || (Completions = {}));
  }
});

// node_modules/openai/resources/chat/chat.mjs
var Chat;
var init_chat = __esm({
  "node_modules/openai/resources/chat/chat.mjs"() {
    init_resource();
    init_completions();
    Chat = class extends APIResource {
      constructor() {
        super(...arguments);
        this.completions = new Completions(this._client);
      }
    };
    (function(Chat3) {
      Chat3.Completions = Completions;
    })(Chat || (Chat = {}));
  }
});

// node_modules/openai/resources/chat/index.mjs
var init_chat2 = __esm({
  "node_modules/openai/resources/chat/index.mjs"() {
    init_chat();
  }
});

// node_modules/openai/resources/shared.mjs
var init_shared = __esm({
  "node_modules/openai/resources/shared.mjs"() {
  }
});

// node_modules/openai/resources/audio/speech.mjs
var Speech;
var init_speech = __esm({
  "node_modules/openai/resources/audio/speech.mjs"() {
    init_resource();
    Speech = class extends APIResource {
      /**
       * Generates audio from the input text.
       */
      create(body2, options3) {
        return this._client.post("/audio/speech", { body: body2, ...options3, __binaryResponse: true });
      }
    };
    /* @__PURE__ */ (function(Speech2) {
    })(Speech || (Speech = {}));
  }
});

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions;
var init_transcriptions = __esm({
  "node_modules/openai/resources/audio/transcriptions.mjs"() {
    init_resource();
    init_core2();
    Transcriptions = class extends APIResource {
      /**
       * Transcribes audio into the input language.
       */
      create(body2, options3) {
        return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body: body2, ...options3 }));
      }
    };
    /* @__PURE__ */ (function(Transcriptions2) {
    })(Transcriptions || (Transcriptions = {}));
  }
});

// node_modules/openai/resources/audio/translations.mjs
var Translations;
var init_translations = __esm({
  "node_modules/openai/resources/audio/translations.mjs"() {
    init_resource();
    init_core2();
    Translations = class extends APIResource {
      /**
       * Translates audio into English.
       */
      create(body2, options3) {
        return this._client.post("/audio/translations", multipartFormRequestOptions({ body: body2, ...options3 }));
      }
    };
    /* @__PURE__ */ (function(Translations2) {
    })(Translations || (Translations = {}));
  }
});

// node_modules/openai/resources/audio/audio.mjs
var Audio;
var init_audio = __esm({
  "node_modules/openai/resources/audio/audio.mjs"() {
    init_resource();
    init_speech();
    init_transcriptions();
    init_translations();
    Audio = class extends APIResource {
      constructor() {
        super(...arguments);
        this.transcriptions = new Transcriptions(this._client);
        this.translations = new Translations(this._client);
        this.speech = new Speech(this._client);
      }
    };
    (function(Audio2) {
      Audio2.Transcriptions = Transcriptions;
      Audio2.Translations = Translations;
      Audio2.Speech = Speech;
    })(Audio || (Audio = {}));
  }
});

// node_modules/openai/resources/beta/assistants/files.mjs
var Files, AssistantFilesPage;
var init_files = __esm({
  "node_modules/openai/resources/beta/assistants/files.mjs"() {
    init_resource();
    init_core2();
    init_files();
    init_pagination();
    Files = class extends APIResource {
      /**
       * Create an assistant file by attaching a
       * [File](https://platform.openai.com/docs/api-reference/files) to an
       * [assistant](https://platform.openai.com/docs/api-reference/assistants).
       */
      create(assistantId, body2, options3) {
        return this._client.post(`/assistants/${assistantId}/files`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Retrieves an AssistantFile.
       */
      retrieve(assistantId, fileId, options3) {
        return this._client.get(`/assistants/${assistantId}/files/${fileId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      list(assistantId, query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list(assistantId, {}, query);
        }
        return this._client.getAPIList(`/assistants/${assistantId}/files`, AssistantFilesPage, {
          query,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Delete an assistant file.
       */
      del(assistantId, fileId, options3) {
        return this._client.delete(`/assistants/${assistantId}/files/${fileId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
    };
    AssistantFilesPage = class extends CursorPage {
    };
    (function(Files4) {
      Files4.AssistantFilesPage = AssistantFilesPage;
    })(Files || (Files = {}));
  }
});

// node_modules/openai/resources/beta/assistants/assistants.mjs
var Assistants, AssistantsPage;
var init_assistants = __esm({
  "node_modules/openai/resources/beta/assistants/assistants.mjs"() {
    init_resource();
    init_core2();
    init_assistants();
    init_files();
    init_pagination();
    Assistants = class extends APIResource {
      constructor() {
        super(...arguments);
        this.files = new Files(this._client);
      }
      /**
       * Create an assistant with a model and instructions.
       */
      create(body2, options3) {
        return this._client.post("/assistants", {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Retrieves an assistant.
       */
      retrieve(assistantId, options3) {
        return this._client.get(`/assistants/${assistantId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Modifies an assistant.
       */
      update(assistantId, body2, options3) {
        return this._client.post(`/assistants/${assistantId}`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      list(query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/assistants", AssistantsPage, {
          query,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Delete an assistant.
       */
      del(assistantId, options3) {
        return this._client.delete(`/assistants/${assistantId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
    };
    AssistantsPage = class extends CursorPage {
    };
    (function(Assistants2) {
      Assistants2.AssistantsPage = AssistantsPage;
      Assistants2.Files = Files;
      Assistants2.AssistantFilesPage = AssistantFilesPage;
    })(Assistants || (Assistants = {}));
  }
});

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}
var init_RunnableFunction = __esm({
  "node_modules/openai/lib/RunnableFunction.mjs"() {
  }
});

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage, isFunctionMessage, isToolMessage;
var init_chatCompletionUtils = __esm({
  "node_modules/openai/lib/chatCompletionUtils.mjs"() {
    isAssistantMessage = (message2) => {
      return message2?.role === "assistant";
    };
    isFunctionMessage = (message2) => {
      return message2?.role === "function";
    };
    isToolMessage = (message2) => {
      return message2?.role === "tool";
    };
  }
});

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldSet2, __classPrivateFieldGet2, _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_connectedPromise, _AbstractChatCompletionRunner_resolveConnectedPromise, _AbstractChatCompletionRunner_rejectConnectedPromise, _AbstractChatCompletionRunner_endPromise, _AbstractChatCompletionRunner_resolveEndPromise, _AbstractChatCompletionRunner_rejectEndPromise, _AbstractChatCompletionRunner_listeners, _AbstractChatCompletionRunner_ended, _AbstractChatCompletionRunner_errored, _AbstractChatCompletionRunner_aborted, _AbstractChatCompletionRunner_catchingPromiseCreated, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_handleError, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult, DEFAULT_MAX_CHAT_COMPLETIONS, AbstractChatCompletionRunner;
var init_AbstractChatCompletionRunner = __esm({
  "node_modules/openai/lib/AbstractChatCompletionRunner.mjs"() {
    init_error();
    init_RunnableFunction();
    init_chatCompletionUtils();
    __classPrivateFieldSet2 = function(receiver, state, value, kind2, f5) {
      if (kind2 === "m")
        throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f5)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind2, f5) {
      if (kind2 === "a" && !f5)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f5 : kind2 === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
    };
    DEFAULT_MAX_CHAT_COMPLETIONS = 10;
    AbstractChatCompletionRunner = class {
      constructor() {
        _AbstractChatCompletionRunner_instances.add(this);
        this.controller = new AbortController();
        _AbstractChatCompletionRunner_connectedPromise.set(this, void 0);
        _AbstractChatCompletionRunner_resolveConnectedPromise.set(this, () => {
        });
        _AbstractChatCompletionRunner_rejectConnectedPromise.set(this, () => {
        });
        _AbstractChatCompletionRunner_endPromise.set(this, void 0);
        _AbstractChatCompletionRunner_resolveEndPromise.set(this, () => {
        });
        _AbstractChatCompletionRunner_rejectEndPromise.set(this, () => {
        });
        _AbstractChatCompletionRunner_listeners.set(this, {});
        this._chatCompletions = [];
        this.messages = [];
        _AbstractChatCompletionRunner_ended.set(this, false);
        _AbstractChatCompletionRunner_errored.set(this, false);
        _AbstractChatCompletionRunner_aborted.set(this, false);
        _AbstractChatCompletionRunner_catchingPromiseCreated.set(this, false);
        _AbstractChatCompletionRunner_handleError.set(this, (error2) => {
          __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_errored, true, "f");
          if (error2 instanceof Error && error2.name === "AbortError") {
            error2 = new APIUserAbortError();
          }
          if (error2 instanceof APIUserAbortError) {
            __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_aborted, true, "f");
            return this._emit("abort", error2);
          }
          if (error2 instanceof OpenAIError) {
            return this._emit("error", error2);
          }
          if (error2 instanceof Error) {
            const openAIError = new OpenAIError(error2.message);
            openAIError.cause = error2;
            return this._emit("error", openAIError);
          }
          return this._emit("error", new OpenAIError(String(error2)));
        });
        __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_connectedPromise, new Promise((resolve2, reject) => {
          __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_resolveConnectedPromise, resolve2, "f");
          __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_endPromise, new Promise((resolve2, reject) => {
          __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_resolveEndPromise, resolve2, "f");
          __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_rejectEndPromise, reject, "f");
        }), "f");
        __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_connectedPromise, "f").catch(() => {
        });
        __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_endPromise, "f").catch(() => {
        });
      }
      _run(executor) {
        setTimeout(() => {
          executor().then(() => {
            this._emitFinal();
            this._emit("end");
          }, __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_handleError, "f"));
        }, 0);
      }
      _addChatCompletion(chatCompletion) {
        this._chatCompletions.push(chatCompletion);
        this._emit("chatCompletion", chatCompletion);
        const message2 = chatCompletion.choices[0]?.message;
        if (message2)
          this._addMessage(message2);
        return chatCompletion;
      }
      _addMessage(message2, emit = true) {
        if (!("content" in message2))
          message2.content = null;
        this.messages.push(message2);
        if (emit) {
          this._emit("message", message2);
          if ((isFunctionMessage(message2) || isToolMessage(message2)) && message2.content) {
            this._emit("functionCallResult", message2.content);
          } else if (isAssistantMessage(message2) && message2.function_call) {
            this._emit("functionCall", message2.function_call);
          } else if (isAssistantMessage(message2) && message2.tool_calls) {
            for (const tool_call of message2.tool_calls) {
              if (tool_call.type === "function") {
                this._emit("functionCall", tool_call.function);
              }
            }
          }
        }
      }
      _connected() {
        if (this.ended)
          return;
        __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_resolveConnectedPromise, "f").call(this);
        this._emit("connect");
      }
      get ended() {
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_ended, "f");
      }
      get errored() {
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_errored, "f");
      }
      get aborted() {
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event];
        if (!listeners)
          return this;
        const index7 = listeners.findIndex((l7) => l7.listener === listener);
        if (index7 >= 0)
          listeners.splice(index7, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve2, reject) => {
          __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve2);
        });
      }
      async done() {
        __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_endPromise, "f");
      }
      /**
       * @returns a promise that resolves with the final ChatCompletion, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
       */
      async finalChatCompletion() {
        await this.done();
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (!completion)
          throw new OpenAIError("stream ended without producing a ChatCompletion");
        return completion;
      }
      /**
       * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalContent() {
        await this.done();
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
       * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the content of the final FunctionCall, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalFunctionCall() {
        await this.done();
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
      }
      async finalFunctionCallResult() {
        await this.done();
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
      }
      async totalUsage() {
        await this.done();
        return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
      }
      allChatCompletions() {
        return [...this._chatCompletions];
      }
      _emit(event, ...args) {
        if (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_ended, "f")) {
          return;
        }
        if (event === "end") {
          __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_ended, true, "f");
          __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event];
        if (listeners) {
          __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = listeners.filter((l7) => !l7.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error2 = args[0];
          if (!__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !listeners?.length) {
            Promise.reject(error2);
          }
          __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error2);
          __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error2);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error2 = args[0];
          if (!__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !listeners?.length) {
            Promise.reject(error2);
          }
          __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error2);
          __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error2);
          this._emit("end");
        }
      }
      _emitFinal() {
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (completion)
          this._emit("finalChatCompletion", completion);
        const finalMessage = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
        if (finalMessage)
          this._emit("finalMessage", finalMessage);
        const finalContent = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
        if (finalContent)
          this._emit("finalContent", finalContent);
        const finalFunctionCall = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
        if (finalFunctionCall)
          this._emit("finalFunctionCall", finalFunctionCall);
        const finalFunctionCallResult = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
        if (finalFunctionCallResult != null)
          this._emit("finalFunctionCallResult", finalFunctionCallResult);
        if (this._chatCompletions.some((c8) => c8.usage)) {
          this._emit("totalUsage", __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
        }
      }
      async _createChatCompletion(completions, params, options3) {
        const signal = options3?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
        const chatCompletion = await completions.create({ ...params, stream: false }, { ...options3, signal: this.controller.signal });
        this._connected();
        return this._addChatCompletion(chatCompletion);
      }
      async _runChatCompletion(completions, params, options3) {
        for (const message2 of params.messages) {
          this._addMessage(message2, false);
        }
        return await this._createChatCompletion(completions, params, options3);
      }
      async _runFunctions(completions, params, options3) {
        const role = "function";
        const { function_call = "auto", stream, ...restParams } = params;
        const singleFunctionToCall = typeof function_call !== "string" && function_call?.name;
        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options3 || {};
        const functionsByName = {};
        for (const f5 of params.functions) {
          functionsByName[f5.name || f5.function.name] = f5;
        }
        const functions = params.functions.map((f5) => ({
          name: f5.name || f5.function.name,
          parameters: f5.parameters,
          description: f5.description
        }));
        for (const message2 of params.messages) {
          this._addMessage(message2, false);
        }
        for (let i9 = 0; i9 < maxChatCompletions; ++i9) {
          const chatCompletion = await this._createChatCompletion(completions, {
            ...restParams,
            function_call,
            functions,
            messages: [...this.messages]
          }, options3);
          const message2 = chatCompletion.choices[0]?.message;
          if (!message2) {
            throw new OpenAIError(`missing message in ChatCompletion response`);
          }
          if (!message2.function_call)
            return;
          const { name: name2, arguments: args } = message2.function_call;
          const fn = functionsByName[name2];
          if (!fn) {
            const content2 = `Invalid function_call: ${JSON.stringify(name2)}. Available options are: ${functions.map((f5) => JSON.stringify(f5.name)).join(", ")}. Please try again`;
            this._addMessage({ role, name: name2, content: content2 });
            continue;
          } else if (singleFunctionToCall && singleFunctionToCall !== name2) {
            const content2 = `Invalid function_call: ${JSON.stringify(name2)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
            this._addMessage({ role, name: name2, content: content2 });
            continue;
          }
          let parsed;
          try {
            parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
          } catch (error2) {
            this._addMessage({
              role,
              name: name2,
              content: error2 instanceof Error ? error2.message : String(error2)
            });
            continue;
          }
          const rawContent = await fn.function(parsed, this);
          const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
          this._addMessage({ role, name: name2, content });
          if (singleFunctionToCall)
            return;
        }
      }
      async _runTools(completions, params, options3) {
        const role = "tool";
        const { tool_choice = "auto", stream, ...restParams } = params;
        const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice?.function?.name;
        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options3 || {};
        const functionsByName = {};
        for (const f5 of params.tools) {
          if (f5.type === "function") {
            functionsByName[f5.function.name || f5.function.function.name] = f5.function;
          }
        }
        const tools = "tools" in params ? params.tools.map((t8) => t8.type === "function" ? {
          type: "function",
          function: {
            name: t8.function.name || t8.function.function.name,
            parameters: t8.function.parameters,
            description: t8.function.description
          }
        } : t8) : void 0;
        for (const message2 of params.messages) {
          this._addMessage(message2, false);
        }
        for (let i9 = 0; i9 < maxChatCompletions; ++i9) {
          const chatCompletion = await this._createChatCompletion(completions, {
            ...restParams,
            tool_choice,
            tools,
            messages: [...this.messages]
          }, options3);
          const message2 = chatCompletion.choices[0]?.message;
          if (!message2) {
            throw new OpenAIError(`missing message in ChatCompletion response`);
          }
          if (!message2.tool_calls) {
            return;
          }
          for (const tool_call of message2.tool_calls) {
            if (tool_call.type !== "function")
              continue;
            const tool_call_id = tool_call.id;
            const { name: name2, arguments: args } = tool_call.function;
            const fn = functionsByName[name2];
            if (!fn) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name2)}. Available options are: ${tools.map((f5) => JSON.stringify(f5.function.name)).join(", ")}. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            } else if (singleFunctionToCall && singleFunctionToCall !== name2) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name2)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            let parsed;
            try {
              parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
            } catch (error2) {
              const content2 = error2 instanceof Error ? error2.message : String(error2);
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            const rawContent = await fn.function(parsed, this);
            const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
            this._addMessage({ role, tool_call_id, content });
            if (singleFunctionToCall) {
              return;
            }
          }
        }
        return;
      }
    };
    _AbstractChatCompletionRunner_connectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_endPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_listeners = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_ended = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_errored = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_aborted = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_handleError = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
      return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
    }, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
      let i9 = this.messages.length;
      while (i9-- > 0) {
        const message2 = this.messages[i9];
        if (isAssistantMessage(message2)) {
          return { ...message2, content: message2.content ?? null };
        }
      }
      throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
    }, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
      for (let i9 = this.messages.length - 1; i9 >= 0; i9--) {
        const message2 = this.messages[i9];
        if (isAssistantMessage(message2) && message2?.function_call) {
          return message2.function_call;
        }
        if (isAssistantMessage(message2) && message2?.tool_calls?.length) {
          return message2.tool_calls.at(-1)?.function;
        }
      }
      return;
    }, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
      for (let i9 = this.messages.length - 1; i9 >= 0; i9--) {
        const message2 = this.messages[i9];
        if (isFunctionMessage(message2) && message2.content != null) {
          return message2.content;
        }
        if (isToolMessage(message2) && message2.content != null && this.messages.some((x4) => x4.role === "assistant" && x4.tool_calls?.some((y7) => y7.type === "function" && y7.id === message2.tool_call_id))) {
          return message2.content;
        }
      }
      return;
    }, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
      const total = {
        completion_tokens: 0,
        prompt_tokens: 0,
        total_tokens: 0
      };
      for (const { usage } of this._chatCompletions) {
        if (usage) {
          total.completion_tokens += usage.completion_tokens;
          total.prompt_tokens += usage.prompt_tokens;
          total.total_tokens += usage.total_tokens;
        }
      }
      return total;
    }, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
      if (params.n != null && params.n > 1) {
        throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
      }
    }, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
      return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
    };
  }
});

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner;
var init_ChatCompletionRunner = __esm({
  "node_modules/openai/lib/ChatCompletionRunner.mjs"() {
    init_AbstractChatCompletionRunner();
    init_chatCompletionUtils();
    ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
      /** @deprecated - please use `runTools` instead. */
      static runFunctions(completions, params, options3) {
        const runner = new _ChatCompletionRunner();
        const opts = {
          ...options3,
          headers: { ...options3?.headers, "X-Stainless-Helper-Method": "runFunctions" }
        };
        runner._run(() => runner._runFunctions(completions, params, opts));
        return runner;
      }
      static runTools(completions, params, options3) {
        const runner = new _ChatCompletionRunner();
        const opts = {
          ...options3,
          headers: { ...options3?.headers, "X-Stainless-Helper-Method": "runTools" }
        };
        runner._run(() => runner._runTools(completions, params, opts));
        return runner;
      }
      _addMessage(message2) {
        super._addMessage(message2);
        if (isAssistantMessage(message2) && message2.content) {
          this._emit("content", message2.content);
        }
      }
    };
  }
});

// node_modules/openai/lib/ChatCompletionStream.mjs
function finalizeChatCompletion(snapshot) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  return {
    ...rest,
    id,
    choices: choices.map(({ message: message2, finish_reason, index: index7, logprobs, ...choiceRest }) => {
      if (!finish_reason)
        throw new OpenAIError(`missing finish_reason for choice ${index7}`);
      const { content = null, function_call, tool_calls, ...messageRest } = message2;
      const role = message2.role;
      if (!role)
        throw new OpenAIError(`missing role for choice ${index7}`);
      if (function_call) {
        const { arguments: args, name: name2 } = function_call;
        if (args == null)
          throw new OpenAIError(`missing function_call.arguments for choice ${index7}`);
        if (!name2)
          throw new OpenAIError(`missing function_call.name for choice ${index7}`);
        return {
          ...choiceRest,
          message: { content, function_call: { arguments: args, name: name2 }, role },
          finish_reason,
          index: index7,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index7,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            tool_calls: tool_calls.map((tool_call, i9) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name: name2, ...fnRest } = fn || {};
              if (id2 == null)
                throw new OpenAIError(`missing choices[${index7}].tool_calls[${i9}].id
${str(snapshot)}`);
              if (type == null)
                throw new OpenAIError(`missing choices[${index7}].tool_calls[${i9}].type
${str(snapshot)}`);
              if (name2 == null)
                throw new OpenAIError(`missing choices[${index7}].tool_calls[${i9}].function.name
${str(snapshot)}`);
              if (args == null)
                throw new OpenAIError(`missing choices[${index7}].tool_calls[${i9}].function.arguments
${str(snapshot)}`);
              return { ...toolRest, id: id2, type, function: { ...fnRest, name: name2, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role },
        finish_reason,
        index: index7,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
}
function str(x4) {
  return JSON.stringify(x4);
}
var __classPrivateFieldGet3, __classPrivateFieldSet3, _ChatCompletionStream_instances, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_addChunk, _ChatCompletionStream_endRequest, _ChatCompletionStream_accumulateChatCompletion, ChatCompletionStream;
var init_ChatCompletionStream = __esm({
  "node_modules/openai/lib/ChatCompletionStream.mjs"() {
    init_error();
    init_AbstractChatCompletionRunner();
    init_streaming();
    __classPrivateFieldGet3 = function(receiver, state, kind2, f5) {
      if (kind2 === "a" && !f5)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f5 : kind2 === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
    };
    __classPrivateFieldSet3 = function(receiver, state, value, kind2, f5) {
      if (kind2 === "m")
        throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f5)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
    };
    ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
      constructor() {
        super(...arguments);
        _ChatCompletionStream_instances.add(this);
        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
      }
      get currentChatCompletionSnapshot() {
        return __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _ChatCompletionStream();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createChatCompletion(completions, params, options3) {
        const runner = new _ChatCompletionStream();
        runner._run(() => runner._runChatCompletion(completions, { ...params, stream: true }, { ...options3, headers: { ...options3?.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      async _createChatCompletion(completions, params, options3) {
        const signal = options3?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        const stream = await completions.create({ ...params, stream: true }, { ...options3, signal: this.controller.signal });
        this._connected();
        for await (const chunk of stream) {
          __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      async _fromReadableStream(readableStream, options3) {
        const signal = options3?.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        this._connected();
        const stream = Stream.fromReadableStream(readableStream, this.controller);
        let chatId;
        for await (const chunk of stream) {
          if (chatId && chatId !== chunk.id) {
            this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
          }
          __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
          chatId = chunk.id;
        }
        if (stream.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      [(_ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
        if (this.ended)
          return;
        __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
      }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
        if (this.ended)
          return;
        const completion = __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
        this._emit("chunk", chunk, completion);
        const delta = chunk.choices[0]?.delta?.content;
        const snapshot = completion.choices[0]?.message;
        if (delta != null && snapshot?.role === "assistant" && snapshot?.content) {
          this._emit("content", delta, snapshot.content);
        }
      }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
        if (this.ended) {
          throw new OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        if (!snapshot) {
          throw new OpenAIError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
        return finalizeChatCompletion(snapshot);
      }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
        var _a3, _b, _c;
        let snapshot = __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        const { choices, ...rest } = chunk;
        if (!snapshot) {
          snapshot = __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
            ...rest,
            choices: []
          }, "f");
        } else {
          Object.assign(snapshot, rest);
        }
        for (const { delta, finish_reason, index: index7, logprobs = null, ...other } of chunk.choices) {
          let choice = snapshot.choices[index7];
          if (!choice) {
            choice = snapshot.choices[index7] = { finish_reason, index: index7, message: {}, logprobs, ...other };
          }
          if (logprobs) {
            if (!choice.logprobs) {
              choice.logprobs = Object.assign({}, logprobs);
            } else {
              const { content: content2, ...rest3 } = logprobs;
              Object.assign(choice.logprobs, rest3);
              if (content2) {
                (_a3 = choice.logprobs).content ?? (_a3.content = []);
                choice.logprobs.content.push(...content2);
              }
            }
          }
          if (finish_reason)
            choice.finish_reason = finish_reason;
          Object.assign(choice, other);
          if (!delta)
            continue;
          const { content, function_call, role, tool_calls, ...rest2 } = delta;
          Object.assign(choice.message, rest2);
          if (content)
            choice.message.content = (choice.message.content || "") + content;
          if (role)
            choice.message.role = role;
          if (function_call) {
            if (!choice.message.function_call) {
              choice.message.function_call = function_call;
            } else {
              if (function_call.name)
                choice.message.function_call.name = function_call.name;
              if (function_call.arguments) {
                (_b = choice.message.function_call).arguments ?? (_b.arguments = "");
                choice.message.function_call.arguments += function_call.arguments;
              }
            }
          }
          if (tool_calls) {
            if (!choice.message.tool_calls)
              choice.message.tool_calls = [];
            for (const { index: index8, id, type, function: fn, ...rest3 } of tool_calls) {
              const tool_call = (_c = choice.message.tool_calls)[index8] ?? (_c[index8] = {});
              Object.assign(tool_call, rest3);
              if (id)
                tool_call.id = id;
              if (type)
                tool_call.type = type;
              if (fn)
                tool_call.function ?? (tool_call.function = { arguments: "" });
              if (fn?.name)
                tool_call.function.name = fn.name;
              if (fn?.arguments)
                tool_call.function.arguments += fn.arguments;
            }
          }
        }
        return snapshot;
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("chunk", (chunk) => {
          const reader = readQueue.shift();
          if (reader) {
            reader(chunk);
          } else {
            pushQueue.push(chunk);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader(void 0);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve2) => readQueue.push(resolve2)).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          }
        };
      }
      toReadableStream() {
        const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
  }
});

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner;
var init_ChatCompletionStreamingRunner = __esm({
  "node_modules/openai/lib/ChatCompletionStreamingRunner.mjs"() {
    init_ChatCompletionStream();
    ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
      static fromReadableStream(stream) {
        const runner = new _ChatCompletionStreamingRunner();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      /** @deprecated - please use `runTools` instead. */
      static runFunctions(completions, params, options3) {
        const runner = new _ChatCompletionStreamingRunner();
        const opts = {
          ...options3,
          headers: { ...options3?.headers, "X-Stainless-Helper-Method": "runFunctions" }
        };
        runner._run(() => runner._runFunctions(completions, params, opts));
        return runner;
      }
      static runTools(completions, params, options3) {
        const runner = new _ChatCompletionStreamingRunner();
        const opts = {
          ...options3,
          headers: { ...options3?.headers, "X-Stainless-Helper-Method": "runTools" }
        };
        runner._run(() => runner._runTools(completions, params, opts));
        return runner;
      }
    };
  }
});

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2;
var init_completions2 = __esm({
  "node_modules/openai/resources/beta/chat/completions.mjs"() {
    init_resource();
    init_ChatCompletionRunner();
    init_ChatCompletionStreamingRunner();
    init_ChatCompletionStream();
    Completions2 = class extends APIResource {
      runFunctions(body2, options3) {
        if (body2.stream) {
          return ChatCompletionStreamingRunner.runFunctions(this._client.chat.completions, body2, options3);
        }
        return ChatCompletionRunner.runFunctions(this._client.chat.completions, body2, options3);
      }
      runTools(body2, options3) {
        if (body2.stream) {
          return ChatCompletionStreamingRunner.runTools(this._client.chat.completions, body2, options3);
        }
        return ChatCompletionRunner.runTools(this._client.chat.completions, body2, options3);
      }
      /**
       * Creates a chat completion stream
       */
      stream(body2, options3) {
        return ChatCompletionStream.createChatCompletion(this._client.chat.completions, body2, options3);
      }
    };
  }
});

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2;
var init_chat3 = __esm({
  "node_modules/openai/resources/beta/chat/chat.mjs"() {
    init_resource();
    init_completions2();
    Chat2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.completions = new Completions2(this._client);
      }
    };
    (function(Chat3) {
      Chat3.Completions = Completions2;
    })(Chat2 || (Chat2 = {}));
  }
});

// node_modules/openai/resources/beta/threads/messages/files.mjs
var Files2, MessageFilesPage;
var init_files2 = __esm({
  "node_modules/openai/resources/beta/threads/messages/files.mjs"() {
    init_resource();
    init_core2();
    init_files2();
    init_pagination();
    Files2 = class extends APIResource {
      /**
       * Retrieves a message file.
       */
      retrieve(threadId, messageId, fileId, options3) {
        return this._client.get(`/threads/${threadId}/messages/${messageId}/files/${fileId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      list(threadId, messageId, query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list(threadId, messageId, {}, query);
        }
        return this._client.getAPIList(`/threads/${threadId}/messages/${messageId}/files`, MessageFilesPage, {
          query,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
    };
    MessageFilesPage = class extends CursorPage {
    };
    (function(Files4) {
      Files4.MessageFilesPage = MessageFilesPage;
    })(Files2 || (Files2 = {}));
  }
});

// node_modules/openai/resources/beta/threads/messages/messages.mjs
var Messages, ThreadMessagesPage;
var init_messages = __esm({
  "node_modules/openai/resources/beta/threads/messages/messages.mjs"() {
    init_resource();
    init_core2();
    init_messages();
    init_files2();
    init_pagination();
    Messages = class extends APIResource {
      constructor() {
        super(...arguments);
        this.files = new Files2(this._client);
      }
      /**
       * Create a message.
       */
      create(threadId, body2, options3) {
        return this._client.post(`/threads/${threadId}/messages`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Retrieve a message.
       */
      retrieve(threadId, messageId, options3) {
        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Modifies a message.
       */
      update(threadId, messageId, body2, options3) {
        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      list(threadId, query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list(threadId, {}, query);
        }
        return this._client.getAPIList(`/threads/${threadId}/messages`, ThreadMessagesPage, {
          query,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
    };
    ThreadMessagesPage = class extends CursorPage {
    };
    (function(Messages2) {
      Messages2.ThreadMessagesPage = ThreadMessagesPage;
      Messages2.Files = Files2;
      Messages2.MessageFilesPage = MessageFilesPage;
    })(Messages || (Messages = {}));
  }
});

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps, RunStepsPage;
var init_steps = __esm({
  "node_modules/openai/resources/beta/threads/runs/steps.mjs"() {
    init_resource();
    init_core2();
    init_steps();
    init_pagination();
    Steps = class extends APIResource {
      /**
       * Retrieves a run step.
       */
      retrieve(threadId, runId, stepId, options3) {
        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      list(threadId, runId, query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list(threadId, runId, {}, query);
        }
        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
          query,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
    };
    RunStepsPage = class extends CursorPage {
    };
    (function(Steps2) {
      Steps2.RunStepsPage = RunStepsPage;
    })(Steps || (Steps = {}));
  }
});

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs, RunsPage;
var init_runs = __esm({
  "node_modules/openai/resources/beta/threads/runs/runs.mjs"() {
    init_resource();
    init_core2();
    init_runs();
    init_steps();
    init_pagination();
    Runs = class extends APIResource {
      constructor() {
        super(...arguments);
        this.steps = new Steps(this._client);
      }
      /**
       * Create a run.
       */
      create(threadId, body2, options3) {
        return this._client.post(`/threads/${threadId}/runs`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Retrieves a run.
       */
      retrieve(threadId, runId, options3) {
        return this._client.get(`/threads/${threadId}/runs/${runId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Modifies a run.
       */
      update(threadId, runId, body2, options3) {
        return this._client.post(`/threads/${threadId}/runs/${runId}`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      list(threadId, query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list(threadId, {}, query);
        }
        return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
          query,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Cancels a run that is `in_progress`.
       */
      cancel(threadId, runId, options3) {
        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * When a run has the `status: "requires_action"` and `required_action.type` is
       * `submit_tool_outputs`, this endpoint can be used to submit the outputs from the
       * tool calls once they're all completed. All outputs must be submitted in a single
       * request.
       */
      submitToolOutputs(threadId, runId, body2, options3) {
        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
    };
    RunsPage = class extends CursorPage {
    };
    (function(Runs2) {
      Runs2.RunsPage = RunsPage;
      Runs2.Steps = Steps;
      Runs2.RunStepsPage = RunStepsPage;
    })(Runs || (Runs = {}));
  }
});

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads;
var init_threads = __esm({
  "node_modules/openai/resources/beta/threads/threads.mjs"() {
    init_resource();
    init_core2();
    init_messages();
    init_runs();
    Threads = class extends APIResource {
      constructor() {
        super(...arguments);
        this.runs = new Runs(this._client);
        this.messages = new Messages(this._client);
      }
      create(body2 = {}, options3) {
        if (isRequestOptions(body2)) {
          return this.create({}, body2);
        }
        return this._client.post("/threads", {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Retrieves a thread.
       */
      retrieve(threadId, options3) {
        return this._client.get(`/threads/${threadId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Modifies a thread.
       */
      update(threadId, body2, options3) {
        return this._client.post(`/threads/${threadId}`, {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Delete a thread.
       */
      del(threadId, options3) {
        return this._client.delete(`/threads/${threadId}`, {
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
      /**
       * Create a thread and run it in one request.
       */
      createAndRun(body2, options3) {
        return this._client.post("/threads/runs", {
          body: body2,
          ...options3,
          headers: { "OpenAI-Beta": "assistants=v1", ...options3?.headers }
        });
      }
    };
    (function(Threads2) {
      Threads2.Runs = Runs;
      Threads2.RunsPage = RunsPage;
      Threads2.Messages = Messages;
      Threads2.ThreadMessagesPage = ThreadMessagesPage;
    })(Threads || (Threads = {}));
  }
});

// node_modules/openai/resources/beta/beta.mjs
var Beta;
var init_beta = __esm({
  "node_modules/openai/resources/beta/beta.mjs"() {
    init_resource();
    init_assistants();
    init_chat3();
    init_threads();
    Beta = class extends APIResource {
      constructor() {
        super(...arguments);
        this.chat = new Chat2(this._client);
        this.assistants = new Assistants(this._client);
        this.threads = new Threads(this._client);
      }
    };
    (function(Beta2) {
      Beta2.Chat = Chat2;
      Beta2.Assistants = Assistants;
      Beta2.AssistantsPage = AssistantsPage;
      Beta2.Threads = Threads;
    })(Beta || (Beta = {}));
  }
});

// node_modules/openai/resources/completions.mjs
var Completions3;
var init_completions3 = __esm({
  "node_modules/openai/resources/completions.mjs"() {
    init_resource();
    Completions3 = class extends APIResource {
      create(body2, options3) {
        return this._client.post("/completions", { body: body2, ...options3, stream: body2.stream ?? false });
      }
    };
    /* @__PURE__ */ (function(Completions4) {
    })(Completions3 || (Completions3 = {}));
  }
});

// node_modules/openai/resources/embeddings.mjs
var Embeddings;
var init_embeddings = __esm({
  "node_modules/openai/resources/embeddings.mjs"() {
    init_resource();
    Embeddings = class extends APIResource {
      /**
       * Creates an embedding vector representing the input text.
       */
      create(body2, options3) {
        return this._client.post("/embeddings", { body: body2, ...options3 });
      }
    };
    /* @__PURE__ */ (function(Embeddings2) {
    })(Embeddings || (Embeddings = {}));
  }
});

// node_modules/openai/resources/files.mjs
var Files3, FileObjectsPage;
var init_files3 = __esm({
  "node_modules/openai/resources/files.mjs"() {
    init_resource();
    init_core2();
    init_core2();
    init_error();
    init_files3();
    init_core2();
    init_pagination();
    Files3 = class extends APIResource {
      /**
       * Upload a file that can be used across various endpoints. The size of all the
       * files uploaded by one organization can be up to 100 GB.
       *
       * The size of individual files can be a maximum of 512 MB or 2 million tokens for
       * Assistants. See the
       * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) to
       * learn more about the types of files supported. The Fine-tuning API only supports
       * `.jsonl` files.
       *
       * Please [contact us](https://help.openai.com/) if you need to increase these
       * storage limits.
       */
      create(body2, options3) {
        return this._client.post("/files", multipartFormRequestOptions({ body: body2, ...options3 }));
      }
      /**
       * Returns information about a specific file.
       */
      retrieve(fileId, options3) {
        return this._client.get(`/files/${fileId}`, options3);
      }
      list(query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/files", FileObjectsPage, { query, ...options3 });
      }
      /**
       * Delete a file.
       */
      del(fileId, options3) {
        return this._client.delete(`/files/${fileId}`, options3);
      }
      /**
       * Returns the contents of the specified file.
       */
      content(fileId, options3) {
        return this._client.get(`/files/${fileId}/content`, { ...options3, __binaryResponse: true });
      }
      /**
       * Returns the contents of the specified file.
       *
       * @deprecated The `.content()` method should be used instead
       */
      retrieveContent(fileId, options3) {
        return this._client.get(`/files/${fileId}/content`, {
          ...options3,
          headers: { Accept: "application/json", ...options3?.headers }
        });
      }
      /**
       * Waits for the given file to be processed, default timeout is 30 mins.
       */
      async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
        const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
        const start = Date.now();
        let file = await this.retrieve(id);
        while (!file.status || !TERMINAL_STATES.has(file.status)) {
          await sleep2(pollInterval);
          file = await this.retrieve(id);
          if (Date.now() - start > maxWait) {
            throw new APIConnectionTimeoutError({
              message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
            });
          }
        }
        return file;
      }
    };
    FileObjectsPage = class extends Page {
    };
    (function(Files4) {
      Files4.FileObjectsPage = FileObjectsPage;
    })(Files3 || (Files3 = {}));
  }
});

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs, FineTuningJobsPage, FineTuningJobEventsPage;
var init_jobs = __esm({
  "node_modules/openai/resources/fine-tuning/jobs.mjs"() {
    init_resource();
    init_core2();
    init_jobs();
    init_pagination();
    Jobs = class extends APIResource {
      /**
       * Creates a fine-tuning job which begins the process of creating a new model from
       * a given dataset.
       *
       * Response includes details of the enqueued job including job status and the name
       * of the fine-tuned models once complete.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
       */
      create(body2, options3) {
        return this._client.post("/fine_tuning/jobs", { body: body2, ...options3 });
      }
      /**
       * Get info about a fine-tuning job.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
       */
      retrieve(fineTuningJobId, options3) {
        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options3);
      }
      list(query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options3 });
      }
      /**
       * Immediately cancel a fine-tune job.
       */
      cancel(fineTuningJobId, options3) {
        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options3);
      }
      listEvents(fineTuningJobId, query = {}, options3) {
        if (isRequestOptions(query)) {
          return this.listEvents(fineTuningJobId, {}, query);
        }
        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
          query,
          ...options3
        });
      }
    };
    FineTuningJobsPage = class extends CursorPage {
    };
    FineTuningJobEventsPage = class extends CursorPage {
    };
    (function(Jobs2) {
      Jobs2.FineTuningJobsPage = FineTuningJobsPage;
      Jobs2.FineTuningJobEventsPage = FineTuningJobEventsPage;
    })(Jobs || (Jobs = {}));
  }
});

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning;
var init_fine_tuning = __esm({
  "node_modules/openai/resources/fine-tuning/fine-tuning.mjs"() {
    init_resource();
    init_jobs();
    FineTuning = class extends APIResource {
      constructor() {
        super(...arguments);
        this.jobs = new Jobs(this._client);
      }
    };
    (function(FineTuning2) {
      FineTuning2.Jobs = Jobs;
      FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
      FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
    })(FineTuning || (FineTuning = {}));
  }
});

// node_modules/openai/resources/images.mjs
var Images;
var init_images = __esm({
  "node_modules/openai/resources/images.mjs"() {
    init_resource();
    init_core2();
    Images = class extends APIResource {
      /**
       * Creates a variation of a given image.
       */
      createVariation(body2, options3) {
        return this._client.post("/images/variations", multipartFormRequestOptions({ body: body2, ...options3 }));
      }
      /**
       * Creates an edited or extended image given an original image and a prompt.
       */
      edit(body2, options3) {
        return this._client.post("/images/edits", multipartFormRequestOptions({ body: body2, ...options3 }));
      }
      /**
       * Creates an image given a prompt.
       */
      generate(body2, options3) {
        return this._client.post("/images/generations", { body: body2, ...options3 });
      }
    };
    /* @__PURE__ */ (function(Images2) {
    })(Images || (Images = {}));
  }
});

// node_modules/openai/resources/models.mjs
var Models, ModelsPage;
var init_models = __esm({
  "node_modules/openai/resources/models.mjs"() {
    init_resource();
    init_models();
    init_pagination();
    Models = class extends APIResource {
      /**
       * Retrieves a model instance, providing basic information about the model such as
       * the owner and permissioning.
       */
      retrieve(model, options3) {
        return this._client.get(`/models/${model}`, options3);
      }
      /**
       * Lists the currently available models, and provides basic information about each
       * one such as the owner and availability.
       */
      list(options3) {
        return this._client.getAPIList("/models", ModelsPage, options3);
      }
      /**
       * Delete a fine-tuned model. You must have the Owner role in your organization to
       * delete a model.
       */
      del(model, options3) {
        return this._client.delete(`/models/${model}`, options3);
      }
    };
    ModelsPage = class extends Page {
    };
    (function(Models2) {
      Models2.ModelsPage = ModelsPage;
    })(Models || (Models = {}));
  }
});

// node_modules/openai/resources/moderations.mjs
var Moderations;
var init_moderations = __esm({
  "node_modules/openai/resources/moderations.mjs"() {
    init_resource();
    Moderations = class extends APIResource {
      /**
       * Classifies if text violates OpenAI's Content Policy
       */
      create(body2, options3) {
        return this._client.post("/moderations", { body: body2, ...options3 });
      }
    };
    /* @__PURE__ */ (function(Moderations2) {
    })(Moderations || (Moderations = {}));
  }
});

// node_modules/openai/resources/index.mjs
var init_resources = __esm({
  "node_modules/openai/resources/index.mjs"() {
    init_chat2();
    init_shared();
    init_audio();
    init_beta();
    init_completions3();
    init_embeddings();
    init_files3();
    init_fine_tuning();
    init_images();
    init_models();
    init_moderations();
  }
});

// node_modules/openai/index.mjs
var _a, OpenAI, OpenAIError2, APIError2, APIConnectionError2, APIConnectionTimeoutError2, APIUserAbortError2, NotFoundError2, ConflictError2, RateLimitError2, BadRequestError2, AuthenticationError2, InternalServerError2, PermissionDeniedError2, UnprocessableEntityError2, openai_default;
var init_openai = __esm({
  "node_modules/openai/index.mjs"() {
    init_core2();
    init_error();
    init_uploads();
    init_pagination();
    init_resources();
    OpenAI = class extends APIClient {
      /**
       * API Client for interfacing with the OpenAI API.
       *
       * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
       * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
       * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
       * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, ...opts } = {}) {
        if (apiKey === void 0) {
          throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
        }
        const options3 = {
          apiKey,
          organization,
          ...opts,
          baseURL: baseURL || `https://api.openai.com/v1`
        };
        if (!options3.dangerouslyAllowBrowser && isRunningInBrowser()) {
          throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
        }
        super({
          baseURL: options3.baseURL,
          timeout: options3.timeout ?? 6e5,
          httpAgent: options3.httpAgent,
          maxRetries: options3.maxRetries,
          fetch: options3.fetch
        });
        this.completions = new Completions3(this);
        this.chat = new Chat(this);
        this.embeddings = new Embeddings(this);
        this.files = new Files3(this);
        this.images = new Images(this);
        this.audio = new Audio(this);
        this.moderations = new Moderations(this);
        this.models = new Models(this);
        this.fineTuning = new FineTuning(this);
        this.beta = new Beta(this);
        this._options = options3;
        this.apiKey = apiKey;
        this.organization = organization;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      defaultHeaders(opts) {
        return {
          ...super.defaultHeaders(opts),
          "OpenAI-Organization": this.organization,
          ...this._options.defaultHeaders
        };
      }
      authHeaders(opts) {
        return { Authorization: `Bearer ${this.apiKey}` };
      }
    };
    _a = OpenAI;
    OpenAI.OpenAI = _a;
    OpenAI.OpenAIError = OpenAIError;
    OpenAI.APIError = APIError;
    OpenAI.APIConnectionError = APIConnectionError;
    OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
    OpenAI.APIUserAbortError = APIUserAbortError;
    OpenAI.NotFoundError = NotFoundError;
    OpenAI.ConflictError = ConflictError;
    OpenAI.RateLimitError = RateLimitError;
    OpenAI.BadRequestError = BadRequestError;
    OpenAI.AuthenticationError = AuthenticationError;
    OpenAI.InternalServerError = InternalServerError;
    OpenAI.PermissionDeniedError = PermissionDeniedError;
    OpenAI.UnprocessableEntityError = UnprocessableEntityError;
    ({ OpenAIError: OpenAIError2, APIError: APIError2, APIConnectionError: APIConnectionError2, APIConnectionTimeoutError: APIConnectionTimeoutError2, APIUserAbortError: APIUserAbortError2, NotFoundError: NotFoundError2, ConflictError: ConflictError2, RateLimitError: RateLimitError2, BadRequestError: BadRequestError2, AuthenticationError: AuthenticationError2, InternalServerError: InternalServerError2, PermissionDeniedError: PermissionDeniedError2, UnprocessableEntityError: UnprocessableEntityError2 } = error_exports);
    (function(OpenAI2) {
      OpenAI2.toFile = toFile;
      OpenAI2.fileFromPath = fileFromPath;
      OpenAI2.Page = Page;
      OpenAI2.CursorPage = CursorPage;
      OpenAI2.Completions = Completions3;
      OpenAI2.Chat = Chat;
      OpenAI2.Embeddings = Embeddings;
      OpenAI2.Files = Files3;
      OpenAI2.FileObjectsPage = FileObjectsPage;
      OpenAI2.Images = Images;
      OpenAI2.Audio = Audio;
      OpenAI2.Moderations = Moderations;
      OpenAI2.Models = Models;
      OpenAI2.ModelsPage = ModelsPage;
      OpenAI2.FineTuning = FineTuning;
      OpenAI2.Beta = Beta;
    })(OpenAI || (OpenAI = {}));
    openai_default = OpenAI;
  }
});

// node_modules/eventsource-parser/dist/index.js
function createParser(onParse) {
  let isFirstChunk;
  let buffer;
  let startingPosition;
  let startingFieldLength;
  let eventId;
  let eventName;
  let data;
  reset2();
  return {
    feed,
    reset: reset2
  };
  function reset2() {
    isFirstChunk = true;
    buffer = "";
    startingPosition = 0;
    startingFieldLength = -1;
    eventId = void 0;
    eventName = void 0;
    data = "";
  }
  function feed(chunk) {
    buffer = buffer ? buffer + chunk : chunk;
    if (isFirstChunk && hasBom(buffer)) {
      buffer = buffer.slice(BOM.length);
    }
    isFirstChunk = false;
    const length = buffer.length;
    let position = 0;
    let discardTrailingNewline = false;
    while (position < length) {
      if (discardTrailingNewline) {
        if (buffer[position] === "\n") {
          ++position;
        }
        discardTrailingNewline = false;
      }
      let lineLength = -1;
      let fieldLength = startingFieldLength;
      let character;
      for (let index7 = startingPosition; lineLength < 0 && index7 < length; ++index7) {
        character = buffer[index7];
        if (character === ":" && fieldLength < 0) {
          fieldLength = index7 - position;
        } else if (character === "\r") {
          discardTrailingNewline = true;
          lineLength = index7 - position;
        } else if (character === "\n") {
          lineLength = index7 - position;
        }
      }
      if (lineLength < 0) {
        startingPosition = length - position;
        startingFieldLength = fieldLength;
        break;
      } else {
        startingPosition = 0;
        startingFieldLength = -1;
      }
      parseEventStreamLine(buffer, position, fieldLength, lineLength);
      position += lineLength + 1;
    }
    if (position === length) {
      buffer = "";
    } else if (position > 0) {
      buffer = buffer.slice(position);
    }
  }
  function parseEventStreamLine(lineBuffer, index7, fieldLength, lineLength) {
    if (lineLength === 0) {
      if (data.length > 0) {
        onParse({
          type: "event",
          id: eventId,
          event: eventName || void 0,
          data: data.slice(0, -1)
          // remove trailing newline
        });
        data = "";
        eventId = void 0;
      }
      eventName = void 0;
      return;
    }
    const noValue = fieldLength < 0;
    const field = lineBuffer.slice(index7, index7 + (noValue ? lineLength : fieldLength));
    let step = 0;
    if (noValue) {
      step = lineLength;
    } else if (lineBuffer[index7 + fieldLength + 1] === " ") {
      step = fieldLength + 2;
    } else {
      step = fieldLength + 1;
    }
    const position = index7 + step;
    const valueLength = lineLength - step;
    const value = lineBuffer.slice(position, position + valueLength).toString();
    if (field === "data") {
      data += value ? "".concat(value, "\n") : "\n";
    } else if (field === "event") {
      eventName = value;
    } else if (field === "id" && !value.includes("\0")) {
      eventId = value;
    } else if (field === "retry") {
      const retry = parseInt(value, 10);
      if (!Number.isNaN(retry)) {
        onParse({
          type: "reconnect-interval",
          value: retry
        });
      }
    }
  }
}
function hasBom(buffer) {
  return BOM.every((charCode, index7) => buffer.charCodeAt(index7) === charCode);
}
var BOM;
var init_dist8 = __esm({
  "node_modules/eventsource-parser/dist/index.js"() {
    BOM = [239, 187, 191];
  }
});

// node_modules/@braintree/sanitize-url/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@braintree/sanitize-url/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BLANK_URL = exports.relativeFirstCharacters = exports.urlSchemeRegex = exports.ctrlCharactersRegex = exports.htmlCtrlEntityRegex = exports.htmlEntitiesRegex = exports.invalidProtocolRegex = void 0;
    exports.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    exports.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    exports.htmlCtrlEntityRegex = /&(newline|tab);/gi;
    exports.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    exports.urlSchemeRegex = /^.+(:|&colon;)/gim;
    exports.relativeFirstCharacters = [".", "/"];
    exports.BLANK_URL = "about:blank";
  }
});

// node_modules/@braintree/sanitize-url/dist/index.js
var require_dist = __commonJS({
  "node_modules/@braintree/sanitize-url/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeUrl = void 0;
    var constants_1 = require_constants();
    function isRelativeUrlWithoutProtocol(url) {
      return constants_1.relativeFirstCharacters.indexOf(url[0]) > -1;
    }
    function decodeHtmlCharacters(str2) {
      var removedNullByte = str2.replace(constants_1.ctrlCharactersRegex, "");
      return removedNullByte.replace(constants_1.htmlEntitiesRegex, function(match, dec) {
        return String.fromCharCode(dec);
      });
    }
    function sanitizeUrl2(url) {
      if (!url) {
        return constants_1.BLANK_URL;
      }
      var sanitizedUrl = decodeHtmlCharacters(url).replace(constants_1.htmlCtrlEntityRegex, "").replace(constants_1.ctrlCharactersRegex, "").trim();
      if (!sanitizedUrl) {
        return constants_1.BLANK_URL;
      }
      if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
      }
      var urlSchemeParseResults = sanitizedUrl.match(constants_1.urlSchemeRegex);
      if (!urlSchemeParseResults) {
        return sanitizedUrl;
      }
      var urlScheme = urlSchemeParseResults[0];
      if (constants_1.invalidProtocolRegex.test(urlScheme)) {
        return constants_1.BLANK_URL;
      }
      return sanitizedUrl;
    }
    exports.sanitizeUrl = sanitizeUrl2;
  }
});

// .svelte-kit/output/server/entries/endpoints/(api)/api/bookmarks/create/_server.ts.js
var server_ts_exports = {};
__export(server_ts_exports, {
  POST: () => POST
});
function formatStreamPart(type, value) {
  const streamPart = streamParts.find((part) => part.name === type);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type}`);
  }
  return `${streamPart.code}:${JSON.stringify(value)}
`;
}
function createChunkDecoder(complex) {
  const decoder2 = new TextDecoder();
  if (!complex) {
    return function(chunk) {
      if (!chunk)
        return "";
      return decoder2.decode(chunk, { stream: true });
    };
  }
  return function(chunk) {
    const decoded = decoder2.decode(chunk, { stream: true }).split("\n").filter((line) => line !== "");
    return decoded.map(parseStreamPart).filter(Boolean);
  };
}
function createEventStreamTransformer(customParser) {
  const textDecoder = new TextDecoder();
  let eventSourceParser;
  return new TransformStream({
    async start(controller) {
      eventSourceParser = createParser(
        (event) => {
          if ("data" in event && event.type === "event" && event.data === "[DONE]" || // Replicate doesn't send [DONE] but does send a 'done' event
          // @see https://replicate.com/docs/streaming
          event.event === "done") {
            controller.terminate();
            return;
          }
          if ("data" in event) {
            const parsedMessage = customParser ? customParser(event.data, {
              event: event.event
            }) : event.data;
            if (parsedMessage)
              controller.enqueue(parsedMessage);
          }
        }
      );
    },
    transform(chunk) {
      eventSourceParser.feed(textDecoder.decode(chunk));
    }
  });
}
function createCallbacksTransformer(cb) {
  const textEncoder = new TextEncoder();
  let aggregatedResponse = "";
  const callbacks = cb || {};
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message2, controller) {
      controller.enqueue(textEncoder.encode(message2));
      aggregatedResponse += message2;
      if (callbacks.onToken)
        await callbacks.onToken(message2);
    },
    async flush() {
      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal && !isOpenAICallbacks) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}
function isOfTypeOpenAIStreamCallbacks(callbacks) {
  return "experimental_onFunctionCall" in callbacks;
}
function trimStartOfStreamHelper() {
  let isStreamStart = true;
  return (text2) => {
    if (isStreamStart) {
      text2 = text2.trimStart();
      if (text2)
        isStreamStart = false;
    }
    return text2;
  };
}
function AIStream(response, customParser, callbacks) {
  if (!response.ok) {
    if (response.body) {
      const reader = response.body.getReader();
      return new ReadableStream({
        async start(controller) {
          const { done, value } = await reader.read();
          if (!done) {
            const errorText = new TextDecoder().decode(value);
            controller.error(new Error(`Response error: ${errorText}`));
          }
        }
      });
    } else {
      return new ReadableStream({
        start(controller) {
          controller.error(new Error("Response error: No response body"));
        }
      });
    }
  }
  const responseBodyStream = response.body || createEmptyReadableStream();
  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));
}
function createEmptyReadableStream() {
  return new ReadableStream({
    start(controller) {
      controller.close();
    }
  });
}
function readableFromAsyncIterable(iterable) {
  let it2 = iterable[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await it2.next();
      if (done)
        controller.close();
      else
        controller.enqueue(value);
    },
    async cancel(reason) {
      var _a3;
      await ((_a3 = it2.return) == null ? void 0 : _a3.call(it2, reason));
    }
  });
}
function createStreamDataTransformer(experimental_streamData) {
  if (!experimental_streamData) {
    return new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(chunk);
      }
    });
  }
  const encoder5 = new TextEncoder();
  const decoder2 = new TextDecoder();
  return new TransformStream({
    transform: async (chunk, controller) => {
      const message2 = decoder2.decode(chunk);
      controller.enqueue(encoder5.encode(formatStreamPart("text", message2)));
    }
  });
}
function parseOpenAIStream() {
  const extract = chunkToText();
  return (data) => extract(JSON.parse(data));
}
async function* streamable4(stream) {
  const extract = chunkToText();
  for await (let chunk of stream) {
    if ("promptFilterResults" in chunk) {
      chunk = {
        id: chunk.id,
        created: chunk.created.getDate(),
        object: chunk.object,
        // not exposed by Azure API
        model: chunk.model,
        // not exposed by Azure API
        choices: chunk.choices.map((choice) => {
          var _a3, _b, _c, _d, _e2, _f, _g;
          return {
            delta: {
              content: (_a3 = choice.delta) == null ? void 0 : _a3.content,
              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,
              role: (_c = choice.delta) == null ? void 0 : _c.role,
              tool_calls: ((_e2 = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e2.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index7) => ({
                index: index7,
                id: toolCall.id,
                function: toolCall.function,
                type: toolCall.type
              })) : void 0
            },
            finish_reason: choice.finishReason,
            index: choice.index
          };
        })
      };
    }
    const text2 = extract(chunk);
    if (text2)
      yield text2;
  }
}
function chunkToText() {
  const trimStartOfStream = trimStartOfStreamHelper();
  let isFunctionStreamingIn;
  return (json2) => {
    var _a3, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    if (isChatCompletionChunk(json2)) {
      const delta = (_a3 = json2.choices[0]) == null ? void 0 : _a3.delta;
      if ((_b = delta.function_call) == null ? void 0 : _b.name) {
        isFunctionStreamingIn = true;
        return `{"function_call": {"name": "${delta.function_call.name}", "arguments": "`;
      } else if ((_e2 = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e2.name) {
        isFunctionStreamingIn = true;
        const toolCall = delta.tool_calls[0];
        if (toolCall.index === 0) {
          return `{"tool_calls":[ {"id": "${toolCall.id}", "type": "function", "function": {"name": "${(_f = toolCall.function) == null ? void 0 : _f.name}", "arguments": "`;
        } else {
          return `"}}, {"id": "${toolCall.id}", "type": "function", "function": {"name": "${(_g = toolCall.function) == null ? void 0 : _g.name}", "arguments": "`;
        }
      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {
        return cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments);
      } else if ((_k = (_j = delta.tool_calls) == null ? void 0 : _j[0].function) == null ? void 0 : _k.arguments) {
        return cleanupArguments((_n = (_m = (_l = delta.tool_calls) == null ? void 0 : _l[0]) == null ? void 0 : _m.function) == null ? void 0 : _n.arguments);
      } else if (isFunctionStreamingIn && (((_o = json2.choices[0]) == null ? void 0 : _o.finish_reason) === "function_call" || ((_p = json2.choices[0]) == null ? void 0 : _p.finish_reason) === "stop")) {
        isFunctionStreamingIn = false;
        return '"}}';
      } else if (isFunctionStreamingIn && ((_q = json2.choices[0]) == null ? void 0 : _q.finish_reason) === "tool_calls") {
        isFunctionStreamingIn = false;
        return '"}}]}';
      }
    }
    const text2 = trimStartOfStream(
      isChatCompletionChunk(json2) && json2.choices[0].delta.content ? json2.choices[0].delta.content : isCompletion(json2) ? json2.choices[0].text : ""
    );
    return text2;
  };
  function cleanupArguments(argumentChunk) {
    let escapedPartialJson = argumentChunk.replace(/\\/g, "\\\\").replace(/\//g, "\\/").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\f/g, "\\f");
    return `${escapedPartialJson}`;
  }
}
function isChatCompletionChunk(data) {
  return "choices" in data && data.choices && data.choices[0] && "delta" in data.choices[0];
}
function isCompletion(data) {
  return "choices" in data && data.choices && data.choices[0] && "text" in data.choices[0];
}
function OpenAIStream(res, callbacks) {
  const cb = callbacks;
  let stream;
  if (Symbol.asyncIterator in res) {
    stream = readableFromAsyncIterable(streamable4(res)).pipeThrough(
      createCallbacksTransformer(
        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {
          ...cb,
          onFinal: void 0
        } : {
          ...cb
        }
      )
    );
  } else {
    stream = AIStream(
      res,
      parseOpenAIStream(),
      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {
        ...cb,
        onFinal: void 0
      } : {
        ...cb
      }
    );
  }
  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {
    const functionCallTransformer = createFunctionCallTransformer(cb);
    return stream.pipeThrough(functionCallTransformer);
  } else {
    return stream.pipeThrough(
      createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData)
    );
  }
}
function createFunctionCallTransformer(callbacks) {
  const textEncoder = new TextEncoder();
  let isFirstChunk = true;
  let aggregatedResponse = "";
  let aggregatedFinalCompletionResponse = "";
  let isFunctionStreamingIn = false;
  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];
  const isComplexMode = callbacks == null ? void 0 : callbacks.experimental_streamData;
  const decode3 = createChunkDecoder();
  return new TransformStream({
    async transform(chunk, controller) {
      const message2 = decode3(chunk);
      aggregatedFinalCompletionResponse += message2;
      const shouldHandleAsFunction = isFirstChunk && (message2.startsWith('{"function_call":') || message2.startsWith('{"tool_calls":'));
      if (shouldHandleAsFunction) {
        isFunctionStreamingIn = true;
        aggregatedResponse += message2;
        isFirstChunk = false;
        return;
      }
      if (!isFunctionStreamingIn) {
        controller.enqueue(
          isComplexMode ? textEncoder.encode(formatStreamPart("text", message2)) : chunk
        );
        return;
      } else {
        aggregatedResponse += message2;
      }
    },
    async flush(controller) {
      try {
        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {
          isFunctionStreamingIn = false;
          const payload = JSON.parse(aggregatedResponse);
          let newFunctionCallMessages = [
            ...functionCallMessages
          ];
          let functionResponse = void 0;
          if (callbacks.experimental_onFunctionCall) {
            if (payload.function_call === void 0) {
              console.warn(
                "experimental_onFunctionCall should not be defined when using tools"
              );
            }
            const argumentsPayload = JSON.parse(
              payload.function_call.arguments
            );
            functionResponse = await callbacks.experimental_onFunctionCall(
              {
                name: payload.function_call.name,
                arguments: argumentsPayload
              },
              (result) => {
                newFunctionCallMessages = [
                  ...functionCallMessages,
                  {
                    role: "assistant",
                    content: "",
                    function_call: payload.function_call
                  },
                  {
                    role: "function",
                    name: payload.function_call.name,
                    content: JSON.stringify(result)
                  }
                ];
                return newFunctionCallMessages;
              }
            );
          }
          if (callbacks.experimental_onToolCall) {
            const toolCalls = {
              tools: []
            };
            for (const tool of payload.tool_calls) {
              toolCalls.tools.push({
                id: tool.id,
                type: "function",
                func: {
                  name: tool.function.name,
                  arguments: tool.function.arguments
                }
              });
            }
            let responseIndex = 0;
            try {
              functionResponse = await callbacks.experimental_onToolCall(
                toolCalls,
                (result) => {
                  if (result) {
                    const { tool_call_id, function_name, tool_call_result } = result;
                    newFunctionCallMessages = [
                      ...newFunctionCallMessages,
                      // Only append the assistant message if it's the first response
                      ...responseIndex === 0 ? [
                        {
                          role: "assistant",
                          content: "",
                          tool_calls: payload.tool_calls.map(
                            (tc) => ({
                              id: tc.id,
                              type: "function",
                              function: {
                                name: tc.function.name,
                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it
                                arguments: JSON.stringify(
                                  tc.function.arguments
                                )
                              }
                            })
                          )
                        }
                      ] : [],
                      // Append the function call result message
                      {
                        role: "tool",
                        tool_call_id,
                        name: function_name,
                        content: JSON.stringify(tool_call_result)
                      }
                    ];
                    responseIndex++;
                  }
                  return newFunctionCallMessages;
                }
              );
            } catch (e5) {
              console.error("Error calling experimental_onToolCall:", e5);
            }
          }
          if (!functionResponse) {
            controller.enqueue(
              textEncoder.encode(
                isComplexMode ? formatStreamPart(
                  payload.function_call ? "function_call" : "tool_calls",
                  // parse to prevent double-encoding:
                  JSON.parse(aggregatedResponse)
                ) : aggregatedResponse
              )
            );
            return;
          } else if (typeof functionResponse === "string") {
            controller.enqueue(
              isComplexMode ? textEncoder.encode(formatStreamPart("text", functionResponse)) : textEncoder.encode(functionResponse)
            );
            return;
          }
          const filteredCallbacks = {
            ...callbacks,
            onStart: void 0
          };
          callbacks.onFinal = void 0;
          const openAIStream = OpenAIStream(functionResponse, {
            ...filteredCallbacks,
            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages
          });
          const reader = openAIStream.getReader();
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              break;
            }
            controller.enqueue(value);
          }
        }
      } finally {
        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {
          await callbacks.onFinal(aggregatedFinalCompletionResponse);
        }
      }
    }
  });
}
var import_sanitize_url, textStreamPart, functionCallStreamPart, dataStreamPart, errorStreamPart, assistantMessageStreamPart, assistantControlDataStreamPart, dataMessageStreamPart, toolCallStreamPart, messageAnnotationsStreamPart, streamParts, streamPartsByCode, validCodes, parseStreamPart, COMPLEX_HEADER, __internal__OpenAIFnMessagesSymbol, StreamingTextResponse, OPENAI_API_KEY, openai, llmSummarize, prompt, POST;
var init_server_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/(api)/api/bookmarks/create/_server.ts.js"() {
    init_openai();
    init_non_secure();
    init_dist8();
    init_shared_server();
    init_chunks();
    import_sanitize_url = __toESM(require_dist(), 1);
    textStreamPart = {
      code: "0",
      name: "text",
      parse: (value) => {
        if (typeof value !== "string") {
          throw new Error('"text" parts expect a string value.');
        }
        return { type: "text", value };
      }
    };
    functionCallStreamPart = {
      code: "1",
      name: "function_call",
      parse: (value) => {
        if (value == null || typeof value !== "object" || !("function_call" in value) || typeof value.function_call !== "object" || value.function_call == null || !("name" in value.function_call) || !("arguments" in value.function_call) || typeof value.function_call.name !== "string" || typeof value.function_call.arguments !== "string") {
          throw new Error(
            '"function_call" parts expect an object with a "function_call" property.'
          );
        }
        return {
          type: "function_call",
          value
        };
      }
    };
    dataStreamPart = {
      code: "2",
      name: "data",
      parse: (value) => {
        if (!Array.isArray(value)) {
          throw new Error('"data" parts expect an array value.');
        }
        return { type: "data", value };
      }
    };
    errorStreamPart = {
      code: "3",
      name: "error",
      parse: (value) => {
        if (typeof value !== "string") {
          throw new Error('"error" parts expect a string value.');
        }
        return { type: "error", value };
      }
    };
    assistantMessageStreamPart = {
      code: "4",
      name: "assistant_message",
      parse: (value) => {
        if (value == null || typeof value !== "object" || !("id" in value) || !("role" in value) || !("content" in value) || typeof value.id !== "string" || typeof value.role !== "string" || value.role !== "assistant" || !Array.isArray(value.content) || !value.content.every(
          (item) => item != null && typeof item === "object" && "type" in item && item.type === "text" && "text" in item && item.text != null && typeof item.text === "object" && "value" in item.text && typeof item.text.value === "string"
        )) {
          throw new Error(
            '"assistant_message" parts expect an object with an "id", "role", and "content" property.'
          );
        }
        return {
          type: "assistant_message",
          value
        };
      }
    };
    assistantControlDataStreamPart = {
      code: "5",
      name: "assistant_control_data",
      parse: (value) => {
        if (value == null || typeof value !== "object" || !("threadId" in value) || !("messageId" in value) || typeof value.threadId !== "string" || typeof value.messageId !== "string") {
          throw new Error(
            '"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.'
          );
        }
        return {
          type: "assistant_control_data",
          value: {
            threadId: value.threadId,
            messageId: value.messageId
          }
        };
      }
    };
    dataMessageStreamPart = {
      code: "6",
      name: "data_message",
      parse: (value) => {
        if (value == null || typeof value !== "object" || !("role" in value) || !("data" in value) || typeof value.role !== "string" || value.role !== "data") {
          throw new Error(
            '"data_message" parts expect an object with a "role" and "data" property.'
          );
        }
        return {
          type: "data_message",
          value
        };
      }
    };
    toolCallStreamPart = {
      code: "7",
      name: "tool_calls",
      parse: (value) => {
        if (value == null || typeof value !== "object" || !("tool_calls" in value) || typeof value.tool_calls !== "object" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc) => {
          tc == null || typeof tc !== "object" || !("id" in tc) || typeof tc.id !== "string" || !("type" in tc) || typeof tc.type !== "string" || !("function" in tc) || tc.function == null || typeof tc.function !== "object" || !("arguments" in tc.function) || typeof tc.function.name !== "string" || typeof tc.function.arguments !== "string";
        })) {
          throw new Error(
            '"tool_calls" parts expect an object with a ToolCallPayload.'
          );
        }
        return {
          type: "tool_calls",
          value
        };
      }
    };
    messageAnnotationsStreamPart = {
      code: "8",
      name: "message_annotations",
      parse: (value) => {
        if (!Array.isArray(value)) {
          throw new Error('"message_annotations" parts expect an array value.');
        }
        return { type: "message_annotations", value };
      }
    };
    streamParts = [
      textStreamPart,
      functionCallStreamPart,
      dataStreamPart,
      errorStreamPart,
      assistantMessageStreamPart,
      assistantControlDataStreamPart,
      dataMessageStreamPart,
      toolCallStreamPart,
      messageAnnotationsStreamPart
    ];
    streamPartsByCode = {
      [textStreamPart.code]: textStreamPart,
      [functionCallStreamPart.code]: functionCallStreamPart,
      [dataStreamPart.code]: dataStreamPart,
      [errorStreamPart.code]: errorStreamPart,
      [assistantMessageStreamPart.code]: assistantMessageStreamPart,
      [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,
      [dataMessageStreamPart.code]: dataMessageStreamPart,
      [toolCallStreamPart.code]: toolCallStreamPart,
      [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart
    };
    ({
      [textStreamPart.name]: textStreamPart.code,
      [functionCallStreamPart.name]: functionCallStreamPart.code,
      [dataStreamPart.name]: dataStreamPart.code,
      [errorStreamPart.name]: errorStreamPart.code,
      [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,
      [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,
      [dataMessageStreamPart.name]: dataMessageStreamPart.code,
      [toolCallStreamPart.name]: toolCallStreamPart.code,
      [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code
    });
    validCodes = streamParts.map((part) => part.code);
    parseStreamPart = (line) => {
      const firstSeparatorIndex = line.indexOf(":");
      if (firstSeparatorIndex === -1) {
        throw new Error("Failed to parse stream string. No separator found.");
      }
      const prefix = line.slice(0, firstSeparatorIndex);
      if (!validCodes.includes(prefix)) {
        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);
      }
      const code = prefix;
      const textValue = line.slice(firstSeparatorIndex + 1);
      const jsonValue = JSON.parse(textValue);
      return streamPartsByCode[code].parse(jsonValue);
    };
    customAlphabet(
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      7
    );
    COMPLEX_HEADER = "X-Experimental-Stream-Data";
    new TextDecoder("utf-8");
    __internal__OpenAIFnMessagesSymbol = Symbol(
      "internal_openai_fn_messages"
    );
    StreamingTextResponse = class extends Response {
      constructor(res, init3, data) {
        let processedStream = res;
        if (data) {
          processedStream = res.pipeThrough(data.stream);
        }
        super(processedStream, {
          ...init3,
          status: 200,
          headers: {
            "Content-Type": "text/plain; charset=utf-8",
            [COMPLEX_HEADER]: data ? "true" : "false",
            ...init3 == null ? void 0 : init3.headers
          }
        });
      }
    };
    OPENAI_API_KEY = private_env.OPENAI_API_KEY;
    openai = new openai_default({ apiKey: OPENAI_API_KEY });
    llmSummarize = async (bookmark) => {
      const completion = await openai.chat.completions.create({
        messages: [
          { role: "system", content: prompt },
          { role: "user", content: bookmark }
        ],
        model: "gpt-4-0125-preview",
        stream: true
      });
      const stream = OpenAIStream(completion);
      return new StreamingTextResponse(stream);
    };
    prompt = `
    In Markdown in this format, follow the bulleted tasks

    ### Summary:
    - Give a simple two to three sentence description.
    ### Requirements or Instructions
    - Include any system or software requirements, or any sample code to demonstrate the use
    ### Details
    - Provide a more detailed explanation of the content as bullet points
    - Include up to a 3 paragraph summary.
    ### Other Links
    - Include a list of relevant links foud on the page with a reason why they were added
    - Exclude this section if there are no other links

    Tags:
    - Suggest hashtags in markdown format. Include specific and generic hashtags.

    Category:
    - A single category that this best fits under

    context:`;
    POST = async ({ request }) => {
      const article = await request.json();
      const stream = await llmSummarize(article.markdown);
      return stream;
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/(api)/api/bookmarks/get_url/_server.ts.js
var server_ts_exports2 = {};
__export(server_ts_exports2, {
  GET: () => GET
});
var import_sanitize_url2, GET;
var init_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/endpoints/(api)/api/bookmarks/get_url/_server.ts.js"() {
    init_chunks();
    import_sanitize_url2 = __toESM(require_dist(), 1);
    init_index2();
    GET = async ({ url, cookies }) => {
      let session;
      {
        try {
          session = await authVerify(cookies);
        } catch (e5) {
          return error(500, { error: e5.message });
        }
        if (!session) {
          return error(403, { error: "Not logged in" });
        }
      }
      const req_url = (0, import_sanitize_url2.sanitizeUrl)(url.searchParams.get("url"));
      if (/^https?:\/\//.test(req_url) === false) {
        return error(500, { error: "Invalid URL" });
      }
      return new Response(await fetch(req_url).then((res) => res.text()));
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/(api)/api/localAuth/auth/_server.ts.js
var server_ts_exports3 = {};
__export(server_ts_exports3, {
  GET: () => GET2
});
var GET2;
var init_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/endpoints/(api)/api/localAuth/auth/_server.ts.js"() {
    GET2 = async () => {
      return new Response();
    };
  }
});

// node_modules/cbor-x/dist/index-no-eval.cjs
var require_index_no_eval = __commonJS({
  "node_modules/cbor-x/dist/index-no-eval.cjs"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.CBOR = {}));
    })(exports, function(exports2) {
      "use strict";
      let decoder2;
      try {
        decoder2 = new TextDecoder();
      } catch (error2) {
      }
      let src;
      let srcEnd;
      let position$1 = 0;
      const LEGACY_RECORD_INLINE_ID = 105;
      const RECORD_DEFINITIONS_ID = 57342;
      const RECORD_INLINE_ID = 57343;
      const BUNDLED_STRINGS_ID = 57337;
      const PACKED_REFERENCE_TAG_ID = 6;
      const STOP_CODE = {};
      let currentDecoder = {};
      let currentStructures;
      let srcString;
      let srcStringStart = 0;
      let srcStringEnd = 0;
      let bundledStrings$1;
      let referenceMap;
      let currentExtensions = [];
      let currentExtensionRanges = [];
      let packedValues;
      let dataView;
      let restoreMapsAsObject;
      let defaultOptions4 = {
        useRecords: false,
        mapsAsObjects: true
      };
      let sequentialMode = false;
      let inlineObjectReadThreshold = 2;
      var BlockedFunction;
      try {
        new BlockedFunction("");
      } catch (error2) {
        inlineObjectReadThreshold = Infinity;
      }
      class Decoder {
        constructor(options3) {
          if (options3) {
            if ((options3.keyMap || options3._keyMap) && !options3.useRecords) {
              options3.useRecords = false;
              options3.mapsAsObjects = true;
            }
            if (options3.useRecords === false && options3.mapsAsObjects === void 0)
              options3.mapsAsObjects = true;
            if (options3.getStructures)
              options3.getShared = options3.getStructures;
            if (options3.getShared && !options3.structures)
              (options3.structures = []).uninitialized = true;
            if (options3.keyMap) {
              this.mapKey = /* @__PURE__ */ new Map();
              for (let [k4, v5] of Object.entries(options3.keyMap))
                this.mapKey.set(v5, k4);
            }
          }
          Object.assign(this, options3);
        }
        /*
        decodeKey(key) {
        	return this.keyMap
        		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
        		: key
        }
        */
        decodeKey(key3) {
          return this.keyMap ? this.mapKey.get(key3) || key3 : key3;
        }
        encodeKey(key3) {
          return this.keyMap && this.keyMap.hasOwnProperty(key3) ? this.keyMap[key3] : key3;
        }
        encodeKeys(rec) {
          if (!this._keyMap)
            return rec;
          let map = /* @__PURE__ */ new Map();
          for (let [k4, v5] of Object.entries(rec))
            map.set(this._keyMap.hasOwnProperty(k4) ? this._keyMap[k4] : k4, v5);
          return map;
        }
        decodeKeys(map) {
          if (!this._keyMap || map.constructor.name != "Map")
            return map;
          if (!this._mapKey) {
            this._mapKey = /* @__PURE__ */ new Map();
            for (let [k4, v5] of Object.entries(this._keyMap))
              this._mapKey.set(v5, k4);
          }
          let res = {};
          map.forEach((v5, k4) => res[safeKey(this._mapKey.has(k4) ? this._mapKey.get(k4) : k4)] = v5);
          return res;
        }
        mapDecode(source2, end) {
          let res = this.decode(source2);
          if (this._keyMap) {
            switch (res.constructor.name) {
              case "Array":
                return res.map((r8) => this.decodeKeys(r8));
            }
          }
          return res;
        }
        decode(source2, end) {
          if (src) {
            return saveState(() => {
              clearSource();
              return this ? this.decode(source2, end) : Decoder.prototype.decode.call(defaultOptions4, source2, end);
            });
          }
          srcEnd = end > -1 ? end : source2.length;
          position$1 = 0;
          srcStringEnd = 0;
          srcString = null;
          bundledStrings$1 = null;
          src = source2;
          try {
            dataView = source2.dataView || (source2.dataView = new DataView(source2.buffer, source2.byteOffset, source2.byteLength));
          } catch (error2) {
            src = null;
            if (source2 instanceof Uint8Array)
              throw error2;
            throw new Error("Source must be a Uint8Array or Buffer but was a " + (source2 && typeof source2 == "object" ? source2.constructor.name : typeof source2));
          }
          if (this instanceof Decoder) {
            currentDecoder = this;
            packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
            if (this.structures) {
              currentStructures = this.structures;
              return checkedRead();
            } else if (!currentStructures || currentStructures.length > 0) {
              currentStructures = [];
            }
          } else {
            currentDecoder = defaultOptions4;
            if (!currentStructures || currentStructures.length > 0)
              currentStructures = [];
            packedValues = null;
          }
          return checkedRead();
        }
        decodeMultiple(source2, forEach) {
          let values, lastPosition = 0;
          try {
            let size = source2.length;
            sequentialMode = true;
            let value = this ? this.decode(source2, size) : defaultDecoder.decode(source2, size);
            if (forEach) {
              if (forEach(value) === false) {
                return;
              }
              while (position$1 < size) {
                lastPosition = position$1;
                if (forEach(checkedRead()) === false) {
                  return;
                }
              }
            } else {
              values = [value];
              while (position$1 < size) {
                lastPosition = position$1;
                values.push(checkedRead());
              }
              return values;
            }
          } catch (error2) {
            error2.lastPosition = lastPosition;
            error2.values = values;
            throw error2;
          } finally {
            sequentialMode = false;
            clearSource();
          }
        }
      }
      function checkedRead() {
        try {
          let result = read2();
          if (bundledStrings$1) {
            if (position$1 >= bundledStrings$1.postBundlePosition) {
              let error2 = new Error("Unexpected bundle position");
              error2.incomplete = true;
              throw error2;
            }
            position$1 = bundledStrings$1.postBundlePosition;
            bundledStrings$1 = null;
          }
          if (position$1 == srcEnd) {
            currentStructures = null;
            src = null;
            if (referenceMap)
              referenceMap = null;
          } else if (position$1 > srcEnd) {
            let error2 = new Error("Unexpected end of CBOR data");
            error2.incomplete = true;
            throw error2;
          } else if (!sequentialMode) {
            throw new Error("Data read, but end of buffer not reached");
          }
          return result;
        } catch (error2) {
          clearSource();
          if (error2 instanceof RangeError || error2.message.startsWith("Unexpected end of buffer")) {
            error2.incomplete = true;
          }
          throw error2;
        }
      }
      function read2() {
        let token = src[position$1++];
        let majorType = token >> 5;
        token = token & 31;
        if (token > 23) {
          switch (token) {
            case 24:
              token = src[position$1++];
              break;
            case 25:
              if (majorType == 7) {
                return getFloat16();
              }
              token = dataView.getUint16(position$1);
              position$1 += 2;
              break;
            case 26:
              if (majorType == 7) {
                let value = dataView.getFloat32(position$1);
                if (currentDecoder.useFloat32 > 2) {
                  let multiplier = mult10[(src[position$1] & 127) << 1 | src[position$1 + 1] >> 7];
                  position$1 += 4;
                  return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
                }
                position$1 += 4;
                return value;
              }
              token = dataView.getUint32(position$1);
              position$1 += 4;
              break;
            case 27:
              if (majorType == 7) {
                let value = dataView.getFloat64(position$1);
                position$1 += 8;
                return value;
              }
              if (majorType > 1) {
                if (dataView.getUint32(position$1) > 0)
                  throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
                token = dataView.getUint32(position$1 + 4);
              } else if (currentDecoder.int64AsNumber) {
                token = dataView.getUint32(position$1) * 4294967296;
                token += dataView.getUint32(position$1 + 4);
              } else
                token = dataView.getBigUint64(position$1);
              position$1 += 8;
              break;
            case 31:
              switch (majorType) {
                case 2:
                case 3:
                  throw new Error("Indefinite length not supported for byte or text strings");
                case 4:
                  let array2 = [];
                  let value, i9 = 0;
                  while ((value = read2()) != STOP_CODE) {
                    array2[i9++] = value;
                  }
                  return majorType == 4 ? array2 : majorType == 3 ? array2.join("") : Buffer.concat(array2);
                case 5:
                  let key3;
                  if (currentDecoder.mapsAsObjects) {
                    let object = {};
                    if (currentDecoder.keyMap)
                      while ((key3 = read2()) != STOP_CODE)
                        object[safeKey(currentDecoder.decodeKey(key3))] = read2();
                    else
                      while ((key3 = read2()) != STOP_CODE)
                        object[safeKey(key3)] = read2();
                    return object;
                  } else {
                    if (restoreMapsAsObject) {
                      currentDecoder.mapsAsObjects = true;
                      restoreMapsAsObject = false;
                    }
                    let map = /* @__PURE__ */ new Map();
                    if (currentDecoder.keyMap)
                      while ((key3 = read2()) != STOP_CODE)
                        map.set(currentDecoder.decodeKey(key3), read2());
                    else
                      while ((key3 = read2()) != STOP_CODE)
                        map.set(key3, read2());
                    return map;
                  }
                case 7:
                  return STOP_CODE;
                default:
                  throw new Error("Invalid major type for indefinite length " + majorType);
              }
            default:
              throw new Error("Unknown token " + token);
          }
        }
        switch (majorType) {
          case 0:
            return token;
          case 1:
            return ~token;
          case 2:
            return readBin(token);
          case 3:
            if (srcStringEnd >= position$1) {
              return srcString.slice(position$1 - srcStringStart, (position$1 += token) - srcStringStart);
            }
            if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
              let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
              if (string != null)
                return string;
            }
            return readFixedString(token);
          case 4:
            let array2 = new Array(token);
            for (let i9 = 0; i9 < token; i9++)
              array2[i9] = read2();
            return array2;
          case 5:
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap)
                for (let i9 = 0; i9 < token; i9++)
                  object[safeKey(currentDecoder.decodeKey(read2()))] = read2();
              else
                for (let i9 = 0; i9 < token; i9++)
                  object[safeKey(read2())] = read2();
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap)
                for (let i9 = 0; i9 < token; i9++)
                  map.set(currentDecoder.decodeKey(read2()), read2());
              else
                for (let i9 = 0; i9 < token; i9++)
                  map.set(read2(), read2());
              return map;
            }
          case 6:
            if (token >= BUNDLED_STRINGS_ID) {
              let structure = currentStructures[token & 8191];
              if (structure) {
                if (!structure.read)
                  structure.read = createStructureReader(structure);
                return structure.read();
              }
              if (token < 65536) {
                if (token == RECORD_INLINE_ID) {
                  let length = readJustLength();
                  let id = read2();
                  let structure2 = read2();
                  recordDefinition(id, structure2);
                  let object = {};
                  if (currentDecoder.keyMap)
                    for (let i9 = 2; i9 < length; i9++) {
                      let key3 = currentDecoder.decodeKey(structure2[i9 - 2]);
                      object[safeKey(key3)] = read2();
                    }
                  else
                    for (let i9 = 2; i9 < length; i9++) {
                      let key3 = structure2[i9 - 2];
                      object[safeKey(key3)] = read2();
                    }
                  return object;
                } else if (token == RECORD_DEFINITIONS_ID) {
                  let length = readJustLength();
                  let id = read2();
                  for (let i9 = 2; i9 < length; i9++) {
                    recordDefinition(id++, read2());
                  }
                  return read2();
                } else if (token == BUNDLED_STRINGS_ID) {
                  return readBundleExt();
                }
                if (currentDecoder.getShared) {
                  loadShared();
                  structure = currentStructures[token & 8191];
                  if (structure) {
                    if (!structure.read)
                      structure.read = createStructureReader(structure);
                    return structure.read();
                  }
                }
              }
            }
            let extension = currentExtensions[token];
            if (extension) {
              if (extension.handlesRead)
                return extension(read2);
              else
                return extension(read2());
            } else {
              let input = read2();
              for (let i9 = 0; i9 < currentExtensionRanges.length; i9++) {
                let value = currentExtensionRanges[i9](token, input);
                if (value !== void 0)
                  return value;
              }
              return new Tag(input, token);
            }
          case 7:
            switch (token) {
              case 20:
                return false;
              case 21:
                return true;
              case 22:
                return null;
              case 23:
                return;
              case 31:
              default:
                let packedValue = (packedValues || getPackedValues())[token];
                if (packedValue !== void 0)
                  return packedValue;
                throw new Error("Unknown token " + token);
            }
          default:
            if (isNaN(token)) {
              let error2 = new Error("Unexpected end of CBOR data");
              error2.incomplete = true;
              throw error2;
            }
            throw new Error("Unknown CBOR token " + token);
        }
      }
      const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
      function createStructureReader(structure) {
        function readObject() {
          let length = src[position$1++];
          length = length & 31;
          if (length > 23) {
            switch (length) {
              case 24:
                length = src[position$1++];
                break;
              case 25:
                length = dataView.getUint16(position$1);
                position$1 += 2;
                break;
              case 26:
                length = dataView.getUint32(position$1);
                position$1 += 4;
                break;
              default:
                throw new Error("Expected array header, but got " + src[position$1 - 1]);
            }
          }
          let compiledReader = this.compiledReader;
          while (compiledReader) {
            if (compiledReader.propertyCount === length)
              return compiledReader(read2);
            compiledReader = compiledReader.next;
          }
          if (this.slowReads++ >= inlineObjectReadThreshold) {
            let array2 = this.length == length ? this : this.slice(0, length);
            compiledReader = currentDecoder.keyMap ? new BlockedFunction("r", "return {" + array2.map((k4) => currentDecoder.decodeKey(k4)).map((k4) => validName.test(k4) ? safeKey(k4) + ":r()" : "[" + JSON.stringify(k4) + "]:r()").join(",") + "}") : new BlockedFunction("r", "return {" + array2.map((key3) => validName.test(key3) ? safeKey(key3) + ":r()" : "[" + JSON.stringify(key3) + "]:r()").join(",") + "}");
            if (this.compiledReader)
              compiledReader.next = this.compiledReader;
            compiledReader.propertyCount = length;
            this.compiledReader = compiledReader;
            return compiledReader(read2);
          }
          let object = {};
          if (currentDecoder.keyMap)
            for (let i9 = 0; i9 < length; i9++)
              object[safeKey(currentDecoder.decodeKey(this[i9]))] = read2();
          else
            for (let i9 = 0; i9 < length; i9++) {
              object[safeKey(this[i9])] = read2();
            }
          return object;
        }
        structure.slowReads = 0;
        return readObject;
      }
      function safeKey(key3) {
        if (typeof key3 === "string")
          return key3 === "__proto__" ? "__proto_" : key3;
        if (typeof key3 !== "object")
          return key3.toString();
        throw new Error("Invalid property name type " + typeof key3);
      }
      let readFixedString = readStringJS;
      let isNativeAccelerationEnabled = false;
      function readStringJS(length) {
        let result;
        if (length < 16) {
          if (result = shortStringInJS(length))
            return result;
        }
        if (length > 64 && decoder2)
          return decoder2.decode(src.subarray(position$1, position$1 += length));
        const end = position$1 + length;
        const units = [];
        result = "";
        while (position$1 < end) {
          const byte1 = src[position$1++];
          if ((byte1 & 128) === 0) {
            units.push(byte1);
          } else if ((byte1 & 224) === 192) {
            const byte2 = src[position$1++] & 63;
            units.push((byte1 & 31) << 6 | byte2);
          } else if ((byte1 & 240) === 224) {
            const byte2 = src[position$1++] & 63;
            const byte3 = src[position$1++] & 63;
            units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
          } else if ((byte1 & 248) === 240) {
            const byte2 = src[position$1++] & 63;
            const byte3 = src[position$1++] & 63;
            const byte4 = src[position$1++] & 63;
            let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
            if (unit > 65535) {
              unit -= 65536;
              units.push(unit >>> 10 & 1023 | 55296);
              unit = 56320 | unit & 1023;
            }
            units.push(unit);
          } else {
            units.push(byte1);
          }
          if (units.length >= 4096) {
            result += fromCharCode.apply(String, units);
            units.length = 0;
          }
        }
        if (units.length > 0) {
          result += fromCharCode.apply(String, units);
        }
        return result;
      }
      let fromCharCode = String.fromCharCode;
      function longStringInJS(length) {
        let start = position$1;
        let bytes = new Array(length);
        for (let i9 = 0; i9 < length; i9++) {
          const byte = src[position$1++];
          if ((byte & 128) > 0) {
            position$1 = start;
            return;
          }
          bytes[i9] = byte;
        }
        return fromCharCode.apply(String, bytes);
      }
      function shortStringInJS(length) {
        if (length < 4) {
          if (length < 2) {
            if (length === 0)
              return "";
            else {
              let a7 = src[position$1++];
              if ((a7 & 128) > 1) {
                position$1 -= 1;
                return;
              }
              return fromCharCode(a7);
            }
          } else {
            let a7 = src[position$1++];
            let b5 = src[position$1++];
            if ((a7 & 128) > 0 || (b5 & 128) > 0) {
              position$1 -= 2;
              return;
            }
            if (length < 3)
              return fromCharCode(a7, b5);
            let c8 = src[position$1++];
            if ((c8 & 128) > 0) {
              position$1 -= 3;
              return;
            }
            return fromCharCode(a7, b5, c8);
          }
        } else {
          let a7 = src[position$1++];
          let b5 = src[position$1++];
          let c8 = src[position$1++];
          let d6 = src[position$1++];
          if ((a7 & 128) > 0 || (b5 & 128) > 0 || (c8 & 128) > 0 || (d6 & 128) > 0) {
            position$1 -= 4;
            return;
          }
          if (length < 6) {
            if (length === 4)
              return fromCharCode(a7, b5, c8, d6);
            else {
              let e5 = src[position$1++];
              if ((e5 & 128) > 0) {
                position$1 -= 5;
                return;
              }
              return fromCharCode(a7, b5, c8, d6, e5);
            }
          } else if (length < 8) {
            let e5 = src[position$1++];
            let f5 = src[position$1++];
            if ((e5 & 128) > 0 || (f5 & 128) > 0) {
              position$1 -= 6;
              return;
            }
            if (length < 7)
              return fromCharCode(a7, b5, c8, d6, e5, f5);
            let g7 = src[position$1++];
            if ((g7 & 128) > 0) {
              position$1 -= 7;
              return;
            }
            return fromCharCode(a7, b5, c8, d6, e5, f5, g7);
          } else {
            let e5 = src[position$1++];
            let f5 = src[position$1++];
            let g7 = src[position$1++];
            let h6 = src[position$1++];
            if ((e5 & 128) > 0 || (f5 & 128) > 0 || (g7 & 128) > 0 || (h6 & 128) > 0) {
              position$1 -= 8;
              return;
            }
            if (length < 10) {
              if (length === 8)
                return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6);
              else {
                let i9 = src[position$1++];
                if ((i9 & 128) > 0) {
                  position$1 -= 9;
                  return;
                }
                return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6, i9);
              }
            } else if (length < 12) {
              let i9 = src[position$1++];
              let j4 = src[position$1++];
              if ((i9 & 128) > 0 || (j4 & 128) > 0) {
                position$1 -= 10;
                return;
              }
              if (length < 11)
                return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6, i9, j4);
              let k4 = src[position$1++];
              if ((k4 & 128) > 0) {
                position$1 -= 11;
                return;
              }
              return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6, i9, j4, k4);
            } else {
              let i9 = src[position$1++];
              let j4 = src[position$1++];
              let k4 = src[position$1++];
              let l7 = src[position$1++];
              if ((i9 & 128) > 0 || (j4 & 128) > 0 || (k4 & 128) > 0 || (l7 & 128) > 0) {
                position$1 -= 12;
                return;
              }
              if (length < 14) {
                if (length === 12)
                  return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6, i9, j4, k4, l7);
                else {
                  let m5 = src[position$1++];
                  if ((m5 & 128) > 0) {
                    position$1 -= 13;
                    return;
                  }
                  return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6, i9, j4, k4, l7, m5);
                }
              } else {
                let m5 = src[position$1++];
                let n7 = src[position$1++];
                if ((m5 & 128) > 0 || (n7 & 128) > 0) {
                  position$1 -= 14;
                  return;
                }
                if (length < 15)
                  return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6, i9, j4, k4, l7, m5, n7);
                let o7 = src[position$1++];
                if ((o7 & 128) > 0) {
                  position$1 -= 15;
                  return;
                }
                return fromCharCode(a7, b5, c8, d6, e5, f5, g7, h6, i9, j4, k4, l7, m5, n7, o7);
              }
            }
          }
        }
      }
      function readBin(length) {
        return currentDecoder.copyBuffers ? (
          // specifically use the copying slice (not the node one)
          Uint8Array.prototype.slice.call(src, position$1, position$1 += length)
        ) : src.subarray(position$1, position$1 += length);
      }
      let f32Array = new Float32Array(1);
      let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
      function getFloat16() {
        let byte0 = src[position$1++];
        let byte1 = src[position$1++];
        let exponent = (byte0 & 127) >> 2;
        if (exponent === 31) {
          if (byte1 || byte0 & 3)
            return NaN;
          return byte0 & 128 ? -Infinity : Infinity;
        }
        if (exponent === 0) {
          let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
          return byte0 & 128 ? -abs : abs;
        }
        u8Array[3] = byte0 & 128 | // sign bit
        (exponent >> 1) + 56;
        u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
        byte1 >> 3;
        u8Array[1] = byte1 << 5;
        u8Array[0] = 0;
        return f32Array[0];
      }
      new Array(4096);
      class Tag {
        constructor(value, tag) {
          this.value = value;
          this.tag = tag;
        }
      }
      currentExtensions[0] = (dateString) => {
        return new Date(dateString);
      };
      currentExtensions[1] = (epochSec) => {
        return new Date(Math.round(epochSec * 1e3));
      };
      currentExtensions[2] = (buffer) => {
        let value = BigInt(0);
        for (let i9 = 0, l7 = buffer.byteLength; i9 < l7; i9++) {
          value = BigInt(buffer[i9]) + value << BigInt(8);
        }
        return value;
      };
      currentExtensions[3] = (buffer) => {
        return BigInt(-1) - currentExtensions[2](buffer);
      };
      currentExtensions[4] = (fraction) => {
        return +(fraction[1] + "e" + fraction[0]);
      };
      currentExtensions[5] = (fraction) => {
        return fraction[1] * Math.exp(fraction[0] * Math.log(2));
      };
      const recordDefinition = (id, structure) => {
        id = id - 57344;
        let existingStructure = currentStructures[id];
        if (existingStructure && existingStructure.isShared) {
          (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
        }
        currentStructures[id] = structure;
        structure.read = createStructureReader(structure);
      };
      currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
        let length = data.length;
        let structure = data[1];
        recordDefinition(data[0], structure);
        let object = {};
        for (let i9 = 2; i9 < length; i9++) {
          let key3 = structure[i9 - 2];
          object[safeKey(key3)] = data[i9];
        }
        return object;
      };
      currentExtensions[14] = (value) => {
        if (bundledStrings$1)
          return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 += value);
        return new Tag(value, 14);
      };
      currentExtensions[15] = (value) => {
        if (bundledStrings$1)
          return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value);
        return new Tag(value, 15);
      };
      let glbl = { Error, RegExp };
      currentExtensions[27] = (data) => {
        return (glbl[data[0]] || Error)(data[1], data[2]);
      };
      const packedTable = (read3) => {
        if (src[position$1++] != 132) {
          let error2 = new Error("Packed values structure must be followed by a 4 element array");
          if (src.length < position$1)
            error2.incomplete = true;
          throw error2;
        }
        let newPackedValues = read3();
        if (!newPackedValues || !newPackedValues.length) {
          let error2 = new Error("Packed values structure must be followed by a 4 element array");
          error2.incomplete = true;
          throw error2;
        }
        packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
        packedValues.prefixes = read3();
        packedValues.suffixes = read3();
        return read3();
      };
      packedTable.handlesRead = true;
      currentExtensions[51] = packedTable;
      currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
        if (!packedValues) {
          if (currentDecoder.getShared)
            loadShared();
          else
            return new Tag(data, PACKED_REFERENCE_TAG_ID);
        }
        if (typeof data == "number")
          return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
        let error2 = new Error("No support for non-integer packed references yet");
        if (data === void 0)
          error2.incomplete = true;
        throw error2;
      };
      currentExtensions[28] = (read3) => {
        if (!referenceMap) {
          referenceMap = /* @__PURE__ */ new Map();
          referenceMap.id = 0;
        }
        let id = referenceMap.id++;
        let token = src[position$1];
        let target2;
        if (token >> 5 == 4)
          target2 = [];
        else
          target2 = {};
        let refEntry = { target: target2 };
        referenceMap.set(id, refEntry);
        let targetProperties = read3();
        if (refEntry.used)
          return Object.assign(target2, targetProperties);
        refEntry.target = targetProperties;
        return targetProperties;
      };
      currentExtensions[28].handlesRead = true;
      currentExtensions[29] = (id) => {
        let refEntry = referenceMap.get(id);
        refEntry.used = true;
        return refEntry.target;
      };
      currentExtensions[258] = (array2) => new Set(array2);
      (currentExtensions[259] = (read3) => {
        if (currentDecoder.mapsAsObjects) {
          currentDecoder.mapsAsObjects = false;
          restoreMapsAsObject = true;
        }
        return read3();
      }).handlesRead = true;
      function combine(a7, b5) {
        if (typeof a7 === "string")
          return a7 + b5;
        if (a7 instanceof Array)
          return a7.concat(b5);
        return Object.assign({}, a7, b5);
      }
      function getPackedValues() {
        if (!packedValues) {
          if (currentDecoder.getShared)
            loadShared();
          else
            throw new Error("No packed values available");
        }
        return packedValues;
      }
      const SHARED_DATA_TAG_ID = 1399353956;
      currentExtensionRanges.push((tag, input) => {
        if (tag >= 225 && tag <= 255)
          return combine(getPackedValues().prefixes[tag - 224], input);
        if (tag >= 28704 && tag <= 32767)
          return combine(getPackedValues().prefixes[tag - 28672], input);
        if (tag >= 1879052288 && tag <= 2147483647)
          return combine(getPackedValues().prefixes[tag - 1879048192], input);
        if (tag >= 216 && tag <= 223)
          return combine(input, getPackedValues().suffixes[tag - 216]);
        if (tag >= 27647 && tag <= 28671)
          return combine(input, getPackedValues().suffixes[tag - 27639]);
        if (tag >= 1811940352 && tag <= 1879048191)
          return combine(input, getPackedValues().suffixes[tag - 1811939328]);
        if (tag == SHARED_DATA_TAG_ID) {
          return {
            packedValues,
            structures: currentStructures.slice(0),
            version: input
          };
        }
        if (tag == 55799)
          return input;
      });
      const isLittleEndianMachine$1 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
      const typedArrays = [
        Uint8Array,
        Uint8ClampedArray,
        Uint16Array,
        Uint32Array,
        typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
        Int8Array,
        Int16Array,
        Int32Array,
        typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
        Float32Array,
        Float64Array
      ];
      const typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
      for (let i9 = 0; i9 < typedArrays.length; i9++) {
        registerTypedArray(typedArrays[i9], typedArrayTags[i9]);
      }
      function registerTypedArray(TypedArray, tag) {
        let dvMethod = "get" + TypedArray.name.slice(0, -5);
        let bytesPerElement;
        if (typeof TypedArray === "function")
          bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
        else
          TypedArray = null;
        for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
          if (!littleEndian && bytesPerElement == 1)
            continue;
          let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
          currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine$1 ? (buffer) => {
            if (!TypedArray)
              throw new Error("Could not find typed array for code " + tag);
            if (!currentDecoder.copyBuffers) {
              if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer.byteOffset & 1) || bytesPerElement === 4 && !(buffer.byteOffset & 3) || bytesPerElement === 8 && !(buffer.byteOffset & 7))
                return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            }
            return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
          } : (buffer) => {
            if (!TypedArray)
              throw new Error("Could not find typed array for code " + tag);
            let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            let elements = buffer.length >> sizeShift;
            let ta = new TypedArray(elements);
            let method = dv[dvMethod];
            for (let i9 = 0; i9 < elements; i9++) {
              ta[i9] = method.call(dv, i9 << sizeShift, littleEndian);
            }
            return ta;
          };
        }
      }
      function readBundleExt() {
        let length = readJustLength();
        let bundlePosition = position$1 + read2();
        for (let i9 = 2; i9 < length; i9++) {
          let bundleLength = readJustLength();
          position$1 += bundleLength;
        }
        let dataPosition = position$1;
        position$1 = bundlePosition;
        bundledStrings$1 = [readStringJS(readJustLength()), readStringJS(readJustLength())];
        bundledStrings$1.position0 = 0;
        bundledStrings$1.position1 = 0;
        bundledStrings$1.postBundlePosition = position$1;
        position$1 = dataPosition;
        return read2();
      }
      function readJustLength() {
        let token = src[position$1++] & 31;
        if (token > 23) {
          switch (token) {
            case 24:
              token = src[position$1++];
              break;
            case 25:
              token = dataView.getUint16(position$1);
              position$1 += 2;
              break;
            case 26:
              token = dataView.getUint32(position$1);
              position$1 += 4;
              break;
          }
        }
        return token;
      }
      function loadShared() {
        if (currentDecoder.getShared) {
          let sharedData = saveState(() => {
            src = null;
            return currentDecoder.getShared();
          }) || {};
          let updatedStructures = sharedData.structures || [];
          currentDecoder.sharedVersion = sharedData.version;
          packedValues = currentDecoder.sharedValues = sharedData.packedValues;
          if (currentStructures === true)
            currentDecoder.structures = currentStructures = updatedStructures;
          else
            currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
        }
      }
      function saveState(callback) {
        let savedSrcEnd = srcEnd;
        let savedPosition = position$1;
        let savedSrcStringStart = srcStringStart;
        let savedSrcStringEnd = srcStringEnd;
        let savedSrcString = srcString;
        let savedReferenceMap = referenceMap;
        let savedBundledStrings = bundledStrings$1;
        let savedSrc = new Uint8Array(src.slice(0, srcEnd));
        let savedStructures = currentStructures;
        let savedDecoder = currentDecoder;
        let savedSequentialMode = sequentialMode;
        let value = callback();
        srcEnd = savedSrcEnd;
        position$1 = savedPosition;
        srcStringStart = savedSrcStringStart;
        srcStringEnd = savedSrcStringEnd;
        srcString = savedSrcString;
        referenceMap = savedReferenceMap;
        bundledStrings$1 = savedBundledStrings;
        src = savedSrc;
        sequentialMode = savedSequentialMode;
        currentStructures = savedStructures;
        currentDecoder = savedDecoder;
        dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
        return value;
      }
      function clearSource() {
        src = null;
        referenceMap = null;
        currentStructures = null;
      }
      function addExtension$1(extension) {
        currentExtensions[extension.tag] = extension.decode;
      }
      const mult10 = new Array(147);
      for (let i9 = 0; i9 < 256; i9++) {
        mult10[i9] = +("1e" + Math.floor(45.15 - i9 * 0.30103));
      }
      let defaultDecoder = new Decoder({ useRecords: false });
      const decode3 = defaultDecoder.decode;
      const decodeMultiple = defaultDecoder.decodeMultiple;
      const FLOAT32_OPTIONS = {
        NEVER: 0,
        ALWAYS: 1,
        DECIMAL_ROUND: 3,
        DECIMAL_FIT: 4
      };
      function roundFloat32(float32Number) {
        f32Array[0] = float32Number;
        let multiplier = mult10[(u8Array[3] & 127) << 1 | u8Array[2] >> 7];
        return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
      }
      let textEncoder;
      try {
        textEncoder = new TextEncoder();
      } catch (error2) {
      }
      let extensions, extensionClasses;
      const Buffer$1 = typeof globalThis === "object" && globalThis.Buffer;
      const hasNodeBuffer = typeof Buffer$1 !== "undefined";
      const ByteArrayAllocate = hasNodeBuffer ? Buffer$1.allocUnsafeSlow : Uint8Array;
      const ByteArray = hasNodeBuffer ? Buffer$1 : Uint8Array;
      const MAX_STRUCTURES = 256;
      const MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
      let throwOnIterable;
      let target;
      let targetView;
      let position = 0;
      let safeEnd;
      let bundledStrings = null;
      const MAX_BUNDLE_SIZE = 61440;
      const hasNonLatin = /[\u0080-\uFFFF]/;
      const RECORD_SYMBOL = Symbol("record-id");
      class Encoder extends Decoder {
        constructor(options3) {
          super(options3);
          this.offset = 0;
          let start;
          let sharedStructures;
          let hasSharedUpdate;
          let structures;
          let referenceMap2;
          options3 = options3 || {};
          let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position2, maxBytes) {
            return target.utf8Write(string, position2, maxBytes);
          } : textEncoder && textEncoder.encodeInto ? function(string, position2) {
            return textEncoder.encodeInto(string, target.subarray(position2)).written;
          } : false;
          let encoder5 = this;
          let hasSharedStructures = options3.structures || options3.saveStructures;
          let maxSharedStructures = options3.maxSharedStructures;
          if (maxSharedStructures == null)
            maxSharedStructures = hasSharedStructures ? 128 : 0;
          if (maxSharedStructures > 8190)
            throw new Error("Maximum maxSharedStructure is 8190");
          let isSequential = options3.sequential;
          if (isSequential) {
            maxSharedStructures = 0;
          }
          if (!this.structures)
            this.structures = [];
          if (this.saveStructures)
            this.saveShared = this.saveStructures;
          let samplingPackedValues, packedObjectMap2, sharedValues = options3.sharedValues;
          let sharedPackedObjectMap2;
          if (sharedValues) {
            sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
            for (let i9 = 0, l7 = sharedValues.length; i9 < l7; i9++) {
              sharedPackedObjectMap2[sharedValues[i9]] = i9;
            }
          }
          let recordIdsToRemove = [];
          let transitionsCount = 0;
          let serializationsSinceTransitionRebuild = 0;
          this.mapEncode = function(value, encodeOptions) {
            if (this._keyMap && !this._mapped) {
              switch (value.constructor.name) {
                case "Array":
                  value = value.map((r8) => this.encodeKeys(r8));
                  break;
              }
            }
            return this.encode(value, encodeOptions);
          };
          this.encode = function(value, encodeOptions) {
            if (!target) {
              target = new ByteArrayAllocate(8192);
              targetView = new DataView(target.buffer, 0, 8192);
              position = 0;
            }
            safeEnd = target.length - 10;
            if (safeEnd - position < 2048) {
              target = new ByteArrayAllocate(target.length);
              targetView = new DataView(target.buffer, 0, target.length);
              safeEnd = target.length - 10;
              position = 0;
            } else if (encodeOptions === REUSE_BUFFER_MODE)
              position = position + 7 & 2147483640;
            start = position;
            if (encoder5.useSelfDescribedHeader) {
              targetView.setUint32(position, 3654940416);
              position += 3;
            }
            referenceMap2 = encoder5.structuredClone ? /* @__PURE__ */ new Map() : null;
            if (encoder5.bundleStrings && typeof value !== "string") {
              bundledStrings = [];
              bundledStrings.size = Infinity;
            } else
              bundledStrings = null;
            sharedStructures = encoder5.structures;
            if (sharedStructures) {
              if (sharedStructures.uninitialized) {
                let sharedData = encoder5.getShared() || {};
                encoder5.structures = sharedStructures = sharedData.structures || [];
                encoder5.sharedVersion = sharedData.version;
                let sharedValues2 = encoder5.sharedValues = sharedData.packedValues;
                if (sharedValues2) {
                  sharedPackedObjectMap2 = {};
                  for (let i9 = 0, l7 = sharedValues2.length; i9 < l7; i9++)
                    sharedPackedObjectMap2[sharedValues2[i9]] = i9;
                }
              }
              let sharedStructuresLength = sharedStructures.length;
              if (sharedStructuresLength > maxSharedStructures && !isSequential)
                sharedStructuresLength = maxSharedStructures;
              if (!sharedStructures.transitions) {
                sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
                for (let i9 = 0; i9 < sharedStructuresLength; i9++) {
                  let keys = sharedStructures[i9];
                  if (!keys)
                    continue;
                  let nextTransition, transition = sharedStructures.transitions;
                  for (let j4 = 0, l7 = keys.length; j4 < l7; j4++) {
                    if (transition[RECORD_SYMBOL] === void 0)
                      transition[RECORD_SYMBOL] = i9;
                    let key3 = keys[j4];
                    nextTransition = transition[key3];
                    if (!nextTransition) {
                      nextTransition = transition[key3] = /* @__PURE__ */ Object.create(null);
                    }
                    transition = nextTransition;
                  }
                  transition[RECORD_SYMBOL] = i9 | 1048576;
                }
              }
              if (!isSequential)
                sharedStructures.nextId = sharedStructuresLength;
            }
            if (hasSharedUpdate)
              hasSharedUpdate = false;
            structures = sharedStructures || [];
            packedObjectMap2 = sharedPackedObjectMap2;
            if (options3.pack) {
              let packedValues2 = /* @__PURE__ */ new Map();
              packedValues2.values = [];
              packedValues2.encoder = encoder5;
              packedValues2.maxValues = options3.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
              packedValues2.objectMap = sharedPackedObjectMap2 || false;
              packedValues2.samplingPackedValues = samplingPackedValues;
              findRepetitiveStrings(value, packedValues2);
              if (packedValues2.values.length > 0) {
                target[position++] = 216;
                target[position++] = 51;
                writeArrayHeader(4);
                let valuesArray = packedValues2.values;
                encode5(valuesArray);
                writeArrayHeader(0);
                writeArrayHeader(0);
                packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
                for (let i9 = 0, l7 = valuesArray.length; i9 < l7; i9++) {
                  packedObjectMap2[valuesArray[i9]] = i9;
                }
              }
            }
            throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
            try {
              if (throwOnIterable)
                return;
              encode5(value);
              if (bundledStrings) {
                writeBundles(start, encode5);
              }
              encoder5.offset = position;
              if (referenceMap2 && referenceMap2.idsToInsert) {
                position += referenceMap2.idsToInsert.length * 2;
                if (position > safeEnd)
                  makeRoom(position);
                encoder5.offset = position;
                let serialized = insertIds(target.subarray(start, position), referenceMap2.idsToInsert);
                referenceMap2 = null;
                return serialized;
              }
              if (encodeOptions & REUSE_BUFFER_MODE) {
                target.start = start;
                target.end = position;
                return target;
              }
              return target.subarray(start, position);
            } finally {
              if (sharedStructures) {
                if (serializationsSinceTransitionRebuild < 10)
                  serializationsSinceTransitionRebuild++;
                if (sharedStructures.length > maxSharedStructures)
                  sharedStructures.length = maxSharedStructures;
                if (transitionsCount > 1e4) {
                  sharedStructures.transitions = null;
                  serializationsSinceTransitionRebuild = 0;
                  transitionsCount = 0;
                  if (recordIdsToRemove.length > 0)
                    recordIdsToRemove = [];
                } else if (recordIdsToRemove.length > 0 && !isSequential) {
                  for (let i9 = 0, l7 = recordIdsToRemove.length; i9 < l7; i9++) {
                    recordIdsToRemove[i9][RECORD_SYMBOL] = void 0;
                  }
                  recordIdsToRemove = [];
                }
              }
              if (hasSharedUpdate && encoder5.saveShared) {
                if (encoder5.structures.length > maxSharedStructures) {
                  encoder5.structures = encoder5.structures.slice(0, maxSharedStructures);
                }
                let returnBuffer = target.subarray(start, position);
                if (encoder5.updateSharedData() === false)
                  return encoder5.encode(value);
                return returnBuffer;
              }
              if (encodeOptions & RESET_BUFFER_MODE)
                position = start;
            }
          };
          this.findCommonStringsToPack = () => {
            samplingPackedValues = /* @__PURE__ */ new Map();
            if (!sharedPackedObjectMap2)
              sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
            return (options4) => {
              let threshold = options4 && options4.threshold || 4;
              let position2 = this.pack ? options4.maxPrivatePackedValues || 16 : 0;
              if (!sharedValues)
                sharedValues = this.sharedValues = [];
              for (let [key3, status] of samplingPackedValues) {
                if (status.count > threshold) {
                  sharedPackedObjectMap2[key3] = position2++;
                  sharedValues.push(key3);
                  hasSharedUpdate = true;
                }
              }
              while (this.saveShared && this.updateSharedData() === false) {
              }
              samplingPackedValues = null;
            };
          };
          const encode5 = (value) => {
            if (position > safeEnd)
              target = makeRoom(position);
            var type = typeof value;
            var length;
            if (type === "string") {
              if (packedObjectMap2) {
                let packedPosition = packedObjectMap2[value];
                if (packedPosition >= 0) {
                  if (packedPosition < 16)
                    target[position++] = packedPosition + 224;
                  else {
                    target[position++] = 198;
                    if (packedPosition & 1)
                      encode5(15 - packedPosition >> 1);
                    else
                      encode5(packedPosition - 16 >> 1);
                  }
                  return;
                } else if (samplingPackedValues && !options3.pack) {
                  let status = samplingPackedValues.get(value);
                  if (status)
                    status.count++;
                  else
                    samplingPackedValues.set(value, {
                      count: 1
                    });
                }
              }
              let strLength = value.length;
              if (bundledStrings && strLength >= 4 && strLength < 1024) {
                if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
                  let extStart;
                  let maxBytes2 = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
                  if (position + maxBytes2 > safeEnd)
                    target = makeRoom(position + maxBytes2);
                  target[position++] = 217;
                  target[position++] = 223;
                  target[position++] = 249;
                  target[position++] = bundledStrings.position ? 132 : 130;
                  target[position++] = 26;
                  extStart = position - start;
                  position += 4;
                  if (bundledStrings.position) {
                    writeBundles(start, encode5);
                  }
                  bundledStrings = ["", ""];
                  bundledStrings.size = 0;
                  bundledStrings.position = extStart;
                }
                let twoByte = hasNonLatin.test(value);
                bundledStrings[twoByte ? 0 : 1] += value;
                target[position++] = twoByte ? 206 : 207;
                encode5(strLength);
                return;
              }
              let headerSize;
              if (strLength < 32) {
                headerSize = 1;
              } else if (strLength < 256) {
                headerSize = 2;
              } else if (strLength < 65536) {
                headerSize = 3;
              } else {
                headerSize = 5;
              }
              let maxBytes = strLength * 3;
              if (position + maxBytes > safeEnd)
                target = makeRoom(position + maxBytes);
              if (strLength < 64 || !encodeUtf8) {
                let i9, c1, c22, strPosition = position + headerSize;
                for (i9 = 0; i9 < strLength; i9++) {
                  c1 = value.charCodeAt(i9);
                  if (c1 < 128) {
                    target[strPosition++] = c1;
                  } else if (c1 < 2048) {
                    target[strPosition++] = c1 >> 6 | 192;
                    target[strPosition++] = c1 & 63 | 128;
                  } else if ((c1 & 64512) === 55296 && ((c22 = value.charCodeAt(i9 + 1)) & 64512) === 56320) {
                    c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
                    i9++;
                    target[strPosition++] = c1 >> 18 | 240;
                    target[strPosition++] = c1 >> 12 & 63 | 128;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  } else {
                    target[strPosition++] = c1 >> 12 | 224;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  }
                }
                length = strPosition - position - headerSize;
              } else {
                length = encodeUtf8(value, position + headerSize, maxBytes);
              }
              if (length < 24) {
                target[position++] = 96 | length;
              } else if (length < 256) {
                if (headerSize < 2) {
                  target.copyWithin(position + 2, position + 1, position + 1 + length);
                }
                target[position++] = 120;
                target[position++] = length;
              } else if (length < 65536) {
                if (headerSize < 3) {
                  target.copyWithin(position + 3, position + 2, position + 2 + length);
                }
                target[position++] = 121;
                target[position++] = length >> 8;
                target[position++] = length & 255;
              } else {
                if (headerSize < 5) {
                  target.copyWithin(position + 5, position + 3, position + 3 + length);
                }
                target[position++] = 122;
                targetView.setUint32(position, length);
                position += 4;
              }
              position += length;
            } else if (type === "number") {
              if (!this.alwaysUseFloat && value >>> 0 === value) {
                if (value < 24) {
                  target[position++] = value;
                } else if (value < 256) {
                  target[position++] = 24;
                  target[position++] = value;
                } else if (value < 65536) {
                  target[position++] = 25;
                  target[position++] = value >> 8;
                  target[position++] = value & 255;
                } else {
                  target[position++] = 26;
                  targetView.setUint32(position, value);
                  position += 4;
                }
              } else if (!this.alwaysUseFloat && value >> 0 === value) {
                if (value >= -24) {
                  target[position++] = 31 - value;
                } else if (value >= -256) {
                  target[position++] = 56;
                  target[position++] = ~value;
                } else if (value >= -65536) {
                  target[position++] = 57;
                  targetView.setUint16(position, ~value);
                  position += 2;
                } else {
                  target[position++] = 58;
                  targetView.setUint32(position, ~value);
                  position += 4;
                }
              } else {
                let useFloat32;
                if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
                  target[position++] = 250;
                  targetView.setFloat32(position, value);
                  let xShifted;
                  if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
                  (xShifted = value * mult10[(target[position] & 127) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {
                    position += 4;
                    return;
                  } else
                    position--;
                }
                target[position++] = 251;
                targetView.setFloat64(position, value);
                position += 8;
              }
            } else if (type === "object") {
              if (!value)
                target[position++] = 246;
              else {
                if (referenceMap2) {
                  let referee = referenceMap2.get(value);
                  if (referee) {
                    target[position++] = 216;
                    target[position++] = 29;
                    target[position++] = 25;
                    if (!referee.references) {
                      let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                      referee.references = [];
                      idsToInsert.push(referee);
                    }
                    referee.references.push(position - start);
                    position += 2;
                    return;
                  } else
                    referenceMap2.set(value, { offset: position - start });
                }
                let constructor = value.constructor;
                if (constructor === Object) {
                  writeObject(value, true);
                } else if (constructor === Array) {
                  length = value.length;
                  if (length < 24) {
                    target[position++] = 128 | length;
                  } else {
                    writeArrayHeader(length);
                  }
                  for (let i9 = 0; i9 < length; i9++) {
                    encode5(value[i9]);
                  }
                } else if (constructor === Map) {
                  if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                    target[position++] = 217;
                    target[position++] = 1;
                    target[position++] = 3;
                  }
                  length = value.size;
                  if (length < 24) {
                    target[position++] = 160 | length;
                  } else if (length < 256) {
                    target[position++] = 184;
                    target[position++] = length;
                  } else if (length < 65536) {
                    target[position++] = 185;
                    target[position++] = length >> 8;
                    target[position++] = length & 255;
                  } else {
                    target[position++] = 186;
                    targetView.setUint32(position, length);
                    position += 4;
                  }
                  if (encoder5.keyMap) {
                    for (let [key3, entryValue] of value) {
                      encode5(encoder5.encodeKey(key3));
                      encode5(entryValue);
                    }
                  } else {
                    for (let [key3, entryValue] of value) {
                      encode5(key3);
                      encode5(entryValue);
                    }
                  }
                } else {
                  for (let i9 = 0, l7 = extensions.length; i9 < l7; i9++) {
                    let extensionClass = extensionClasses[i9];
                    if (value instanceof extensionClass) {
                      let extension = extensions[i9];
                      let tag = extension.tag;
                      if (tag == void 0)
                        tag = extension.getTag && extension.getTag.call(this, value);
                      if (tag < 24) {
                        target[position++] = 192 | tag;
                      } else if (tag < 256) {
                        target[position++] = 216;
                        target[position++] = tag;
                      } else if (tag < 65536) {
                        target[position++] = 217;
                        target[position++] = tag >> 8;
                        target[position++] = tag & 255;
                      } else if (tag > -1) {
                        target[position++] = 218;
                        targetView.setUint32(position, tag);
                        position += 4;
                      }
                      extension.encode.call(this, value, encode5, makeRoom);
                      return;
                    }
                  }
                  if (value[Symbol.iterator]) {
                    if (throwOnIterable) {
                      let error2 = new Error("Iterable should be serialized as iterator");
                      error2.iteratorNotHandled = true;
                      throw error2;
                    }
                    target[position++] = 159;
                    for (let entry of value) {
                      encode5(entry);
                    }
                    target[position++] = 255;
                    return;
                  }
                  if (value[Symbol.asyncIterator] || isBlob(value)) {
                    let error2 = new Error("Iterable/blob should be serialized as iterator");
                    error2.iteratorNotHandled = true;
                    throw error2;
                  }
                  if (this.useToJSON && value.toJSON) {
                    const json2 = value.toJSON();
                    if (json2 !== value)
                      return encode5(json2);
                  }
                  writeObject(value, !value.hasOwnProperty);
                }
              }
            } else if (type === "boolean") {
              target[position++] = value ? 245 : 244;
            } else if (type === "bigint") {
              if (value < BigInt(1) << BigInt(64) && value >= 0) {
                target[position++] = 27;
                targetView.setBigUint64(position, value);
              } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
                target[position++] = 59;
                targetView.setBigUint64(position, -value - BigInt(1));
              } else {
                if (this.largeBigIntToFloat) {
                  target[position++] = 251;
                  targetView.setFloat64(position, Number(value));
                } else {
                  throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
                }
              }
              position += 8;
            } else if (type === "undefined") {
              target[position++] = 247;
            } else {
              throw new Error("Unknown type: " + type);
            }
          };
          const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
            let keys = Object.keys(object);
            let vals = Object.values(object);
            let length = keys.length;
            if (length < 24) {
              target[position++] = 160 | length;
            } else if (length < 256) {
              target[position++] = 184;
              target[position++] = length;
            } else if (length < 65536) {
              target[position++] = 185;
              target[position++] = length >> 8;
              target[position++] = length & 255;
            } else {
              target[position++] = 186;
              targetView.setUint32(position, length);
              position += 4;
            }
            if (encoder5.keyMap) {
              for (let i9 = 0; i9 < length; i9++) {
                encode5(encoder5.encodeKey(keys[i9]));
                encode5(vals[i9]);
              }
            } else {
              for (let i9 = 0; i9 < length; i9++) {
                encode5(keys[i9]);
                encode5(vals[i9]);
              }
            }
          } : (object, safePrototype) => {
            target[position++] = 185;
            let objectOffset = position - start;
            position += 2;
            let size = 0;
            if (encoder5.keyMap) {
              for (let key3 in object)
                if (safePrototype || object.hasOwnProperty(key3)) {
                  encode5(encoder5.encodeKey(key3));
                  encode5(object[key3]);
                  size++;
                }
            } else {
              for (let key3 in object)
                if (safePrototype || object.hasOwnProperty(key3)) {
                  encode5(key3);
                  encode5(object[key3]);
                  size++;
                }
            }
            target[objectOffset++ + start] = size >> 8;
            target[objectOffset + start] = size & 255;
          } : (object, safePrototype) => {
            let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
            let newTransitions = 0;
            let length = 0;
            let parentRecordId;
            let keys;
            if (this.keyMap) {
              keys = Object.keys(object).map((k4) => this.encodeKey(k4));
              length = keys.length;
              for (let i9 = 0; i9 < length; i9++) {
                let key3 = keys[i9];
                nextTransition = transition[key3];
                if (!nextTransition) {
                  nextTransition = transition[key3] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
              }
            } else {
              for (let key3 in object)
                if (safePrototype || object.hasOwnProperty(key3)) {
                  nextTransition = transition[key3];
                  if (!nextTransition) {
                    if (transition[RECORD_SYMBOL] & 1048576) {
                      parentRecordId = transition[RECORD_SYMBOL] & 65535;
                    }
                    nextTransition = transition[key3] = /* @__PURE__ */ Object.create(null);
                    newTransitions++;
                  }
                  transition = nextTransition;
                  length++;
                }
            }
            let recordId = transition[RECORD_SYMBOL];
            if (recordId !== void 0) {
              recordId &= 65535;
              target[position++] = 217;
              target[position++] = recordId >> 8 | 224;
              target[position++] = recordId & 255;
            } else {
              if (!keys)
                keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
              if (parentRecordId === void 0) {
                recordId = structures.nextId++;
                if (!recordId) {
                  recordId = 0;
                  structures.nextId = 1;
                }
                if (recordId >= MAX_STRUCTURES) {
                  structures.nextId = (recordId = maxSharedStructures) + 1;
                }
              } else {
                recordId = parentRecordId;
              }
              structures[recordId] = keys;
              if (recordId < maxSharedStructures) {
                target[position++] = 217;
                target[position++] = recordId >> 8 | 224;
                target[position++] = recordId & 255;
                transition = structures.transitions;
                for (let i9 = 0; i9 < length; i9++) {
                  if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
                    transition[RECORD_SYMBOL] = recordId;
                  transition = transition[keys[i9]];
                }
                transition[RECORD_SYMBOL] = recordId | 1048576;
                hasSharedUpdate = true;
              } else {
                transition[RECORD_SYMBOL] = recordId;
                targetView.setUint32(position, 3655335680);
                position += 3;
                if (newTransitions)
                  transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
                if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
                  recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
                recordIdsToRemove.push(transition);
                writeArrayHeader(length + 2);
                encode5(57344 + recordId);
                encode5(keys);
                if (safePrototype === null)
                  return;
                for (let key3 in object)
                  if (safePrototype || object.hasOwnProperty(key3))
                    encode5(object[key3]);
                return;
              }
            }
            if (length < 24) {
              target[position++] = 128 | length;
            } else {
              writeArrayHeader(length);
            }
            if (safePrototype === null)
              return;
            for (let key3 in object)
              if (safePrototype || object.hasOwnProperty(key3))
                encode5(object[key3]);
          };
          const makeRoom = (end) => {
            let newSize;
            if (end > 16777216) {
              if (end - start > MAX_BUFFER_SIZE)
                throw new Error("Encoded buffer would be larger than maximum buffer size");
              newSize = Math.min(
                MAX_BUFFER_SIZE,
                Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
              );
            } else
              newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
            let newBuffer = new ByteArrayAllocate(newSize);
            targetView = new DataView(newBuffer.buffer, 0, newSize);
            if (target.copy)
              target.copy(newBuffer, 0, start, end);
            else
              newBuffer.set(target.slice(start, end));
            position -= start;
            start = 0;
            safeEnd = newBuffer.length - 10;
            return target = newBuffer;
          };
          let chunkThreshold = 100;
          let continuedChunkThreshold = 1e3;
          this.encodeAsIterable = function(value, options4) {
            return startEncoding(value, options4, encodeObjectAsIterable);
          };
          this.encodeAsAsyncIterable = function(value, options4) {
            return startEncoding(value, options4, encodeObjectAsAsyncIterable);
          };
          function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
            let constructor = object.constructor;
            if (constructor === Object) {
              let useRecords = encoder5.useRecords !== false;
              if (useRecords)
                writeObject(object, null);
              else
                writeEntityLength(Object.keys(object).length, 160);
              for (let key3 in object) {
                let value = object[key3];
                if (!useRecords)
                  encode5(key3);
                if (value && typeof value === "object") {
                  if (iterateProperties[key3])
                    yield* encodeObjectAsIterable(value, iterateProperties[key3]);
                  else
                    yield* tryEncode(value, iterateProperties, key3);
                } else
                  encode5(value);
              }
            } else if (constructor === Array) {
              let length = object.length;
              writeArrayHeader(length);
              for (let i9 = 0; i9 < length; i9++) {
                let value = object[i9];
                if (value && (typeof value === "object" || position - start > chunkThreshold)) {
                  if (iterateProperties.element)
                    yield* encodeObjectAsIterable(value, iterateProperties.element);
                  else
                    yield* tryEncode(value, iterateProperties, "element");
                } else
                  encode5(value);
              }
            } else if (object[Symbol.iterator]) {
              target[position++] = 159;
              for (let value of object) {
                if (value && (typeof value === "object" || position - start > chunkThreshold)) {
                  if (iterateProperties.element)
                    yield* encodeObjectAsIterable(value, iterateProperties.element);
                  else
                    yield* tryEncode(value, iterateProperties, "element");
                } else
                  encode5(value);
              }
              target[position++] = 255;
            } else if (isBlob(object)) {
              writeEntityLength(object.size, 64);
              yield target.subarray(start, position);
              yield object;
              restartEncoding();
            } else if (object[Symbol.asyncIterator]) {
              target[position++] = 159;
              yield target.subarray(start, position);
              yield object;
              restartEncoding();
              target[position++] = 255;
            } else {
              encode5(object);
            }
            if (finalIterable && position > start)
              yield target.subarray(start, position);
            else if (position - start > chunkThreshold) {
              yield target.subarray(start, position);
              restartEncoding();
            }
          }
          function* tryEncode(value, iterateProperties, key3) {
            let restart = position - start;
            try {
              encode5(value);
              if (position - start > chunkThreshold) {
                yield target.subarray(start, position);
                restartEncoding();
              }
            } catch (error2) {
              if (error2.iteratorNotHandled) {
                iterateProperties[key3] = {};
                position = start + restart;
                yield* encodeObjectAsIterable.call(this, value, iterateProperties[key3]);
              } else
                throw error2;
            }
          }
          function restartEncoding() {
            chunkThreshold = continuedChunkThreshold;
            encoder5.encode(null, THROW_ON_ITERABLE);
          }
          function startEncoding(value, options4, encodeIterable) {
            if (options4 && options4.chunkThreshold)
              chunkThreshold = continuedChunkThreshold = options4.chunkThreshold;
            else
              chunkThreshold = 100;
            if (value && typeof value === "object") {
              encoder5.encode(null, THROW_ON_ITERABLE);
              return encodeIterable(value, encoder5.iterateProperties || (encoder5.iterateProperties = {}), true);
            }
            return [encoder5.encode(value)];
          }
          async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
            for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
              let constructor = encodedValue.constructor;
              if (constructor === ByteArray || constructor === Uint8Array)
                yield encodedValue;
              else if (isBlob(encodedValue)) {
                let reader = encodedValue.stream().getReader();
                let next2;
                while (!(next2 = await reader.read()).done) {
                  yield next2.value;
                }
              } else if (encodedValue[Symbol.asyncIterator]) {
                for await (let asyncValue of encodedValue) {
                  restartEncoding();
                  if (asyncValue)
                    yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
                  else
                    yield encoder5.encode(asyncValue);
                }
              } else {
                yield encodedValue;
              }
            }
          }
        }
        useBuffer(buffer) {
          target = buffer;
          targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
          position = 0;
        }
        clearSharedData() {
          if (this.structures)
            this.structures = [];
          if (this.sharedValues)
            this.sharedValues = void 0;
        }
        updateSharedData() {
          let lastVersion = this.sharedVersion || 0;
          this.sharedVersion = lastVersion + 1;
          let structuresCopy = this.structures.slice(0);
          let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
          let saveResults = this.saveShared(
            sharedData,
            (existingShared) => (existingShared && existingShared.version || 0) == lastVersion
          );
          if (saveResults === false) {
            sharedData = this.getShared() || {};
            this.structures = sharedData.structures || [];
            this.sharedValues = sharedData.packedValues;
            this.sharedVersion = sharedData.version;
            this.structures.nextId = this.structures.length;
          } else {
            structuresCopy.forEach((structure, i9) => this.structures[i9] = structure);
          }
          return saveResults;
        }
      }
      function writeEntityLength(length, majorValue) {
        if (length < 24)
          target[position++] = majorValue | length;
        else if (length < 256) {
          target[position++] = majorValue | 24;
          target[position++] = length;
        } else if (length < 65536) {
          target[position++] = majorValue | 25;
          target[position++] = length >> 8;
          target[position++] = length & 255;
        } else {
          target[position++] = majorValue | 26;
          targetView.setUint32(position, length);
          position += 4;
        }
      }
      class SharedData {
        constructor(structures, values, version) {
          this.structures = structures;
          this.packedValues = values;
          this.version = version;
        }
      }
      function writeArrayHeader(length) {
        if (length < 24)
          target[position++] = 128 | length;
        else if (length < 256) {
          target[position++] = 152;
          target[position++] = length;
        } else if (length < 65536) {
          target[position++] = 153;
          target[position++] = length >> 8;
          target[position++] = length & 255;
        } else {
          target[position++] = 154;
          targetView.setUint32(position, length);
          position += 4;
        }
      }
      const BlobConstructor = typeof Blob === "undefined" ? function() {
      } : Blob;
      function isBlob(object) {
        if (object instanceof BlobConstructor)
          return true;
        let tag = object[Symbol.toStringTag];
        return tag === "Blob" || tag === "File";
      }
      function findRepetitiveStrings(value, packedValues2) {
        switch (typeof value) {
          case "string":
            if (value.length > 3) {
              if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
                return;
              let packedStatus = packedValues2.get(value);
              if (packedStatus) {
                if (++packedStatus.count == 2) {
                  packedValues2.values.push(value);
                }
              } else {
                packedValues2.set(value, {
                  count: 1
                });
                if (packedValues2.samplingPackedValues) {
                  let status = packedValues2.samplingPackedValues.get(value);
                  if (status)
                    status.count++;
                  else
                    packedValues2.samplingPackedValues.set(value, {
                      count: 1
                    });
                }
              }
            }
            break;
          case "object":
            if (value) {
              if (value instanceof Array) {
                for (let i9 = 0, l7 = value.length; i9 < l7; i9++) {
                  findRepetitiveStrings(value[i9], packedValues2);
                }
              } else {
                let includeKeys = !packedValues2.encoder.useRecords;
                for (var key3 in value) {
                  if (value.hasOwnProperty(key3)) {
                    if (includeKeys)
                      findRepetitiveStrings(key3, packedValues2);
                    findRepetitiveStrings(value[key3], packedValues2);
                  }
                }
              }
            }
            break;
          case "function":
            console.log(value);
        }
      }
      const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
      extensionClasses = [
        Date,
        Set,
        Error,
        RegExp,
        Tag,
        ArrayBuffer,
        Uint8Array,
        Uint8ClampedArray,
        Uint16Array,
        Uint32Array,
        typeof BigUint64Array == "undefined" ? function() {
        } : BigUint64Array,
        Int8Array,
        Int16Array,
        Int32Array,
        typeof BigInt64Array == "undefined" ? function() {
        } : BigInt64Array,
        Float32Array,
        Float64Array,
        SharedData
      ];
      extensions = [
        {
          // Date
          tag: 1,
          encode(date, encode5) {
            let seconds = date.getTime() / 1e3;
            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
              target[position++] = 26;
              targetView.setUint32(position, seconds);
              position += 4;
            } else {
              target[position++] = 251;
              targetView.setFloat64(position, seconds);
              position += 8;
            }
          }
        },
        {
          // Set
          tag: 258,
          // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
          encode(set2, encode5) {
            let array2 = Array.from(set2);
            encode5(array2);
          }
        },
        {
          // Error
          tag: 27,
          // http://cbor.schmorp.de/generic-object
          encode(error2, encode5) {
            encode5([error2.name, error2.message]);
          }
        },
        {
          // RegExp
          tag: 27,
          // http://cbor.schmorp.de/generic-object
          encode(regex, encode5) {
            encode5(["RegExp", regex.source, regex.flags]);
          }
        },
        {
          // Tag
          getTag(tag) {
            return tag.tag;
          },
          encode(tag, encode5) {
            encode5(tag.value);
          }
        },
        {
          // ArrayBuffer
          encode(arrayBuffer, encode5, makeRoom) {
            writeBuffer(arrayBuffer, makeRoom);
          }
        },
        {
          // Uint8Array
          getTag(typedArray) {
            if (typedArray.constructor === Uint8Array) {
              if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
                return 64;
            }
          },
          encode(typedArray, encode5, makeRoom) {
            writeBuffer(typedArray, makeRoom);
          }
        },
        typedArrayEncoder(68, 1),
        typedArrayEncoder(69, 2),
        typedArrayEncoder(70, 4),
        typedArrayEncoder(71, 8),
        typedArrayEncoder(72, 1),
        typedArrayEncoder(77, 2),
        typedArrayEncoder(78, 4),
        typedArrayEncoder(79, 8),
        typedArrayEncoder(85, 4),
        typedArrayEncoder(86, 8),
        {
          encode(sharedData, encode5) {
            let packedValues2 = sharedData.packedValues || [];
            let sharedStructures = sharedData.structures || [];
            if (packedValues2.values.length > 0) {
              target[position++] = 216;
              target[position++] = 51;
              writeArrayHeader(4);
              let valuesArray = packedValues2.values;
              encode5(valuesArray);
              writeArrayHeader(0);
              writeArrayHeader(0);
              packedObjectMap = Object.create(sharedPackedObjectMap || null);
              for (let i9 = 0, l7 = valuesArray.length; i9 < l7; i9++) {
                packedObjectMap[valuesArray[i9]] = i9;
              }
            }
            if (sharedStructures) {
              targetView.setUint32(position, 3655335424);
              position += 3;
              let definitions = sharedStructures.slice(0);
              definitions.unshift(57344);
              definitions.push(new Tag(sharedData.version, 1399353956));
              encode5(definitions);
            } else
              encode5(new Tag(sharedData.version, 1399353956));
          }
        }
      ];
      function typedArrayEncoder(tag, size) {
        if (!isLittleEndianMachine && size > 1)
          tag -= 4;
        return {
          tag,
          encode: function writeExtBuffer(typedArray, encode5) {
            let length = typedArray.byteLength;
            let offset = typedArray.byteOffset || 0;
            let buffer = typedArray.buffer || typedArray;
            encode5(hasNodeBuffer ? Buffer$1.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
          }
        };
      }
      function writeBuffer(buffer, makeRoom) {
        let length = buffer.byteLength;
        if (length < 24) {
          target[position++] = 64 + length;
        } else if (length < 256) {
          target[position++] = 88;
          target[position++] = length;
        } else if (length < 65536) {
          target[position++] = 89;
          target[position++] = length >> 8;
          target[position++] = length & 255;
        } else {
          target[position++] = 90;
          targetView.setUint32(position, length);
          position += 4;
        }
        if (position + length >= target.length) {
          makeRoom(position + length);
        }
        target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position);
        position += length;
      }
      function insertIds(serialized, idsToInsert) {
        let nextId;
        let distanceToMove = idsToInsert.length * 2;
        let lastEnd = serialized.length - distanceToMove;
        idsToInsert.sort((a7, b5) => a7.offset > b5.offset ? 1 : -1);
        for (let id = 0; id < idsToInsert.length; id++) {
          let referee = idsToInsert[id];
          referee.id = id;
          for (let position2 of referee.references) {
            serialized[position2++] = id >> 8;
            serialized[position2] = id & 255;
          }
        }
        while (nextId = idsToInsert.pop()) {
          let offset = nextId.offset;
          serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
          distanceToMove -= 2;
          let position2 = offset + distanceToMove;
          serialized[position2++] = 216;
          serialized[position2++] = 28;
          lastEnd = offset;
        }
        return serialized;
      }
      function writeBundles(start, encode5) {
        targetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1);
        let writeStrings = bundledStrings;
        bundledStrings = null;
        encode5(writeStrings[0]);
        encode5(writeStrings[1]);
      }
      function addExtension(extension) {
        if (extension.Class) {
          if (!extension.encode)
            throw new Error("Extension has no encode function");
          extensionClasses.unshift(extension.Class);
          extensions.unshift(extension);
        }
        addExtension$1(extension);
      }
      let defaultEncoder = new Encoder({ useRecords: false });
      const encode4 = defaultEncoder.encode;
      const encodeAsIterable = defaultEncoder.encodeAsIterable;
      const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
      const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
      const REUSE_BUFFER_MODE = 512;
      const RESET_BUFFER_MODE = 1024;
      const THROW_ON_ITERABLE = 2048;
      function encodeIter(objectIterator, options3 = {}) {
        if (!objectIterator || typeof objectIterator !== "object") {
          throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");
        } else if (typeof objectIterator[Symbol.iterator] === "function") {
          return encodeIterSync(objectIterator, options3);
        } else if (typeof objectIterator.then === "function" || typeof objectIterator[Symbol.asyncIterator] === "function") {
          return encodeIterAsync(objectIterator, options3);
        } else {
          throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise");
        }
      }
      function* encodeIterSync(objectIterator, options3) {
        const encoder5 = new Encoder(options3);
        for (const value of objectIterator) {
          yield encoder5.encode(value);
        }
      }
      async function* encodeIterAsync(objectIterator, options3) {
        const encoder5 = new Encoder(options3);
        for await (const value of objectIterator) {
          yield encoder5.encode(value);
        }
      }
      function decodeIter(bufferIterator, options3 = {}) {
        if (!bufferIterator || typeof bufferIterator !== "object") {
          throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");
        }
        const decoder3 = new Decoder(options3);
        let incomplete;
        const parser2 = (chunk) => {
          let yields;
          if (incomplete) {
            chunk = Buffer.concat([incomplete, chunk]);
            incomplete = void 0;
          }
          try {
            yields = decoder3.decodeMultiple(chunk);
          } catch (err) {
            if (err.incomplete) {
              incomplete = chunk.slice(err.lastPosition);
              yields = err.values;
            } else {
              throw err;
            }
          }
          return yields;
        };
        if (typeof bufferIterator[Symbol.iterator] === "function") {
          return function* iter() {
            for (const value of bufferIterator) {
              yield* parser2(value);
            }
          }();
        } else if (typeof bufferIterator[Symbol.asyncIterator] === "function") {
          return async function* iter() {
            for await (const value of bufferIterator) {
              yield* parser2(value);
            }
          }();
        }
      }
      exports2.ALWAYS = ALWAYS;
      exports2.DECIMAL_FIT = DECIMAL_FIT;
      exports2.DECIMAL_ROUND = DECIMAL_ROUND;
      exports2.Decoder = Decoder;
      exports2.Encoder = Encoder;
      exports2.FLOAT32_OPTIONS = FLOAT32_OPTIONS;
      exports2.NEVER = NEVER;
      exports2.REUSE_BUFFER_MODE = REUSE_BUFFER_MODE;
      exports2.Tag = Tag;
      exports2.addExtension = addExtension;
      exports2.clearSource = clearSource;
      exports2.decode = decode3;
      exports2.decodeIter = decodeIter;
      exports2.decodeMultiple = decodeMultiple;
      exports2.encode = encode4;
      exports2.encodeAsAsyncIterable = encodeAsAsyncIterable;
      exports2.encodeAsIterable = encodeAsIterable;
      exports2.encodeIter = encodeIter;
      exports2.isNativeAccelerationEnabled = isNativeAccelerationEnabled;
      exports2.roundFloat32 = roundFloat32;
    });
  }
});

// node_modules/@hexagon/base64/src/base64.js
var chars4, charsUrl, genLookup, lookup9, lookupUrl, base64UrlPattern, base64Pattern, base642, base64_default;
var init_base64 = __esm({
  "node_modules/@hexagon/base64/src/base64.js"() {
    chars4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    charsUrl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    genLookup = (target) => {
      const lookupTemp = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      const len = chars4.length;
      for (let i9 = 0; i9 < len; i9++) {
        lookupTemp[target.charCodeAt(i9)] = i9;
      }
      return lookupTemp;
    };
    lookup9 = genLookup(chars4);
    lookupUrl = genLookup(charsUrl);
    base64UrlPattern = /^[-A-Za-z0-9\-_]*$/;
    base64Pattern = /^[-A-Za-z0-9+/]*={0,3}$/;
    base642 = {};
    base642.toArrayBuffer = (data, urlMode) => {
      const len = data.length;
      let bufferLength = data.length * 0.75, i9, p5 = 0, encoded1, encoded2, encoded3, encoded4;
      if (data[data.length - 1] === "=") {
        bufferLength--;
        if (data[data.length - 2] === "=") {
          bufferLength--;
        }
      }
      const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer), target = urlMode ? lookupUrl : lookup9;
      for (i9 = 0; i9 < len; i9 += 4) {
        encoded1 = target[data.charCodeAt(i9)];
        encoded2 = target[data.charCodeAt(i9 + 1)];
        encoded3 = target[data.charCodeAt(i9 + 2)];
        encoded4 = target[data.charCodeAt(i9 + 3)];
        bytes[p5++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
    base642.fromArrayBuffer = (arrBuf, urlMode) => {
      const bytes = new Uint8Array(arrBuf);
      let i9, result = "";
      const len = bytes.length, target = urlMode ? charsUrl : chars4;
      for (i9 = 0; i9 < len; i9 += 3) {
        result += target[bytes[i9] >> 2];
        result += target[(bytes[i9] & 3) << 4 | bytes[i9 + 1] >> 4];
        result += target[(bytes[i9 + 1] & 15) << 2 | bytes[i9 + 2] >> 6];
        result += target[bytes[i9 + 2] & 63];
      }
      const remainder = len % 3;
      if (remainder === 2) {
        result = result.substring(0, result.length - 1) + (urlMode ? "" : "=");
      } else if (remainder === 1) {
        result = result.substring(0, result.length - 2) + (urlMode ? "" : "==");
      }
      return result;
    };
    base642.toString = (str2, urlMode) => {
      return new TextDecoder().decode(base642.toArrayBuffer(str2, urlMode));
    };
    base642.fromString = (str2, urlMode) => {
      return base642.fromArrayBuffer(new TextEncoder().encode(str2), urlMode);
    };
    base642.validate = (encoded, urlMode) => {
      if (!(typeof encoded === "string" || encoded instanceof String)) {
        return false;
      }
      try {
        return urlMode ? base64UrlPattern.test(encoded) : base64Pattern.test(encoded);
      } catch (_e2) {
        return false;
      }
    };
    base642.base64 = base642;
    base64_default = base642;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F4() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F4.prototype = __global__;
      return new F4();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
        var support = {
          searchParams: "URLSearchParams" in global2,
          iterable: "Symbol" in global2 && "iterator" in Symbol,
          blob: "FileReader" in global2 && "Blob" in global2 && function() {
            try {
              new Blob();
              return true;
            } catch (e5) {
              return false;
            }
          }(),
          formData: "FormData" in global2,
          arrayBuffer: "ArrayBuffer" in global2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers3(headers2) {
          this.map = {};
          if (headers2 instanceof Headers3) {
            headers2.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers2)) {
            headers2.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers2) {
            Object.getOwnPropertyNames(headers2).forEach(function(name2) {
              this.append(name2, headers2[name2]);
            }, this);
          }
        }
        Headers3.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers3.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers3.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers3.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers3.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers3.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers3.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers3.prototype[Symbol.iterator] = Headers3.prototype.entries;
        }
        function consumed(body2) {
          if (body2.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body2.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve2, reject) {
            reader.onload = function() {
              resolve2(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars5 = new Array(view.length);
          for (var i9 = 0; i9 < view.length; i9++) {
            chars5[i9] = String.fromCharCode(view[i9]);
          }
          return chars5.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body2) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body2;
            if (!body2) {
              this._bodyText = "";
            } else if (typeof body2 === "string") {
              this._bodyText = body2;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body2)) {
              this._bodyBlob = body2;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body2)) {
              this._bodyFormData = body2;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body2)) {
              this._bodyText = body2.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body2)) {
              this._bodyArrayBuffer = bufferClone(body2.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body2) || isArrayBufferView(body2))) {
              this._bodyArrayBuffer = bufferClone(body2);
            } else {
              this._bodyText = body2 = Object.prototype.toString.call(body2);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body2 === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body2)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode3);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request3(input, options3) {
          if (!(this instanceof Request3)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options3 = options3 || {};
          var body2 = options3.body;
          if (input instanceof Request3) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options3.headers) {
              this.headers = new Headers3(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body2 && input._bodyInit != null) {
              body2 = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options3.credentials || this.credentials || "same-origin";
          if (options3.headers || !this.headers) {
            this.headers = new Headers3(options3.headers);
          }
          this.method = normalizeMethod(options3.method || this.method || "GET");
          this.mode = options3.mode || this.mode || null;
          this.signal = options3.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body2) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body2);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options3.cache === "no-store" || options3.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request3.prototype.clone = function() {
          return new Request3(this, { body: this._bodyInit });
        };
        function decode3(body2) {
          var form = new FormData();
          body2.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name2 = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers2 = new Headers3();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key3 = parts.shift().trim();
            if (key3) {
              var value = parts.join(":").trim();
              headers2.append(key3, value);
            }
          });
          return headers2;
        }
        Body.call(Request3.prototype);
        function Response3(bodyInit, options3) {
          if (!(this instanceof Response3)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options3) {
            options3 = {};
          }
          this.type = "default";
          this.status = options3.status === void 0 ? 200 : options3.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options3.statusText === void 0 ? "" : "" + options3.statusText;
          this.headers = new Headers3(options3.headers);
          this.url = options3.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response3.prototype);
        Response3.prototype.clone = function() {
          return new Response3(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers3(this.headers),
            url: this.url
          });
        };
        Response3.error = function() {
          var response = new Response3(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response3.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response3(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message2, name2) {
            this.message = message2;
            this.name = name2;
            var error2 = Error(message2);
            this.stack = error2.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch5(input, init3) {
          return new Promise(function(resolve2, reject) {
            var request = new Request3(input, init3);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options3 = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options3.url = "responseURL" in xhr ? xhr.responseURL : options3.headers.get("X-Request-URL");
              var body2 = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve2(new Response3(body2, options3));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global2.location.href ? global2.location.href : url;
              } catch (e5) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init3 && typeof init3.headers === "object" && !(init3.headers instanceof Headers3)) {
              Object.getOwnPropertyNames(init3.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init3.headers[name2]));
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch5.polyfill = true;
        if (!global2.fetch) {
          global2.fetch = fetch5;
          global2.Headers = Headers3;
          global2.Request = Request3;
          global2.Response = Response3;
        }
        exports2.Headers = Headers3;
        exports2.Request = Request3;
        exports2.Response = Response3;
        exports2.fetch = fetch5;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/pvtsutils/build/index.js
var require_build = __commonJS({
  "node_modules/pvtsutils/build/index.js"(exports) {
    "use strict";
    var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
    var BufferSourceConverter5 = class _BufferSourceConverter {
      static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
      }
      static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
          return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
      }
      static toUint8Array(data) {
        return this.toView(data, Uint8Array);
      }
      static toView(data, type) {
        if (data.constructor === type) {
          return data;
        }
        if (this.isArrayBuffer(data)) {
          return new type(data);
        }
        if (this.isArrayBufferView(data)) {
          return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
      }
      static isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
      }
      static isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
      }
      static isEqual(a7, b5) {
        const aView = _BufferSourceConverter.toUint8Array(a7);
        const bView = _BufferSourceConverter.toUint8Array(b5);
        if (aView.length !== bView.byteLength) {
          return false;
        }
        for (let i9 = 0; i9 < aView.length; i9++) {
          if (aView[i9] !== bView[i9]) {
            return false;
          }
        }
        return true;
      }
      static concat(...args) {
        let buffers;
        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
          buffers = args[0];
        } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
          buffers = args[0];
        } else {
          if (args[args.length - 1] instanceof Function) {
            buffers = args.slice(0, args.length - 1);
          } else {
            buffers = args;
          }
        }
        let size = 0;
        for (const buffer of buffers) {
          size += buffer.byteLength;
        }
        const res = new Uint8Array(size);
        let offset = 0;
        for (const buffer of buffers) {
          const view = this.toUint8Array(buffer);
          res.set(view, offset);
          offset += view.length;
        }
        if (args[args.length - 1] instanceof Function) {
          return this.toView(res, args[args.length - 1]);
        }
        return res.buffer;
      }
    };
    var STRING_TYPE = "string";
    var HEX_REGEX = /^[0-9a-f]+$/i;
    var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
    var Utf8Converter = class {
      static fromString(text2) {
        const s9 = unescape(encodeURIComponent(text2));
        const uintArray = new Uint8Array(s9.length);
        for (let i9 = 0; i9 < s9.length; i9++) {
          uintArray[i9] = s9.charCodeAt(i9);
        }
        return uintArray.buffer;
      }
      static toString(buffer) {
        const buf = BufferSourceConverter5.toUint8Array(buffer);
        let encodedString = "";
        for (let i9 = 0; i9 < buf.length; i9++) {
          encodedString += String.fromCharCode(buf[i9]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
      }
    };
    var Utf16Converter = class {
      static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter5.toArrayBuffer(buffer);
        const dataView = new DataView(arrayBuffer);
        let res = "";
        for (let i9 = 0; i9 < arrayBuffer.byteLength; i9 += 2) {
          const code = dataView.getUint16(i9, littleEndian);
          res += String.fromCharCode(code);
        }
        return res;
      }
      static fromString(text2, littleEndian = false) {
        const res = new ArrayBuffer(text2.length * 2);
        const dataView = new DataView(res);
        for (let i9 = 0; i9 < text2.length; i9++) {
          dataView.setUint16(i9 * 2, text2.charCodeAt(i9), littleEndian);
        }
        return res;
      }
    };
    var Convert4 = class _Convert {
      static isHex(data) {
        return typeof data === STRING_TYPE && HEX_REGEX.test(data);
      }
      static isBase64(data) {
        return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
      }
      static isBase64Url(data) {
        return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
      }
      static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter5.toUint8Array(buffer);
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.ToUtf8String(buf);
          case "binary":
            return this.ToBinary(buf);
          case "hex":
            return this.ToHex(buf);
          case "base64":
            return this.ToBase64(buf);
          case "base64url":
            return this.ToBase64Url(buf);
          case "utf16le":
            return Utf16Converter.toString(buf, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buf);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static FromString(str2, enc = "utf8") {
        if (!str2) {
          return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.FromUtf8String(str2);
          case "binary":
            return this.FromBinary(str2);
          case "hex":
            return this.FromHex(str2);
          case "base64":
            return this.FromBase64(str2);
          case "base64url":
            return this.FromBase64Url(str2);
          case "utf16le":
            return Utf16Converter.fromString(str2, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(str2);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static ToBase64(buffer) {
        const buf = BufferSourceConverter5.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
          const binary = this.ToString(buf, "binary");
          return btoa(binary);
        } else {
          return Buffer.from(buf).toString("base64");
        }
      }
      static FromBase64(base643) {
        const formatted = this.formatString(base643);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64(formatted)) {
          throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
          return this.FromBinary(atob(formatted));
        } else {
          return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
      }
      static FromBase64Url(base64url) {
        const formatted = this.formatString(base64url);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64Url(formatted)) {
          throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
      }
      static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
      static FromUtf8String(text2, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.FromBinary(text2);
          case "utf8":
            return Utf8Converter.fromString(text2);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(text2);
          case "utf16le":
          case "usc2":
            return Utf16Converter.fromString(text2, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static ToUtf8String(buffer, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.ToBinary(buffer);
          case "utf8":
            return Utf8Converter.toString(buffer);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buffer);
          case "utf16le":
          case "usc2":
            return Utf16Converter.toString(buffer, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static FromBinary(text2) {
        const stringLength = text2.length;
        const resultView = new Uint8Array(stringLength);
        for (let i9 = 0; i9 < stringLength; i9++) {
          resultView[i9] = text2.charCodeAt(i9);
        }
        return resultView.buffer;
      }
      static ToBinary(buffer) {
        const buf = BufferSourceConverter5.toUint8Array(buffer);
        let res = "";
        for (let i9 = 0; i9 < buf.length; i9++) {
          res += String.fromCharCode(buf[i9]);
        }
        return res;
      }
      static ToHex(buffer) {
        const buf = BufferSourceConverter5.toUint8Array(buffer);
        let result = "";
        const len = buf.length;
        for (let i9 = 0; i9 < len; i9++) {
          const byte = buf[i9];
          if (byte < 16) {
            result += "0";
          }
          result += byte.toString(16);
        }
        return result;
      }
      static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isHex(formatted)) {
          throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
          formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for (let i9 = 0; i9 < formatted.length; i9 = i9 + 2) {
          const c8 = formatted.slice(i9, i9 + 2);
          res[i9 / 2] = parseInt(c8, 16);
        }
        return res.buffer;
      }
      static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
      }
      static FromUtf16String(text2, littleEndian = false) {
        return Utf16Converter.fromString(text2, littleEndian);
      }
      static Base64Padding(base643) {
        const padCount = 4 - base643.length % 4;
        if (padCount < 4) {
          for (let i9 = 0; i9 < padCount; i9++) {
            base643 += "=";
          }
        }
        return base643;
      }
      static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
      }
    };
    Convert4.DEFAULT_UTF8_ENCODING = "utf8";
    function assign(target, ...sources) {
      const res = arguments[0];
      for (let i9 = 1; i9 < arguments.length; i9++) {
        const obj = arguments[i9];
        for (const prop in obj) {
          res[prop] = obj[prop];
        }
      }
      return res;
    }
    function combine(...buf) {
      const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
      const res = new Uint8Array(totalByteLength);
      let currentPos = 0;
      buf.map((item) => new Uint8Array(item)).forEach((arr2) => {
        for (const item2 of arr2) {
          res[currentPos++] = item2;
        }
      });
      return res.buffer;
    }
    function isEqual2(bytes1, bytes2) {
      if (!(bytes1 && bytes2)) {
        return false;
      }
      if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
      }
      const b1 = new Uint8Array(bytes1);
      const b22 = new Uint8Array(bytes2);
      for (let i9 = 0; i9 < bytes1.byteLength; i9++) {
        if (b1[i9] !== b22[i9]) {
          return false;
        }
      }
      return true;
    }
    exports.BufferSourceConverter = BufferSourceConverter5;
    exports.Convert = Convert4;
    exports.assign = assign;
    exports.combine = combine;
    exports.isEqual = isEqual2;
  }
});

// node_modules/pvutils/build/utils.es.js
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i9 = inputBuffer.length - 1; i9 >= 0; i9--) {
    result += inputBuffer[inputBuffer.length - 1 - i9] * Math.pow(2, inputBase * i9);
  }
  return result;
}
function utilToBase(value, base2, reserved2 = -1) {
  const internalReserved = reserved2;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base2);
  for (let i9 = 1; i9 < 8; i9++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i9);
        result = i9;
      } else {
        if (internalReserved < i9) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j4 = i9 - 1; j4 >= 0; j4--) {
        const basis = Math.pow(2, j4 * base2);
        retView[result - j4 - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j4 - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base2);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf[0] === 255 && buf[1] & 128;
    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i9 = 0; i9 < this.valueHex.byteLength; i9++) {
    bigIntView[i9] = 0;
  }
  bigIntView[0] = buf[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j4 = 0; j4 < this.valueHex.byteLength; j4++) {
    smallIntView[j4] = buf[j4];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i9 = 1; i9 < 8; i9++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i9);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i9);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k4 = 0; k4 < tempBuf.byteLength; k4++) {
          retView[k4 + 1] = tempView[k4];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i9 = 0; i9 < view1.length; i9++) {
    if (view1[i9] !== view2[i9]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str2 = inputNumber.toString(10);
  if (fullLength < str2.length) {
    return "";
  }
  const dif = fullLength - str2.length;
  const padding = new Array(dif);
  for (let i9 = 0; i9 < dif; i9++) {
    padding[i9] = "0";
  }
  const paddingString = padding.join("");
  return paddingString.concat(str2);
}
var log2;
var init_utils_es = __esm({
  "node_modules/pvutils/build/utils.es.js"() {
    log2 = Math.log(2);
  }
});

// node_modules/asn1js/build/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  Any: () => Any,
  BaseBlock: () => BaseBlock,
  BaseStringBlock: () => BaseStringBlock,
  BitString: () => BitString,
  BmpString: () => BmpString,
  Boolean: () => Boolean2,
  CharacterString: () => CharacterString,
  Choice: () => Choice,
  Constructed: () => Constructed,
  DATE: () => DATE,
  DateTime: () => DateTime,
  Duration: () => Duration,
  EndOfContent: () => EndOfContent,
  Enumerated: () => Enumerated,
  GeneralString: () => GeneralString,
  GeneralizedTime: () => GeneralizedTime,
  GraphicString: () => GraphicString,
  HexBlock: () => HexBlock,
  IA5String: () => IA5String,
  Integer: () => Integer,
  Null: () => Null,
  NumericString: () => NumericString,
  ObjectIdentifier: () => ObjectIdentifier,
  OctetString: () => OctetString,
  Primitive: () => Primitive,
  PrintableString: () => PrintableString,
  RawData: () => RawData,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier,
  Repeated: () => Repeated,
  Sequence: () => Sequence,
  Set: () => Set2,
  TIME: () => TIME,
  TeletexString: () => TeletexString,
  TimeOfDay: () => TimeOfDay,
  UTCTime: () => UTCTime,
  UniversalString: () => UniversalString,
  Utf8String: () => Utf8String,
  ValueBlock: () => ValueBlock,
  VideotexString: () => VideotexString,
  ViewWriter: () => ViewWriter,
  VisibleString: () => VisibleString,
  compareSchema: () => compareSchema,
  fromBER: () => fromBER,
  verifySchema: () => verifySchema
});
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat2(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i9 = 0; i9 < buffers.length; i9++) {
    const buffer = buffers[i9];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i9 = 0; i9 < buffers.length; i9++) {
    const buffer = buffers[i9];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}
function HexBlock(BaseClass) {
  var _a3;
  return _a3 = class Some extends BaseClass {
    constructor(...args) {
      var _a4;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_a4 = params.isHexOnly) !== null && _a4 !== void 0 ? _a4 : false;
      this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: pvtsutils.Convert.ToHex(this.valueHexView)
      };
    }
  }, _a3.NAME = "hexBlock", _a3;
}
function prepareIndefiniteForm(baseBlock) {
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!baseBlock.lenBlock.isIndefiniteForm;
}
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType();
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock();
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}
function viewAdd(first, second) {
  const c8 = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i9 = max; i9 >= 0; i9--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c8[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c8[0];
    }
    c8[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c8[0] > 0)
    firstViewCopy = utilConcatView(c8, firstViewCopy);
  return firstViewCopy;
}
function power2(n7) {
  if (n7 >= powers2.length) {
    for (let p5 = powers2.length; p5 <= n7; p5++) {
      const c8 = new Uint8Array([0]);
      let digits = powers2[p5 - 1].slice(0);
      for (let i9 = digits.length - 1; i9 >= 0; i9--) {
        const newValue = new Uint8Array([(digits[i9] << 1) + c8[0]]);
        c8[0] = newValue[0] / 10;
        digits[i9] = newValue[0] % 10;
      }
      if (c8[0] > 0)
        digits = utilConcatView(c8, digits);
      powers2.push(digits);
    }
  }
  return powers2[n7];
}
function viewSub(first, second) {
  let b5 = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i9 = secondViewCopyLength; i9 >= 0; i9--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b5;
    switch (true) {
      case value < 0:
        b5 = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b5 = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b5 > 0) {
    for (let i9 = firstViewCopyLength - secondViewCopyLength + 1; i9 >= 0; i9--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b5;
      if (value < 0) {
        b5 = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b5 = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}
function compareSchema(root2, inputData, inputSchema) {
  if (inputSchema instanceof Choice) {
    for (let j4 = 0; j4 < inputSchema.value.length; j4++) {
      const result = compareSchema(root2, inputData, inputSchema.value[j4]);
      if (result.verified) {
        return {
          verified: true,
          result: root2
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: {
          error: "Wrong values for Choice type"
        }
      };
      if (inputSchema.hasOwnProperty(NAME))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any) {
    if (inputSchema.hasOwnProperty(NAME))
      root2[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root2
    };
  }
  if (root2 instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root2
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root2
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root2
    };
  }
  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root2
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root2
      };
    }
    for (let i9 = 0; i9 < schemaView.length; i9++) {
      if (schemaView[i9] !== asn1View[1]) {
        return {
          verified: false,
          result: root2
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
    if (inputSchema.name)
      root2[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: {
        error: "Unknown error"
      }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root2
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i9 = 0; i9 < inputSchema.valueBlock.value.length; i9++)
        _optional = _optional && (inputSchema.valueBlock.value[i9].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root2
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
          delete root2[inputSchema.name];
      }
      root2.error = "Inconsistent object length";
      return {
        verified: false,
        result: root2
      };
    }
    for (let i9 = 0; i9 < maxLength; i9++) {
      if (i9 - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i9].optional === false) {
          const _result = {
            verified: false,
            result: root2
          };
          root2.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root2[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) {
          result = compareSchema(root2, inputData.valueBlock.value[i9], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root2[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root2;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i9]);
          }
        } else {
          result = compareSchema(root2, inputData.valueBlock.value[i9 - admission], inputSchema.valueBlock.value[i9]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i9].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root2[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root2
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root2[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root2
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
    const asn1 = localFromBER(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root2[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema(root2, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root2
  };
}
function verifySchema(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema(asn1.result, asn1.result, inputSchema);
}
var pvtsutils, ViewWriter, powers2, digitsString, NAME, VALUE_HEX_VIEW, IS_HEX_ONLY, ID_BLOCK, TAG_CLASS, TAG_NUMBER, IS_CONSTRUCTED, FROM_BER, TO_BER, LOCAL, EMPTY_STRING, EMPTY_BUFFER, EMPTY_VIEW, END_OF_CONTENT_NAME, OCTET_STRING_NAME, BIT_STRING_NAME, LocalBaseBlock, ValueBlock, LocalIdentificationBlock, LocalLengthBlock, typeStore, BaseBlock, BaseStringBlock, LocalPrimitiveValueBlock, _a$w, Primitive, LocalConstructedValueBlock, _a$v, Constructed, LocalEndOfContentValueBlock, _a$u, EndOfContent, _a$t, Null, LocalBooleanValueBlock, _a$s, Boolean2, LocalOctetStringValueBlock, _a$r, OctetString, LocalBitStringValueBlock, _a$q, BitString, _a$p, LocalIntegerValueBlock, _a$o, Integer, _a$n, Enumerated, LocalSidValueBlock, LocalObjectIdentifierValueBlock, _a$m, ObjectIdentifier, LocalRelativeSidValueBlock, LocalRelativeObjectIdentifierValueBlock, _a$l, RelativeObjectIdentifier, _a$k, Sequence, _a$j, Set2, LocalStringValueBlock, LocalSimpleStringValueBlock, LocalSimpleStringBlock, LocalUtf8StringValueBlock, _a$i, Utf8String, LocalBmpStringValueBlock, _a$h, BmpString, LocalUniversalStringValueBlock, _a$g, UniversalString, _a$f, NumericString, _a$e, PrintableString, _a$d, TeletexString, _a$c, VideotexString, _a$b, IA5String, _a$a, GraphicString, _a$9, VisibleString, _a$8, GeneralString, _a$7, CharacterString, _a$6, UTCTime, _a$5, GeneralizedTime, _a$4, DATE, _a$3, TimeOfDay, _a$2, DateTime, _a$1, Duration, _a2, TIME, Any, Choice, Repeated, RawData;
var init_index_es = __esm({
  "node_modules/asn1js/build/index.es.js"() {
    pvtsutils = __toESM(require_build());
    init_utils_es();
    ViewWriter = class {
      constructor() {
        this.items = [];
      }
      write(buf) {
        this.items.push(buf);
      }
      final() {
        return concat2(this.items);
      }
    };
    powers2 = [new Uint8Array([1])];
    digitsString = "0123456789";
    NAME = "name";
    VALUE_HEX_VIEW = "valueHexView";
    IS_HEX_ONLY = "isHexOnly";
    ID_BLOCK = "idBlock";
    TAG_CLASS = "tagClass";
    TAG_NUMBER = "tagNumber";
    IS_CONSTRUCTED = "isConstructed";
    FROM_BER = "fromBER";
    TO_BER = "toBER";
    LOCAL = "local";
    EMPTY_STRING = "";
    EMPTY_BUFFER = new ArrayBuffer(0);
    EMPTY_VIEW = new Uint8Array(0);
    END_OF_CONTENT_NAME = "EndOfContent";
    OCTET_STRING_NAME = "OCTET STRING";
    BIT_STRING_NAME = "BIT STRING";
    LocalBaseBlock = class {
      constructor({ blockLength = 0, error: error2 = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
        this.blockLength = blockLength;
        this.error = error2;
        this.warnings = warnings;
        this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);
      }
      static blockName() {
        return this.NAME;
      }
      get valueBeforeDecode() {
        return this.valueBeforeDecodeView.slice().buffer;
      }
      set valueBeforeDecode(value) {
        this.valueBeforeDecodeView = new Uint8Array(value);
      }
      toJSON() {
        return {
          blockName: this.constructor.NAME,
          blockLength: this.blockLength,
          error: this.error,
          warnings: this.warnings,
          valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView)
        };
      }
    };
    LocalBaseBlock.NAME = "baseBlock";
    ValueBlock = class extends LocalBaseBlock {
      fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
      toBER(sizeOnly, writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
    };
    ValueBlock.NAME = "valueBlock";
    LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
      constructor({ idBlock = {} } = {}) {
        var _a3, _b, _c, _d;
        super();
        if (idBlock) {
          this.isHexOnly = (_a3 = idBlock.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
          this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
          this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
          this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
          this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
        } else {
          this.tagClass = -1;
          this.tagNumber = -1;
          this.isConstructed = false;
        }
      }
      toBER(sizeOnly = false) {
        let firstOctet = 0;
        switch (this.tagClass) {
          case 1:
            firstOctet |= 0;
            break;
          case 2:
            firstOctet |= 64;
            break;
          case 3:
            firstOctet |= 128;
            break;
          case 4:
            firstOctet |= 192;
            break;
          default:
            this.error = "Unknown tag class";
            return EMPTY_BUFFER;
        }
        if (this.isConstructed)
          firstOctet |= 32;
        if (this.tagNumber < 31 && !this.isHexOnly) {
          const retView2 = new Uint8Array(1);
          if (!sizeOnly) {
            let number = this.tagNumber;
            number &= 31;
            firstOctet |= number;
            retView2[0] = firstOctet;
          }
          return retView2.buffer;
        }
        if (!this.isHexOnly) {
          const encodedBuf = utilToBase(this.tagNumber, 7);
          const encodedView = new Uint8Array(encodedBuf);
          const size = encodedBuf.byteLength;
          const retView2 = new Uint8Array(size + 1);
          retView2[0] = firstOctet | 31;
          if (!sizeOnly) {
            for (let i9 = 0; i9 < size - 1; i9++)
              retView2[i9 + 1] = encodedView[i9] | 128;
            retView2[size] = encodedView[size - 1];
          }
          return retView2.buffer;
        }
        const retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = firstOctet | 31;
        if (!sizeOnly) {
          const curView = this.valueHexView;
          for (let i9 = 0; i9 < curView.length - 1; i9++)
            retView[i9 + 1] = curView[i9] | 128;
          retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        const tagClassMask = intBuffer[0] & 192;
        switch (tagClassMask) {
          case 0:
            this.tagClass = 1;
            break;
          case 64:
            this.tagClass = 2;
            break;
          case 128:
            this.tagClass = 3;
            break;
          case 192:
            this.tagClass = 4;
            break;
          default:
            this.error = "Unknown tag class";
            return -1;
        }
        this.isConstructed = (intBuffer[0] & 32) === 32;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 31;
        if (tagNumberMask !== 31) {
          this.tagNumber = tagNumberMask;
          this.blockLength = 1;
        } else {
          let count = 1;
          let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
          let tagNumberBufferMaxLength = 255;
          while (intBuffer[count] & 128) {
            intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
            count++;
            if (count >= intBuffer.length) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
            }
            if (count === tagNumberBufferMaxLength) {
              tagNumberBufferMaxLength += 255;
              const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
              for (let i9 = 0; i9 < intTagNumberBuffer.length; i9++)
                tempBufferView2[i9] = intTagNumberBuffer[i9];
              intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
            }
          }
          this.blockLength = count + 1;
          intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
          const tempBufferView = new Uint8Array(count);
          for (let i9 = 0; i9 < count; i9++)
            tempBufferView[i9] = intTagNumberBuffer[i9];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
          intTagNumberBuffer.set(tempBufferView);
          if (this.blockLength <= 9)
            this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
          else {
            this.isHexOnly = true;
            this.warnings.push("Tag too long, represented as hex-coded");
          }
        }
        if (this.tagClass === 1 && this.isConstructed) {
          switch (this.tagNumber) {
            case 1:
            case 2:
            case 5:
            case 6:
            case 9:
            case 13:
            case 14:
            case 23:
            case 24:
            case 31:
            case 32:
            case 33:
            case 34:
              this.error = "Constructed encoding used for primitive type";
              return -1;
          }
        }
        return inputOffset + this.blockLength;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          tagClass: this.tagClass,
          tagNumber: this.tagNumber,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalIdentificationBlock.NAME = "identificationBlock";
    LocalLengthBlock = class extends LocalBaseBlock {
      constructor({ lenBlock = {} } = {}) {
        var _a3, _b, _c;
        super();
        this.isIndefiniteForm = (_a3 = lenBlock.isIndefiniteForm) !== null && _a3 !== void 0 ? _a3 : false;
        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        if (intBuffer[0] === 255) {
          this.error = "Length block 0xFF is reserved by standard";
          return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 128;
        if (this.isIndefiniteForm) {
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 128);
        if (this.longFormUsed === false) {
          this.length = intBuffer[0];
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        const count = intBuffer[0] & 127;
        if (count > 8) {
          this.error = "Too big integer";
          return -1;
        }
        if (count + 1 > intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        const lenOffset = inputOffset + 1;
        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0)
          this.warnings.push("Needlessly long encoded length");
        this.length = utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127)
          this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127)
          this.longFormUsed = true;
        if (this.isIndefiniteForm) {
          retBuf = new ArrayBuffer(1);
          if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = 128;
          }
          return retBuf;
        }
        if (this.longFormUsed) {
          const encodedBuf = utilToBase(this.length, 8);
          if (encodedBuf.byteLength > 127) {
            this.error = "Too big length";
            return EMPTY_BUFFER;
          }
          retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
          if (sizeOnly)
            return retBuf;
          const encodedView = new Uint8Array(encodedBuf);
          retView = new Uint8Array(retBuf);
          retView[0] = encodedBuf.byteLength | 128;
          for (let i9 = 0; i9 < encodedBuf.byteLength; i9++)
            retView[i9 + 1] = encodedView[i9];
          return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
          retView = new Uint8Array(retBuf);
          retView[0] = this.length;
        }
        return retBuf;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          longFormUsed: this.longFormUsed,
          length: this.length
        };
      }
    };
    LocalLengthBlock.NAME = "lengthBlock";
    typeStore = {};
    BaseBlock = class extends LocalBaseBlock {
      constructor({ name: name2 = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
        super(parameters);
        this.name = name2;
        this.optional = optional;
        if (primitiveSchema) {
          this.primitiveSchema = primitiveSchema;
        }
        this.idBlock = new LocalIdentificationBlock(parameters);
        this.lenBlock = new LocalLengthBlock(parameters);
        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        if (!writer) {
          prepareIndefiniteForm(this);
        }
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
          _writer.write(new Uint8Array([128]).buffer);
          this.valueBlock.toBER(sizeOnly, _writer);
          _writer.write(new ArrayBuffer(2));
        } else {
          const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
          this.lenBlock.length = valueBlockBuf.byteLength;
          const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
          _writer.write(lenBlockBuf);
          _writer.write(valueBlockBuf);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          idBlock: this.idBlock.toJSON(),
          lenBlock: this.lenBlock.toJSON(),
          valueBlock: this.valueBlock.toJSON(),
          name: this.name,
          optional: this.optional
        };
        if (this.primitiveSchema)
          object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
      }
      toString(encoding = "ascii") {
        if (encoding === "ascii") {
          return this.onAsciiEncoding();
        }
        return pvtsutils.Convert.ToHex(this.toBER());
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
      }
      isEqual(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof this.constructor)) {
          return false;
        }
        const thisRaw = this.toBER();
        const otherRaw = other.toBER();
        return isEqualBuffer(thisRaw, otherRaw);
      }
    };
    BaseBlock.NAME = "BaseBlock";
    BaseStringBlock = class extends BaseBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
        super(parameters, stringValueBlockType);
        if (value) {
          this.fromString(value);
        }
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value) {
        this.valueBlock.value = value;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
      }
    };
    BaseStringBlock.NAME = "BaseStringBlock";
    LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ isHexOnly = true, ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = isHexOnly;
      }
    };
    LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
    Primitive = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
      }
    };
    _a$w = Primitive;
    (() => {
      typeStore.Primitive = _a$w;
    })();
    Primitive.NAME = "PRIMITIVE";
    LocalConstructedValueBlock = class extends ValueBlock {
      constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
        super(parameters);
        this.value = value;
        this.isIndefiniteForm = isIndefiniteForm;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
          this.warnings.push("Zero buffer length");
          return inputOffset;
        }
        let currentOffset = inputOffset;
        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
          const returnObject = localFromBER(view, currentOffset, inputLength);
          if (returnObject.offset === -1) {
            this.error = returnObject.result.error;
            this.warnings.concat(returnObject.result.warnings);
            return -1;
          }
          currentOffset = returnObject.offset;
          this.blockLength += returnObject.result.blockLength;
          inputLength -= returnObject.result.blockLength;
          this.value.push(returnObject.result);
          if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
            break;
          }
        }
        if (this.isIndefiniteForm) {
          if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
            this.value.pop();
          } else {
            this.warnings.push("No EndOfContent block encoded");
          }
        }
        return currentOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        for (let i9 = 0; i9 < this.value.length; i9++) {
          this.value[i9].toBER(sizeOnly, _writer);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          value: []
        };
        for (const value of this.value) {
          object.value.push(value.toJSON());
        }
        return object;
      }
    };
    LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
    Constructed = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        const values = [];
        for (const value of this.valueBlock.value) {
          values.push(value.toString("ascii").split("\n").map((o7) => `  ${o7}`).join("\n"));
        }
        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
        return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
      }
    };
    _a$v = Constructed;
    (() => {
      typeStore.Constructed = _a$v;
    })();
    Constructed.NAME = "CONSTRUCTED";
    LocalEndOfContentValueBlock = class extends ValueBlock {
      fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
      }
      toBER(sizeOnly) {
        return EMPTY_BUFFER;
      }
    };
    LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
    EndOfContent = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
      }
    };
    _a$u = EndOfContent;
    (() => {
      typeStore.EndOfContent = _a$u;
    })();
    EndOfContent.NAME = END_OF_CONTENT_NAME;
    Null = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, ValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0)
          this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
          this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
          return -1;
        }
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        const retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
          const retView = new Uint8Array(retBuf);
          retView[0] = 5;
          retView[1] = 0;
        }
        if (writer) {
          writer.write(retBuf);
        }
        return retBuf;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME}`;
      }
    };
    _a$t = Null;
    (() => {
      typeStore.Null = _a$t;
    })();
    Null.NAME = "NULL";
    LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ value, ...parameters } = {}) {
        super(parameters);
        if (parameters.valueHex) {
          this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);
        } else {
          this.valueHexView = new Uint8Array(1);
        }
        if (value) {
          this.value = value;
        }
      }
      get value() {
        for (const octet of this.valueHexView) {
          if (octet > 0) {
            return true;
          }
        }
        return false;
      }
      set value(value) {
        this.valueHexView[0] = value ? 255 : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1)
          this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return inputOffset + inputLength;
      }
      toBER() {
        return this.valueHexView.slice();
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalBooleanValueBlock.NAME = "BooleanValueBlock";
    Boolean2 = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value) {
        this.valueBlock.value = value;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.getValue}`;
      }
    };
    _a$s = Boolean2;
    (() => {
      typeStore.Boolean = _a$s;
    })();
    Boolean2.NAME = "BOOLEAN";
    LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      constructor({ isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.isConstructed = isConstructed;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed) {
          this.isHexOnly = false;
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (let i9 = 0; i9 < this.value.length; i9++) {
            const currentBlockName = this.value[i9].constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== OCTET_STRING_NAME) {
              this.error = "OCTET STRING may consists of OCTET STRINGs only";
              return -1;
            }
          }
        } else {
          this.isHexOnly = true;
          resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
          this.blockLength = inputLength;
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed)
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isConstructed: this.isConstructed
        };
      }
    };
    LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
    OctetString = class _OctetString extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters.isIndefiniteForm
          },
          ...parameters
        }, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
          if (this.idBlock.error.length === 0)
            this.blockLength += this.idBlock.blockLength;
          if (this.lenBlock.error.length === 0)
            this.blockLength += this.lenBlock.blockLength;
          return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
          const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          const buf = view.subarray(inputOffset, inputOffset + inputLength);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength) {
                this.valueBlock.value = [asn.result];
              }
            }
          } catch (e5) {
          }
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        }
        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;
      }
      getValue() {
        if (!this.idBlock.isConstructed) {
          return this.valueBlock.valueHexView.slice().buffer;
        }
        const array2 = [];
        for (const content of this.valueBlock.value) {
          if (content instanceof _OctetString) {
            array2.push(content.valueBlock.valueHexView);
          }
        }
        return pvtsutils.BufferSourceConverter.concat(array2);
      }
    };
    _a$r = OctetString;
    (() => {
      typeStore.OctetString = _a$r;
    })();
    OctetString.NAME = OCTET_STRING_NAME;
    LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.unusedBits = unusedBits;
        this.isConstructed = isConstructed;
        this.blockLength = this.valueHexView.byteLength;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        let resultOffset = -1;
        if (this.isConstructed) {
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (const value of this.value) {
            const currentBlockName = value.constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== BIT_STRING_NAME) {
              this.error = "BIT STRING may consists of BIT STRINGs only";
              return -1;
            }
            const valueBlock = value.valueBlock;
            if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
              this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
              return -1;
            }
            this.unusedBits = valueBlock.unusedBits;
          }
          return resultOffset;
        }
        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
          this.error = "Unused bits for BitString must be in range 0-7";
          return -1;
        }
        if (!this.unusedBits) {
          const buf = intBuffer.subarray(1);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength - 1) {
                this.value = [asn.result];
              }
            }
          } catch (e5) {
          }
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed) {
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        }
        if (sizeOnly) {
          return new ArrayBuffer(this.valueHexView.byteLength + 1);
        }
        if (!this.valueHexView.byteLength) {
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          unusedBits: this.unusedBits,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalBitStringValueBlock.NAME = "BitStringValueBlock";
    BitString = class extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters.isIndefiniteForm
          },
          ...parameters
        }, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        } else {
          const bits = [];
          const valueHex = this.valueBlock.valueHexView;
          for (const byte of valueHex) {
            bits.push(byte.toString(2).padStart(8, "0"));
          }
          const bitsStr = bits.join("");
          return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
        }
      }
    };
    _a$q = BitString;
    (() => {
      typeStore.BitString = _a$q;
    })();
    BitString.NAME = BIT_STRING_NAME;
    LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ value, ...parameters } = {}) {
        super(parameters);
        this._valueDec = 0;
        if (parameters.valueHex) {
          this.setValueHex();
        }
        if (value !== void 0) {
          this.valueDec = value;
        }
      }
      setValueHex() {
        if (this.valueHexView.length >= 4) {
          this.warnings.push("Too big Integer for decoding, hex only");
          this.isHexOnly = true;
          this._valueDec = 0;
        } else {
          this.isHexOnly = false;
          if (this.valueHexView.length > 0) {
            this._valueDec = utilDecodeTC.call(this);
          }
        }
      }
      set valueDec(v5) {
        this._valueDec = v5;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(utilEncodeTC(v5));
      }
      get valueDec() {
        return this._valueDec;
      }
      fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1)
          return offset;
        const view = this.valueHexView;
        if (view[0] === 0 && (view[1] & 128) !== 0) {
          this.valueHexView = view.subarray(1);
        } else {
          if (expectedLength !== 0) {
            if (view.length < expectedLength) {
              if (expectedLength - view.length > 1)
                expectedLength = view.length + 1;
              this.valueHexView = view.subarray(expectedLength - view.length);
            }
          }
        }
        return offset;
      }
      toDER(sizeOnly = false) {
        const view = this.valueHexView;
        switch (true) {
          case (view[0] & 128) !== 0:
            {
              const updatedView = new Uint8Array(this.valueHexView.length + 1);
              updatedView[0] = 0;
              updatedView.set(view, 1);
              this.valueHexView = updatedView;
            }
            break;
          case (view[0] === 0 && (view[1] & 128) === 0):
            {
              this.valueHexView = this.valueHexView.subarray(1);
            }
            break;
        }
        return this.toBER(sizeOnly);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) {
          return resultOffset;
        }
        this.setValueHex();
        return resultOffset;
      }
      toBER(sizeOnly) {
        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
      toString() {
        const firstBit = this.valueHexView.length * 8 - 1;
        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = this.valueHexView;
        let result = "";
        let flag = false;
        for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
          currentByte = asn1View[byteNumber];
          for (let i9 = 0; i9 < 8; i9++) {
            if ((currentByte & 1) === 1) {
              switch (bitNumber) {
                case firstBit:
                  digits = viewSub(power2(bitNumber), digits);
                  result = "-";
                  break;
                default:
                  digits = viewAdd(digits, power2(bitNumber));
              }
            }
            bitNumber++;
            currentByte >>= 1;
          }
        }
        for (let i9 = 0; i9 < digits.length; i9++) {
          if (digits[i9])
            flag = true;
          if (flag)
            result += digitsString.charAt(digits[i9]);
        }
        if (flag === false)
          result += digitsString.charAt(0);
        return result;
      }
    };
    _a$p = LocalIntegerValueBlock;
    LocalIntegerValueBlock.NAME = "IntegerValueBlock";
    (() => {
      Object.defineProperty(_a$p.prototype, "valueHex", {
        set: function(v5) {
          this.valueHexView = new Uint8Array(v5);
          this.setValueHex();
        },
        get: function() {
          return this.valueHexView.slice().buffer;
        }
      });
    })();
    Integer = class _Integer extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
      }
      toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
      }
      static fromBigInt(value) {
        assertBigInt();
        const bigIntValue = BigInt(value);
        const writer = new ViewWriter();
        const hex = bigIntValue.toString(16).replace(/^-/, "");
        const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));
        if (bigIntValue < 0) {
          const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
          first[0] |= 128;
          const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first)}`);
          const secondInt = firstInt + bigIntValue;
          const second = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));
          second[0] |= 128;
          writer.write(second);
        } else {
          if (view[0] & 128) {
            writer.write(new Uint8Array([0]));
          }
          writer.write(view);
        }
        const res = new _Integer({
          valueHex: writer.final()
        });
        return res;
      }
      convertToDER() {
        const integer = new _Integer({ valueHex: this.valueBlock.valueHexView });
        integer.valueBlock.toDER();
        return integer;
      }
      convertFromDER() {
        return new _Integer({
          valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
        });
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
      }
    };
    _a$o = Integer;
    (() => {
      typeStore.Integer = _a$o;
    })();
    Integer.NAME = "INTEGER";
    Enumerated = class extends Integer {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
      }
    };
    _a$n = Enumerated;
    (() => {
      typeStore.Enumerated = _a$n;
    })();
    Enumerated.NAME = "ENUMERATED";
    LocalSidValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
        this.isFirstSid = isFirstSid;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i9 = 0; i9 < inputLength; i9++) {
          this.valueHexView[i9] = intBuffer[i9] & 127;
          this.blockLength++;
          if ((intBuffer[i9] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i9 = 0; i9 < this.blockLength; i9++) {
          tempView[i9] = this.valueHexView[i9];
        }
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      set valueBigInt(value) {
        assertBigInt();
        let bits = BigInt(value).toString(2);
        while (bits.length % 7) {
          bits = "0" + bits;
        }
        const bytes = new Uint8Array(bits.length / 7);
        for (let i9 = 0; i9 < bytes.length; i9++) {
          bytes[i9] = parseInt(bits.slice(i9 * 7, i9 * 7 + 7), 2) + (i9 + 1 < bytes.length ? 128 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i9 = 0; i9 < this.blockLength - 1; i9++)
            retView2[i9] = curView[i9] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i9 = 0; i9 < len; i9++)
            retView[i9] = encodedView[i9] | 128;
          retView[len] = encodedView[len];
        }
        return retView;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = pvtsutils.Convert.ToHex(this.valueHexView);
        else {
          if (this.isFirstSid) {
            let sidValue = this.valueDec;
            if (this.valueDec <= 39)
              result = "0.";
            else {
              if (this.valueDec <= 79) {
                result = "1.";
                sidValue -= 40;
              } else {
                result = "2.";
                sidValue -= 80;
              }
            }
            result += sidValue.toString();
          } else
            result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec,
          isFirstSid: this.isFirstSid
        };
      }
    };
    LocalSidValueBlock.NAME = "sidBlock";
    LocalObjectIdentifierValueBlock = class extends ValueBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value) {
          this.fromString(value);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          if (this.value.length === 0)
            sidBlock.isFirstSid = true;
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly) {
        const retBuffers = [];
        for (let i9 = 0; i9 < this.value.length; i9++) {
          const valueBuf = this.value[i9].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i9].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat2(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          if (flag) {
            const sidBlock = this.value[0];
            let plus = 0;
            switch (sidBlock.valueDec) {
              case 0:
                break;
              case 1:
                plus = 40;
                break;
              case 2:
                plus = 80;
                break;
              default:
                this.value = [];
                return;
            }
            const parsedSID = parseInt(sid, 10);
            if (isNaN(parsedSID))
              return;
            sidBlock.valueDec = parsedSID + plus;
            flag = false;
          } else {
            const sidBlock = new LocalSidValueBlock();
            if (sid > Number.MAX_SAFE_INTEGER) {
              assertBigInt();
              const sidValue = BigInt(sid);
              sidBlock.valueBigInt = sidValue;
            } else {
              sidBlock.valueDec = parseInt(sid, 10);
              if (isNaN(sidBlock.valueDec))
                return;
            }
            if (!this.value.length) {
              sidBlock.isFirstSid = true;
              flag = true;
            }
            this.value.push(sidBlock);
          }
        } while (pos2 !== -1);
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i9 = 0; i9 < this.value.length; i9++) {
          isHexOnly = this.value[i9].isHexOnly;
          let sidStr = this.value[i9].toString();
          if (i9 !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            if (this.value[i9].isFirstSid)
              result = `2.{${sidStr} - 80}`;
            else
              result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i9 = 0; i9 < this.value.length; i9++) {
          object.sidArray.push(this.value[i9].toJSON());
        }
        return object;
      }
    };
    LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
    ObjectIdentifier = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value) {
        this.valueBlock.fromString(value);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$m = ObjectIdentifier;
    (() => {
      typeStore.ObjectIdentifier = _a$m;
    })();
    ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
    LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
      constructor({ valueDec = 0, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0)
          return inputOffset;
        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength))
          return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i9 = 0; i9 < inputLength; i9++) {
          this.valueHexView[i9] = intBuffer[i9] & 127;
          this.blockLength++;
          if ((intBuffer[i9] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i9 = 0; i9 < this.blockLength; i9++)
          tempView[i9] = this.valueHexView[i9];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i9 = 0; i9 < this.blockLength - 1; i9++)
            retView2[i9] = curView[i9] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i9 = 0; i9 < len; i9++)
            retView[i9] = encodedView[i9] | 128;
          retView[len] = encodedView[len];
        }
        return retView.buffer;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = pvtsutils.Convert.ToHex(this.valueHexView);
        else {
          result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
    };
    LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
    LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value) {
          this.fromString(value);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalRelativeSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const retBuffers = [];
        for (let i9 = 0; i9 < this.value.length; i9++) {
          const valueBuf = this.value[i9].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i9].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat2(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          const sidBlock = new LocalRelativeSidValueBlock();
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return true;
          this.value.push(sidBlock);
        } while (pos2 !== -1);
        return true;
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i9 = 0; i9 < this.value.length; i9++) {
          isHexOnly = this.value[i9].isHexOnly;
          let sidStr = this.value[i9].toString();
          if (i9 !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i9 = 0; i9 < this.value.length; i9++)
          object.sidArray.push(this.value[i9].toJSON());
        return object;
      }
    };
    LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
    RelativeObjectIdentifier = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value) {
        this.valueBlock.fromString(value);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$l = RelativeObjectIdentifier;
    (() => {
      typeStore.RelativeObjectIdentifier = _a$l;
    })();
    RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
    Sequence = class extends Constructed {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
      }
    };
    _a$k = Sequence;
    (() => {
      typeStore.Sequence = _a$k;
    })();
    Sequence.NAME = "SEQUENCE";
    Set2 = class extends Constructed {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
      }
    };
    _a$j = Set2;
    (() => {
      typeStore.Set = _a$j;
    })();
    Set2.NAME = "SET";
    LocalStringValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = true;
        this.value = EMPTY_STRING;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalStringValueBlock.NAME = "StringValueBlock";
    LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
    };
    LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
    LocalSimpleStringBlock = class extends BaseStringBlock {
      constructor({ ...parameters } = {}) {
        super(parameters, LocalSimpleStringValueBlock);
      }
      fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));
      }
      fromString(inputString) {
        const strLen = inputString.length;
        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for (let i9 = 0; i9 < strLen; i9++)
          view[i9] = inputString.charCodeAt(i9);
        this.valueBlock.value = inputString;
      }
    };
    LocalSimpleStringBlock.NAME = "SIMPLE STRING";
    LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        try {
          this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);
        } catch (ex) {
          this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
          this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);
        }
      }
      fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
      }
    };
    LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
    Utf8String = class extends LocalUtf8StringValueBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
      }
    };
    _a$i = Utf8String;
    (() => {
      typeStore.Utf8String = _a$i;
    })();
    Utf8String.NAME = "UTF8String";
    LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      }
      fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));
      }
    };
    LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
    BmpString = class extends LocalBmpStringValueBlock {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
      }
    };
    _a$h = BmpString;
    (() => {
      typeStore.BmpString = _a$h;
    })();
    BmpString.NAME = "BMPString";
    LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for (let i9 = 0; i9 < valueView.length; i9 += 4) {
          valueView[i9] = valueView[i9 + 3];
          valueView[i9 + 1] = valueView[i9 + 2];
          valueView[i9 + 2] = 0;
          valueView[i9 + 3] = 0;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
      }
      fromString(inputString) {
        const strLength = inputString.length;
        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for (let i9 = 0; i9 < strLength; i9++) {
          const codeBuf = utilToBase(inputString.charCodeAt(i9), 8);
          const codeView = new Uint8Array(codeBuf);
          if (codeView.length > 4)
            continue;
          const dif = 4 - codeView.length;
          for (let j4 = codeView.length - 1; j4 >= 0; j4--)
            valueHexView[i9 * 4 + j4 + dif] = codeView[j4];
        }
        this.valueBlock.value = inputString;
      }
    };
    LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
    UniversalString = class extends LocalUniversalStringValueBlock {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
      }
    };
    _a$g = UniversalString;
    (() => {
      typeStore.UniversalString = _a$g;
    })();
    UniversalString.NAME = "UniversalString";
    NumericString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
      }
    };
    _a$f = NumericString;
    (() => {
      typeStore.NumericString = _a$f;
    })();
    NumericString.NAME = "NumericString";
    PrintableString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
      }
    };
    _a$e = PrintableString;
    (() => {
      typeStore.PrintableString = _a$e;
    })();
    PrintableString.NAME = "PrintableString";
    TeletexString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
      }
    };
    _a$d = TeletexString;
    (() => {
      typeStore.TeletexString = _a$d;
    })();
    TeletexString.NAME = "TeletexString";
    VideotexString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
      }
    };
    _a$c = VideotexString;
    (() => {
      typeStore.VideotexString = _a$c;
    })();
    VideotexString.NAME = "VideotexString";
    IA5String = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
      }
    };
    _a$b = IA5String;
    (() => {
      typeStore.IA5String = _a$b;
    })();
    IA5String.NAME = "IA5String";
    GraphicString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
      }
    };
    _a$a = GraphicString;
    (() => {
      typeStore.GraphicString = _a$a;
    })();
    GraphicString.NAME = "GraphicString";
    VisibleString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
      }
    };
    _a$9 = VisibleString;
    (() => {
      typeStore.VisibleString = _a$9;
    })();
    VisibleString.NAME = "VisibleString";
    GeneralString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
      }
    };
    _a$8 = GeneralString;
    (() => {
      typeStore.GeneralString = _a$8;
    })();
    GeneralString.NAME = "GeneralString";
    CharacterString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
      }
    };
    _a$7 = CharacterString;
    (() => {
      typeStore.CharacterString = _a$7;
    })();
    CharacterString.NAME = "CharacterString";
    UTCTime = class extends VisibleString {
      constructor({ value, valueDate, ...parameters } = {}) {
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if (value) {
          this.fromString(value);
          this.valueBlock.valueHexView = new Uint8Array(value.length);
          for (let i9 = 0; i9 < value.length; i9++)
            this.valueBlock.valueHexView[i9] = value.charCodeAt(i9);
        }
        if (valueDate) {
          this.fromDate(valueDate);
          this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
      }
      fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));
      }
      toBuffer() {
        const str2 = this.toString();
        const buffer = new ArrayBuffer(str2.length);
        const view = new Uint8Array(buffer);
        for (let i9 = 0; i9 < str2.length; i9++)
          view[i9] = str2.charCodeAt(i9);
        return buffer;
      }
      fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
      }
      fromString(inputString) {
        const parser2 = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser2.exec(inputString);
        if (parserArray === null) {
          this.error = "Wrong input string for conversion";
          return;
        }
        const year2 = parseInt(parserArray[1], 10);
        if (year2 >= 50)
          this.year = 1900 + year2;
        else
          this.year = 2e3 + year2;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = new Array(7);
          outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
          outputArray[1] = padNumber(this.month, 2);
          outputArray[2] = padNumber(this.day, 2);
          outputArray[3] = padNumber(this.hour, 2);
          outputArray[4] = padNumber(this.minute, 2);
          outputArray[5] = padNumber(this.second, 2);
          outputArray[6] = "Z";
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second
        };
      }
    };
    _a$6 = UTCTime;
    (() => {
      typeStore.UTCTime = _a$6;
    })();
    UTCTime.NAME = "UTCTime";
    GeneralizedTime = class extends UTCTime {
      constructor(parameters = {}) {
        var _b;
        super(parameters);
        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
      }
      fromDate(inputDate) {
        super.fromDate(inputDate);
        this.millisecond = inputDate.getUTCMilliseconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
      }
      fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser2;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
          timeString = inputString.substring(0, inputString.length - 1);
          isUTC = true;
        } else {
          const number = new Number(inputString[inputString.length - 1]);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          timeString = inputString;
        }
        if (isUTC) {
          if (timeString.indexOf("+") !== -1)
            throw new Error("Wrong input string for conversion");
          if (timeString.indexOf("-") !== -1)
            throw new Error("Wrong input string for conversion");
        } else {
          let multiplier = 1;
          let differencePosition = timeString.indexOf("+");
          let differenceString = "";
          if (differencePosition === -1) {
            differencePosition = timeString.indexOf("-");
            multiplier = -1;
          }
          if (differencePosition !== -1) {
            differenceString = timeString.substring(differencePosition + 1);
            timeString = timeString.substring(0, differencePosition);
            if (differenceString.length !== 2 && differenceString.length !== 4)
              throw new Error("Wrong input string for conversion");
            let number = parseInt(differenceString.substring(0, 2), 10);
            if (isNaN(number.valueOf()))
              throw new Error("Wrong input string for conversion");
            hourDifference = multiplier * number;
            if (differenceString.length === 4) {
              number = parseInt(differenceString.substring(2, 4), 10);
              if (isNaN(number.valueOf()))
                throw new Error("Wrong input string for conversion");
              minuteDifference = multiplier * number;
            }
          }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1)
          fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
          const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
          if (isNaN(fractionPartCheck.valueOf()))
            throw new Error("Wrong input string for conversion");
          fractionPart = fractionPartCheck.valueOf();
          dateTimeString = timeString.substring(0, fractionPointPosition);
        } else
          dateTimeString = timeString;
        switch (true) {
          case dateTimeString.length === 8:
            parser2 = /(\d{4})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1)
              throw new Error("Wrong input string for conversion");
            break;
          case dateTimeString.length === 10:
            parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.minute = Math.floor(fractionResult);
              fractionResult = 60 * (fractionResult - this.minute);
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 12:
            parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 14:
            parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              const fractionResult = 1e3 * fractionPart;
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          default:
            throw new Error("Wrong input string for conversion");
        }
        const parserArray = parser2.exec(dateTimeString);
        if (parserArray === null)
          throw new Error("Wrong input string for conversion");
        for (let j4 = 1; j4 < parserArray.length; j4++) {
          switch (j4) {
            case 1:
              this.year = parseInt(parserArray[j4], 10);
              break;
            case 2:
              this.month = parseInt(parserArray[j4], 10);
              break;
            case 3:
              this.day = parseInt(parserArray[j4], 10);
              break;
            case 4:
              this.hour = parseInt(parserArray[j4], 10) + hourDifference;
              break;
            case 5:
              this.minute = parseInt(parserArray[j4], 10) + minuteDifference;
              break;
            case 6:
              this.second = parseInt(parserArray[j4], 10);
              break;
            default:
              throw new Error("Wrong input string for conversion");
          }
        }
        if (isUTC === false) {
          const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
          this.year = tempDate.getUTCFullYear();
          this.month = tempDate.getUTCMonth();
          this.day = tempDate.getUTCDay();
          this.hour = tempDate.getUTCHours();
          this.minute = tempDate.getUTCMinutes();
          this.second = tempDate.getUTCSeconds();
          this.millisecond = tempDate.getUTCMilliseconds();
        }
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = [];
          outputArray.push(padNumber(this.year, 4));
          outputArray.push(padNumber(this.month, 2));
          outputArray.push(padNumber(this.day, 2));
          outputArray.push(padNumber(this.hour, 2));
          outputArray.push(padNumber(this.minute, 2));
          outputArray.push(padNumber(this.second, 2));
          if (this.millisecond !== 0) {
            outputArray.push(".");
            outputArray.push(padNumber(this.millisecond, 3));
          }
          outputArray.push("Z");
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          millisecond: this.millisecond
        };
      }
    };
    _a$5 = GeneralizedTime;
    (() => {
      typeStore.GeneralizedTime = _a$5;
    })();
    GeneralizedTime.NAME = "GeneralizedTime";
    DATE = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
      }
    };
    _a$4 = DATE;
    (() => {
      typeStore.DATE = _a$4;
    })();
    DATE.NAME = "DATE";
    TimeOfDay = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
      }
    };
    _a$3 = TimeOfDay;
    (() => {
      typeStore.TimeOfDay = _a$3;
    })();
    TimeOfDay.NAME = "TimeOfDay";
    DateTime = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
      }
    };
    _a$2 = DateTime;
    (() => {
      typeStore.DateTime = _a$2;
    })();
    DateTime.NAME = "DateTime";
    Duration = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
      }
    };
    _a$1 = Duration;
    (() => {
      typeStore.Duration = _a$1;
    })();
    Duration.NAME = "Duration";
    TIME = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
      }
    };
    _a2 = TIME;
    (() => {
      typeStore.TIME = _a2;
    })();
    TIME.NAME = "TIME";
    Any = class {
      constructor({ name: name2 = EMPTY_STRING, optional = false } = {}) {
        this.name = name2;
        this.optional = optional;
      }
    };
    Choice = class extends Any {
      constructor({ value = [], ...parameters } = {}) {
        super(parameters);
        this.value = value;
      }
    };
    Repeated = class extends Any {
      constructor({ value = new Any(), local = false, ...parameters } = {}) {
        super(parameters);
        this.value = value;
        this.local = local;
      }
    };
    RawData = class {
      constructor({ data = EMPTY_VIEW } = {}) {
        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(data);
      }
      get data() {
        return this.dataView.slice().buffer;
      }
      set data(value) {
        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(value);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const endLength = inputOffset + inputLength;
        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
      }
      toBER(sizeOnly) {
        return this.dataView.slice().buffer;
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes, AsnPropTypes;
var init_enums = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/enums.js"() {
    (function(AsnTypeTypes2) {
      AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
      AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
      AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
    })(AsnTypeTypes || (AsnTypeTypes = {}));
    (function(AsnPropTypes2) {
      AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
      AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
      AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
      AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
      AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
      AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
      AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
      AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
      AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
      AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
      AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
      AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
      AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
      AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
      AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
      AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
      AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
      AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
      AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
      AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
      AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
      AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
      AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
      AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
      AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
      AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
      AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
    })(AsnPropTypes || (AsnPropTypes = {}));
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
var import_pvtsutils, BitString2;
var init_bit_string = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js"() {
    init_index_es();
    import_pvtsutils = __toESM(require_build());
    BitString2 = class {
      constructor(params, unusedBits = 0) {
        this.unusedBits = 0;
        this.value = new ArrayBuffer(0);
        if (params) {
          if (typeof params === "number") {
            this.fromNumber(params);
          } else if (import_pvtsutils.BufferSourceConverter.isBufferSource(params)) {
            this.unusedBits = unusedBits;
            this.value = import_pvtsutils.BufferSourceConverter.toArrayBuffer(params);
          } else {
            throw TypeError("Unsupported type of 'params' argument for BitString");
          }
        }
      }
      fromASN(asn) {
        if (!(asn instanceof BitString)) {
          throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
        }
        this.unusedBits = asn.valueBlock.unusedBits;
        this.value = asn.valueBlock.valueHex;
        return this;
      }
      toASN() {
        return new BitString({ unusedBits: this.unusedBits, valueHex: this.value });
      }
      toSchema(name2) {
        return new BitString({ name: name2 });
      }
      toNumber() {
        let res = "";
        const uintArray = new Uint8Array(this.value);
        for (const octet of uintArray) {
          res += octet.toString(2).padStart(8, "0");
        }
        res = res.split("").reverse().join("");
        if (this.unusedBits) {
          res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
        }
        return parseInt(res, 2);
      }
      fromNumber(value) {
        let bits = value.toString(2);
        const octetSize = bits.length + 7 >> 3;
        this.unusedBits = (octetSize << 3) - bits.length;
        const octets = new Uint8Array(octetSize);
        bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
        let index7 = 0;
        while (index7 < octetSize) {
          octets[index7] = parseInt(bits.slice(index7 << 3, (index7 << 3) + 8), 2);
          index7++;
        }
        this.value = octets.buffer;
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
var import_pvtsutils2, OctetString2;
var init_octet_string = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js"() {
    init_index_es();
    import_pvtsutils2 = __toESM(require_build());
    OctetString2 = class {
      get byteLength() {
        return this.buffer.byteLength;
      }
      get byteOffset() {
        return 0;
      }
      constructor(param) {
        if (typeof param === "number") {
          this.buffer = new ArrayBuffer(param);
        } else {
          if (import_pvtsutils2.BufferSourceConverter.isBufferSource(param)) {
            this.buffer = import_pvtsutils2.BufferSourceConverter.toArrayBuffer(param);
          } else if (Array.isArray(param)) {
            this.buffer = new Uint8Array(param);
          } else {
            this.buffer = new ArrayBuffer(0);
          }
        }
      }
      fromASN(asn) {
        if (!(asn instanceof OctetString)) {
          throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
        }
        this.buffer = asn.valueBlock.valueHex;
        return this;
      }
      toASN() {
        return new OctetString({ valueHex: this.buffer });
      }
      toSchema(name2) {
        return new OctetString({ name: name2 });
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/types/index.js
var init_types = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/types/index.js"() {
    init_bit_string();
    init_octet_string();
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/converters.js
function createStringConverter(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
function defaultConverter(type) {
  switch (type) {
    case AsnPropTypes.Any:
      return AsnAnyConverter;
    case AsnPropTypes.BitString:
      return AsnBitStringConverter;
    case AsnPropTypes.BmpString:
      return AsnBmpStringConverter;
    case AsnPropTypes.Boolean:
      return AsnBooleanConverter;
    case AsnPropTypes.CharacterString:
      return AsnCharacterStringConverter;
    case AsnPropTypes.Enumerated:
      return AsnEnumeratedConverter;
    case AsnPropTypes.GeneralString:
      return AsnGeneralStringConverter;
    case AsnPropTypes.GeneralizedTime:
      return AsnGeneralizedTimeConverter;
    case AsnPropTypes.GraphicString:
      return AsnGraphicStringConverter;
    case AsnPropTypes.IA5String:
      return AsnIA5StringConverter;
    case AsnPropTypes.Integer:
      return AsnIntegerConverter;
    case AsnPropTypes.Null:
      return AsnNullConverter;
    case AsnPropTypes.NumericString:
      return AsnNumericStringConverter;
    case AsnPropTypes.ObjectIdentifier:
      return AsnObjectIdentifierConverter;
    case AsnPropTypes.OctetString:
      return AsnOctetStringConverter;
    case AsnPropTypes.PrintableString:
      return AsnPrintableStringConverter;
    case AsnPropTypes.TeletexString:
      return AsnTeletexStringConverter;
    case AsnPropTypes.UTCTime:
      return AsnUTCTimeConverter;
    case AsnPropTypes.UniversalString:
      return AsnUniversalStringConverter;
    case AsnPropTypes.Utf8String:
      return AsnUtf8StringConverter;
    case AsnPropTypes.VideotexString:
      return AsnVideotexStringConverter;
    case AsnPropTypes.VisibleString:
      return AsnVisibleStringConverter;
    default:
      return null;
  }
}
var AsnAnyConverter, AsnIntegerConverter, AsnEnumeratedConverter, AsnIntegerArrayBufferConverter, AsnBitStringConverter, AsnObjectIdentifierConverter, AsnBooleanConverter, AsnOctetStringConverter, AsnUtf8StringConverter, AsnBmpStringConverter, AsnUniversalStringConverter, AsnNumericStringConverter, AsnPrintableStringConverter, AsnTeletexStringConverter, AsnVideotexStringConverter, AsnIA5StringConverter, AsnGraphicStringConverter, AsnVisibleStringConverter, AsnGeneralStringConverter, AsnCharacterStringConverter, AsnUTCTimeConverter, AsnGeneralizedTimeConverter, AsnNullConverter;
var init_converters = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/converters.js"() {
    init_index_es();
    init_enums();
    init_types();
    AsnAnyConverter = {
      fromASN: (value) => value instanceof Null ? null : value.valueBeforeDecodeView,
      toASN: (value) => {
        if (value === null) {
          return new Null();
        }
        const schema = fromBER(value);
        if (schema.result.error) {
          throw new Error(schema.result.error);
        }
        return schema.result;
      }
    };
    AsnIntegerConverter = {
      fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
      toASN: (value) => new Integer({ value: +value })
    };
    AsnEnumeratedConverter = {
      fromASN: (value) => value.valueBlock.valueDec,
      toASN: (value) => new Enumerated({ value })
    };
    AsnIntegerArrayBufferConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new Integer({ valueHex: value })
    };
    AsnBitStringConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new BitString({ valueHex: value })
    };
    AsnObjectIdentifierConverter = {
      fromASN: (value) => value.valueBlock.toString(),
      toASN: (value) => new ObjectIdentifier({ value })
    };
    AsnBooleanConverter = {
      fromASN: (value) => value.valueBlock.value,
      toASN: (value) => new Boolean2({ value })
    };
    AsnOctetStringConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new OctetString({ valueHex: value })
    };
    AsnUtf8StringConverter = createStringConverter(Utf8String);
    AsnBmpStringConverter = createStringConverter(BmpString);
    AsnUniversalStringConverter = createStringConverter(UniversalString);
    AsnNumericStringConverter = createStringConverter(NumericString);
    AsnPrintableStringConverter = createStringConverter(PrintableString);
    AsnTeletexStringConverter = createStringConverter(TeletexString);
    AsnVideotexStringConverter = createStringConverter(VideotexString);
    AsnIA5StringConverter = createStringConverter(IA5String);
    AsnGraphicStringConverter = createStringConverter(GraphicString);
    AsnVisibleStringConverter = createStringConverter(VisibleString);
    AsnGeneralStringConverter = createStringConverter(GeneralString);
    AsnCharacterStringConverter = createStringConverter(CharacterString);
    AsnUTCTimeConverter = {
      fromASN: (value) => value.toDate(),
      toASN: (value) => new UTCTime({ valueDate: value })
    };
    AsnGeneralizedTimeConverter = {
      fromASN: (value) => value.toDate(),
      toASN: (value) => new GeneralizedTime({ valueDate: value })
    };
    AsnNullConverter = {
      fromASN: () => null,
      toASN: () => {
        return new Null();
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && "toASN" in target && "fromASN" in target);
  }
}
function isTypeOfArray(target) {
  var _a3;
  if (target) {
    const proto = Object.getPrototypeOf(target);
    if (((_a3 = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a3 === void 0 ? void 0 : _a3.constructor) === Array) {
      return true;
    }
    return isTypeOfArray(proto);
  }
  return false;
}
function isArrayEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b22 = new Uint8Array(bytes2);
  for (let i9 = 0; i9 < bytes1.byteLength; i9++) {
    if (b1[i9] !== b22[i9]) {
      return false;
    }
  }
  return true;
}
var init_helper = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/helper.js"() {
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/schema.js
var AsnSchemaStorage;
var init_schema = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/schema.js"() {
    init_index_es();
    init_enums();
    init_helper();
    AsnSchemaStorage = class {
      constructor() {
        this.items = /* @__PURE__ */ new WeakMap();
      }
      has(target) {
        return this.items.has(target);
      }
      get(target, checkSchema = false) {
        const schema = this.items.get(target);
        if (!schema) {
          throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
        }
        if (checkSchema && !schema.schema) {
          throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
        }
        return schema;
      }
      cache(target) {
        const schema = this.get(target);
        if (!schema.schema) {
          schema.schema = this.create(target, true);
        }
      }
      createDefault(target) {
        const schema = {
          type: AsnTypeTypes.Sequence,
          items: {}
        };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
          Object.assign(schema, parentSchema);
          schema.items = Object.assign({}, schema.items, parentSchema.items);
        }
        return schema;
      }
      create(target, useNames) {
        const schema = this.items.get(target) || this.createDefault(target);
        const asn1Value = [];
        for (const key3 in schema.items) {
          const item = schema.items[key3];
          const name2 = useNames ? key3 : "";
          let asn1Item;
          if (typeof item.type === "number") {
            const Asn1TypeName = AsnPropTypes[item.type];
            const Asn1Type = index_es_exports[Asn1TypeName];
            if (!Asn1Type) {
              throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
            }
            asn1Item = new Asn1Type({ name: name2 });
          } else if (isConvertible(item.type)) {
            const instance2 = new item.type();
            asn1Item = instance2.toSchema(name2);
          } else if (item.optional) {
            const itemSchema = this.get(item.type);
            if (itemSchema.type === AsnTypeTypes.Choice) {
              asn1Item = new Any({ name: name2 });
            } else {
              asn1Item = this.create(item.type, false);
              asn1Item.name = name2;
            }
          } else {
            asn1Item = new Any({ name: name2 });
          }
          const optional = !!item.optional || item.defaultValue !== void 0;
          if (item.repeated) {
            asn1Item.name = "";
            const Container = item.repeated === "set" ? Set2 : Sequence;
            asn1Item = new Container({
              name: "",
              value: [
                new Repeated({
                  name: name2,
                  value: asn1Item
                })
              ]
            });
          }
          if (item.context !== null && item.context !== void 0) {
            if (item.implicit) {
              if (typeof item.type === "number" || isConvertible(item.type)) {
                const Container = item.repeated ? Constructed : Primitive;
                asn1Value.push(new Container({
                  name: name2,
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  }
                }));
              } else {
                this.cache(item.type);
                const isRepeated = !!item.repeated;
                let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
                value = "valueBlock" in value ? value.valueBlock.value : value.value;
                asn1Value.push(new Constructed({
                  name: !isRepeated ? name2 : "",
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  },
                  value
                }));
              }
            } else {
              asn1Value.push(new Constructed({
                optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: item.context
                },
                value: [asn1Item]
              }));
            }
          } else {
            asn1Item.optional = optional;
            asn1Value.push(asn1Item);
          }
        }
        switch (schema.type) {
          case AsnTypeTypes.Sequence:
            return new Sequence({ value: asn1Value, name: "" });
          case AsnTypeTypes.Set:
            return new Set2({ value: asn1Value, name: "" });
          case AsnTypeTypes.Choice:
            return new Choice({ value: asn1Value, name: "" });
          default:
            throw new Error(`Unsupported ASN1 type in use`);
        }
      }
      set(target, schema) {
        this.items.set(target, schema);
        return this;
      }
      findParentSchema(target) {
        const parent = Object.getPrototypeOf(target);
        if (parent) {
          const schema = this.items.get(parent);
          return schema || this.findParentSchema(parent);
        }
        return null;
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage;
var init_storage = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/storage.js"() {
    init_schema();
    schemaStorage = new AsnSchemaStorage();
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType, AsnProp;
var init_decorators = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/decorators.js"() {
    init_converters();
    init_enums();
    init_storage();
    AsnType = (options3) => (target) => {
      let schema;
      if (!schemaStorage.has(target)) {
        schema = schemaStorage.createDefault(target);
        schemaStorage.set(target, schema);
      } else {
        schema = schemaStorage.get(target);
      }
      Object.assign(schema, options3);
    };
    AsnProp = (options3) => (target, propertyKey) => {
      let schema;
      if (!schemaStorage.has(target.constructor)) {
        schema = schemaStorage.createDefault(target.constructor);
        schemaStorage.set(target.constructor, schema);
      } else {
        schema = schemaStorage.get(target.constructor);
      }
      const copyOptions = Object.assign({}, options3);
      if (typeof copyOptions.type === "number" && !copyOptions.converter) {
        const defaultConverter2 = defaultConverter(options3.type);
        if (!defaultConverter2) {
          throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
        }
        copyOptions.converter = defaultConverter2;
      }
      schema.items[propertyKey] = copyOptions;
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
var AsnSchemaValidationError;
var init_schema_validation = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js"() {
    AsnSchemaValidationError = class extends Error {
      constructor() {
        super(...arguments);
        this.schemas = [];
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js
var init_errors2 = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js"() {
    init_schema_validation();
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/parser.js
var AsnParser;
var init_parser = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/parser.js"() {
    init_index_es();
    init_enums();
    init_converters();
    init_errors2();
    init_helper();
    init_storage();
    AsnParser = class {
      static parse(data, target) {
        const asn1Parsed = fromBER(data);
        if (asn1Parsed.result.error) {
          throw new Error(asn1Parsed.result.error);
        }
        const res = this.fromASN(asn1Parsed.result, target);
        return res;
      }
      static fromASN(asn1Schema, target) {
        var _a3;
        try {
          if (isConvertible(target)) {
            const value = new target();
            return value.fromASN(asn1Schema);
          }
          const schema = schemaStorage.get(target);
          schemaStorage.cache(target);
          let targetSchema = schema.schema;
          if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {
            targetSchema = new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: asn1Schema.idBlock.tagNumber
              },
              value: schema.schema.valueBlock.value
            });
            for (const key3 in schema.items) {
              delete asn1Schema[key3];
            }
          }
          const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);
          if (!asn1ComparedSchema.verified) {
            throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
          }
          const res = new target();
          if (isTypeOfArray(target)) {
            if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {
              throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
            }
            const itemType = schema.itemType;
            if (typeof itemType === "number") {
              const converter = defaultConverter(itemType);
              if (!converter) {
                throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
              }
              return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
            } else {
              return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
            }
          }
          for (const key3 in schema.items) {
            const asn1SchemaValue = asn1ComparedSchema.result[key3];
            if (!asn1SchemaValue) {
              continue;
            }
            const schemaItem = schema.items[key3];
            const schemaItemType = schemaItem.type;
            if (typeof schemaItemType === "number" || isConvertible(schemaItemType)) {
              const converter = (_a3 = schemaItem.converter) !== null && _a3 !== void 0 ? _a3 : isConvertible(schemaItemType) ? new schemaItemType() : null;
              if (!converter) {
                throw new Error("Converter is empty");
              }
              if (schemaItem.repeated) {
                if (schemaItem.implicit) {
                  const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
                  const newItem = new Container();
                  newItem.valueBlock = asn1SchemaValue.valueBlock;
                  const newItemAsn = fromBER(newItem.toBER(false));
                  if (newItemAsn.offset === -1) {
                    throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
                  }
                  if (!("value" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {
                    throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
                  }
                  const value = newItemAsn.result.valueBlock.value;
                  res[key3] = Array.from(value, (element) => converter.fromASN(element));
                } else {
                  res[key3] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
                }
              } else {
                let value = asn1SchemaValue;
                if (schemaItem.implicit) {
                  let newItem;
                  if (isConvertible(schemaItemType)) {
                    newItem = new schemaItemType().toSchema("");
                  } else {
                    const Asn1TypeName = AsnPropTypes[schemaItemType];
                    const Asn1Type = index_es_exports[Asn1TypeName];
                    if (!Asn1Type) {
                      throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                    }
                    newItem = new Asn1Type();
                  }
                  newItem.valueBlock = value.valueBlock;
                  value = fromBER(newItem.toBER(false)).result;
                }
                res[key3] = converter.fromASN(value);
              }
            } else {
              if (schemaItem.repeated) {
                if (!Array.isArray(asn1SchemaValue)) {
                  throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
                }
                res[key3] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
              } else {
                res[key3] = this.fromASN(asn1SchemaValue, schemaItemType);
              }
            }
          }
          return res;
        } catch (error2) {
          if (error2 instanceof AsnSchemaValidationError) {
            error2.schemas.push(target.name);
          }
          throw error2;
        }
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
var AsnSerializer;
var init_serializer = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/serializer.js"() {
    init_index_es();
    init_converters();
    init_enums();
    init_helper();
    init_storage();
    AsnSerializer = class _AsnSerializer {
      static serialize(obj) {
        if (obj instanceof BaseBlock) {
          return obj.toBER(false);
        }
        return this.toASN(obj).toBER(false);
      }
      static toASN(obj) {
        if (obj && typeof obj === "object" && isConvertible(obj)) {
          return obj.toASN();
        }
        if (!(obj && typeof obj === "object")) {
          throw new TypeError("Parameter 1 should be type of Object.");
        }
        const target = obj.constructor;
        const schema = schemaStorage.get(target);
        schemaStorage.cache(target);
        let asn1Value = [];
        if (schema.itemType) {
          if (!Array.isArray(obj)) {
            throw new TypeError("Parameter 1 should be type of Array.");
          }
          if (typeof schema.itemType === "number") {
            const converter = defaultConverter(schema.itemType);
            if (!converter) {
              throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
            }
            asn1Value = obj.map((o7) => converter.toASN(o7));
          } else {
            asn1Value = obj.map((o7) => this.toAsnItem({ type: schema.itemType }, "[]", target, o7));
          }
        } else {
          for (const key3 in schema.items) {
            const schemaItem = schema.items[key3];
            const objProp = obj[key3];
            if (objProp === void 0 || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
              continue;
            }
            const asn1Item = _AsnSerializer.toAsnItem(schemaItem, key3, target, objProp);
            if (typeof schemaItem.context === "number") {
              if (schemaItem.implicit) {
                if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible(schemaItem.type))) {
                  const value = {};
                  value.valueHex = asn1Item instanceof Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
                  asn1Value.push(new Primitive({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    ...value
                  }));
                } else {
                  asn1Value.push(new Constructed({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    value: asn1Item.valueBlock.value
                  }));
                }
              } else {
                asn1Value.push(new Constructed({
                  optional: schemaItem.optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: schemaItem.context
                  },
                  value: [asn1Item]
                }));
              }
            } else if (schemaItem.repeated) {
              asn1Value = asn1Value.concat(asn1Item);
            } else {
              asn1Value.push(asn1Item);
            }
          }
        }
        let asnSchema;
        switch (schema.type) {
          case AsnTypeTypes.Sequence:
            asnSchema = new Sequence({ value: asn1Value });
            break;
          case AsnTypeTypes.Set:
            asnSchema = new Set2({ value: asn1Value });
            break;
          case AsnTypeTypes.Choice:
            if (!asn1Value[0]) {
              throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
            }
            asnSchema = asn1Value[0];
            break;
        }
        return asnSchema;
      }
      static toAsnItem(schemaItem, key3, target, objProp) {
        let asn1Item;
        if (typeof schemaItem.type === "number") {
          const converter = schemaItem.converter;
          if (!converter) {
            throw new Error(`Property '${key3}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
          }
          if (schemaItem.repeated) {
            if (!Array.isArray(objProp)) {
              throw new TypeError("Parameter 'objProp' should be type of Array.");
            }
            const items = Array.from(objProp, (element) => converter.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = converter.toASN(objProp);
          }
        } else {
          if (schemaItem.repeated) {
            if (!Array.isArray(objProp)) {
              throw new TypeError("Parameter 'objProp' should be type of Array.");
            }
            const items = Array.from(objProp, (element) => this.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = this.toASN(objProp);
          }
        }
        return asn1Item;
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/objects.js
var AsnArray;
var init_objects = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/objects.js"() {
    AsnArray = class extends Array {
      constructor(items = []) {
        if (typeof items === "number") {
          super(items);
        } else {
          super();
          for (const item of items) {
            this.push(item);
          }
        }
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/convert.js
var import_pvtsutils3, AsnConvert;
var init_convert = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/convert.js"() {
    init_index_es();
    import_pvtsutils3 = __toESM(require_build());
    init_parser();
    init_serializer();
    AsnConvert = class _AsnConvert {
      static serialize(obj) {
        return AsnSerializer.serialize(obj);
      }
      static parse(data, target) {
        return AsnParser.parse(data, target);
      }
      static toString(data) {
        const buf = import_pvtsutils3.BufferSourceConverter.isBufferSource(data) ? import_pvtsutils3.BufferSourceConverter.toArrayBuffer(data) : _AsnConvert.serialize(data);
        const asn = fromBER(buf);
        if (asn.offset === -1) {
          throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
        }
        return asn.result.toString();
      }
    };
  }
});

// node_modules/@peculiar/asn1-schema/build/es2015/index.js
var init_es2015 = __esm({
  "node_modules/@peculiar/asn1-schema/build/es2015/index.js"() {
    init_converters();
    init_types();
    init_decorators();
    init_enums();
    init_parser();
    init_serializer();
    init_errors2();
    init_objects();
    init_convert();
  }
});

// node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key3, desc) {
  var c8 = arguments.length, r8 = c8 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key3) : desc, d6;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r8 = Reflect.decorate(decorators, target, key3, desc);
  else
    for (var i9 = decorators.length - 1; i9 >= 0; i9--)
      if (d6 = decorators[i9])
        r8 = (c8 < 3 ? d6(r8) : c8 > 3 ? d6(target, key3, r8) : d6(target, key3)) || r8;
  return c8 > 3 && r8 && Object.defineProperty(target, key3, r8), r8;
}
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports, module2) {
    (function(root2) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string, parts) {
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          const ref = string.split(":");
          const results = [];
          for (let i9 = 0; i9 < ref.length; i9++) {
            results.push(parseInt(ref[i9], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string) {
        if (hexRegex.test(string)) {
          return parseInt(string, 16);
        }
        if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
          if (octalRegex.test(string)) {
            return parseInt(string, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string} as octal`);
        }
        return parseInt(string, 10);
      }
      function padPart(part, length) {
        while (part.length < length) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i9, octet;
          for (i9 = 0; i9 < octets.length; i9++) {
            octet = octets[i9];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 18, 0, 0]), 15],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i9, octet, zeros;
          for (i9 = 3; i9 >= 0; i9 -= 1) {
            octet = this.octets[i9];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i9 = 0;
          while (i9 < 4) {
            octets.push(parseInt(ipInterfaceOctets[i9], 10) | parseInt(subnetMaskOctets[i9], 10) ^ 255);
            i9++;
          }
          return new this(octets);
        } catch (e5) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (e5) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        let cidr, i9, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i9 = 0;
          while (i9 < 4) {
            octets.push(parseInt(ipInterfaceOctets[i9], 10) & parseInt(subnetMaskOctets[i9], 10));
            i9++;
          }
          return new this(octets);
        } catch (e5) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string) {
        const parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        let match;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string) {
        let match, part, value;
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i9 = 0; i9 < ref.length; i9++) {
              part = ref[i9];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j4 = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j4 < filledOctetCount) {
          octets[j4] = 255;
          j4++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i9, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i9 = 0; i9 <= 14; i9 += 2) {
              this.parts.push(parts[i9] << 8 | parts[i9 + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i9 = 0; i9 < this.parts.length; i9++) {
            part = this.parts[i9];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC4291
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]],
          benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
          amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
          as112v6: [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
          orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i9 = 7; i9 >= 0; i9 -= 1) {
            part = this.parts[i9];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes = [];
          const ref = this.parts;
          for (let i9 = 0; i9 < ref.length; i9++) {
            part = ref[i9];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i9 = 0; i9 < this.parts.length; i9++) {
              results.push(padPart(this.parts[i9].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i9 = 0; i9 < this.parts.length; i9++) {
              results.push(this.parts[i9].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toRFC5952String();
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i9 = 0;
          while (i9 < 16) {
            octets.push(parseInt(ipInterfaceOctets[i9], 10) | parseInt(subnetMaskOctets[i9], 10) ^ 255);
            i9++;
          }
          return new this(octets);
        } catch (e5) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e5})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv6.isValid = function(string) {
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e5) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string) {
        let cidr, i9, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i9 = 0;
          while (i9 < 16) {
            octets.push(parseInt(ipInterfaceOctets[i9], 10) & parseInt(subnetMaskOctets[i9], 10));
            i9++;
          }
          return new this(octets);
        } catch (e5) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e5})`);
        }
      };
      ipaddr.IPv6.parse = function(string) {
        const addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        let maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string) {
        let addr, i9, match, octet, octets, zoneId;
        if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string)) {
          return expandIPv6(string, 8);
        }
        if (match = string.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i9 = 0; i9 < octets.length; i9++) {
              octet = octets[i9];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j4 = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j4 < filledOctetCount) {
          octets[j4] = 255;
          j4++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (e5) {
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (e23) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string) {
        const addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i9, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i9 = 0; i9 < rangeSubnets.length; i9++) {
              subnet = rangeSubnets[i9];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root2.ipaddr = ipaddr;
      }
    })(exports);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
var ip, import_pvtsutils4, IpConverter;
var init_ip_converter = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js"() {
    ip = __toESM(require_ipaddr());
    import_pvtsutils4 = __toESM(require_build());
    IpConverter = class {
      static decodeIP(value) {
        if (value.length === 64 && parseInt(value, 16) === 0) {
          return "::/0";
        }
        if (value.length !== 16) {
          return value;
        }
        const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a7, k4) => a7 + +k4, 0);
        let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match) => `${parseInt(match, 16)}.`);
        ip2 = ip2.slice(0, -1);
        return `${ip2}/${mask}`;
      }
      static toString(buf) {
        if (buf.byteLength === 4 || buf.byteLength === 16) {
          const uint8 = new Uint8Array(buf);
          const addr = ip.fromByteArray(Array.from(uint8));
          return addr.toString();
        }
        return this.decodeIP(import_pvtsutils4.Convert.ToHex(buf));
      }
      static fromString(text2) {
        const addr = ip.parse(text2);
        return new Uint8Array(addr.toByteArray()).buffer;
      }
    };
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/name.js
var import_pvtsutils5, RelativeDistinguishedName_1, RDNSequence_1, Name_1, DirectoryString, AttributeValue, AttributeTypeAndValue, RelativeDistinguishedName, RDNSequence, Name;
var init_name = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/name.js"() {
    init_tslib_es6();
    init_es2015();
    import_pvtsutils5 = __toESM(require_build());
    DirectoryString = class DirectoryString2 {
      constructor(params = {}) {
        Object.assign(this, params);
      }
      toString() {
        return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.TeletexString })
    ], DirectoryString.prototype, "teletexString", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.PrintableString })
    ], DirectoryString.prototype, "printableString", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.UniversalString })
    ], DirectoryString.prototype, "universalString", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Utf8String })
    ], DirectoryString.prototype, "utf8String", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.BmpString })
    ], DirectoryString.prototype, "bmpString", void 0);
    DirectoryString = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], DirectoryString);
    AttributeValue = class AttributeValue2 extends DirectoryString {
      constructor(params = {}) {
        super(params);
        Object.assign(this, params);
      }
      toString() {
        return this.ia5String || (this.anyValue ? import_pvtsutils5.Convert.ToHex(this.anyValue) : super.toString());
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.IA5String })
    ], AttributeValue.prototype, "ia5String", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Any })
    ], AttributeValue.prototype, "anyValue", void 0);
    AttributeValue = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], AttributeValue);
    AttributeTypeAndValue = class {
      constructor(params = {}) {
        this.type = "";
        this.value = new AttributeValue();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], AttributeTypeAndValue.prototype, "type", void 0);
    __decorate([
      AsnProp({ type: AttributeValue })
    ], AttributeTypeAndValue.prototype, "value", void 0);
    RelativeDistinguishedName = RelativeDistinguishedName_1 = class RelativeDistinguishedName2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RelativeDistinguishedName_1.prototype);
      }
    };
    RelativeDistinguishedName = RelativeDistinguishedName_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Set, itemType: AttributeTypeAndValue })
    ], RelativeDistinguishedName);
    RDNSequence = RDNSequence_1 = class RDNSequence2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RDNSequence_1.prototype);
      }
    };
    RDNSequence = RDNSequence_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: RelativeDistinguishedName })
    ], RDNSequence);
    Name = Name_1 = class Name2 extends RDNSequence {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Name_1.prototype);
      }
    };
    Name = Name_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence })
    ], Name);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter, OtherName, EDIPartyName, GeneralName;
var init_general_name = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/general_name.js"() {
    init_tslib_es6();
    init_es2015();
    init_ip_converter();
    init_name();
    AsnIpConverter = {
      fromASN: (value) => IpConverter.toString(AsnOctetStringConverter.fromASN(value)),
      toASN: (value) => AsnOctetStringConverter.toASN(IpConverter.fromString(value))
    };
    OtherName = class {
      constructor(params = {}) {
        this.typeId = "";
        this.value = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], OtherName.prototype, "typeId", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Any, context: 0 })
    ], OtherName.prototype, "value", void 0);
    EDIPartyName = class {
      constructor(params = {}) {
        this.partyName = new DirectoryString();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: DirectoryString, optional: true, context: 0, implicit: true })
    ], EDIPartyName.prototype, "nameAssigner", void 0);
    __decorate([
      AsnProp({ type: DirectoryString, context: 1, implicit: true })
    ], EDIPartyName.prototype, "partyName", void 0);
    GeneralName = class GeneralName2 {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: OtherName, context: 0, implicit: true })
    ], GeneralName.prototype, "otherName", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.IA5String, context: 1, implicit: true })
    ], GeneralName.prototype, "rfc822Name", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.IA5String, context: 2, implicit: true })
    ], GeneralName.prototype, "dNSName", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Any, context: 3, implicit: true })
    ], GeneralName.prototype, "x400Address", void 0);
    __decorate([
      AsnProp({ type: Name, context: 4, implicit: false })
    ], GeneralName.prototype, "directoryName", void 0);
    __decorate([
      AsnProp({ type: EDIPartyName, context: 5 })
    ], GeneralName.prototype, "ediPartyName", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.IA5String, context: 6, implicit: true })
    ], GeneralName.prototype, "uniformResourceIdentifier", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.OctetString, context: 7, implicit: true, converter: AsnIpConverter })
    ], GeneralName.prototype, "iPAddress", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier, context: 8, implicit: true })
    ], GeneralName.prototype, "registeredID", void 0);
    GeneralName = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], GeneralName);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix, id_pe, id_qt, id_kp, id_ad, id_qt_csp, id_qt_unotice, id_ad_ocsp, id_ad_caIssuers, id_ad_timeStamping, id_ad_caRepository, id_ce;
var init_object_identifiers = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js"() {
    id_pkix = "1.3.6.1.5.5.7";
    id_pe = `${id_pkix}.1`;
    id_qt = `${id_pkix}.2`;
    id_kp = `${id_pkix}.3`;
    id_ad = `${id_pkix}.48`;
    id_qt_csp = `${id_qt}.1`;
    id_qt_unotice = `${id_qt}.2`;
    id_ad_ocsp = `${id_ad}.1`;
    id_ad_caIssuers = `${id_ad}.2`;
    id_ad_timeStamping = `${id_ad}.3`;
    id_ad_caRepository = `${id_ad}.5`;
    id_ce = "2.5.29";
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_1, id_pe_authorityInfoAccess, AccessDescription, AuthorityInfoAccessSyntax;
var init_authority_information_access = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js"() {
    init_tslib_es6();
    init_es2015();
    init_general_name();
    init_object_identifiers();
    id_pe_authorityInfoAccess = `${id_pe}.1`;
    AccessDescription = class {
      constructor(params = {}) {
        this.accessMethod = "";
        this.accessLocation = new GeneralName();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], AccessDescription.prototype, "accessMethod", void 0);
    __decorate([
      AsnProp({ type: GeneralName })
    ], AccessDescription.prototype, "accessLocation", void 0);
    AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = class AuthorityInfoAccessSyntax2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_1.prototype);
      }
    };
    AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
    ], AuthorityInfoAccessSyntax);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier, KeyIdentifier, AuthorityKeyIdentifier;
var init_authority_key_identifier = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js"() {
    init_tslib_es6();
    init_es2015();
    init_general_name();
    init_object_identifiers();
    id_ce_authorityKeyIdentifier = `${id_ce}.35`;
    KeyIdentifier = class extends OctetString2 {
    };
    AuthorityKeyIdentifier = class {
      constructor(params = {}) {
        if (params) {
          Object.assign(this, params);
        }
      }
    };
    __decorate([
      AsnProp({ type: KeyIdentifier, context: 0, optional: true, implicit: true })
    ], AuthorityKeyIdentifier.prototype, "keyIdentifier", void 0);
    __decorate([
      AsnProp({ type: GeneralName, context: 1, optional: true, implicit: true, repeated: "sequence" })
    ], AuthorityKeyIdentifier.prototype, "authorityCertIssuer", void 0);
    __decorate([
      AsnProp({
        type: AsnPropTypes.Integer,
        context: 2,
        optional: true,
        implicit: true,
        converter: AsnIntegerArrayBufferConverter
      })
    ], AuthorityKeyIdentifier.prototype, "authorityCertSerialNumber", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints, BasicConstraints;
var init_basic_constraints = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_basicConstraints = `${id_ce}.19`;
    BasicConstraints = class {
      constructor(params = {}) {
        this.cA = false;
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Boolean, defaultValue: false })
    ], BasicConstraints.prototype, "cA", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, optional: true })
    ], BasicConstraints.prototype, "pathLenConstraint", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_1, GeneralNames;
var init_general_names = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/general_names.js"() {
    init_tslib_es6();
    init_es2015();
    init_general_name();
    init_es2015();
    GeneralNames = GeneralNames_1 = class GeneralNames2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, GeneralNames_1.prototype);
      }
    };
    GeneralNames = GeneralNames_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralName })
    ], GeneralNames);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_1, id_ce_certificateIssuer, CertificateIssuer;
var init_certificate_issuer = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js"() {
    init_tslib_es6();
    init_es2015();
    init_general_names();
    init_object_identifiers();
    id_ce_certificateIssuer = `${id_ce}.29`;
    CertificateIssuer = CertificateIssuer_1 = class CertificateIssuer2 extends GeneralNames {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificateIssuer_1.prototype);
      }
    };
    CertificateIssuer = CertificateIssuer_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence })
    ], CertificateIssuer);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_1, id_ce_certificatePolicies, id_ce_certificatePolicies_anyPolicy, DisplayText, NoticeReference, UserNotice, Qualifier, PolicyQualifierInfo, PolicyInformation, CertificatePolicies;
var init_certificate_policies = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_certificatePolicies = `${id_ce}.32`;
    id_ce_certificatePolicies_anyPolicy = `${id_ce_certificatePolicies}.0`;
    DisplayText = class DisplayText2 {
      constructor(params = {}) {
        Object.assign(this, params);
      }
      toString() {
        return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.IA5String })
    ], DisplayText.prototype, "ia5String", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.VisibleString })
    ], DisplayText.prototype, "visibleString", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.BmpString })
    ], DisplayText.prototype, "bmpString", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Utf8String })
    ], DisplayText.prototype, "utf8String", void 0);
    DisplayText = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], DisplayText);
    NoticeReference = class {
      constructor(params = {}) {
        this.organization = new DisplayText();
        this.noticeNumbers = [];
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: DisplayText })
    ], NoticeReference.prototype, "organization", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, repeated: "sequence" })
    ], NoticeReference.prototype, "noticeNumbers", void 0);
    UserNotice = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: NoticeReference, optional: true })
    ], UserNotice.prototype, "noticeRef", void 0);
    __decorate([
      AsnProp({ type: DisplayText, optional: true })
    ], UserNotice.prototype, "explicitText", void 0);
    Qualifier = class Qualifier2 {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.IA5String })
    ], Qualifier.prototype, "cPSuri", void 0);
    __decorate([
      AsnProp({ type: UserNotice })
    ], Qualifier.prototype, "userNotice", void 0);
    Qualifier = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], Qualifier);
    PolicyQualifierInfo = class {
      constructor(params = {}) {
        this.policyQualifierId = "";
        this.qualifier = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], PolicyQualifierInfo.prototype, "policyQualifierId", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Any })
    ], PolicyQualifierInfo.prototype, "qualifier", void 0);
    PolicyInformation = class {
      constructor(params = {}) {
        this.policyIdentifier = "";
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], PolicyInformation.prototype, "policyIdentifier", void 0);
    __decorate([
      AsnProp({ type: PolicyQualifierInfo, repeated: "sequence", optional: true })
    ], PolicyInformation.prototype, "policyQualifiers", void 0);
    CertificatePolicies = CertificatePolicies_1 = class CertificatePolicies2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificatePolicies_1.prototype);
      }
    };
    CertificatePolicies = CertificatePolicies_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyInformation })
    ], CertificatePolicies);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber, CRLNumber;
var init_crl_number = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_cRLNumber = `${id_ce}.20`;
    CRLNumber = class CRLNumber2 {
      constructor(value = 0) {
        this.value = value;
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], CRLNumber.prototype, "value", void 0);
    CRLNumber = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], CRLNumber);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator, BaseCRLNumber;
var init_crl_delta_indicator = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    init_crl_number();
    id_ce_deltaCRLIndicator = `${id_ce}.27`;
    BaseCRLNumber = class BaseCRLNumber2 extends CRLNumber {
    };
    BaseCRLNumber = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], BaseCRLNumber);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_1, id_ce_cRLDistributionPoints, ReasonFlags, Reason, DistributionPointName, DistributionPoint, CRLDistributionPoints;
var init_crl_distribution_points = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js"() {
    init_tslib_es6();
    init_es2015();
    init_name();
    init_general_name();
    init_object_identifiers();
    id_ce_cRLDistributionPoints = `${id_ce}.31`;
    (function(ReasonFlags2) {
      ReasonFlags2[ReasonFlags2["unused"] = 1] = "unused";
      ReasonFlags2[ReasonFlags2["keyCompromise"] = 2] = "keyCompromise";
      ReasonFlags2[ReasonFlags2["cACompromise"] = 4] = "cACompromise";
      ReasonFlags2[ReasonFlags2["affiliationChanged"] = 8] = "affiliationChanged";
      ReasonFlags2[ReasonFlags2["superseded"] = 16] = "superseded";
      ReasonFlags2[ReasonFlags2["cessationOfOperation"] = 32] = "cessationOfOperation";
      ReasonFlags2[ReasonFlags2["certificateHold"] = 64] = "certificateHold";
      ReasonFlags2[ReasonFlags2["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
      ReasonFlags2[ReasonFlags2["aACompromise"] = 256] = "aACompromise";
    })(ReasonFlags || (ReasonFlags = {}));
    Reason = class extends BitString2 {
      toJSON() {
        const res = [];
        const flags = this.toNumber();
        if (flags & ReasonFlags.aACompromise) {
          res.push("aACompromise");
        }
        if (flags & ReasonFlags.affiliationChanged) {
          res.push("affiliationChanged");
        }
        if (flags & ReasonFlags.cACompromise) {
          res.push("cACompromise");
        }
        if (flags & ReasonFlags.certificateHold) {
          res.push("certificateHold");
        }
        if (flags & ReasonFlags.cessationOfOperation) {
          res.push("cessationOfOperation");
        }
        if (flags & ReasonFlags.keyCompromise) {
          res.push("keyCompromise");
        }
        if (flags & ReasonFlags.privilegeWithdrawn) {
          res.push("privilegeWithdrawn");
        }
        if (flags & ReasonFlags.superseded) {
          res.push("superseded");
        }
        if (flags & ReasonFlags.unused) {
          res.push("unused");
        }
        return res;
      }
      toString() {
        return `[${this.toJSON().join(", ")}]`;
      }
    };
    DistributionPointName = class DistributionPointName2 {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: GeneralName, context: 0, repeated: "sequence", implicit: true })
    ], DistributionPointName.prototype, "fullName", void 0);
    __decorate([
      AsnProp({ type: RelativeDistinguishedName, context: 1, implicit: true })
    ], DistributionPointName.prototype, "nameRelativeToCRLIssuer", void 0);
    DistributionPointName = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], DistributionPointName);
    DistributionPoint = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: DistributionPointName, context: 0, optional: true })
    ], DistributionPoint.prototype, "distributionPoint", void 0);
    __decorate([
      AsnProp({ type: Reason, context: 1, optional: true, implicit: true })
    ], DistributionPoint.prototype, "reasons", void 0);
    __decorate([
      AsnProp({ type: GeneralName, context: 2, optional: true, repeated: "sequence", implicit: true })
    ], DistributionPoint.prototype, "cRLIssuer", void 0);
    CRLDistributionPoints = CRLDistributionPoints_1 = class CRLDistributionPoints2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CRLDistributionPoints_1.prototype);
      }
    };
    CRLDistributionPoints = CRLDistributionPoints_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
    ], CRLDistributionPoints);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_1, id_ce_freshestCRL, FreshestCRL;
var init_crl_freshest = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    init_crl_distribution_points();
    id_ce_freshestCRL = `${id_ce}.46`;
    FreshestCRL = FreshestCRL_1 = class FreshestCRL2 extends CRLDistributionPoints {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, FreshestCRL_1.prototype);
      }
    };
    FreshestCRL = FreshestCRL_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
    ], FreshestCRL);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint, IssuingDistributionPoint;
var init_crl_issuing_distribution_point = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js"() {
    init_tslib_es6();
    init_es2015();
    init_crl_distribution_points();
    init_object_identifiers();
    init_es2015();
    id_ce_issuingDistributionPoint = `${id_ce}.28`;
    IssuingDistributionPoint = class _IssuingDistributionPoint {
      constructor(params = {}) {
        this.onlyContainsUserCerts = _IssuingDistributionPoint.ONLY;
        this.onlyContainsCACerts = _IssuingDistributionPoint.ONLY;
        this.indirectCRL = _IssuingDistributionPoint.ONLY;
        this.onlyContainsAttributeCerts = _IssuingDistributionPoint.ONLY;
        Object.assign(this, params);
      }
    };
    IssuingDistributionPoint.ONLY = false;
    __decorate([
      AsnProp({ type: DistributionPointName, context: 0, optional: true })
    ], IssuingDistributionPoint.prototype, "distributionPoint", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Boolean, context: 1, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlyContainsUserCerts", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Boolean, context: 2, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlyContainsCACerts", void 0);
    __decorate([
      AsnProp({ type: Reason, context: 3, optional: true, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlySomeReasons", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Boolean, context: 4, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "indirectCRL", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Boolean, context: 5, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlyContainsAttributeCerts", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons, CRLReasons, CRLReason;
var init_crl_reason = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_cRLReasons = `${id_ce}.21`;
    (function(CRLReasons2) {
      CRLReasons2[CRLReasons2["unspecified"] = 0] = "unspecified";
      CRLReasons2[CRLReasons2["keyCompromise"] = 1] = "keyCompromise";
      CRLReasons2[CRLReasons2["cACompromise"] = 2] = "cACompromise";
      CRLReasons2[CRLReasons2["affiliationChanged"] = 3] = "affiliationChanged";
      CRLReasons2[CRLReasons2["superseded"] = 4] = "superseded";
      CRLReasons2[CRLReasons2["cessationOfOperation"] = 5] = "cessationOfOperation";
      CRLReasons2[CRLReasons2["certificateHold"] = 6] = "certificateHold";
      CRLReasons2[CRLReasons2["removeFromCRL"] = 8] = "removeFromCRL";
      CRLReasons2[CRLReasons2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
      CRLReasons2[CRLReasons2["aACompromise"] = 10] = "aACompromise";
    })(CRLReasons || (CRLReasons = {}));
    CRLReason = class CRLReason2 {
      constructor(reason = CRLReasons.unspecified) {
        this.reason = CRLReasons.unspecified;
        this.reason = reason;
      }
      toJSON() {
        return CRLReasons[this.reason];
      }
      toString() {
        return this.toJSON();
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Enumerated })
    ], CRLReason.prototype, "reason", void 0);
    CRLReason = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], CRLReason);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_1, id_ce_extKeyUsage, ExtendedKeyUsage, anyExtendedKeyUsage, id_kp_serverAuth, id_kp_clientAuth, id_kp_codeSigning, id_kp_emailProtection, id_kp_timeStamping, id_kp_OCSPSigning;
var init_extended_key_usage = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_extKeyUsage = `${id_ce}.37`;
    ExtendedKeyUsage = ExtendedKeyUsage_1 = class ExtendedKeyUsage2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ExtendedKeyUsage_1.prototype);
      }
    };
    ExtendedKeyUsage = ExtendedKeyUsage_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: AsnPropTypes.ObjectIdentifier })
    ], ExtendedKeyUsage);
    anyExtendedKeyUsage = `${id_ce_extKeyUsage}.0`;
    id_kp_serverAuth = `${id_kp}.1`;
    id_kp_clientAuth = `${id_kp}.2`;
    id_kp_codeSigning = `${id_kp}.3`;
    id_kp_emailProtection = `${id_kp}.4`;
    id_kp_timeStamping = `${id_kp}.8`;
    id_kp_OCSPSigning = `${id_kp}.9`;
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy, InhibitAnyPolicy;
var init_inhibit_any_policy = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_inhibitAnyPolicy = `${id_ce}.54`;
    InhibitAnyPolicy = class InhibitAnyPolicy2 {
      constructor(value = new ArrayBuffer(0)) {
        this.value = value;
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], InhibitAnyPolicy.prototype, "value", void 0);
    InhibitAnyPolicy = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], InhibitAnyPolicy);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate, InvalidityDate;
var init_invalidity_date = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_invalidityDate = `${id_ce}.24`;
    InvalidityDate = class InvalidityDate2 {
      constructor(value) {
        this.value = /* @__PURE__ */ new Date();
        if (value) {
          this.value = value;
        }
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.GeneralizedTime })
    ], InvalidityDate.prototype, "value", void 0);
    InvalidityDate = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], InvalidityDate);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_1, id_ce_issuerAltName, IssueAlternativeName;
var init_issuer_alternative_name = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js"() {
    init_tslib_es6();
    init_es2015();
    init_general_names();
    init_object_identifiers();
    id_ce_issuerAltName = `${id_ce}.18`;
    IssueAlternativeName = IssueAlternativeName_1 = class IssueAlternativeName2 extends GeneralNames {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, IssueAlternativeName_1.prototype);
      }
    };
    IssueAlternativeName = IssueAlternativeName_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence })
    ], IssueAlternativeName);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage, KeyUsageFlags;
var init_key_usage = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js"() {
    init_es2015();
    init_object_identifiers();
    id_ce_keyUsage = `${id_ce}.15`;
    (function(KeyUsageFlags2) {
      KeyUsageFlags2[KeyUsageFlags2["digitalSignature"] = 1] = "digitalSignature";
      KeyUsageFlags2[KeyUsageFlags2["nonRepudiation"] = 2] = "nonRepudiation";
      KeyUsageFlags2[KeyUsageFlags2["keyEncipherment"] = 4] = "keyEncipherment";
      KeyUsageFlags2[KeyUsageFlags2["dataEncipherment"] = 8] = "dataEncipherment";
      KeyUsageFlags2[KeyUsageFlags2["keyAgreement"] = 16] = "keyAgreement";
      KeyUsageFlags2[KeyUsageFlags2["keyCertSign"] = 32] = "keyCertSign";
      KeyUsageFlags2[KeyUsageFlags2["cRLSign"] = 64] = "cRLSign";
      KeyUsageFlags2[KeyUsageFlags2["encipherOnly"] = 128] = "encipherOnly";
      KeyUsageFlags2[KeyUsageFlags2["decipherOnly"] = 256] = "decipherOnly";
    })(KeyUsageFlags || (KeyUsageFlags = {}));
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_1, id_ce_nameConstraints, GeneralSubtree, GeneralSubtrees, NameConstraints;
var init_name_constraints = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js"() {
    init_tslib_es6();
    init_es2015();
    init_general_name();
    init_object_identifiers();
    id_ce_nameConstraints = `${id_ce}.30`;
    GeneralSubtree = class {
      constructor(params = {}) {
        this.base = new GeneralName();
        this.minimum = 0;
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: GeneralName })
    ], GeneralSubtree.prototype, "base", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, context: 0, defaultValue: 0, implicit: true })
    ], GeneralSubtree.prototype, "minimum", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, context: 1, optional: true, implicit: true })
    ], GeneralSubtree.prototype, "maximum", void 0);
    GeneralSubtrees = GeneralSubtrees_1 = class GeneralSubtrees2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, GeneralSubtrees_1.prototype);
      }
    };
    GeneralSubtrees = GeneralSubtrees_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralSubtree })
    ], GeneralSubtrees);
    NameConstraints = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: GeneralSubtrees, context: 0, optional: true, implicit: true })
    ], NameConstraints.prototype, "permittedSubtrees", void 0);
    __decorate([
      AsnProp({ type: GeneralSubtrees, context: 1, optional: true, implicit: true })
    ], NameConstraints.prototype, "excludedSubtrees", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints, PolicyConstraints;
var init_policy_constraints = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_policyConstraints = `${id_ce}.36`;
    PolicyConstraints = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({
        type: AsnPropTypes.Integer,
        context: 0,
        implicit: true,
        optional: true,
        converter: AsnIntegerArrayBufferConverter
      })
    ], PolicyConstraints.prototype, "requireExplicitPolicy", void 0);
    __decorate([
      AsnProp({
        type: AsnPropTypes.Integer,
        context: 1,
        implicit: true,
        optional: true,
        converter: AsnIntegerArrayBufferConverter
      })
    ], PolicyConstraints.prototype, "inhibitPolicyMapping", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_1, id_ce_policyMappings, PolicyMapping, PolicyMappings;
var init_policy_mappings = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_policyMappings = `${id_ce}.33`;
    PolicyMapping = class {
      constructor(params = {}) {
        this.issuerDomainPolicy = "";
        this.subjectDomainPolicy = "";
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], PolicyMapping.prototype, "issuerDomainPolicy", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], PolicyMapping.prototype, "subjectDomainPolicy", void 0);
    PolicyMappings = PolicyMappings_1 = class PolicyMappings2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, PolicyMappings_1.prototype);
      }
    };
    PolicyMappings = PolicyMappings_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyMapping })
    ], PolicyMappings);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_1, id_ce_subjectAltName, SubjectAlternativeName;
var init_subject_alternative_name = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js"() {
    init_tslib_es6();
    init_es2015();
    init_general_names();
    init_object_identifiers();
    id_ce_subjectAltName = `${id_ce}.17`;
    SubjectAlternativeName = SubjectAlternativeName_1 = class SubjectAlternativeName2 extends GeneralNames {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectAlternativeName_1.prototype);
      }
    };
    SubjectAlternativeName = SubjectAlternativeName_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence })
    ], SubjectAlternativeName);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
var Attribute;
var init_attribute = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/attribute.js"() {
    init_tslib_es6();
    init_es2015();
    Attribute = class {
      constructor(params = {}) {
        this.type = "";
        this.values = [];
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], Attribute.prototype, "type", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
    ], Attribute.prototype, "values", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_1, id_ce_subjectDirectoryAttributes, SubjectDirectoryAttributes;
var init_subject_directory_attributes = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js"() {
    init_tslib_es6();
    init_es2015();
    init_attribute();
    init_object_identifiers();
    id_ce_subjectDirectoryAttributes = `${id_ce}.9`;
    SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = class SubjectDirectoryAttributes2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectDirectoryAttributes_1.prototype);
      }
    };
    SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
    ], SubjectDirectoryAttributes);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier, SubjectKeyIdentifier;
var init_subject_key_identifier = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js"() {
    init_object_identifiers();
    init_authority_key_identifier();
    id_ce_subjectKeyIdentifier = `${id_ce}.14`;
    SubjectKeyIdentifier = class extends KeyIdentifier {
    };
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod, PrivateKeyUsagePeriod;
var init_private_key_usage_period = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    id_ce_privateKeyUsagePeriod = `${id_ce}.16`;
    PrivateKeyUsagePeriod = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 0, implicit: true, optional: true })
    ], PrivateKeyUsagePeriod.prototype, "notBefore", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 1, implicit: true, optional: true })
    ], PrivateKeyUsagePeriod.prototype, "notAfter", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags, EntrustInfo, EntrustVersionInfo;
var init_entrust_version_info = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js"() {
    init_tslib_es6();
    init_es2015();
    (function(EntrustInfoFlags2) {
      EntrustInfoFlags2[EntrustInfoFlags2["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
      EntrustInfoFlags2[EntrustInfoFlags2["newExtensions"] = 2] = "newExtensions";
      EntrustInfoFlags2[EntrustInfoFlags2["pKIXCertificate"] = 4] = "pKIXCertificate";
    })(EntrustInfoFlags || (EntrustInfoFlags = {}));
    EntrustInfo = class extends BitString2 {
      toJSON() {
        const res = [];
        const flags = this.toNumber();
        if (flags & EntrustInfoFlags.pKIXCertificate) {
          res.push("pKIXCertificate");
        }
        if (flags & EntrustInfoFlags.newExtensions) {
          res.push("newExtensions");
        }
        if (flags & EntrustInfoFlags.keyUpdateAllowed) {
          res.push("keyUpdateAllowed");
        }
        return res;
      }
      toString() {
        return `[${this.toJSON().join(", ")}]`;
      }
    };
    EntrustVersionInfo = class {
      constructor(params = {}) {
        this.entrustVers = "";
        this.entrustInfoFlags = new EntrustInfo();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.GeneralString })
    ], EntrustVersionInfo.prototype, "entrustVers", void 0);
    __decorate([
      AsnProp({ type: EntrustInfo })
    ], EntrustVersionInfo.prototype, "entrustInfoFlags", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_1, id_pe_subjectInfoAccess, SubjectInfoAccessSyntax;
var init_subject_info_access = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js"() {
    init_tslib_es6();
    init_es2015();
    init_object_identifiers();
    init_authority_information_access();
    id_pe_subjectInfoAccess = `${id_pe}.11`;
    SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = class SubjectInfoAccessSyntax2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectInfoAccessSyntax_1.prototype);
      }
    };
    SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
    ], SubjectInfoAccessSyntax);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/index.js
var init_extensions = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extensions/index.js"() {
    init_authority_information_access();
    init_authority_key_identifier();
    init_basic_constraints();
    init_certificate_issuer();
    init_certificate_policies();
    init_crl_delta_indicator();
    init_crl_distribution_points();
    init_crl_freshest();
    init_crl_issuing_distribution_point();
    init_crl_number();
    init_crl_reason();
    init_extended_key_usage();
    init_inhibit_any_policy();
    init_invalidity_date();
    init_issuer_alternative_name();
    init_key_usage();
    init_name_constraints();
    init_policy_constraints();
    init_policy_mappings();
    init_subject_alternative_name();
    init_subject_directory_attributes();
    init_subject_key_identifier();
    init_private_key_usage_period();
    init_entrust_version_info();
    init_subject_info_access();
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
var pvtsutils2, AlgorithmIdentifier;
var init_algorithm_identifier = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js"() {
    init_tslib_es6();
    init_es2015();
    pvtsutils2 = __toESM(require_build());
    AlgorithmIdentifier = class _AlgorithmIdentifier {
      constructor(params = {}) {
        this.algorithm = "";
        Object.assign(this, params);
      }
      isEqual(data) {
        return data instanceof _AlgorithmIdentifier && data.algorithm == this.algorithm && (data.parameters && this.parameters && pvtsutils2.isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
      }
    };
    __decorate([
      AsnProp({
        type: AsnPropTypes.ObjectIdentifier
      })
    ], AlgorithmIdentifier.prototype, "algorithm", void 0);
    __decorate([
      AsnProp({
        type: AsnPropTypes.Any,
        optional: true
      })
    ], AlgorithmIdentifier.prototype, "parameters", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
var SubjectPublicKeyInfo;
var init_subject_public_key_info = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js"() {
    init_tslib_es6();
    init_es2015();
    init_algorithm_identifier();
    SubjectPublicKeyInfo = class {
      constructor(params = {}) {
        this.algorithm = new AlgorithmIdentifier();
        this.subjectPublicKey = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AlgorithmIdentifier })
    ], SubjectPublicKeyInfo.prototype, "algorithm", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.BitString })
    ], SubjectPublicKeyInfo.prototype, "subjectPublicKey", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time;
var init_time = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/time.js"() {
    init_tslib_es6();
    init_es2015();
    Time = class Time2 {
      constructor(time) {
        if (time) {
          if (typeof time === "string" || typeof time === "number" || time instanceof Date) {
            const date = new Date(time);
            if (date.getUTCFullYear() > 2049) {
              this.generalTime = date;
            } else {
              this.utcTime = date;
            }
          } else {
            Object.assign(this, time);
          }
        }
      }
      getTime() {
        const time = this.utcTime || this.generalTime;
        if (!time) {
          throw new Error("Cannot get time from CHOICE object");
        }
        return time;
      }
    };
    __decorate([
      AsnProp({
        type: AsnPropTypes.UTCTime
      })
    ], Time.prototype, "utcTime", void 0);
    __decorate([
      AsnProp({
        type: AsnPropTypes.GeneralizedTime
      })
    ], Time.prototype, "generalTime", void 0);
    Time = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], Time);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/validity.js
var Validity;
var init_validity = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/validity.js"() {
    init_tslib_es6();
    init_es2015();
    init_time();
    Validity = class {
      constructor(params) {
        this.notBefore = new Time(/* @__PURE__ */ new Date());
        this.notAfter = new Time(/* @__PURE__ */ new Date());
        if (params) {
          this.notBefore = new Time(params.notBefore);
          this.notAfter = new Time(params.notAfter);
        }
      }
    };
    __decorate([
      AsnProp({ type: Time })
    ], Validity.prototype, "notBefore", void 0);
    __decorate([
      AsnProp({ type: Time })
    ], Validity.prototype, "notAfter", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_1, Extension, Extensions;
var init_extension = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/extension.js"() {
    init_tslib_es6();
    init_es2015();
    Extension = class _Extension {
      constructor(params = {}) {
        this.extnID = "";
        this.critical = _Extension.CRITICAL;
        this.extnValue = new OctetString2();
        Object.assign(this, params);
      }
    };
    Extension.CRITICAL = false;
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], Extension.prototype, "extnID", void 0);
    __decorate([
      AsnProp({
        type: AsnPropTypes.Boolean,
        defaultValue: Extension.CRITICAL
      })
    ], Extension.prototype, "critical", void 0);
    __decorate([
      AsnProp({ type: OctetString2 })
    ], Extension.prototype, "extnValue", void 0);
    Extensions = Extensions_1 = class Extensions2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Extensions_1.prototype);
      }
    };
    Extensions = Extensions_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: Extension })
    ], Extensions);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version;
var init_types2 = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/types.js"() {
    (function(Version3) {
      Version3[Version3["v1"] = 0] = "v1";
      Version3[Version3["v2"] = 1] = "v2";
      Version3[Version3["v3"] = 2] = "v3";
    })(Version || (Version = {}));
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
var TBSCertificate;
var init_tbs_certificate = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js"() {
    init_tslib_es6();
    init_es2015();
    init_algorithm_identifier();
    init_name();
    init_subject_public_key_info();
    init_validity();
    init_extension();
    init_types2();
    TBSCertificate = class {
      constructor(params = {}) {
        this.version = Version.v1;
        this.serialNumber = new ArrayBuffer(0);
        this.signature = new AlgorithmIdentifier();
        this.issuer = new Name();
        this.validity = new Validity();
        this.subject = new Name();
        this.subjectPublicKeyInfo = new SubjectPublicKeyInfo();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({
        type: AsnPropTypes.Integer,
        context: 0,
        defaultValue: Version.v1
      })
    ], TBSCertificate.prototype, "version", void 0);
    __decorate([
      AsnProp({
        type: AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
      })
    ], TBSCertificate.prototype, "serialNumber", void 0);
    __decorate([
      AsnProp({ type: AlgorithmIdentifier })
    ], TBSCertificate.prototype, "signature", void 0);
    __decorate([
      AsnProp({ type: Name })
    ], TBSCertificate.prototype, "issuer", void 0);
    __decorate([
      AsnProp({ type: Validity })
    ], TBSCertificate.prototype, "validity", void 0);
    __decorate([
      AsnProp({ type: Name })
    ], TBSCertificate.prototype, "subject", void 0);
    __decorate([
      AsnProp({ type: SubjectPublicKeyInfo })
    ], TBSCertificate.prototype, "subjectPublicKeyInfo", void 0);
    __decorate([
      AsnProp({
        type: AsnPropTypes.BitString,
        context: 1,
        implicit: true,
        optional: true
      })
    ], TBSCertificate.prototype, "issuerUniqueID", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.BitString, context: 2, implicit: true, optional: true })
    ], TBSCertificate.prototype, "subjectUniqueID", void 0);
    __decorate([
      AsnProp({ type: Extensions, context: 3, optional: true })
    ], TBSCertificate.prototype, "extensions", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
var Certificate;
var init_certificate = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/certificate.js"() {
    init_tslib_es6();
    init_es2015();
    init_algorithm_identifier();
    init_tbs_certificate();
    Certificate = class {
      constructor(params = {}) {
        this.tbsCertificate = new TBSCertificate();
        this.signatureAlgorithm = new AlgorithmIdentifier();
        this.signatureValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: TBSCertificate })
    ], Certificate.prototype, "tbsCertificate", void 0);
    __decorate([
      AsnProp({ type: AlgorithmIdentifier })
    ], Certificate.prototype, "signatureAlgorithm", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.BitString })
    ], Certificate.prototype, "signatureValue", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
var RevokedCertificate, TBSCertList;
var init_tbs_cert_list = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js"() {
    init_tslib_es6();
    init_es2015();
    init_algorithm_identifier();
    init_name();
    init_time();
    init_extension();
    RevokedCertificate = class {
      constructor(params = {}) {
        this.userCertificate = new ArrayBuffer(0);
        this.revocationDate = new Time();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RevokedCertificate.prototype, "userCertificate", void 0);
    __decorate([
      AsnProp({ type: Time })
    ], RevokedCertificate.prototype, "revocationDate", void 0);
    __decorate([
      AsnProp({ type: Extension, optional: true, repeated: "sequence" })
    ], RevokedCertificate.prototype, "crlEntryExtensions", void 0);
    TBSCertList = class {
      constructor(params = {}) {
        this.signature = new AlgorithmIdentifier();
        this.issuer = new Name();
        this.thisUpdate = new Time();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, optional: true })
    ], TBSCertList.prototype, "version", void 0);
    __decorate([
      AsnProp({ type: AlgorithmIdentifier })
    ], TBSCertList.prototype, "signature", void 0);
    __decorate([
      AsnProp({ type: Name })
    ], TBSCertList.prototype, "issuer", void 0);
    __decorate([
      AsnProp({ type: Time })
    ], TBSCertList.prototype, "thisUpdate", void 0);
    __decorate([
      AsnProp({ type: Time, optional: true })
    ], TBSCertList.prototype, "nextUpdate", void 0);
    __decorate([
      AsnProp({ type: RevokedCertificate, repeated: "sequence", optional: true })
    ], TBSCertList.prototype, "revokedCertificates", void 0);
    __decorate([
      AsnProp({ type: Extension, optional: true, context: 0, repeated: "sequence" })
    ], TBSCertList.prototype, "crlExtensions", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
var CertificateList;
var init_certificate_list = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js"() {
    init_tslib_es6();
    init_es2015();
    init_algorithm_identifier();
    init_tbs_cert_list();
    CertificateList = class {
      constructor(params = {}) {
        this.tbsCertList = new TBSCertList();
        this.signatureAlgorithm = new AlgorithmIdentifier();
        this.signature = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: TBSCertList })
    ], CertificateList.prototype, "tbsCertList", void 0);
    __decorate([
      AsnProp({ type: AlgorithmIdentifier })
    ], CertificateList.prototype, "signatureAlgorithm", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.BitString })
    ], CertificateList.prototype, "signature", void 0);
  }
});

// node_modules/@peculiar/asn1-x509/build/es2015/index.js
var init_es20152 = __esm({
  "node_modules/@peculiar/asn1-x509/build/es2015/index.js"() {
    init_extensions();
    init_algorithm_identifier();
    init_attribute();
    init_certificate();
    init_certificate_list();
    init_extension();
    init_general_name();
    init_general_names();
    init_name();
    init_object_identifiers();
    init_subject_public_key_info();
    init_tbs_cert_list();
    init_tbs_certificate();
    init_time();
    init_types2();
    init_validity();
  }
});

// node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js
var id_ecPublicKey, id_ecdsaWithSHA1, id_ecdsaWithSHA224, id_ecdsaWithSHA256, id_ecdsaWithSHA384, id_ecdsaWithSHA512, id_secp256r1, id_secp384r1;
var init_object_identifiers2 = __esm({
  "node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js"() {
    id_ecPublicKey = "1.2.840.10045.2.1";
    id_ecdsaWithSHA1 = "1.2.840.10045.4.1";
    id_ecdsaWithSHA224 = "1.2.840.10045.4.3.1";
    id_ecdsaWithSHA256 = "1.2.840.10045.4.3.2";
    id_ecdsaWithSHA384 = "1.2.840.10045.4.3.3";
    id_ecdsaWithSHA512 = "1.2.840.10045.4.3.4";
    id_secp256r1 = "1.2.840.10045.3.1.7";
    id_secp384r1 = "1.3.132.0.34";
  }
});

// node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js
function create2(algorithm) {
  return new AlgorithmIdentifier({ algorithm });
}
var ecdsaWithSHA1, ecdsaWithSHA224, ecdsaWithSHA256, ecdsaWithSHA384, ecdsaWithSHA512;
var init_algorithms = __esm({
  "node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js"() {
    init_es20152();
    init_object_identifiers2();
    ecdsaWithSHA1 = create2(id_ecdsaWithSHA1);
    ecdsaWithSHA224 = create2(id_ecdsaWithSHA224);
    ecdsaWithSHA256 = create2(id_ecdsaWithSHA256);
    ecdsaWithSHA384 = create2(id_ecdsaWithSHA384);
    ecdsaWithSHA512 = create2(id_ecdsaWithSHA512);
  }
});

// node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js
var ECParameters;
var init_ec_parameters = __esm({
  "node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js"() {
    init_tslib_es6();
    init_es2015();
    ECParameters = class ECParameters2 {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], ECParameters.prototype, "namedCurve", void 0);
    ECParameters = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], ECParameters);
  }
});

// node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js
var ECPrivateKey;
var init_ec_private_key = __esm({
  "node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js"() {
    init_tslib_es6();
    init_es2015();
    init_ec_parameters();
    ECPrivateKey = class {
      constructor(params = {}) {
        this.version = 1;
        this.privateKey = new OctetString2();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], ECPrivateKey.prototype, "version", void 0);
    __decorate([
      AsnProp({ type: OctetString2 })
    ], ECPrivateKey.prototype, "privateKey", void 0);
    __decorate([
      AsnProp({ type: ECParameters, context: 0, optional: true })
    ], ECPrivateKey.prototype, "parameters", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.BitString, context: 1, optional: true })
    ], ECPrivateKey.prototype, "publicKey", void 0);
  }
});

// node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js
var ECDSASigValue;
var init_ec_signature_value = __esm({
  "node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js"() {
    init_tslib_es6();
    init_es2015();
    ECDSASigValue = class {
      constructor(params = {}) {
        this.r = new ArrayBuffer(0);
        this.s = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], ECDSASigValue.prototype, "r", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], ECDSASigValue.prototype, "s", void 0);
  }
});

// node_modules/@peculiar/asn1-ecc/build/es2015/index.js
var init_es20153 = __esm({
  "node_modules/@peculiar/asn1-ecc/build/es2015/index.js"() {
    init_algorithms();
    init_ec_parameters();
    init_ec_private_key();
    init_ec_signature_value();
    init_object_identifiers2();
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js
var id_pkcs_1, id_rsaEncryption, id_RSAES_OAEP, id_pSpecified, id_RSASSA_PSS, id_md2WithRSAEncryption, id_md5WithRSAEncryption, id_sha1WithRSAEncryption, id_sha224WithRSAEncryption, id_sha256WithRSAEncryption, id_sha384WithRSAEncryption, id_sha512WithRSAEncryption, id_sha512_224WithRSAEncryption, id_sha512_256WithRSAEncryption, id_sha1, id_sha224, id_sha256, id_sha384, id_sha512, id_sha512_224, id_sha512_256, id_md2, id_md5, id_mgf1;
var init_object_identifiers3 = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js"() {
    id_pkcs_1 = "1.2.840.113549.1.1";
    id_rsaEncryption = `${id_pkcs_1}.1`;
    id_RSAES_OAEP = `${id_pkcs_1}.7`;
    id_pSpecified = `${id_pkcs_1}.9`;
    id_RSASSA_PSS = `${id_pkcs_1}.10`;
    id_md2WithRSAEncryption = `${id_pkcs_1}.2`;
    id_md5WithRSAEncryption = `${id_pkcs_1}.4`;
    id_sha1WithRSAEncryption = `${id_pkcs_1}.5`;
    id_sha224WithRSAEncryption = `${id_pkcs_1}.14`;
    id_sha256WithRSAEncryption = `${id_pkcs_1}.11`;
    id_sha384WithRSAEncryption = `${id_pkcs_1}.12`;
    id_sha512WithRSAEncryption = `${id_pkcs_1}.13`;
    id_sha512_224WithRSAEncryption = `${id_pkcs_1}.15`;
    id_sha512_256WithRSAEncryption = `${id_pkcs_1}.16`;
    id_sha1 = "1.3.14.3.2.26";
    id_sha224 = "2.16.840.1.101.3.4.2.4";
    id_sha256 = "2.16.840.1.101.3.4.2.1";
    id_sha384 = "2.16.840.1.101.3.4.2.2";
    id_sha512 = "2.16.840.1.101.3.4.2.3";
    id_sha512_224 = "2.16.840.1.101.3.4.2.5";
    id_sha512_256 = "2.16.840.1.101.3.4.2.6";
    id_md2 = "1.2.840.113549.2.2";
    id_md5 = "1.2.840.113549.2.5";
    id_mgf1 = `${id_pkcs_1}.8`;
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js
function create3(algorithm) {
  return new AlgorithmIdentifier({ algorithm, parameters: null });
}
var md2, md4, sha1, sha224, sha2562, sha384, sha512, sha512_224, sha512_256, mgf1SHA1, pSpecifiedEmpty, rsaEncryption, md2WithRSAEncryption, md5WithRSAEncryption, sha1WithRSAEncryption, sha224WithRSAEncryption, sha256WithRSAEncryption, sha384WithRSAEncryption, sha512WithRSAEncryption, sha512_224WithRSAEncryption, sha512_256WithRSAEncryption;
var init_algorithms2 = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js"() {
    init_es2015();
    init_es20152();
    init_object_identifiers3();
    md2 = create3(id_md2);
    md4 = create3(id_md5);
    sha1 = create3(id_sha1);
    sha224 = create3(id_sha224);
    sha2562 = create3(id_sha256);
    sha384 = create3(id_sha384);
    sha512 = create3(id_sha512);
    sha512_224 = create3(id_sha512_224);
    sha512_256 = create3(id_sha512_256);
    mgf1SHA1 = new AlgorithmIdentifier({
      algorithm: id_mgf1,
      parameters: AsnConvert.serialize(sha1)
    });
    pSpecifiedEmpty = new AlgorithmIdentifier({
      algorithm: id_pSpecified,
      parameters: AsnConvert.serialize(AsnOctetStringConverter.toASN(new Uint8Array([218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24, 144, 175, 216, 7, 9]).buffer))
    });
    rsaEncryption = create3(id_rsaEncryption);
    md2WithRSAEncryption = create3(id_md2WithRSAEncryption);
    md5WithRSAEncryption = create3(id_md5WithRSAEncryption);
    sha1WithRSAEncryption = create3(id_sha1WithRSAEncryption);
    sha224WithRSAEncryption = create3(id_sha512_224WithRSAEncryption);
    sha256WithRSAEncryption = create3(id_sha512_256WithRSAEncryption);
    sha384WithRSAEncryption = create3(id_sha384WithRSAEncryption);
    sha512WithRSAEncryption = create3(id_sha512WithRSAEncryption);
    sha512_224WithRSAEncryption = create3(id_sha512_224WithRSAEncryption);
    sha512_256WithRSAEncryption = create3(id_sha512_256WithRSAEncryption);
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js
var RsaEsOaepParams, RSAES_OAEP;
var init_rsaes_oaep = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js"() {
    init_tslib_es6();
    init_es2015();
    init_es20152();
    init_object_identifiers3();
    init_algorithms2();
    RsaEsOaepParams = class {
      constructor(params = {}) {
        this.hashAlgorithm = new AlgorithmIdentifier(sha1);
        this.maskGenAlgorithm = new AlgorithmIdentifier({
          algorithm: id_mgf1,
          parameters: AsnConvert.serialize(sha1)
        });
        this.pSourceAlgorithm = new AlgorithmIdentifier(pSpecifiedEmpty);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha1 })
    ], RsaEsOaepParams.prototype, "hashAlgorithm", void 0);
    __decorate([
      AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
    ], RsaEsOaepParams.prototype, "maskGenAlgorithm", void 0);
    __decorate([
      AsnProp({ type: AlgorithmIdentifier, context: 2, defaultValue: pSpecifiedEmpty })
    ], RsaEsOaepParams.prototype, "pSourceAlgorithm", void 0);
    RSAES_OAEP = new AlgorithmIdentifier({
      algorithm: id_RSAES_OAEP,
      parameters: AsnConvert.serialize(new RsaEsOaepParams())
    });
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js
var RsaSaPssParams, RSASSA_PSS;
var init_rsassa_pss = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js"() {
    init_tslib_es6();
    init_es2015();
    init_es20152();
    init_object_identifiers3();
    init_algorithms2();
    RsaSaPssParams = class {
      constructor(params = {}) {
        this.hashAlgorithm = new AlgorithmIdentifier(sha1);
        this.maskGenAlgorithm = new AlgorithmIdentifier({
          algorithm: id_mgf1,
          parameters: AsnConvert.serialize(sha1)
        });
        this.saltLength = 20;
        this.trailerField = 1;
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha1 })
    ], RsaSaPssParams.prototype, "hashAlgorithm", void 0);
    __decorate([
      AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
    ], RsaSaPssParams.prototype, "maskGenAlgorithm", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, context: 2, defaultValue: 20 })
    ], RsaSaPssParams.prototype, "saltLength", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, context: 3, defaultValue: 1 })
    ], RsaSaPssParams.prototype, "trailerField", void 0);
    RSASSA_PSS = new AlgorithmIdentifier({
      algorithm: id_RSASSA_PSS,
      parameters: AsnConvert.serialize(new RsaSaPssParams())
    });
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js
var DigestInfo;
var init_rsassa_pkcs1_v1_5 = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js"() {
    init_tslib_es6();
    init_es20152();
    init_es2015();
    DigestInfo = class {
      constructor(params = {}) {
        this.digestAlgorithm = new AlgorithmIdentifier();
        this.digest = new OctetString2();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AlgorithmIdentifier })
    ], DigestInfo.prototype, "digestAlgorithm", void 0);
    __decorate([
      AsnProp({ type: OctetString2 })
    ], DigestInfo.prototype, "digest", void 0);
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/index.js
var init_parameters = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/parameters/index.js"() {
    init_rsaes_oaep();
    init_rsassa_pss();
    init_rsassa_pkcs1_v1_5();
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js
var OtherPrimeInfos_1, OtherPrimeInfo, OtherPrimeInfos;
var init_other_prime_info = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js"() {
    init_tslib_es6();
    init_es2015();
    OtherPrimeInfo = class {
      constructor(params = {}) {
        this.prime = new ArrayBuffer(0);
        this.exponent = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], OtherPrimeInfo.prototype, "prime", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], OtherPrimeInfo.prototype, "exponent", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], OtherPrimeInfo.prototype, "coefficient", void 0);
    OtherPrimeInfos = OtherPrimeInfos_1 = class OtherPrimeInfos2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, OtherPrimeInfos_1.prototype);
      }
    };
    OtherPrimeInfos = OtherPrimeInfos_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: OtherPrimeInfo })
    ], OtherPrimeInfos);
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js
var RSAPrivateKey;
var init_rsa_private_key = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js"() {
    init_tslib_es6();
    init_es2015();
    init_other_prime_info();
    RSAPrivateKey = class {
      constructor(params = {}) {
        this.version = 0;
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        this.privateExponent = new ArrayBuffer(0);
        this.prime1 = new ArrayBuffer(0);
        this.prime2 = new ArrayBuffer(0);
        this.exponent1 = new ArrayBuffer(0);
        this.exponent2 = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], RSAPrivateKey.prototype, "version", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "modulus", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "publicExponent", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "privateExponent", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "prime1", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "prime2", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "exponent1", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "exponent2", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "coefficient", void 0);
    __decorate([
      AsnProp({ type: OtherPrimeInfos, optional: true })
    ], RSAPrivateKey.prototype, "otherPrimeInfos", void 0);
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js
var RSAPublicKey;
var init_rsa_public_key = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js"() {
    init_tslib_es6();
    init_es2015();
    RSAPublicKey = class {
      constructor(params = {}) {
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPublicKey.prototype, "modulus", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
    ], RSAPublicKey.prototype, "publicExponent", void 0);
  }
});

// node_modules/@peculiar/asn1-rsa/build/es2015/index.js
var init_es20154 = __esm({
  "node_modules/@peculiar/asn1-rsa/build/es2015/index.js"() {
    init_parameters();
    init_algorithms2();
    init_object_identifiers3();
    init_other_prime_info();
    init_rsa_private_key();
    init_rsa_public_key();
  }
});

// node_modules/@peculiar/asn1-android/build/es2015/key_description.js
var IntegerSet_1, id_ce_keyDescription, VerifiedBootState, RootOfTrust, IntegerSet, AuthorizationList, SecurityLevel, Version2, KeyDescription;
var init_key_description = __esm({
  "node_modules/@peculiar/asn1-android/build/es2015/key_description.js"() {
    init_tslib_es6();
    init_es2015();
    id_ce_keyDescription = "1.3.6.1.4.1.11129.2.1.17";
    (function(VerifiedBootState2) {
      VerifiedBootState2[VerifiedBootState2["verified"] = 0] = "verified";
      VerifiedBootState2[VerifiedBootState2["selfSigned"] = 1] = "selfSigned";
      VerifiedBootState2[VerifiedBootState2["unverified"] = 2] = "unverified";
      VerifiedBootState2[VerifiedBootState2["failed"] = 3] = "failed";
    })(VerifiedBootState || (VerifiedBootState = {}));
    RootOfTrust = class {
      constructor(params = {}) {
        this.verifiedBootKey = new OctetString2();
        this.deviceLocked = false;
        this.verifiedBootState = VerifiedBootState.verified;
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: OctetString2 })
    ], RootOfTrust.prototype, "verifiedBootKey", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Boolean })
    ], RootOfTrust.prototype, "deviceLocked", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Enumerated })
    ], RootOfTrust.prototype, "verifiedBootState", void 0);
    __decorate([
      AsnProp({ type: OctetString2, optional: true })
    ], RootOfTrust.prototype, "verifiedBootHash", void 0);
    IntegerSet = IntegerSet_1 = class IntegerSet2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, IntegerSet_1.prototype);
      }
    };
    IntegerSet = IntegerSet_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Set, itemType: AsnPropTypes.Integer })
    ], IntegerSet);
    AuthorizationList = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ context: 1, type: IntegerSet, optional: true })
    ], AuthorizationList.prototype, "purpose", void 0);
    __decorate([
      AsnProp({ context: 2, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "algorithm", void 0);
    __decorate([
      AsnProp({ context: 3, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "keySize", void 0);
    __decorate([
      AsnProp({ context: 5, type: IntegerSet, optional: true })
    ], AuthorizationList.prototype, "digest", void 0);
    __decorate([
      AsnProp({ context: 6, type: IntegerSet, optional: true })
    ], AuthorizationList.prototype, "padding", void 0);
    __decorate([
      AsnProp({ context: 10, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "ecCurve", void 0);
    __decorate([
      AsnProp({ context: 200, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "rsaPublicExponent", void 0);
    __decorate([
      AsnProp({ context: 203, type: IntegerSet, optional: true })
    ], AuthorizationList.prototype, "mgfDigest", void 0);
    __decorate([
      AsnProp({ context: 303, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "rollbackResistance", void 0);
    __decorate([
      AsnProp({ context: 305, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "earlyBootOnly", void 0);
    __decorate([
      AsnProp({ context: 400, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "activeDateTime", void 0);
    __decorate([
      AsnProp({ context: 401, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "originationExpireDateTime", void 0);
    __decorate([
      AsnProp({ context: 402, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "usageExpireDateTime", void 0);
    __decorate([
      AsnProp({ context: 405, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "usageCountLimit", void 0);
    __decorate([
      AsnProp({ context: 503, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "noAuthRequired", void 0);
    __decorate([
      AsnProp({ context: 504, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "userAuthType", void 0);
    __decorate([
      AsnProp({ context: 505, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "authTimeout", void 0);
    __decorate([
      AsnProp({ context: 506, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "allowWhileOnBody", void 0);
    __decorate([
      AsnProp({ context: 507, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "trustedUserPresenceRequired", void 0);
    __decorate([
      AsnProp({ context: 508, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "trustedConfirmationRequired", void 0);
    __decorate([
      AsnProp({ context: 509, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "unlockedDeviceRequired", void 0);
    __decorate([
      AsnProp({ context: 600, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "allApplications", void 0);
    __decorate([
      AsnProp({ context: 601, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "applicationId", void 0);
    __decorate([
      AsnProp({ context: 701, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "creationDateTime", void 0);
    __decorate([
      AsnProp({ context: 702, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "origin", void 0);
    __decorate([
      AsnProp({ context: 703, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "rollbackResistant", void 0);
    __decorate([
      AsnProp({ context: 704, type: RootOfTrust, optional: true })
    ], AuthorizationList.prototype, "rootOfTrust", void 0);
    __decorate([
      AsnProp({ context: 705, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "osVersion", void 0);
    __decorate([
      AsnProp({ context: 706, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "osPatchLevel", void 0);
    __decorate([
      AsnProp({ context: 709, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationApplicationId", void 0);
    __decorate([
      AsnProp({ context: 710, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdBrand", void 0);
    __decorate([
      AsnProp({ context: 711, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdDevice", void 0);
    __decorate([
      AsnProp({ context: 712, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdProduct", void 0);
    __decorate([
      AsnProp({ context: 713, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdSerial", void 0);
    __decorate([
      AsnProp({ context: 714, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdImei", void 0);
    __decorate([
      AsnProp({ context: 715, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdMeid", void 0);
    __decorate([
      AsnProp({ context: 716, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdManufacturer", void 0);
    __decorate([
      AsnProp({ context: 717, type: OctetString2, optional: true })
    ], AuthorizationList.prototype, "attestationIdModel", void 0);
    __decorate([
      AsnProp({ context: 718, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "vendorPatchLevel", void 0);
    __decorate([
      AsnProp({ context: 719, type: AsnPropTypes.Integer, optional: true })
    ], AuthorizationList.prototype, "bootPatchLevel", void 0);
    __decorate([
      AsnProp({ context: 720, type: AsnPropTypes.Null, optional: true })
    ], AuthorizationList.prototype, "deviceUniqueAttestation", void 0);
    (function(SecurityLevel2) {
      SecurityLevel2[SecurityLevel2["software"] = 0] = "software";
      SecurityLevel2[SecurityLevel2["trustedEnvironment"] = 1] = "trustedEnvironment";
      SecurityLevel2[SecurityLevel2["strongBox"] = 2] = "strongBox";
    })(SecurityLevel || (SecurityLevel = {}));
    (function(Version3) {
      Version3[Version3["KM2"] = 1] = "KM2";
      Version3[Version3["KM3"] = 2] = "KM3";
      Version3[Version3["KM4"] = 3] = "KM4";
      Version3[Version3["KM4_1"] = 4] = "KM4_1";
      Version3[Version3["keyMint1"] = 100] = "keyMint1";
      Version3[Version3["keyMint2"] = 200] = "keyMint2";
    })(Version2 || (Version2 = {}));
    KeyDescription = class {
      constructor(params = {}) {
        this.attestationVersion = Version2.KM4;
        this.attestationSecurityLevel = SecurityLevel.software;
        this.keymasterVersion = 0;
        this.keymasterSecurityLevel = SecurityLevel.software;
        this.attestationChallenge = new OctetString2();
        this.uniqueId = new OctetString2();
        this.softwareEnforced = new AuthorizationList();
        this.teeEnforced = new AuthorizationList();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], KeyDescription.prototype, "attestationVersion", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Enumerated })
    ], KeyDescription.prototype, "attestationSecurityLevel", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], KeyDescription.prototype, "keymasterVersion", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Enumerated })
    ], KeyDescription.prototype, "keymasterSecurityLevel", void 0);
    __decorate([
      AsnProp({ type: OctetString2 })
    ], KeyDescription.prototype, "attestationChallenge", void 0);
    __decorate([
      AsnProp({ type: OctetString2 })
    ], KeyDescription.prototype, "uniqueId", void 0);
    __decorate([
      AsnProp({ type: AuthorizationList })
    ], KeyDescription.prototype, "softwareEnforced", void 0);
    __decorate([
      AsnProp({ type: AuthorizationList })
    ], KeyDescription.prototype, "teeEnforced", void 0);
  }
});

// node_modules/@peculiar/asn1-android/build/es2015/nonstandard.js
var NonStandardAuthorizationList_1, NonStandardAuthorization, NonStandardAuthorizationList, NonStandardKeyDescription;
var init_nonstandard = __esm({
  "node_modules/@peculiar/asn1-android/build/es2015/nonstandard.js"() {
    init_tslib_es6();
    init_es2015();
    init_key_description();
    NonStandardAuthorization = class NonStandardAuthorization2 extends AuthorizationList {
    };
    NonStandardAuthorization = __decorate([
      AsnType({ type: AsnTypeTypes.Choice })
    ], NonStandardAuthorization);
    NonStandardAuthorizationList = NonStandardAuthorizationList_1 = class NonStandardAuthorizationList2 extends AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, NonStandardAuthorizationList_1.prototype);
      }
      findProperty(key3) {
        const prop = this.find((o7) => key3 in o7);
        if (prop) {
          return prop[key3];
        }
        return void 0;
      }
    };
    NonStandardAuthorizationList = NonStandardAuthorizationList_1 = __decorate([
      AsnType({ type: AsnTypeTypes.Sequence, itemType: NonStandardAuthorization })
    ], NonStandardAuthorizationList);
    NonStandardKeyDescription = class {
      constructor(params = {}) {
        this.attestationVersion = Version2.KM4;
        this.attestationSecurityLevel = SecurityLevel.software;
        this.keymasterVersion = 0;
        this.keymasterSecurityLevel = SecurityLevel.software;
        this.attestationChallenge = new OctetString2();
        this.uniqueId = new OctetString2();
        this.softwareEnforced = new NonStandardAuthorizationList();
        this.teeEnforced = new NonStandardAuthorizationList();
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], NonStandardKeyDescription.prototype, "attestationVersion", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Enumerated })
    ], NonStandardKeyDescription.prototype, "attestationSecurityLevel", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], NonStandardKeyDescription.prototype, "keymasterVersion", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Enumerated })
    ], NonStandardKeyDescription.prototype, "keymasterSecurityLevel", void 0);
    __decorate([
      AsnProp({ type: OctetString2 })
    ], NonStandardKeyDescription.prototype, "attestationChallenge", void 0);
    __decorate([
      AsnProp({ type: OctetString2 })
    ], NonStandardKeyDescription.prototype, "uniqueId", void 0);
    __decorate([
      AsnProp({ type: NonStandardAuthorizationList })
    ], NonStandardKeyDescription.prototype, "softwareEnforced", void 0);
    __decorate([
      AsnProp({ type: NonStandardAuthorizationList })
    ], NonStandardKeyDescription.prototype, "teeEnforced", void 0);
  }
});

// node_modules/@peculiar/asn1-android/build/es2015/attestation.js
var AttestationPackageInfo, AttestationApplicationId;
var init_attestation = __esm({
  "node_modules/@peculiar/asn1-android/build/es2015/attestation.js"() {
    init_tslib_es6();
    init_es2015();
    AttestationPackageInfo = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AsnPropTypes.OctetString })
    ], AttestationPackageInfo.prototype, "packageName", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.Integer })
    ], AttestationPackageInfo.prototype, "version", void 0);
    AttestationApplicationId = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    __decorate([
      AsnProp({ type: AttestationPackageInfo, repeated: "set" })
    ], AttestationApplicationId.prototype, "packageInfos", void 0);
    __decorate([
      AsnProp({ type: AsnPropTypes.OctetString, repeated: "set" })
    ], AttestationApplicationId.prototype, "signatureDigests", void 0);
  }
});

// node_modules/@peculiar/asn1-android/build/es2015/index.js
var init_es20155 = __esm({
  "node_modules/@peculiar/asn1-android/build/es2015/index.js"() {
    init_key_description();
    init_nonstandard();
    init_attestation();
  }
});

// node_modules/@simplewebauthn/server/esm/deps.js
var cborx, import_cross_fetch;
var init_deps = __esm({
  "node_modules/@simplewebauthn/server/esm/deps.js"() {
    cborx = __toESM(require_index_no_eval(), 1);
    init_base64();
    import_cross_fetch = __toESM(require_browser_ponyfill(), 1);
    init_es2015();
    init_es20152();
    init_es20153();
    init_es20154();
    init_es20155();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoBase64URL.js
var isoBase64URL_exports = {};
__export(isoBase64URL_exports, {
  fromBuffer: () => fromBuffer,
  fromString: () => fromString,
  isBase64: () => isBase64,
  isBase64url: () => isBase64url,
  toBase64: () => toBase64,
  toBuffer: () => toBuffer,
  toString: () => toString
});
function toBuffer(base64urlString, from = "base64url") {
  const _buffer = base64_default.toArrayBuffer(base64urlString, from === "base64url");
  return new Uint8Array(_buffer);
}
function fromBuffer(buffer, to = "base64url") {
  return base64_default.fromArrayBuffer(buffer, to === "base64url");
}
function toBase64(base64urlString) {
  const fromBase64Url = base64_default.toArrayBuffer(base64urlString, true);
  const toBase642 = base64_default.fromArrayBuffer(fromBase64Url);
  return toBase642;
}
function fromString(ascii) {
  return base64_default.fromString(ascii, true);
}
function toString(base64urlString) {
  return base64_default.toString(base64urlString, true);
}
function isBase64(input) {
  return base64_default.validate(input, false);
}
function isBase64url(input) {
  input = input.replace(/=/g, "");
  return base64_default.validate(input, true);
}
var init_isoBase64URL = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoBase64URL.js"() {
    init_deps();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCBOR.js
var isoCBOR_exports = {};
__export(isoCBOR_exports, {
  decodeFirst: () => decodeFirst,
  encode: () => encode3
});
function decodeFirst(input) {
  const _input = new Uint8Array(input);
  const decoded = encoder4.decodeMultiple(_input);
  if (decoded === void 0) {
    throw new Error("CBOR input data was empty");
  }
  const [first] = decoded;
  return first;
}
function encode3(input) {
  return encoder4.encode(input);
}
var encoder4;
var init_isoCBOR = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCBOR.js"() {
    init_deps();
    encoder4 = new cborx.Encoder({
      mapsAsObjects: false,
      tagUint8Array: false
    });
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/cose.js
function isCOSEPublicKeyOKP(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.OKP;
}
function isCOSEPublicKeyEC2(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.EC2;
}
function isCOSEPublicKeyRSA(cosePublicKey) {
  const kty = cosePublicKey.get(COSEKEYS.kty);
  return isCOSEKty(kty) && kty === COSEKTY.RSA;
}
function isCOSEKty(kty) {
  return Object.values(COSEKTY).indexOf(kty) >= 0;
}
function isCOSEAlg(alg) {
  return Object.values(COSEALG).indexOf(alg) >= 0;
}
var COSEKEYS, COSEKTY, COSECRV, COSEALG;
var init_cose = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/cose.js"() {
    (function(COSEKEYS2) {
      COSEKEYS2[COSEKEYS2["kty"] = 1] = "kty";
      COSEKEYS2[COSEKEYS2["alg"] = 3] = "alg";
      COSEKEYS2[COSEKEYS2["crv"] = -1] = "crv";
      COSEKEYS2[COSEKEYS2["x"] = -2] = "x";
      COSEKEYS2[COSEKEYS2["y"] = -3] = "y";
      COSEKEYS2[COSEKEYS2["n"] = -1] = "n";
      COSEKEYS2[COSEKEYS2["e"] = -2] = "e";
    })(COSEKEYS || (COSEKEYS = {}));
    (function(COSEKTY2) {
      COSEKTY2[COSEKTY2["OKP"] = 1] = "OKP";
      COSEKTY2[COSEKTY2["EC2"] = 2] = "EC2";
      COSEKTY2[COSEKTY2["RSA"] = 3] = "RSA";
    })(COSEKTY || (COSEKTY = {}));
    (function(COSECRV2) {
      COSECRV2[COSECRV2["P256"] = 1] = "P256";
      COSECRV2[COSECRV2["P384"] = 2] = "P384";
      COSECRV2[COSECRV2["P521"] = 3] = "P521";
      COSECRV2[COSECRV2["ED25519"] = 6] = "ED25519";
      COSECRV2[COSECRV2["SECP256K1"] = 8] = "SECP256K1";
    })(COSECRV || (COSECRV = {}));
    (function(COSEALG2) {
      COSEALG2[COSEALG2["ES256"] = -7] = "ES256";
      COSEALG2[COSEALG2["EdDSA"] = -8] = "EdDSA";
      COSEALG2[COSEALG2["ES384"] = -35] = "ES384";
      COSEALG2[COSEALG2["ES512"] = -36] = "ES512";
      COSEALG2[COSEALG2["PS256"] = -37] = "PS256";
      COSEALG2[COSEALG2["PS384"] = -38] = "PS384";
      COSEALG2[COSEALG2["PS512"] = -39] = "PS512";
      COSEALG2[COSEALG2["ES256K"] = -47] = "ES256K";
      COSEALG2[COSEALG2["RS256"] = -257] = "RS256";
      COSEALG2[COSEALG2["RS384"] = -258] = "RS384";
      COSEALG2[COSEALG2["RS512"] = -259] = "RS512";
      COSEALG2[COSEALG2["RS1"] = -65535] = "RS1";
    })(COSEALG || (COSEALG = {}));
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoAlg.js
function mapCoseAlgToWebCryptoAlg(alg) {
  if ([COSEALG.RS1].indexOf(alg) >= 0) {
    return "SHA-1";
  } else if ([COSEALG.ES256, COSEALG.PS256, COSEALG.RS256].indexOf(alg) >= 0) {
    return "SHA-256";
  } else if ([COSEALG.ES384, COSEALG.PS384, COSEALG.RS384].indexOf(alg) >= 0) {
    return "SHA-384";
  } else if ([COSEALG.ES512, COSEALG.PS512, COSEALG.RS512, COSEALG.EdDSA].indexOf(alg) >= 0) {
    return "SHA-512";
  }
  throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto alg`);
}
var init_mapCoseAlgToWebCryptoAlg = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoAlg.js"() {
    init_cose();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getWebCrypto.js
async function getWebCrypto() {
  if (webCrypto) {
    return webCrypto;
  }
  const _globalThisCrypto = _getWebCryptoInternals.stubThisGlobalThisCrypto();
  if (_globalThisCrypto) {
    webCrypto = _globalThisCrypto;
    return webCrypto;
  }
  const _nodeCrypto = await _getWebCryptoInternals.stubThisImportNodeCrypto();
  if (_nodeCrypto?.webcrypto) {
    webCrypto = _nodeCrypto.webcrypto;
    return webCrypto;
  }
  throw new MissingWebCrypto();
}
var webCrypto, MissingWebCrypto, _getWebCryptoInternals;
var init_getWebCrypto = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getWebCrypto.js"() {
    webCrypto = void 0;
    MissingWebCrypto = class extends Error {
      constructor() {
        const message2 = "An instance of the Crypto API could not be located";
        super(message2);
        this.name = "MissingWebCrypto";
      }
    };
    _getWebCryptoInternals = {
      stubThisImportNodeCrypto: async () => {
        try {
          const _nodeCrypto = await import(
            /* webpackIgnore: true */
            "node:crypto"
          );
          return _nodeCrypto;
        } catch (_err) {
          return { webcrypto: void 0 };
        }
      },
      stubThisGlobalThisCrypto: () => globalThis.crypto,
      // Make it possible to reset the `webCrypto` at the top of the file
      setCachedCrypto: (newCrypto) => {
        webCrypto = newCrypto;
      }
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/digest.js
async function digest(data, algorithm) {
  const WebCrypto = await getWebCrypto();
  const subtleAlgorithm = mapCoseAlgToWebCryptoAlg(algorithm);
  const hashed = await WebCrypto.subtle.digest(subtleAlgorithm, data);
  return new Uint8Array(hashed);
}
var init_digest2 = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/digest.js"() {
    init_mapCoseAlgToWebCryptoAlg();
    init_getWebCrypto();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getRandomValues.js
async function getRandomValues(array2) {
  const WebCrypto = await getWebCrypto();
  WebCrypto.getRandomValues(array2);
  return array2;
}
var init_getRandomValues = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/getRandomValues.js"() {
    init_getWebCrypto();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/importKey.js
async function importKey(opts) {
  const WebCrypto = await getWebCrypto();
  const { keyData, algorithm } = opts;
  return WebCrypto.subtle.importKey("jwk", keyData, algorithm, false, [
    "verify"
  ]);
}
var init_importKey = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/importKey.js"() {
    init_getWebCrypto();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyEC2.js
async function verifyEC2(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const crv = cosePublicKey.get(COSEKEYS.crv);
  const x4 = cosePublicKey.get(COSEKEYS.x);
  const y7 = cosePublicKey.get(COSEKEYS.y);
  if (!alg) {
    throw new Error("Public key was missing alg (EC2)");
  }
  if (!crv) {
    throw new Error("Public key was missing crv (EC2)");
  }
  if (!x4) {
    throw new Error("Public key was missing x (EC2)");
  }
  if (!y7) {
    throw new Error("Public key was missing y (EC2)");
  }
  let _crv;
  if (crv === COSECRV.P256) {
    _crv = "P-256";
  } else if (crv === COSECRV.P384) {
    _crv = "P-384";
  } else if (crv === COSECRV.P521) {
    _crv = "P-521";
  } else {
    throw new Error(`Unexpected COSE crv value of ${crv} (EC2)`);
  }
  const keyData = {
    kty: "EC",
    crv: _crv,
    x: isoBase64URL_exports.fromBuffer(x4),
    y: isoBase64URL_exports.fromBuffer(y7),
    ext: false
  };
  const keyAlgorithm = {
    /**
     * Note to future self: you can't use `mapCoseAlgToWebCryptoKeyAlgName()` here because some
     * leaf certs from actual devices specified an RSA SHA value for `alg` (e.g. `-257`) which
     * would then map here to `'RSASSA-PKCS1-v1_5'`. We always want `'ECDSA'` here so we'll
     * hard-code this.
     */
    name: "ECDSA",
    namedCurve: _crv
  };
  const key3 = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  let subtleAlg = mapCoseAlgToWebCryptoAlg(alg);
  if (shaHashOverride) {
    subtleAlg = mapCoseAlgToWebCryptoAlg(shaHashOverride);
  }
  const verifyAlgorithm = {
    name: "ECDSA",
    hash: { name: subtleAlg }
  };
  return WebCrypto.subtle.verify(verifyAlgorithm, key3, signature, data);
}
var init_verifyEC2 = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyEC2.js"() {
    init_cose();
    init_mapCoseAlgToWebCryptoAlg();
    init_importKey();
    init_iso();
    init_getWebCrypto();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoKeyAlgName.js
function mapCoseAlgToWebCryptoKeyAlgName(alg) {
  if ([COSEALG.EdDSA].indexOf(alg) >= 0) {
    return "Ed25519";
  } else if ([COSEALG.ES256, COSEALG.ES384, COSEALG.ES512, COSEALG.ES256K].indexOf(alg) >= 0) {
    return "ECDSA";
  } else if ([COSEALG.RS256, COSEALG.RS384, COSEALG.RS512, COSEALG.RS1].indexOf(alg) >= 0) {
    return "RSASSA-PKCS1-v1_5";
  } else if ([COSEALG.PS256, COSEALG.PS384, COSEALG.PS512].indexOf(alg) >= 0) {
    return "RSA-PSS";
  }
  throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto key alg name`);
}
var init_mapCoseAlgToWebCryptoKeyAlgName = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoKeyAlgName.js"() {
    init_cose();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyRSA.js
async function verifyRSA(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const n7 = cosePublicKey.get(COSEKEYS.n);
  const e5 = cosePublicKey.get(COSEKEYS.e);
  if (!alg) {
    throw new Error("Public key was missing alg (RSA)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Public key had invalid alg ${alg} (RSA)`);
  }
  if (!n7) {
    throw new Error("Public key was missing n (RSA)");
  }
  if (!e5) {
    throw new Error("Public key was missing e (RSA)");
  }
  const keyData = {
    kty: "RSA",
    alg: "",
    n: isoBase64URL_exports.fromBuffer(n7),
    e: isoBase64URL_exports.fromBuffer(e5),
    ext: false
  };
  const keyAlgorithm = {
    name: mapCoseAlgToWebCryptoKeyAlgName(alg),
    hash: { name: mapCoseAlgToWebCryptoAlg(alg) }
  };
  const verifyAlgorithm = {
    name: mapCoseAlgToWebCryptoKeyAlgName(alg)
  };
  if (shaHashOverride) {
    keyAlgorithm.hash.name = mapCoseAlgToWebCryptoAlg(shaHashOverride);
  }
  if (keyAlgorithm.name === "RSASSA-PKCS1-v1_5") {
    if (keyAlgorithm.hash.name === "SHA-256") {
      keyData.alg = "RS256";
    } else if (keyAlgorithm.hash.name === "SHA-384") {
      keyData.alg = "RS384";
    } else if (keyAlgorithm.hash.name === "SHA-512") {
      keyData.alg = "RS512";
    } else if (keyAlgorithm.hash.name === "SHA-1") {
      keyData.alg = "RS1";
    }
  } else if (keyAlgorithm.name === "RSA-PSS") {
    let saltLength = 0;
    if (keyAlgorithm.hash.name === "SHA-256") {
      keyData.alg = "PS256";
      saltLength = 32;
    } else if (keyAlgorithm.hash.name === "SHA-384") {
      keyData.alg = "PS384";
      saltLength = 48;
    } else if (keyAlgorithm.hash.name === "SHA-512") {
      keyData.alg = "PS512";
      saltLength = 64;
    }
    verifyAlgorithm.saltLength = saltLength;
  } else {
    throw new Error(`Unexpected RSA key algorithm ${alg} (${keyAlgorithm.name})`);
  }
  const key3 = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  return WebCrypto.subtle.verify(verifyAlgorithm, key3, signature, data);
}
var init_verifyRSA = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyRSA.js"() {
    init_cose();
    init_mapCoseAlgToWebCryptoAlg();
    init_importKey();
    init_iso();
    init_mapCoseAlgToWebCryptoKeyAlgName();
    init_getWebCrypto();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/convertAAGUIDToString.js
function convertAAGUIDToString(aaguid) {
  const hex = isoUint8Array_exports.toHex(aaguid);
  const segments = [
    hex.slice(0, 8),
    hex.slice(8, 12),
    hex.slice(12, 16),
    hex.slice(16, 20),
    hex.slice(20, 32)
    // 8
  ];
  return segments.join("-");
}
var init_convertAAGUIDToString = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/convertAAGUIDToString.js"() {
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/convertCertBufferToPEM.js
function convertCertBufferToPEM(certBuffer) {
  let b64cert;
  if (typeof certBuffer === "string") {
    if (isoBase64URL_exports.isBase64url(certBuffer)) {
      b64cert = isoBase64URL_exports.toBase64(certBuffer);
    } else if (isoBase64URL_exports.isBase64(certBuffer)) {
      b64cert = certBuffer;
    } else {
      throw new Error("Certificate is not a valid base64 or base64url string");
    }
  } else {
    b64cert = isoBase64URL_exports.fromBuffer(certBuffer, "base64");
  }
  let PEMKey = "";
  for (let i9 = 0; i9 < Math.ceil(b64cert.length / 64); i9 += 1) {
    const start = 64 * i9;
    PEMKey += `${b64cert.substr(start, 64)}
`;
  }
  PEMKey = `-----BEGIN CERTIFICATE-----
${PEMKey}-----END CERTIFICATE-----
`;
  return PEMKey;
}
var init_convertCertBufferToPEM = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/convertCertBufferToPEM.js"() {
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/convertCOSEtoPKCS.js
function convertCOSEtoPKCS(cosePublicKey) {
  const struct = isoCBOR_exports.decodeFirst(cosePublicKey);
  const tag = Uint8Array.from([4]);
  const x4 = struct.get(COSEKEYS.x);
  const y7 = struct.get(COSEKEYS.y);
  if (!x4) {
    throw new Error("COSE public key was missing x");
  }
  if (y7) {
    return isoUint8Array_exports.concat([tag, x4, y7]);
  }
  return isoUint8Array_exports.concat([tag, x4]);
}
var init_convertCOSEtoPKCS = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/convertCOSEtoPKCS.js"() {
    init_iso();
    init_cose();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/decodeAttestationObject.js
function decodeAttestationObject(attestationObject) {
  return _decodeAttestationObjectInternals.stubThis(isoCBOR_exports.decodeFirst(attestationObject));
}
var _decodeAttestationObjectInternals;
var init_decodeAttestationObject = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/decodeAttestationObject.js"() {
    init_iso();
    _decodeAttestationObjectInternals = {
      stubThis: (value) => value
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/decodeClientDataJSON.js
function decodeClientDataJSON(data) {
  const toString2 = isoBase64URL_exports.toString(data);
  const clientData = JSON.parse(toString2);
  return _decodeClientDataJSONInternals.stubThis(clientData);
}
var _decodeClientDataJSONInternals;
var init_decodeClientDataJSON = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/decodeClientDataJSON.js"() {
    init_iso();
    _decodeClientDataJSONInternals = {
      stubThis: (value) => value
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/decodeCredentialPublicKey.js
function decodeCredentialPublicKey(publicKey) {
  return _decodeCredentialPublicKeyInternals.stubThis(isoCBOR_exports.decodeFirst(publicKey));
}
var _decodeCredentialPublicKeyInternals;
var init_decodeCredentialPublicKey = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/decodeCredentialPublicKey.js"() {
    init_iso();
    _decodeCredentialPublicKeyInternals = {
      stubThis: (value) => value
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/getCertificateInfo.js
function getCertificateInfo(leafCertBuffer) {
  const x509 = AsnParser.parse(leafCertBuffer, Certificate);
  const parsedCert = x509.tbsCertificate;
  const issuer = { combined: "" };
  parsedCert.issuer.forEach(([iss]) => {
    const key3 = issuerSubjectIDKey[iss.type];
    if (key3) {
      issuer[key3] = iss.value.toString();
    }
  });
  issuer.combined = issuerSubjectToString(issuer);
  const subject = { combined: "" };
  parsedCert.subject.forEach(([iss]) => {
    const key3 = issuerSubjectIDKey[iss.type];
    if (key3) {
      subject[key3] = iss.value.toString();
    }
  });
  subject.combined = issuerSubjectToString(subject);
  let basicConstraintsCA = false;
  if (parsedCert.extensions) {
    for (const ext of parsedCert.extensions) {
      if (ext.extnID === id_ce_basicConstraints) {
        const basicConstraints = AsnParser.parse(ext.extnValue, BasicConstraints);
        basicConstraintsCA = basicConstraints.cA;
      }
    }
  }
  return {
    issuer,
    subject,
    version: parsedCert.version,
    basicConstraintsCA,
    notBefore: parsedCert.validity.notBefore.getTime(),
    notAfter: parsedCert.validity.notAfter.getTime(),
    parsedCertificate: x509
  };
}
function issuerSubjectToString(input) {
  const parts = [];
  if (input.C) {
    parts.push(input.C);
  }
  if (input.O) {
    parts.push(input.O);
  }
  if (input.OU) {
    parts.push(input.OU);
  }
  if (input.CN) {
    parts.push(input.CN);
  }
  return parts.join(" : ");
}
var issuerSubjectIDKey;
var init_getCertificateInfo = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/getCertificateInfo.js"() {
    init_deps();
    issuerSubjectIDKey = {
      "2.5.4.6": "C",
      "2.5.4.10": "O",
      "2.5.4.11": "OU",
      "2.5.4.3": "CN"
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/fetch.js
function fetch4(url) {
  return _fetchInternals.stubThis(url);
}
var _fetchInternals;
var init_fetch = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/fetch.js"() {
    init_deps();
    _fetchInternals = {
      stubThis: (url) => (0, import_cross_fetch.fetch)(url)
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/isCertRevoked.js
async function isCertRevoked(cert) {
  const { extensions } = cert.tbsCertificate;
  if (!extensions) {
    return false;
  }
  let extAuthorityKeyID;
  let extSubjectKeyID;
  let extCRLDistributionPoints;
  extensions.forEach((ext) => {
    if (ext.extnID === id_ce_authorityKeyIdentifier) {
      extAuthorityKeyID = AsnParser.parse(ext.extnValue, AuthorityKeyIdentifier);
    } else if (ext.extnID === id_ce_subjectKeyIdentifier) {
      extSubjectKeyID = AsnParser.parse(ext.extnValue, SubjectKeyIdentifier);
    } else if (ext.extnID === id_ce_cRLDistributionPoints) {
      extCRLDistributionPoints = AsnParser.parse(ext.extnValue, CRLDistributionPoints);
    }
  });
  let keyIdentifier = void 0;
  if (extAuthorityKeyID && extAuthorityKeyID.keyIdentifier) {
    keyIdentifier = isoUint8Array_exports.toHex(new Uint8Array(extAuthorityKeyID.keyIdentifier.buffer));
  } else if (extSubjectKeyID) {
    keyIdentifier = isoUint8Array_exports.toHex(new Uint8Array(extSubjectKeyID.buffer));
  }
  const certSerialHex = isoUint8Array_exports.toHex(new Uint8Array(cert.tbsCertificate.serialNumber));
  if (keyIdentifier) {
    const cached = cacheRevokedCerts[keyIdentifier];
    if (cached) {
      const now = /* @__PURE__ */ new Date();
      if (!cached.nextUpdate || cached.nextUpdate > now) {
        return cached.revokedCerts.indexOf(certSerialHex) >= 0;
      }
    }
  }
  const crlURL = extCRLDistributionPoints?.[0].distributionPoint?.fullName?.[0].uniformResourceIdentifier;
  if (!crlURL) {
    return false;
  }
  let certListBytes;
  try {
    const respCRL = await fetch4(crlURL);
    certListBytes = await respCRL.arrayBuffer();
  } catch (_err) {
    return false;
  }
  let data;
  try {
    data = AsnParser.parse(certListBytes, CertificateList);
  } catch (_err) {
    return false;
  }
  const newCached = {
    revokedCerts: [],
    nextUpdate: void 0
  };
  if (data.tbsCertList.nextUpdate) {
    newCached.nextUpdate = data.tbsCertList.nextUpdate.getTime();
  }
  const revokedCerts = data.tbsCertList.revokedCertificates;
  if (revokedCerts) {
    for (const cert2 of revokedCerts) {
      const revokedHex = isoUint8Array_exports.toHex(new Uint8Array(cert2.userCertificate));
      newCached.revokedCerts.push(revokedHex);
    }
    if (keyIdentifier) {
      cacheRevokedCerts[keyIdentifier] = newCached;
    }
    return newCached.revokedCerts.indexOf(certSerialHex) >= 0;
  }
  return false;
}
var cacheRevokedCerts;
var init_isCertRevoked = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/isCertRevoked.js"() {
    init_deps();
    init_iso();
    init_fetch();
    cacheRevokedCerts = {};
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/decodeAuthenticatorExtensions.js
function decodeAuthenticatorExtensions(extensionData) {
  let toCBOR;
  try {
    toCBOR = isoCBOR_exports.decodeFirst(extensionData);
  } catch (err) {
    const _err = err;
    throw new Error(`Error decoding authenticator extensions: ${_err.message}`);
  }
  return convertMapToObjectDeep(toCBOR);
}
function convertMapToObjectDeep(input) {
  const mapped = {};
  for (const [key3, value] of input) {
    if (value instanceof Map) {
      mapped[key3] = convertMapToObjectDeep(value);
    } else {
      mapped[key3] = value;
    }
  }
  return mapped;
}
var init_decodeAuthenticatorExtensions = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/decodeAuthenticatorExtensions.js"() {
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/parseAuthenticatorData.js
function parseAuthenticatorData(authData) {
  if (authData.byteLength < 37) {
    throw new Error(`Authenticator data was ${authData.byteLength} bytes, expected at least 37 bytes`);
  }
  let pointer = 0;
  const dataView = isoUint8Array_exports.toDataView(authData);
  const rpIdHash = authData.slice(pointer, pointer += 32);
  const flagsBuf = authData.slice(pointer, pointer += 1);
  const flagsInt = flagsBuf[0];
  const flags = {
    up: !!(flagsInt & 1 << 0),
    uv: !!(flagsInt & 1 << 2),
    be: !!(flagsInt & 1 << 3),
    bs: !!(flagsInt & 1 << 4),
    at: !!(flagsInt & 1 << 6),
    ed: !!(flagsInt & 1 << 7),
    flagsInt
  };
  const counterBuf = authData.slice(pointer, pointer + 4);
  const counter = dataView.getUint32(pointer, false);
  pointer += 4;
  let aaguid = void 0;
  let credentialID = void 0;
  let credentialPublicKey = void 0;
  if (flags.at) {
    aaguid = authData.slice(pointer, pointer += 16);
    const credIDLen = dataView.getUint16(pointer);
    pointer += 2;
    credentialID = authData.slice(pointer, pointer += credIDLen);
    const badEdDSACBOR = isoUint8Array_exports.fromHex("a301634f4b500327206745643235353139");
    const bytesAtCurrentPosition = authData.slice(pointer, pointer + badEdDSACBOR.byteLength);
    let foundBadCBOR = false;
    if (isoUint8Array_exports.areEqual(badEdDSACBOR, bytesAtCurrentPosition)) {
      foundBadCBOR = true;
      authData[pointer] = 164;
    }
    const firstDecoded = isoCBOR_exports.decodeFirst(authData.slice(pointer));
    const firstEncoded = Uint8Array.from(isoCBOR_exports.encode(firstDecoded));
    if (foundBadCBOR) {
      authData[pointer] = 163;
    }
    credentialPublicKey = firstEncoded;
    pointer += firstEncoded.byteLength;
  }
  let extensionsData = void 0;
  let extensionsDataBuffer = void 0;
  if (flags.ed) {
    const firstDecoded = isoCBOR_exports.decodeFirst(authData.slice(pointer));
    extensionsDataBuffer = Uint8Array.from(isoCBOR_exports.encode(firstDecoded));
    extensionsData = decodeAuthenticatorExtensions(extensionsDataBuffer);
    pointer += extensionsDataBuffer.byteLength;
  }
  if (authData.byteLength > pointer) {
    throw new Error("Leftover bytes detected while parsing authenticator data");
  }
  return _parseAuthenticatorDataInternals.stubThis({
    rpIdHash,
    flagsBuf,
    flags,
    counter,
    counterBuf,
    aaguid,
    credentialID,
    credentialPublicKey,
    extensionsData,
    extensionsDataBuffer
  });
}
var _parseAuthenticatorDataInternals;
var init_parseAuthenticatorData = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/parseAuthenticatorData.js"() {
    init_decodeAuthenticatorExtensions();
    init_iso();
    _parseAuthenticatorDataInternals = {
      stubThis: (value) => value
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/toHash.js
function toHash(data, algorithm = -7) {
  if (typeof data === "string") {
    data = isoUint8Array_exports.fromUTF8String(data);
  }
  const digest2 = isoCrypto_exports.digest(data, algorithm);
  return digest2;
}
var init_toHash = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/toHash.js"() {
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/mapX509SignatureAlgToCOSEAlg.js
function mapX509SignatureAlgToCOSEAlg(signatureAlgorithm) {
  let alg;
  if (signatureAlgorithm === "1.2.840.10045.4.3.2") {
    alg = COSEALG.ES256;
  } else if (signatureAlgorithm === "1.2.840.10045.4.3.3") {
    alg = COSEALG.ES384;
  } else if (signatureAlgorithm === "1.2.840.10045.4.3.4") {
    alg = COSEALG.ES512;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.11") {
    alg = COSEALG.RS256;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.12") {
    alg = COSEALG.RS384;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.13") {
    alg = COSEALG.RS512;
  } else if (signatureAlgorithm === "1.2.840.113549.1.1.5") {
    alg = COSEALG.RS1;
  } else {
    throw new Error(`Unable to map X.509 signature algorithm ${signatureAlgorithm} to a COSE algorithm`);
  }
  return alg;
}
var init_mapX509SignatureAlgToCOSEAlg = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/mapX509SignatureAlgToCOSEAlg.js"() {
    init_cose();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/convertX509PublicKeyToCOSE.js
function convertX509PublicKeyToCOSE(x509Certificate) {
  let cosePublicKey = /* @__PURE__ */ new Map();
  const x509 = AsnParser.parse(x509Certificate, Certificate);
  const { tbsCertificate } = x509;
  const { subjectPublicKeyInfo, signature: _tbsSignature } = tbsCertificate;
  const signatureAlgorithm = _tbsSignature.algorithm;
  const publicKeyAlgorithmID = subjectPublicKeyInfo.algorithm.algorithm;
  if (publicKeyAlgorithmID === id_ecPublicKey) {
    if (!subjectPublicKeyInfo.algorithm.parameters) {
      throw new Error("Certificate public key was missing parameters (EC2)");
    }
    const ecParameters = AsnParser.parse(new Uint8Array(subjectPublicKeyInfo.algorithm.parameters), ECParameters);
    let crv = -999;
    const { namedCurve } = ecParameters;
    if (namedCurve === id_secp256r1) {
      crv = COSECRV.P256;
    } else if (namedCurve === id_secp384r1) {
      crv = COSECRV.P384;
    } else {
      throw new Error(`Certificate public key contained unexpected namedCurve ${namedCurve} (EC2)`);
    }
    const subjectPublicKey = new Uint8Array(subjectPublicKeyInfo.subjectPublicKey);
    let x4;
    let y7;
    if (subjectPublicKey[0] === 4) {
      let pointer = 1;
      const halfLength = (subjectPublicKey.length - 1) / 2;
      x4 = subjectPublicKey.slice(pointer, pointer += halfLength);
      y7 = subjectPublicKey.slice(pointer);
    } else {
      throw new Error('TODO: Figure out how to handle public keys in "compressed form"');
    }
    const coseEC2PubKey = /* @__PURE__ */ new Map();
    coseEC2PubKey.set(COSEKEYS.kty, COSEKTY.EC2);
    coseEC2PubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));
    coseEC2PubKey.set(COSEKEYS.crv, crv);
    coseEC2PubKey.set(COSEKEYS.x, x4);
    coseEC2PubKey.set(COSEKEYS.y, y7);
    cosePublicKey = coseEC2PubKey;
  } else if (publicKeyAlgorithmID === "1.2.840.113549.1.1.1") {
    const rsaPublicKey = AsnParser.parse(subjectPublicKeyInfo.subjectPublicKey, RSAPublicKey);
    const coseRSAPubKey = /* @__PURE__ */ new Map();
    coseRSAPubKey.set(COSEKEYS.kty, COSEKTY.RSA);
    coseRSAPubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));
    coseRSAPubKey.set(COSEKEYS.n, new Uint8Array(rsaPublicKey.modulus));
    coseRSAPubKey.set(COSEKEYS.e, new Uint8Array(rsaPublicKey.publicExponent));
    cosePublicKey = coseRSAPubKey;
  } else {
    throw new Error(`Certificate public key contained unexpected algorithm ID ${publicKeyAlgorithmID}`);
  }
  return cosePublicKey;
}
var init_convertX509PublicKeyToCOSE = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/convertX509PublicKeyToCOSE.js"() {
    init_deps();
    init_cose();
    init_mapX509SignatureAlgToCOSEAlg();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/verifySignature.js
function verifySignature(opts) {
  const { signature, data, credentialPublicKey, x509Certificate, hashAlgorithm } = opts;
  if (!x509Certificate && !credentialPublicKey) {
    throw new Error('Must declare either "leafCert" or "credentialPublicKey"');
  }
  if (x509Certificate && credentialPublicKey) {
    throw new Error('Must not declare both "leafCert" and "credentialPublicKey"');
  }
  let cosePublicKey = /* @__PURE__ */ new Map();
  if (credentialPublicKey) {
    cosePublicKey = decodeCredentialPublicKey(credentialPublicKey);
  } else if (x509Certificate) {
    cosePublicKey = convertX509PublicKeyToCOSE(x509Certificate);
  }
  return _verifySignatureInternals.stubThis(isoCrypto_exports.verify({
    cosePublicKey,
    signature,
    data,
    shaHashOverride: hashAlgorithm
  }));
}
var _verifySignatureInternals;
var init_verifySignature = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/verifySignature.js"() {
    init_iso();
    init_decodeCredentialPublicKey();
    init_convertX509PublicKeyToCOSE();
    _verifySignatureInternals = {
      stubThis: (value) => value
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/convertPEMToBytes.js
function convertPEMToBytes(pem) {
  const certBase64 = pem.replace("-----BEGIN CERTIFICATE-----", "").replace("-----END CERTIFICATE-----", "").replace(/[\n ]/g, "");
  return isoBase64URL_exports.toBuffer(certBase64, "base64");
}
var init_convertPEMToBytes = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/convertPEMToBytes.js"() {
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/validateCertificatePath.js
async function validateCertificatePath(certificates, rootCertificates = []) {
  if (rootCertificates.length === 0) {
    return true;
  }
  let invalidSubjectAndIssuerError = false;
  let certificateNotYetValidOrExpiredErrorMessage = void 0;
  for (const rootCert of rootCertificates) {
    try {
      const certsWithRoot = certificates.concat([rootCert]);
      await _validatePath(certsWithRoot);
      invalidSubjectAndIssuerError = false;
      certificateNotYetValidOrExpiredErrorMessage = void 0;
      break;
    } catch (err) {
      if (err instanceof InvalidSubjectAndIssuer) {
        invalidSubjectAndIssuerError = true;
      } else if (err instanceof CertificateNotYetValidOrExpired) {
        certificateNotYetValidOrExpiredErrorMessage = err.message;
      } else {
        throw err;
      }
    }
  }
  if (invalidSubjectAndIssuerError) {
    throw new InvalidSubjectAndIssuer();
  } else if (certificateNotYetValidOrExpiredErrorMessage) {
    throw new CertificateNotYetValidOrExpired(certificateNotYetValidOrExpiredErrorMessage);
  }
  return true;
}
async function _validatePath(certificates) {
  if (new Set(certificates).size !== certificates.length) {
    throw new Error("Invalid certificate path: found duplicate certificates");
  }
  for (let i9 = 0; i9 < certificates.length; i9 += 1) {
    const subjectPem = certificates[i9];
    const isLeafCert = i9 === 0;
    const isRootCert = i9 + 1 >= certificates.length;
    let issuerPem = "";
    if (isRootCert) {
      issuerPem = subjectPem;
    } else {
      issuerPem = certificates[i9 + 1];
    }
    const subjectInfo = getCertificateInfo(convertPEMToBytes(subjectPem));
    const issuerInfo = getCertificateInfo(convertPEMToBytes(issuerPem));
    const x509Subject = subjectInfo.parsedCertificate;
    const subjectCertRevoked = await isCertRevoked(x509Subject);
    if (subjectCertRevoked) {
      throw new Error(`Found revoked certificate in certificate path`);
    }
    const { notBefore, notAfter } = issuerInfo;
    const now = new Date(Date.now());
    if (notBefore > now || notAfter < now) {
      if (isLeafCert) {
        throw new CertificateNotYetValidOrExpired(`Leaf certificate is not yet valid or expired: ${issuerPem}`);
      } else if (isRootCert) {
        throw new CertificateNotYetValidOrExpired(`Root certificate is not yet valid or expired: ${issuerPem}`);
      } else {
        throw new CertificateNotYetValidOrExpired(`Intermediate certificate is not yet valid or expired: ${issuerPem}`);
      }
    }
    if (subjectInfo.issuer.combined !== issuerInfo.subject.combined) {
      throw new InvalidSubjectAndIssuer();
    }
    const data = AsnSerializer.serialize(x509Subject.tbsCertificate);
    const signature = x509Subject.signatureValue;
    const signatureAlgorithm = mapX509SignatureAlgToCOSEAlg(x509Subject.signatureAlgorithm.algorithm);
    const issuerCertBytes = convertPEMToBytes(issuerPem);
    const verified = await verifySignature({
      data: new Uint8Array(data),
      signature: new Uint8Array(signature),
      x509Certificate: issuerCertBytes,
      hashAlgorithm: signatureAlgorithm
    });
    if (!verified) {
      throw new Error("Invalid certificate path: invalid signature");
    }
  }
  return true;
}
var InvalidSubjectAndIssuer, CertificateNotYetValidOrExpired;
var init_validateCertificatePath = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/validateCertificatePath.js"() {
    init_deps();
    init_isCertRevoked();
    init_verifySignature();
    init_mapX509SignatureAlgToCOSEAlg();
    init_getCertificateInfo();
    init_convertPEMToBytes();
    InvalidSubjectAndIssuer = class extends Error {
      constructor() {
        const message2 = "Subject issuer did not match issuer subject";
        super(message2);
        this.name = "InvalidSubjectAndIssuer";
      }
    };
    CertificateNotYetValidOrExpired = class extends Error {
      constructor(message2) {
        super(message2);
        this.name = "CertificateNotYetValidOrExpired";
      }
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/index.js
var init_helpers = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/index.js"() {
    init_convertAAGUIDToString();
    init_convertCertBufferToPEM();
    init_convertCOSEtoPKCS();
    init_decodeAttestationObject();
    init_decodeClientDataJSON();
    init_decodeCredentialPublicKey();
    init_generateChallenge();
    init_getCertificateInfo();
    init_isCertRevoked();
    init_parseAuthenticatorData();
    init_toHash();
    init_validateCertificatePath();
    init_verifySignature();
    init_iso();
    init_cose();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyOKP.js
async function verifyOKP(opts) {
  const { cosePublicKey, signature, data } = opts;
  const WebCrypto = await getWebCrypto();
  const alg = cosePublicKey.get(COSEKEYS.alg);
  const crv = cosePublicKey.get(COSEKEYS.crv);
  const x4 = cosePublicKey.get(COSEKEYS.x);
  if (!alg) {
    throw new Error("Public key was missing alg (OKP)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Public key had invalid alg ${alg} (OKP)`);
  }
  if (!crv) {
    throw new Error("Public key was missing crv (OKP)");
  }
  if (!x4) {
    throw new Error("Public key was missing x (OKP)");
  }
  let _crv;
  if (crv === COSECRV.ED25519) {
    _crv = "Ed25519";
  } else {
    throw new Error(`Unexpected COSE crv value of ${crv} (OKP)`);
  }
  const keyData = {
    kty: "OKP",
    crv: _crv,
    alg: "EdDSA",
    x: isoBase64URL_exports.fromBuffer(x4),
    ext: false
  };
  const keyAlgorithm = {
    name: _crv,
    namedCurve: _crv
  };
  const key3 = await importKey({
    keyData,
    algorithm: keyAlgorithm
  });
  const verifyAlgorithm = {
    name: _crv
  };
  return WebCrypto.subtle.verify(verifyAlgorithm, key3, signature, data);
}
var init_verifyOKP = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyOKP.js"() {
    init_cose();
    init_helpers();
    init_importKey();
    init_getWebCrypto();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/unwrapEC2Signature.js
function unwrapEC2Signature(signature) {
  const parsedSignature = AsnParser.parse(signature, ECDSASigValue);
  let rBytes = new Uint8Array(parsedSignature.r);
  let sBytes = new Uint8Array(parsedSignature.s);
  if (shouldRemoveLeadingZero(rBytes)) {
    rBytes = rBytes.slice(1);
  }
  if (shouldRemoveLeadingZero(sBytes)) {
    sBytes = sBytes.slice(1);
  }
  const finalSignature = isoUint8Array_exports.concat([rBytes, sBytes]);
  return finalSignature;
}
function shouldRemoveLeadingZero(bytes) {
  return bytes[0] === 0 && (bytes[1] & 1 << 7) !== 0;
}
var init_unwrapEC2Signature = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/unwrapEC2Signature.js"() {
    init_deps();
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verify.js
function verify2(opts) {
  const { cosePublicKey, signature, data, shaHashOverride } = opts;
  if (isCOSEPublicKeyEC2(cosePublicKey)) {
    const unwrappedSignature = unwrapEC2Signature(signature);
    return verifyEC2({
      cosePublicKey,
      signature: unwrappedSignature,
      data,
      shaHashOverride
    });
  } else if (isCOSEPublicKeyRSA(cosePublicKey)) {
    return verifyRSA({ cosePublicKey, signature, data, shaHashOverride });
  } else if (isCOSEPublicKeyOKP(cosePublicKey)) {
    return verifyOKP({ cosePublicKey, signature, data });
  }
  const kty = cosePublicKey.get(COSEKEYS.kty);
  throw new Error(`Signature verification with public key of kty ${kty} is not supported by this method`);
}
var init_verify6 = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/verify.js"() {
    init_cose();
    init_verifyEC2();
    init_verifyRSA();
    init_verifyOKP();
    init_unwrapEC2Signature();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/index.js
var isoCrypto_exports = {};
__export(isoCrypto_exports, {
  digest: () => digest,
  getRandomValues: () => getRandomValues,
  verify: () => verify2
});
var init_isoCrypto = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoCrypto/index.js"() {
    init_digest2();
    init_getRandomValues();
    init_verify6();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/isoUint8Array.js
var isoUint8Array_exports = {};
__export(isoUint8Array_exports, {
  areEqual: () => areEqual,
  concat: () => concat3,
  fromASCIIString: () => fromASCIIString,
  fromHex: () => fromHex,
  fromUTF8String: () => fromUTF8String,
  toDataView: () => toDataView,
  toHex: () => toHex,
  toUTF8String: () => toUTF8String
});
function areEqual(array1, array2) {
  if (array1.length != array2.length) {
    return false;
  }
  return array1.every((val, i9) => val === array2[i9]);
}
function toHex(array2) {
  const hexParts = Array.from(array2, (i9) => i9.toString(16).padStart(2, "0"));
  return hexParts.join("");
}
function fromHex(hex) {
  if (!hex) {
    return Uint8Array.from([]);
  }
  const isValid = hex.length !== 0 && hex.length % 2 === 0 && !/[^a-fA-F0-9]/u.test(hex);
  if (!isValid) {
    throw new Error("Invalid hex string");
  }
  const byteStrings = hex.match(/.{1,2}/g) ?? [];
  return Uint8Array.from(byteStrings.map((byte) => parseInt(byte, 16)));
}
function concat3(arrays) {
  let pointer = 0;
  const totalLength = arrays.reduce((prev, curr) => prev + curr.length, 0);
  const toReturn = new Uint8Array(totalLength);
  arrays.forEach((arr2) => {
    toReturn.set(arr2, pointer);
    pointer += arr2.length;
  });
  return toReturn;
}
function toUTF8String(array2) {
  const decoder2 = new globalThis.TextDecoder("utf-8");
  return decoder2.decode(array2);
}
function fromUTF8String(utf8String) {
  const encoder5 = new globalThis.TextEncoder();
  return encoder5.encode(utf8String);
}
function fromASCIIString(value) {
  return Uint8Array.from(value.split("").map((x4) => x4.charCodeAt(0)));
}
function toDataView(array2) {
  return new DataView(array2.buffer, array2.byteOffset, array2.length);
}
var init_isoUint8Array = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/isoUint8Array.js"() {
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/iso/index.js
var init_iso = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/iso/index.js"() {
    init_isoBase64URL();
    init_isoCBOR();
    init_isoCrypto();
    init_isoUint8Array();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/generateChallenge.js
async function generateChallenge() {
  const challenge = new Uint8Array(32);
  await isoCrypto_exports.getRandomValues(challenge);
  return _generateChallengeInternals.stubThis(challenge);
}
var _generateChallengeInternals;
var init_generateChallenge = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/generateChallenge.js"() {
    init_iso();
    _generateChallengeInternals = {
      stubThis: (value) => value
    };
  }
});

// node_modules/@simplewebauthn/server/esm/registration/generateRegistrationOptions.js
async function generateRegistrationOptions(options3) {
  const { rpName: rpName2, rpID: rpID3, userID, userName, challenge = await generateChallenge(), userDisplayName = userName, timeout = 6e4, attestationType = "none", excludeCredentials = [], authenticatorSelection = defaultAuthenticatorSelection, extensions, supportedAlgorithmIDs = defaultSupportedAlgorithmIDs } = options3;
  const pubKeyCredParams = supportedAlgorithmIDs.map((id) => ({
    alg: id,
    type: "public-key"
  }));
  if (authenticatorSelection.residentKey === void 0) {
    if (authenticatorSelection.requireResidentKey) {
      authenticatorSelection.residentKey = "required";
    } else {
    }
  } else {
    authenticatorSelection.requireResidentKey = authenticatorSelection.residentKey === "required";
  }
  let _challenge = challenge;
  if (typeof _challenge === "string") {
    _challenge = isoUint8Array_exports.fromUTF8String(_challenge);
  }
  return {
    challenge: isoBase64URL_exports.fromBuffer(_challenge),
    rp: {
      name: rpName2,
      id: rpID3
    },
    user: {
      id: userID,
      name: userName,
      displayName: userDisplayName
    },
    pubKeyCredParams,
    timeout,
    attestation: attestationType,
    excludeCredentials: excludeCredentials.map((cred) => ({
      ...cred,
      id: isoBase64URL_exports.fromBuffer(cred.id)
    })),
    authenticatorSelection,
    extensions: {
      ...extensions,
      credProps: true
    }
  };
}
var supportedCOSEAlgorithmIdentifiers, defaultAuthenticatorSelection, defaultSupportedAlgorithmIDs;
var init_generateRegistrationOptions = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/generateRegistrationOptions.js"() {
    init_generateChallenge();
    init_iso();
    supportedCOSEAlgorithmIdentifiers = [
      // EdDSA (In first position to encourage authenticators to use this over ES256)
      -8,
      // ECDSA w/ SHA-256
      -7,
      // ECDSA w/ SHA-512
      -36,
      // RSASSA-PSS w/ SHA-256
      -37,
      // RSASSA-PSS w/ SHA-384
      -38,
      // RSASSA-PSS w/ SHA-512
      -39,
      // RSASSA-PKCS1-v1_5 w/ SHA-256
      -257,
      // RSASSA-PKCS1-v1_5 w/ SHA-384
      -258,
      // RSASSA-PKCS1-v1_5 w/ SHA-512
      -259,
      // RSASSA-PKCS1-v1_5 w/ SHA-1 (Deprecated; here for legacy support)
      -65535
    ];
    defaultAuthenticatorSelection = {
      residentKey: "preferred",
      userVerification: "preferred"
    };
    defaultSupportedAlgorithmIDs = [-8, -7, -257];
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/parseBackupFlags.js
function parseBackupFlags({ be: be3, bs }) {
  const credentialBackedUp = bs;
  let credentialDeviceType = "singleDevice";
  if (be3) {
    credentialDeviceType = "multiDevice";
  }
  if (credentialDeviceType === "singleDevice" && credentialBackedUp) {
    throw new InvalidBackupFlags("Single-device credential indicated that it was backed up, which should be impossible.");
  }
  return { credentialDeviceType, credentialBackedUp };
}
var InvalidBackupFlags;
var init_parseBackupFlags = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/parseBackupFlags.js"() {
    InvalidBackupFlags = class extends Error {
      constructor(message2) {
        super(message2);
        this.name = "InvalidBackupFlags";
      }
    };
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/matchExpectedRPID.js
async function matchExpectedRPID(rpIDHash, expectedRPIDs) {
  try {
    const matchedRPID = await Promise.any(expectedRPIDs.map((expected) => {
      return new Promise((resolve2, reject) => {
        toHash(isoUint8Array_exports.fromASCIIString(expected)).then((expectedRPIDHash) => {
          if (isoUint8Array_exports.areEqual(rpIDHash, expectedRPIDHash)) {
            resolve2(expected);
          } else {
            reject();
          }
        });
      });
    }));
    return matchedRPID;
  } catch (err) {
    const _err = err;
    if (_err.name === "AggregateError") {
      throw new UnexpectedRPIDHash();
    }
    throw err;
  }
}
var UnexpectedRPIDHash;
var init_matchExpectedRPID = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/matchExpectedRPID.js"() {
    init_toHash();
    init_iso();
    UnexpectedRPIDHash = class extends Error {
      constructor() {
        const message2 = "Unexpected RP ID hash";
        super(message2);
        this.name = "UnexpectedRPIDHash";
      }
    };
  }
});

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-safetynet.js
var GlobalSign_Root_CA;
var init_android_safetynet = __esm({
  "node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-safetynet.js"() {
    GlobalSign_Root_CA = `-----BEGIN CERTIFICATE-----
MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG
A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw
MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i
YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT
aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ
jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp
xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp
1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG
snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ
U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8
9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E
BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B
AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz
yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE
38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP
AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad
DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME
HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
-----END CERTIFICATE-----
`;
  }
});

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-key.js
var Google_Hardware_Attestation_Root_1, Google_Hardware_Attestation_Root_2;
var init_android_key = __esm({
  "node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/android-key.js"() {
    Google_Hardware_Attestation_Root_1 = `-----BEGIN CERTIFICATE-----
MIIFYDCCA0igAwIBAgIJAOj6GWMU0voYMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTYwNTI2MTYyODUyWhcNMjYwNTI0MTYy
ODUyWjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaOBpjCBozAdBgNVHQ4EFgQUNmHhAHyIBQlRi0RsR/8aTMnqTxIwHwYD
VR0jBBgwFoAUNmHhAHyIBQlRi0RsR/8aTMnqTxIwDwYDVR0TAQH/BAUwAwEB/zAO
BgNVHQ8BAf8EBAMCAYYwQAYDVR0fBDkwNzA1oDOgMYYvaHR0cHM6Ly9hbmRyb2lk
Lmdvb2dsZWFwaXMuY29tL2F0dGVzdGF0aW9uL2NybC8wDQYJKoZIhvcNAQELBQAD
ggIBACDIw41L3KlXG0aMiS//cqrG+EShHUGo8HNsw30W1kJtjn6UBwRM6jnmiwfB
Pb8VA91chb2vssAtX2zbTvqBJ9+LBPGCdw/E53Rbf86qhxKaiAHOjpvAy5Y3m00m
qC0w/Zwvju1twb4vhLaJ5NkUJYsUS7rmJKHHBnETLi8GFqiEsqTWpG/6ibYCv7rY
DBJDcR9W62BW9jfIoBQcxUCUJouMPH25lLNcDc1ssqvC2v7iUgI9LeoM1sNovqPm
QUiG9rHli1vXxzCyaMTjwftkJLkf6724DFhuKug2jITV0QkXvaJWF4nUaHOTNA4u
JU9WDvZLI1j83A+/xnAJUucIv/zGJ1AMH2boHqF8CY16LpsYgBt6tKxxWH00XcyD
CdW2KlBCeqbQPcsFmWyWugxdcekhYsAWyoSf818NUsZdBWBaR/OukXrNLfkQ79Iy
ZohZbvabO/X+MVT3rriAoKc8oE2Uws6DF+60PV7/WIPjNvXySdqspImSN78mflxD
qwLqRBYkA3I75qppLGG9rp7UCdRjxMl8ZDBld+7yvHVgt1cVzJx9xnyGCC23Uaic
MDSXYrB4I4WHXPGjxhZuCuPBLTdOLU8YRvMYdEvYebWHMpvwGCF6bAx3JBpIeOQ1
wDB5y0USicV3YgYGmi+NZfhA4URSh77Yd6uuJOJENRaNVTzk
-----END CERTIFICATE-----
`;
    Google_Hardware_Attestation_Root_2 = `-----BEGIN CERTIFICATE-----
MIIFHDCCAwSgAwIBAgIJANUP8luj8tazMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV
BAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTkxMTIyMjAzNzU4WhcNMzQxMTE4MjAz
NzU4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B
AQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS
Sxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7
tv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj
nar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq
C4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ
oVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O
JtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg
sTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi
igHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M
RPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E
aDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um
AGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud
IwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBOMaBc8oumXb2voc7XCWnu
XKhBBK3e2KMGz39t7lA3XXRe2ZLLAkLM5y3J7tURkf5a1SutfdOyXAmeE6SRo83U
h6WszodmMkxK5GM4JGrnt4pBisu5igXEydaW7qq2CdC6DOGjG+mEkN8/TA6p3cno
L/sPyz6evdjLlSeJ8rFBH6xWyIZCbrcpYEJzXaUOEaxxXxgYz5/cTiVKN2M1G2ok
QBUIYSY6bjEL4aUN5cfo7ogP3UvliEo3Eo0YgwuzR2v0KR6C1cZqZJSTnghIC/vA
D32KdNQ+c3N+vl2OTsUVMC1GiWkngNx1OO1+kXW+YTnnTUOtOIswUP/Vqd5SYgAI
mMAfY8U9/iIgkQj6T2W6FsScy94IN9fFhE1UtzmLoBIuUFsVXJMTz+Jucth+IqoW
Fua9v1R93/k98p41pjtFX+H8DslVgfP097vju4KDlqN64xV1grw3ZLl4CiOe/A91
oeLm2UHOq6wn3esB4r2EIQKb6jTVGu5sYCcdWpXr0AUVqcABPdgL+H7qJguBw09o
jm6xNIrw2OocrDKsudk/okr/AwqEyPKw9WnMlQgLIKw1rODG2NvU9oR3GVGdMkUB
ZutL8VuFkERQGt6vQ2OCw0sV47VMkuYbacK/xyZFiRcrPJPb41zgbQj9XAEyLKCH
ex0SdDrx+tWUDqG8At2JHA==
-----END CERTIFICATE-----
`;
  }
});

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/apple.js
var Apple_WebAuthn_Root_CA;
var init_apple = __esm({
  "node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/apple.js"() {
    Apple_WebAuthn_Root_CA = `-----BEGIN CERTIFICATE-----
MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w
HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ
bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx
NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG
A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49
AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k
xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/
pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk
2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA
MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3
jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B
1bWeT0vT
-----END CERTIFICATE-----
`;
  }
});

// node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/mds.js
var GlobalSign_Root_CA_R3;
var init_mds = __esm({
  "node_modules/@simplewebauthn/server/esm/services/defaultRootCerts/mds.js"() {
    GlobalSign_Root_CA_R3 = `-----BEGIN CERTIFICATE-----
 MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
 A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
 Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
 MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
 A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
 hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
 RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
 gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
 KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
 QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
 XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
 DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
 LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
 RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
 jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
 6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
 mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
 Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
 WD9f
 -----END CERTIFICATE-----
 `;
  }
});

// node_modules/@simplewebauthn/server/esm/services/settingsService.js
var BaseSettingsService, SettingsService;
var init_settingsService = __esm({
  "node_modules/@simplewebauthn/server/esm/services/settingsService.js"() {
    init_convertCertBufferToPEM();
    init_android_safetynet();
    init_android_key();
    init_apple();
    init_mds();
    BaseSettingsService = class {
      constructor() {
        Object.defineProperty(this, "pemCertificates", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.pemCertificates = /* @__PURE__ */ new Map();
      }
      /**
       * Set potential root certificates for attestation formats that use them. Root certs will be tried
       * one-by-one when validating a certificate path.
       *
       * Certificates can be specified as a raw `Buffer`, or as a PEM-formatted string. If a
       * `Buffer` is passed in it will be converted to PEM format.
       */
      setRootCertificates(opts) {
        const { identifier, certificates } = opts;
        const newCertificates = [];
        for (const cert of certificates) {
          if (cert instanceof Uint8Array) {
            newCertificates.push(convertCertBufferToPEM(cert));
          } else {
            newCertificates.push(cert);
          }
        }
        this.pemCertificates.set(identifier, newCertificates);
      }
      /**
       * Get any registered root certificates for the specified attestation format
       */
      getRootCertificates(opts) {
        const { identifier } = opts;
        return this.pemCertificates.get(identifier) ?? [];
      }
    };
    SettingsService = new BaseSettingsService();
    SettingsService.setRootCertificates({
      identifier: "android-key",
      certificates: [
        Google_Hardware_Attestation_Root_1,
        Google_Hardware_Attestation_Root_2
      ]
    });
    SettingsService.setRootCertificates({
      identifier: "android-safetynet",
      certificates: [GlobalSign_Root_CA]
    });
    SettingsService.setRootCertificates({
      identifier: "apple",
      certificates: [Apple_WebAuthn_Root_CA]
    });
    SettingsService.setRootCertificates({
      identifier: "mds",
      certificates: [GlobalSign_Root_CA_R3]
    });
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationFIDOU2F.js
async function verifyAttestationFIDOU2F(options3) {
  const { attStmt, clientDataHash, rpIdHash, credentialID, credentialPublicKey, aaguid, rootCertificates } = options3;
  const reservedByte = Uint8Array.from([0]);
  const publicKey = convertCOSEtoPKCS(credentialPublicKey);
  const signatureBase = isoUint8Array_exports.concat([
    reservedByte,
    rpIdHash,
    clientDataHash,
    credentialID,
    publicKey
  ]);
  const sig = attStmt.get("sig");
  const x5c = attStmt.get("x5c");
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (FIDOU2F)");
  }
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (FIDOU2F)");
  }
  const aaguidToHex = Number.parseInt(isoUint8Array_exports.toHex(aaguid), 16);
  if (aaguidToHex !== 0) {
    throw new Error(`AAGUID "${aaguidToHex}" was not expected value`);
  }
  try {
    await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
  } catch (err) {
    const _err = err;
    throw new Error(`${_err.message} (FIDOU2F)`);
  }
  return verifySignature({
    signature: sig,
    data: signatureBase,
    x509Certificate: x5c[0],
    hashAlgorithm: COSEALG.ES256
  });
}
var init_verifyAttestationFIDOU2F = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationFIDOU2F.js"() {
    init_convertCOSEtoPKCS();
    init_convertCertBufferToPEM();
    init_validateCertificatePath();
    init_verifySignature();
    init_iso();
    init_cose();
  }
});

// node_modules/@simplewebauthn/server/esm/helpers/logging.js
function getLogger(_name) {
  return (_message, ..._rest) => {
  };
}
var init_logging = __esm({
  "node_modules/@simplewebauthn/server/esm/helpers/logging.js"() {
  }
});

// node_modules/@simplewebauthn/server/esm/metadata/parseJWT.js
function parseJWT(jwt) {
  const parts = jwt.split(".");
  return [
    JSON.parse(isoBase64URL_exports.toString(parts[0])),
    JSON.parse(isoBase64URL_exports.toString(parts[1])),
    parts[2]
  ];
}
var init_parseJWT = __esm({
  "node_modules/@simplewebauthn/server/esm/metadata/parseJWT.js"() {
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/metadata/verifyJWT.js
function verifyJWT(jwt, leafCert) {
  const [header, payload, signature] = jwt.split(".");
  const certCOSE = convertX509PublicKeyToCOSE(leafCert);
  const data = isoUint8Array_exports.fromUTF8String(`${header}.${payload}`);
  const signatureBytes = isoBase64URL_exports.toBuffer(signature);
  if (isCOSEPublicKeyEC2(certCOSE)) {
    return verifyEC2({
      data,
      signature: signatureBytes,
      cosePublicKey: certCOSE,
      shaHashOverride: COSEALG.ES256
    });
  } else if (isCOSEPublicKeyRSA(certCOSE)) {
    return verifyRSA({
      data,
      signature: signatureBytes,
      cosePublicKey: certCOSE
    });
  }
  const kty = certCOSE.get(COSEKEYS.kty);
  throw new Error(`JWT verification with public key of kty ${kty} is not supported by this method`);
}
var init_verifyJWT = __esm({
  "node_modules/@simplewebauthn/server/esm/metadata/verifyJWT.js"() {
    init_convertX509PublicKeyToCOSE();
    init_iso();
    init_cose();
    init_verifyEC2();
    init_verifyRSA();
  }
});

// node_modules/@simplewebauthn/server/esm/services/metadataService.js
var defaultURLMDS, SERVICE_STATE, log, BaseMetadataService, MetadataService;
var init_metadataService = __esm({
  "node_modules/@simplewebauthn/server/esm/services/metadataService.js"() {
    init_validateCertificatePath();
    init_convertCertBufferToPEM();
    init_convertAAGUIDToString();
    init_settingsService();
    init_logging();
    init_convertPEMToBytes();
    init_fetch();
    init_parseJWT();
    init_verifyJWT();
    defaultURLMDS = "https://mds.fidoalliance.org/";
    (function(SERVICE_STATE2) {
      SERVICE_STATE2[SERVICE_STATE2["DISABLED"] = 0] = "DISABLED";
      SERVICE_STATE2[SERVICE_STATE2["REFRESHING"] = 1] = "REFRESHING";
      SERVICE_STATE2[SERVICE_STATE2["READY"] = 2] = "READY";
    })(SERVICE_STATE || (SERVICE_STATE = {}));
    log = getLogger("MetadataService");
    BaseMetadataService = class {
      constructor() {
        Object.defineProperty(this, "mdsCache", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: {}
        });
        Object.defineProperty(this, "statementCache", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: {}
        });
        Object.defineProperty(this, "state", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: SERVICE_STATE.DISABLED
        });
        Object.defineProperty(this, "verificationMode", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "strict"
        });
      }
      /**
       * Prepare the service to handle remote MDS servers and/or cache local metadata statements.
       *
       * **Options:**
       *
       * @param opts.mdsServers An array of URLs to FIDO Alliance Metadata Service
       * (version 3.0)-compatible servers. Defaults to the official FIDO MDS server
       * @param opts.statements An array of local metadata statements
       * @param opts.verificationMode How MetadataService will handle unregistered AAGUIDs. Defaults to
       * `"strict"` which throws errors during registration response verification when an
       * unregistered AAGUID is encountered. Set to `"permissive"` to allow registration by
       * authenticators with unregistered AAGUIDs
       */
      async initialize(opts = {}) {
        const { mdsServers = [defaultURLMDS], statements, verificationMode } = opts;
        this.setState(SERVICE_STATE.REFRESHING);
        if (statements?.length) {
          let statementsAdded = 0;
          statements.forEach((statement) => {
            if (statement.aaguid) {
              this.statementCache[statement.aaguid] = {
                entry: {
                  metadataStatement: statement,
                  statusReports: [],
                  timeOfLastStatusChange: "1970-01-01"
                },
                url: ""
              };
              statementsAdded += 1;
            }
          });
          log(`Cached ${statementsAdded} local statements`);
        }
        if (mdsServers?.length) {
          const currentCacheCount = Object.keys(this.statementCache).length;
          let numServers = mdsServers.length;
          for (const url of mdsServers) {
            try {
              await this.downloadBlob({
                url,
                no: 0,
                nextUpdate: /* @__PURE__ */ new Date(0)
              });
            } catch (err) {
              log(`Could not download BLOB from ${url}:`, err);
              numServers -= 1;
            }
          }
          const newCacheCount = Object.keys(this.statementCache).length;
          const cacheDiff = newCacheCount - currentCacheCount;
          log(`Cached ${cacheDiff} statements from ${numServers} metadata server(s)`);
        }
        if (verificationMode) {
          this.verificationMode = verificationMode;
        }
        this.setState(SERVICE_STATE.READY);
      }
      /**
       * Get a metadata statement for a given AAGUID.
       *
       * This method will coordinate updating the cache as per the `nextUpdate` property in the initial
       * BLOB download.
       */
      async getStatement(aaguid) {
        if (this.state === SERVICE_STATE.DISABLED) {
          return;
        }
        if (!aaguid) {
          return;
        }
        if (aaguid instanceof Uint8Array) {
          aaguid = convertAAGUIDToString(aaguid);
        }
        await this.pauseUntilReady();
        const cachedStatement = this.statementCache[aaguid];
        if (!cachedStatement) {
          if (this.verificationMode === "strict") {
            throw new Error(`No metadata statement found for aaguid "${aaguid}"`);
          }
          return;
        }
        if (cachedStatement.url) {
          const mds = this.mdsCache[cachedStatement.url];
          const now = /* @__PURE__ */ new Date();
          if (now > mds.nextUpdate) {
            try {
              this.setState(SERVICE_STATE.REFRESHING);
              await this.downloadBlob(mds);
            } finally {
              this.setState(SERVICE_STATE.READY);
            }
          }
        }
        const { entry } = cachedStatement;
        for (const report of entry.statusReports) {
          const { status } = report;
          if (status === "USER_VERIFICATION_BYPASS" || status === "ATTESTATION_KEY_COMPROMISE" || status === "USER_KEY_REMOTE_COMPROMISE" || status === "USER_KEY_PHYSICAL_COMPROMISE") {
            throw new Error(`Detected compromised aaguid "${aaguid}"`);
          }
        }
        return entry.metadataStatement;
      }
      /**
       * Download and process the latest BLOB from MDS
       */
      async downloadBlob(mds) {
        const { url, no } = mds;
        const resp = await fetch4(url);
        const data = await resp.text();
        const parsedJWT = parseJWT(data);
        const header = parsedJWT[0];
        const payload = parsedJWT[1];
        if (payload.no <= no) {
          throw new Error(`Latest BLOB no. "${payload.no}" is not greater than previous ${no}`);
        }
        const headerCertsPEM = header.x5c.map(convertCertBufferToPEM);
        try {
          const rootCerts = SettingsService.getRootCertificates({
            identifier: "mds"
          });
          await validateCertificatePath(headerCertsPEM, rootCerts);
        } catch (error2) {
          const _error = error2;
          throw new Error(`BLOB certificate path could not be validated: ${_error.message}`);
        }
        const leafCert = headerCertsPEM[0];
        const verified = await verifyJWT(data, convertPEMToBytes(leafCert));
        if (!verified) {
          throw new Error("BLOB signature could not be verified");
        }
        for (const entry of payload.entries) {
          if (entry.aaguid) {
            this.statementCache[entry.aaguid] = { entry, url };
          }
        }
        const [year2, month, day2] = payload.nextUpdate.split("-");
        this.mdsCache[url] = {
          ...mds,
          // Store the payload `no` to make sure we're getting the next BLOB in the sequence
          no: payload.no,
          // Convert the nextUpdate property into a Date so we can determine when to re-download
          nextUpdate: new Date(
            parseInt(year2, 10),
            // Months need to be zero-indexed
            parseInt(month, 10) - 1,
            parseInt(day2, 10)
          )
        };
      }
      /**
       * A helper method to pause execution until the service is ready
       */
      pauseUntilReady() {
        if (this.state === SERVICE_STATE.READY) {
          return new Promise((resolve2) => {
            resolve2();
          });
        }
        const readyPromise = new Promise((resolve2, reject) => {
          const totalTimeoutMS = 7e4;
          const intervalMS = 100;
          let iterations = totalTimeoutMS / intervalMS;
          const intervalID = globalThis.setInterval(() => {
            if (iterations < 1) {
              clearInterval(intervalID);
              reject(`State did not become ready in ${totalTimeoutMS / 1e3} seconds`);
            } else if (this.state === SERVICE_STATE.READY) {
              clearInterval(intervalID);
              resolve2();
            }
            iterations -= 1;
          }, intervalMS);
        });
        return readyPromise;
      }
      /**
       * Report service status on change
       */
      setState(newState) {
        this.state = newState;
        if (newState === SERVICE_STATE.DISABLED) {
          log("MetadataService is DISABLED");
        } else if (newState === SERVICE_STATE.REFRESHING) {
          log("MetadataService is REFRESHING");
        } else if (newState === SERVICE_STATE.READY) {
          log("MetadataService is READY");
        }
      }
    };
    MetadataService = new BaseMetadataService();
  }
});

// node_modules/@simplewebauthn/server/esm/metadata/verifyAttestationWithMetadata.js
async function verifyAttestationWithMetadata({ statement, credentialPublicKey, x5c, attestationStatementAlg }) {
  const { authenticationAlgorithms, authenticatorGetInfo, attestationRootCertificates } = statement;
  const keypairCOSEAlgs = /* @__PURE__ */ new Set();
  authenticationAlgorithms.forEach((algSign) => {
    const algSignCOSEINFO = algSignToCOSEInfoMap[algSign];
    if (algSignCOSEINFO) {
      keypairCOSEAlgs.add(algSignCOSEINFO);
    }
  });
  const decodedPublicKey = decodeCredentialPublicKey(credentialPublicKey);
  const kty = decodedPublicKey.get(COSEKEYS.kty);
  const alg = decodedPublicKey.get(COSEKEYS.alg);
  if (!kty) {
    throw new Error("Credential public key was missing kty");
  }
  if (!alg) {
    throw new Error("Credential public key was missing alg");
  }
  if (!kty) {
    throw new Error("Credential public key was missing kty");
  }
  const publicKeyCOSEInfo = { kty, alg };
  if (isCOSEPublicKeyEC2(decodedPublicKey)) {
    const crv = decodedPublicKey.get(COSEKEYS.crv);
    publicKeyCOSEInfo.crv = crv;
  }
  let foundMatch = false;
  for (const keypairAlg of keypairCOSEAlgs) {
    if (keypairAlg.alg === publicKeyCOSEInfo.alg && keypairAlg.kty === publicKeyCOSEInfo.kty) {
      if ((keypairAlg.kty === COSEKTY.EC2 || keypairAlg.kty === COSEKTY.OKP) && keypairAlg.crv === publicKeyCOSEInfo.crv) {
        foundMatch = true;
      } else {
        foundMatch = true;
      }
    }
    if (foundMatch) {
      break;
    }
  }
  if (!foundMatch) {
    const debugMDSAlgs = authenticationAlgorithms.map((algSign) => `'${algSign}' (COSE info: ${stringifyCOSEInfo(algSignToCOSEInfoMap[algSign])})`);
    const strMDSAlgs = JSON.stringify(debugMDSAlgs, null, 2).replace(/"/g, "");
    const strPubKeyAlg = stringifyCOSEInfo(publicKeyCOSEInfo);
    throw new Error(`Public key parameters ${strPubKeyAlg} did not match any of the following metadata algorithms:
${strMDSAlgs}`);
  }
  if (attestationStatementAlg !== void 0 && authenticatorGetInfo?.algorithms !== void 0) {
    const getInfoAlgs = authenticatorGetInfo.algorithms.map((_alg) => _alg.alg);
    if (getInfoAlgs.indexOf(attestationStatementAlg) < 0) {
      throw new Error(`Attestation statement alg ${attestationStatementAlg} did not match one of ${getInfoAlgs}`);
    }
  }
  const authenticatorCerts = x5c.map(convertCertBufferToPEM);
  const statementRootCerts = attestationRootCertificates.map(convertCertBufferToPEM);
  let authenticatorIsSelfReferencing = false;
  if (authenticatorCerts.length === 1 && statementRootCerts.indexOf(authenticatorCerts[0]) >= 0) {
    authenticatorIsSelfReferencing = true;
  }
  if (!authenticatorIsSelfReferencing) {
    try {
      await validateCertificatePath(authenticatorCerts, statementRootCerts);
    } catch (err) {
      const _err = err;
      throw new Error(`Could not validate certificate path with any metadata root certificates: ${_err.message}`);
    }
  }
  return true;
}
function stringifyCOSEInfo(info) {
  const { kty, alg, crv } = info;
  let toReturn = "";
  if (kty !== COSEKTY.RSA) {
    toReturn = `{ kty: ${kty}, alg: ${alg}, crv: ${crv} }`;
  } else {
    toReturn = `{ kty: ${kty}, alg: ${alg} }`;
  }
  return toReturn;
}
var algSignToCOSEInfoMap;
var init_verifyAttestationWithMetadata = __esm({
  "node_modules/@simplewebauthn/server/esm/metadata/verifyAttestationWithMetadata.js"() {
    init_convertCertBufferToPEM();
    init_validateCertificatePath();
    init_decodeCredentialPublicKey();
    init_cose();
    algSignToCOSEInfoMap = {
      secp256r1_ecdsa_sha256_raw: { kty: 2, alg: -7, crv: 1 },
      secp256r1_ecdsa_sha256_der: { kty: 2, alg: -7, crv: 1 },
      rsassa_pss_sha256_raw: { kty: 3, alg: -37 },
      rsassa_pss_sha256_der: { kty: 3, alg: -37 },
      secp256k1_ecdsa_sha256_raw: { kty: 2, alg: -47, crv: 8 },
      secp256k1_ecdsa_sha256_der: { kty: 2, alg: -47, crv: 8 },
      rsassa_pss_sha384_raw: { kty: 3, alg: -38 },
      rsassa_pkcsv15_sha256_raw: { kty: 3, alg: -257 },
      rsassa_pkcsv15_sha384_raw: { kty: 3, alg: -258 },
      rsassa_pkcsv15_sha512_raw: { kty: 3, alg: -259 },
      rsassa_pkcsv15_sha1_raw: { kty: 3, alg: -65535 },
      secp384r1_ecdsa_sha384_raw: { kty: 2, alg: -35, crv: 2 },
      secp512r1_ecdsa_sha256_raw: { kty: 2, alg: -36, crv: 3 },
      ed25519_eddsa_sha512_raw: { kty: 1, alg: -8, crv: 6 }
    };
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationPacked.js
async function verifyAttestationPacked(options3) {
  const { attStmt, clientDataHash, authData, credentialPublicKey, aaguid, rootCertificates } = options3;
  const sig = attStmt.get("sig");
  const x5c = attStmt.get("x5c");
  const alg = attStmt.get("alg");
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (Packed)");
  }
  if (!alg) {
    throw new Error("Attestation statement did not contain alg (Packed)");
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Attestation statement contained invalid alg ${alg} (Packed)`);
  }
  const signatureBase = isoUint8Array_exports.concat([authData, clientDataHash]);
  let verified = false;
  if (x5c) {
    const { subject, basicConstraintsCA, version, notBefore, notAfter } = getCertificateInfo(x5c[0]);
    const { OU, CN, O: O3, C: C5 } = subject;
    if (OU !== "Authenticator Attestation") {
      throw new Error('Certificate OU was not "Authenticator Attestation" (Packed|Full)');
    }
    if (!CN) {
      throw new Error("Certificate CN was empty (Packed|Full)");
    }
    if (!O3) {
      throw new Error("Certificate O was empty (Packed|Full)");
    }
    if (!C5 || C5.length !== 2) {
      throw new Error("Certificate C was not two-character ISO 3166 code (Packed|Full)");
    }
    if (basicConstraintsCA) {
      throw new Error("Certificate basic constraints CA was not `false` (Packed|Full)");
    }
    if (version !== 2) {
      throw new Error("Certificate version was not `3` (ASN.1 value of 2) (Packed|Full)");
    }
    let now = /* @__PURE__ */ new Date();
    if (notBefore > now) {
      throw new Error(`Certificate not good before "${notBefore.toString()}" (Packed|Full)`);
    }
    now = /* @__PURE__ */ new Date();
    if (notAfter < now) {
      throw new Error(`Certificate not good after "${notAfter.toString()}" (Packed|Full)`);
    }
    const statement = await MetadataService.getStatement(aaguid);
    if (statement) {
      if (statement.attestationTypes.indexOf("basic_full") < 0) {
        throw new Error("Metadata does not indicate support for full attestations (Packed|Full)");
      }
      try {
        await verifyAttestationWithMetadata({
          statement,
          credentialPublicKey,
          x5c,
          attestationStatementAlg: alg
        });
      } catch (err) {
        const _err = err;
        throw new Error(`${_err.message} (Packed|Full)`);
      }
    } else {
      try {
        await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
      } catch (err) {
        const _err = err;
        throw new Error(`${_err.message} (Packed|Full)`);
      }
    }
    verified = await verifySignature({
      signature: sig,
      data: signatureBase,
      x509Certificate: x5c[0]
    });
  } else {
    verified = await verifySignature({
      signature: sig,
      data: signatureBase,
      credentialPublicKey,
      hashAlgorithm: alg
    });
  }
  return verified;
}
var init_verifyAttestationPacked = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationPacked.js"() {
    init_cose();
    init_convertCertBufferToPEM();
    init_validateCertificatePath();
    init_getCertificateInfo();
    init_verifySignature();
    init_iso();
    init_metadataService();
    init_verifyAttestationWithMetadata();
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidSafetyNet.js
async function verifyAttestationAndroidSafetyNet(options3) {
  const { attStmt, clientDataHash, authData, aaguid, rootCertificates, verifyTimestampMS = true, credentialPublicKey } = options3;
  const alg = attStmt.get("alg");
  const response = attStmt.get("response");
  const ver = attStmt.get("ver");
  if (!ver) {
    throw new Error("No ver value in attestation (SafetyNet)");
  }
  if (!response) {
    throw new Error("No response was included in attStmt by authenticator (SafetyNet)");
  }
  const jwt = isoUint8Array_exports.toUTF8String(response);
  const jwtParts = jwt.split(".");
  const HEADER = JSON.parse(isoBase64URL_exports.toString(jwtParts[0]));
  const PAYLOAD = JSON.parse(isoBase64URL_exports.toString(jwtParts[1]));
  const SIGNATURE = jwtParts[2];
  const { nonce, ctsProfileMatch, timestampMs } = PAYLOAD;
  if (verifyTimestampMS) {
    let now = Date.now();
    if (timestampMs > Date.now()) {
      throw new Error(`Payload timestamp "${timestampMs}" was later than "${now}" (SafetyNet)`);
    }
    const timestampPlusDelay = timestampMs + 60 * 1e3;
    now = Date.now();
    if (timestampPlusDelay < now) {
      throw new Error(`Payload timestamp "${timestampPlusDelay}" has expired (SafetyNet)`);
    }
  }
  const nonceBase = isoUint8Array_exports.concat([authData, clientDataHash]);
  const nonceBuffer = await toHash(nonceBase);
  const expectedNonce = isoBase64URL_exports.fromBuffer(nonceBuffer, "base64");
  if (nonce !== expectedNonce) {
    throw new Error("Could not verify payload nonce (SafetyNet)");
  }
  if (!ctsProfileMatch) {
    throw new Error("Could not verify device integrity (SafetyNet)");
  }
  const leafCertBuffer = isoBase64URL_exports.toBuffer(HEADER.x5c[0], "base64");
  const leafCertInfo = getCertificateInfo(leafCertBuffer);
  const { subject } = leafCertInfo;
  if (subject.CN !== "attest.android.com") {
    throw new Error('Certificate common name was not "attest.android.com" (SafetyNet)');
  }
  const statement = await MetadataService.getStatement(aaguid);
  if (statement) {
    try {
      await verifyAttestationWithMetadata({
        statement,
        credentialPublicKey,
        x5c: HEADER.x5c,
        attestationStatementAlg: alg
      });
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (SafetyNet)`);
    }
  } else {
    try {
      await validateCertificatePath(HEADER.x5c.map(convertCertBufferToPEM), rootCertificates);
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (SafetyNet)`);
    }
  }
  const signatureBaseBuffer = isoUint8Array_exports.fromUTF8String(`${jwtParts[0]}.${jwtParts[1]}`);
  const signatureBuffer = isoBase64URL_exports.toBuffer(SIGNATURE);
  const verified = await verifySignature({
    signature: signatureBuffer,
    data: signatureBaseBuffer,
    x509Certificate: leafCertBuffer
  });
  return verified;
}
var init_verifyAttestationAndroidSafetyNet = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidSafetyNet.js"() {
    init_toHash();
    init_verifySignature();
    init_getCertificateInfo();
    init_validateCertificatePath();
    init_convertCertBufferToPEM();
    init_iso();
    init_metadataService();
    init_verifyAttestationWithMetadata();
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/constants.js
var TPM_ST, TPM_ALG, TPM_ECC_CURVE, TPM_MANUFACTURERS, TPM_ECC_CURVE_COSE_CRV_MAP;
var init_constants2 = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/constants.js"() {
    TPM_ST = {
      196: "TPM_ST_RSP_COMMAND",
      32768: "TPM_ST_NULL",
      32769: "TPM_ST_NO_SESSIONS",
      32770: "TPM_ST_SESSIONS",
      32788: "TPM_ST_ATTEST_NV",
      32789: "TPM_ST_ATTEST_COMMAND_AUDIT",
      32790: "TPM_ST_ATTEST_SESSION_AUDIT",
      32791: "TPM_ST_ATTEST_CERTIFY",
      32792: "TPM_ST_ATTEST_QUOTE",
      32793: "TPM_ST_ATTEST_TIME",
      32794: "TPM_ST_ATTEST_CREATION",
      32801: "TPM_ST_CREATION",
      32802: "TPM_ST_VERIFIED",
      32803: "TPM_ST_AUTH_SECRET",
      32804: "TPM_ST_HASHCHECK",
      32805: "TPM_ST_AUTH_SIGNED",
      32809: "TPM_ST_FU_MANIFEST"
    };
    TPM_ALG = {
      0: "TPM_ALG_ERROR",
      1: "TPM_ALG_RSA",
      4: "TPM_ALG_SHA",
      // @ts-ignore 2300
      4: "TPM_ALG_SHA1",
      5: "TPM_ALG_HMAC",
      6: "TPM_ALG_AES",
      7: "TPM_ALG_MGF1",
      8: "TPM_ALG_KEYEDHASH",
      10: "TPM_ALG_XOR",
      11: "TPM_ALG_SHA256",
      12: "TPM_ALG_SHA384",
      13: "TPM_ALG_SHA512",
      16: "TPM_ALG_NULL",
      18: "TPM_ALG_SM3_256",
      19: "TPM_ALG_SM4",
      20: "TPM_ALG_RSASSA",
      21: "TPM_ALG_RSAES",
      22: "TPM_ALG_RSAPSS",
      23: "TPM_ALG_OAEP",
      24: "TPM_ALG_ECDSA",
      25: "TPM_ALG_ECDH",
      26: "TPM_ALG_ECDAA",
      27: "TPM_ALG_SM2",
      28: "TPM_ALG_ECSCHNORR",
      29: "TPM_ALG_ECMQV",
      32: "TPM_ALG_KDF1_SP800_56A",
      33: "TPM_ALG_KDF2",
      34: "TPM_ALG_KDF1_SP800_108",
      35: "TPM_ALG_ECC",
      37: "TPM_ALG_SYMCIPHER",
      38: "TPM_ALG_CAMELLIA",
      64: "TPM_ALG_CTR",
      65: "TPM_ALG_OFB",
      66: "TPM_ALG_CBC",
      67: "TPM_ALG_CFB",
      68: "TPM_ALG_ECB"
    };
    TPM_ECC_CURVE = {
      0: "TPM_ECC_NONE",
      1: "TPM_ECC_NIST_P192",
      2: "TPM_ECC_NIST_P224",
      3: "TPM_ECC_NIST_P256",
      4: "TPM_ECC_NIST_P384",
      5: "TPM_ECC_NIST_P521",
      16: "TPM_ECC_BN_P256",
      17: "TPM_ECC_BN_P638",
      32: "TPM_ECC_SM2_P256"
    };
    TPM_MANUFACTURERS = {
      "id:414D4400": {
        name: "AMD",
        id: "AMD"
      },
      "id:41544D4C": {
        name: "Atmel",
        id: "ATML"
      },
      "id:4252434D": {
        name: "Broadcom",
        id: "BRCM"
      },
      "id:49424d00": {
        name: "IBM",
        id: "IBM"
      },
      "id:49465800": {
        name: "Infineon",
        id: "IFX"
      },
      "id:494E5443": {
        name: "Intel",
        id: "INTC"
      },
      "id:4C454E00": {
        name: "Lenovo",
        id: "LEN"
      },
      "id:4E534D20": {
        name: "National Semiconductor",
        id: "NSM"
      },
      "id:4E545A00": {
        name: "Nationz",
        id: "NTZ"
      },
      "id:4E544300": {
        name: "Nuvoton Technology",
        id: "NTC"
      },
      "id:51434F4D": {
        name: "Qualcomm",
        id: "QCOM"
      },
      "id:534D5343": {
        name: "SMSC",
        id: "SMSC"
      },
      "id:53544D20": {
        name: "ST Microelectronics",
        id: "STM"
      },
      "id:534D534E": {
        name: "Samsung",
        id: "SMSN"
      },
      "id:534E5300": {
        name: "Sinosun",
        id: "SNS"
      },
      "id:54584E00": {
        name: "Texas Instruments",
        id: "TXN"
      },
      "id:57454300": {
        name: "Winbond",
        id: "WEC"
      },
      "id:524F4343": {
        name: "Fuzhouk Rockchip",
        id: "ROCC"
      },
      "id:FFFFF1D0": {
        name: "FIDO Alliance",
        id: "FIDO"
      }
    };
    TPM_ECC_CURVE_COSE_CRV_MAP = {
      TPM_ECC_NIST_P256: 1,
      TPM_ECC_NIST_P384: 2,
      TPM_ECC_NIST_P521: 3,
      TPM_ECC_BN_P256: 1,
      TPM_ECC_SM2_P256: 1
      // p256
    };
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/parseCertInfo.js
function parseCertInfo(certInfo) {
  let pointer = 0;
  const dataView = isoUint8Array_exports.toDataView(certInfo);
  const magic = dataView.getUint32(pointer);
  pointer += 4;
  const typeBuffer = dataView.getUint16(pointer);
  pointer += 2;
  const type = TPM_ST[typeBuffer];
  const qualifiedSignerLength = dataView.getUint16(pointer);
  pointer += 2;
  const qualifiedSigner = certInfo.slice(pointer, pointer += qualifiedSignerLength);
  const extraDataLength = dataView.getUint16(pointer);
  pointer += 2;
  const extraData = certInfo.slice(pointer, pointer += extraDataLength);
  const clock = certInfo.slice(pointer, pointer += 8);
  const resetCount = dataView.getUint32(pointer);
  pointer += 4;
  const restartCount = dataView.getUint32(pointer);
  pointer += 4;
  const safe = !!certInfo.slice(pointer, pointer += 1);
  const clockInfo = { clock, resetCount, restartCount, safe };
  const firmwareVersion = certInfo.slice(pointer, pointer += 8);
  const attestedNameLength = dataView.getUint16(pointer);
  pointer += 2;
  const attestedName = certInfo.slice(pointer, pointer += attestedNameLength);
  const attestedNameDataView = isoUint8Array_exports.toDataView(attestedName);
  const qualifiedNameLength = dataView.getUint16(pointer);
  pointer += 2;
  const qualifiedName = certInfo.slice(pointer, pointer += qualifiedNameLength);
  const attested = {
    nameAlg: TPM_ALG[attestedNameDataView.getUint16(0)],
    nameAlgBuffer: attestedName.slice(0, 2),
    name: attestedName,
    qualifiedName
  };
  return {
    magic,
    type,
    qualifiedSigner,
    extraData,
    clockInfo,
    firmwareVersion,
    attested
  };
}
var init_parseCertInfo = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/parseCertInfo.js"() {
    init_constants2();
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/parsePubArea.js
function parsePubArea(pubArea) {
  let pointer = 0;
  const dataView = isoUint8Array_exports.toDataView(pubArea);
  const type = TPM_ALG[dataView.getUint16(pointer)];
  pointer += 2;
  const nameAlg = TPM_ALG[dataView.getUint16(pointer)];
  pointer += 2;
  const objectAttributesInt = dataView.getUint32(pointer);
  pointer += 4;
  const objectAttributes = {
    fixedTPM: !!(objectAttributesInt & 1),
    stClear: !!(objectAttributesInt & 2),
    fixedParent: !!(objectAttributesInt & 8),
    sensitiveDataOrigin: !!(objectAttributesInt & 16),
    userWithAuth: !!(objectAttributesInt & 32),
    adminWithPolicy: !!(objectAttributesInt & 64),
    noDA: !!(objectAttributesInt & 512),
    encryptedDuplication: !!(objectAttributesInt & 1024),
    restricted: !!(objectAttributesInt & 32768),
    decrypt: !!(objectAttributesInt & 65536),
    signOrEncrypt: !!(objectAttributesInt & 131072)
  };
  const authPolicyLength = dataView.getUint16(pointer);
  pointer += 2;
  const authPolicy = pubArea.slice(pointer, pointer += authPolicyLength);
  const parameters = {};
  let unique = Uint8Array.from([]);
  if (type === "TPM_ALG_RSA") {
    const symmetric = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const scheme = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const keyBits = dataView.getUint16(pointer);
    pointer += 2;
    const exponent = dataView.getUint32(pointer);
    pointer += 4;
    parameters.rsa = { symmetric, scheme, keyBits, exponent };
    const uniqueLength = dataView.getUint16(pointer);
    pointer += 2;
    unique = pubArea.slice(pointer, pointer += uniqueLength);
  } else if (type === "TPM_ALG_ECC") {
    const symmetric = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const scheme = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    const curveID = TPM_ECC_CURVE[dataView.getUint16(pointer)];
    pointer += 2;
    const kdf = TPM_ALG[dataView.getUint16(pointer)];
    pointer += 2;
    parameters.ecc = { symmetric, scheme, curveID, kdf };
    const uniqueXLength = dataView.getUint16(pointer);
    pointer += 2;
    const uniqueX = pubArea.slice(pointer, pointer += uniqueXLength);
    const uniqueYLength = dataView.getUint16(pointer);
    pointer += 2;
    const uniqueY = pubArea.slice(pointer, pointer += uniqueYLength);
    unique = isoUint8Array_exports.concat([uniqueX, uniqueY]);
  } else {
    throw new Error(`Unexpected type "${type}" (TPM)`);
  }
  return {
    type,
    nameAlg,
    objectAttributes,
    authPolicy,
    parameters,
    unique
  };
}
var init_parsePubArea = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/parsePubArea.js"() {
    init_constants2();
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/verifyAttestationTPM.js
async function verifyAttestationTPM(options3) {
  const { aaguid, attStmt, authData, credentialPublicKey, clientDataHash, rootCertificates } = options3;
  const ver = attStmt.get("ver");
  const sig = attStmt.get("sig");
  const alg = attStmt.get("alg");
  const x5c = attStmt.get("x5c");
  const pubArea = attStmt.get("pubArea");
  const certInfo = attStmt.get("certInfo");
  if (ver !== "2.0") {
    throw new Error(`Unexpected ver "${ver}", expected "2.0" (TPM)`);
  }
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (TPM)");
  }
  if (!alg) {
    throw new Error(`Attestation statement did not contain alg (TPM)`);
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Attestation statement contained invalid alg ${alg} (TPM)`);
  }
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (TPM)");
  }
  if (!pubArea) {
    throw new Error("Attestation statement did not contain pubArea (TPM)");
  }
  if (!certInfo) {
    throw new Error("Attestation statement did not contain certInfo (TPM)");
  }
  const parsedPubArea = parsePubArea(pubArea);
  const { unique, type: pubType, parameters } = parsedPubArea;
  const cosePublicKey = decodeCredentialPublicKey(credentialPublicKey);
  if (pubType === "TPM_ALG_RSA") {
    if (!isCOSEPublicKeyRSA(cosePublicKey)) {
      throw new Error(`Credential public key with kty ${cosePublicKey.get(COSEKEYS.kty)} did not match ${pubType}`);
    }
    const n7 = cosePublicKey.get(COSEKEYS.n);
    const e5 = cosePublicKey.get(COSEKEYS.e);
    if (!n7) {
      throw new Error("COSE public key missing n (TPM|RSA)");
    }
    if (!e5) {
      throw new Error("COSE public key missing e (TPM|RSA)");
    }
    if (!isoUint8Array_exports.areEqual(unique, n7)) {
      throw new Error("PubArea unique is not same as credentialPublicKey (TPM|RSA)");
    }
    if (!parameters.rsa) {
      throw new Error(`Parsed pubArea type is RSA, but missing parameters.rsa (TPM|RSA)`);
    }
    const eBuffer = e5;
    const pubAreaExponent = parameters.rsa.exponent || 65537;
    const eSum = eBuffer[0] + (eBuffer[1] << 8) + (eBuffer[2] << 16);
    if (pubAreaExponent !== eSum) {
      throw new Error(`Unexpected public key exp ${eSum}, expected ${pubAreaExponent} (TPM|RSA)`);
    }
  } else if (pubType === "TPM_ALG_ECC") {
    if (!isCOSEPublicKeyEC2(cosePublicKey)) {
      throw new Error(`Credential public key with kty ${cosePublicKey.get(COSEKEYS.kty)} did not match ${pubType}`);
    }
    const crv = cosePublicKey.get(COSEKEYS.crv);
    const x4 = cosePublicKey.get(COSEKEYS.x);
    const y7 = cosePublicKey.get(COSEKEYS.y);
    if (!crv) {
      throw new Error("COSE public key missing crv (TPM|ECC)");
    }
    if (!x4) {
      throw new Error("COSE public key missing x (TPM|ECC)");
    }
    if (!y7) {
      throw new Error("COSE public key missing y (TPM|ECC)");
    }
    if (!isoUint8Array_exports.areEqual(unique, isoUint8Array_exports.concat([x4, y7]))) {
      throw new Error("PubArea unique is not same as public key x and y (TPM|ECC)");
    }
    if (!parameters.ecc) {
      throw new Error(`Parsed pubArea type is ECC, but missing parameters.ecc (TPM|ECC)`);
    }
    const pubAreaCurveID = parameters.ecc.curveID;
    const pubAreaCurveIDMapToCOSECRV = TPM_ECC_CURVE_COSE_CRV_MAP[pubAreaCurveID];
    if (pubAreaCurveIDMapToCOSECRV !== crv) {
      throw new Error(`Public area key curve ID "${pubAreaCurveID}" mapped to "${pubAreaCurveIDMapToCOSECRV}" which did not match public key crv of "${crv}" (TPM|ECC)`);
    }
  } else {
    throw new Error(`Unsupported pubArea.type "${pubType}"`);
  }
  const parsedCertInfo = parseCertInfo(certInfo);
  const { magic, type: certType, attested, extraData } = parsedCertInfo;
  if (magic !== 4283712327) {
    throw new Error(`Unexpected magic value "${magic}", expected "0xff544347" (TPM)`);
  }
  if (certType !== "TPM_ST_ATTEST_CERTIFY") {
    throw new Error(`Unexpected type "${certType}", expected "TPM_ST_ATTEST_CERTIFY" (TPM)`);
  }
  const pubAreaHash = await toHash(pubArea, attestedNameAlgToCOSEAlg(attested.nameAlg));
  const attestedName = isoUint8Array_exports.concat([
    attested.nameAlgBuffer,
    pubAreaHash
  ]);
  if (!isoUint8Array_exports.areEqual(attested.name, attestedName)) {
    throw new Error(`Attested name comparison failed (TPM)`);
  }
  const attToBeSigned = isoUint8Array_exports.concat([authData, clientDataHash]);
  const attToBeSignedHash = await toHash(attToBeSigned, alg);
  if (!isoUint8Array_exports.areEqual(extraData, attToBeSignedHash)) {
    throw new Error("CertInfo extra data did not equal hashed attestation (TPM)");
  }
  if (x5c.length < 1) {
    throw new Error("No certificates present in x5c array (TPM)");
  }
  const leafCertInfo = getCertificateInfo(x5c[0]);
  const { basicConstraintsCA, version, subject, notAfter, notBefore } = leafCertInfo;
  if (basicConstraintsCA) {
    throw new Error("Certificate basic constraints CA was not `false` (TPM)");
  }
  if (version !== 2) {
    throw new Error("Certificate version was not `3` (ASN.1 value of 2) (TPM)");
  }
  if (subject.combined.length > 0) {
    throw new Error("Certificate subject was not empty (TPM)");
  }
  let now = /* @__PURE__ */ new Date();
  if (notBefore > now) {
    throw new Error(`Certificate not good before "${notBefore.toString()}" (TPM)`);
  }
  now = /* @__PURE__ */ new Date();
  if (notAfter < now) {
    throw new Error(`Certificate not good after "${notAfter.toString()}" (TPM)`);
  }
  const parsedCert = AsnParser.parse(x5c[0], Certificate);
  if (!parsedCert.tbsCertificate.extensions) {
    throw new Error("Certificate was missing extensions (TPM)");
  }
  let subjectAltNamePresent;
  let extKeyUsage;
  parsedCert.tbsCertificate.extensions.forEach((ext) => {
    if (ext.extnID === id_ce_subjectAltName) {
      subjectAltNamePresent = AsnParser.parse(ext.extnValue, SubjectAlternativeName);
    } else if (ext.extnID === id_ce_extKeyUsage) {
      extKeyUsage = AsnParser.parse(ext.extnValue, ExtendedKeyUsage);
    }
  });
  if (!subjectAltNamePresent) {
    throw new Error("Certificate did not contain subjectAltName extension (TPM)");
  }
  if (!subjectAltNamePresent[0].directoryName?.[0].length) {
    throw new Error("Certificate subjectAltName extension directoryName was empty (TPM)");
  }
  const { tcgAtTpmManufacturer, tcgAtTpmModel, tcgAtTpmVersion } = getTcgAtTpmValues(subjectAltNamePresent[0].directoryName);
  if (!tcgAtTpmManufacturer || !tcgAtTpmModel || !tcgAtTpmVersion) {
    throw new Error("Certificate contained incomplete subjectAltName data (TPM)");
  }
  if (!extKeyUsage) {
    throw new Error("Certificate did not contain ExtendedKeyUsage extension (TPM)");
  }
  if (!TPM_MANUFACTURERS[tcgAtTpmManufacturer]) {
    throw new Error(`Could not match TPM manufacturer "${tcgAtTpmManufacturer}" (TPM)`);
  }
  if (extKeyUsage[0] !== "2.23.133.8.3") {
    throw new Error(`Unexpected extKeyUsage "${extKeyUsage[0]}", expected "2.23.133.8.3" (TPM)`);
  }
  const statement = await MetadataService.getStatement(aaguid);
  if (statement) {
    try {
      await verifyAttestationWithMetadata({
        statement,
        credentialPublicKey,
        x5c,
        attestationStatementAlg: alg
      });
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (TPM)`);
    }
  } else {
    try {
      await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (TPM)`);
    }
  }
  return verifySignature({
    signature: sig,
    data: certInfo,
    x509Certificate: x5c[0],
    hashAlgorithm: alg
  });
}
function getTcgAtTpmValues(root2) {
  const oidManufacturer = "2.23.133.2.1";
  const oidModel = "2.23.133.2.2";
  const oidVersion = "2.23.133.2.3";
  let tcgAtTpmManufacturer;
  let tcgAtTpmModel;
  let tcgAtTpmVersion;
  root2.forEach((relName) => {
    relName.forEach((attr2) => {
      if (attr2.type === oidManufacturer) {
        tcgAtTpmManufacturer = attr2.value.toString();
      } else if (attr2.type === oidModel) {
        tcgAtTpmModel = attr2.value.toString();
      } else if (attr2.type === oidVersion) {
        tcgAtTpmVersion = attr2.value.toString();
      }
    });
  });
  return {
    tcgAtTpmManufacturer,
    tcgAtTpmModel,
    tcgAtTpmVersion
  };
}
function attestedNameAlgToCOSEAlg(alg) {
  if (alg === "TPM_ALG_SHA256") {
    return COSEALG.ES256;
  } else if (alg === "TPM_ALG_SHA384") {
    return COSEALG.ES384;
  } else if (alg === "TPM_ALG_SHA512") {
    return COSEALG.ES512;
  }
  throw new Error(`Unexpected TPM attested name alg ${alg}`);
}
var init_verifyAttestationTPM = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/tpm/verifyAttestationTPM.js"() {
    init_deps();
    init_decodeCredentialPublicKey();
    init_cose();
    init_toHash();
    init_convertCertBufferToPEM();
    init_validateCertificatePath();
    init_getCertificateInfo();
    init_verifySignature();
    init_iso();
    init_metadataService();
    init_verifyAttestationWithMetadata();
    init_constants2();
    init_parseCertInfo();
    init_parsePubArea();
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidKey.js
async function verifyAttestationAndroidKey(options3) {
  const { authData, clientDataHash, attStmt, credentialPublicKey, aaguid, rootCertificates } = options3;
  const x5c = attStmt.get("x5c");
  const sig = attStmt.get("sig");
  const alg = attStmt.get("alg");
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (AndroidKey)");
  }
  if (!sig) {
    throw new Error("No attestation signature provided in attestation statement (AndroidKey)");
  }
  if (!alg) {
    throw new Error(`Attestation statement did not contain alg (AndroidKey)`);
  }
  if (!isCOSEAlg(alg)) {
    throw new Error(`Attestation statement contained invalid alg ${alg} (AndroidKey)`);
  }
  const parsedCert = AsnParser.parse(x5c[0], Certificate);
  const parsedCertPubKey = new Uint8Array(parsedCert.tbsCertificate.subjectPublicKeyInfo.subjectPublicKey);
  const credPubKeyPKCS = convertCOSEtoPKCS(credentialPublicKey);
  if (!isoUint8Array_exports.areEqual(credPubKeyPKCS, parsedCertPubKey)) {
    throw new Error("Credential public key does not equal leaf cert public key (AndroidKey)");
  }
  const extKeyStore = parsedCert.tbsCertificate.extensions?.find((ext) => ext.extnID === id_ce_keyDescription);
  if (!extKeyStore) {
    throw new Error("Certificate did not contain extKeyStore (AndroidKey)");
  }
  const parsedExtKeyStore = AsnParser.parse(extKeyStore.extnValue, KeyDescription);
  const { attestationChallenge, teeEnforced, softwareEnforced } = parsedExtKeyStore;
  if (!isoUint8Array_exports.areEqual(new Uint8Array(attestationChallenge.buffer), clientDataHash)) {
    throw new Error("Attestation challenge was not equal to client data hash (AndroidKey)");
  }
  if (teeEnforced.allApplications !== void 0) {
    throw new Error('teeEnforced contained "allApplications [600]" tag (AndroidKey)');
  }
  if (softwareEnforced.allApplications !== void 0) {
    throw new Error('teeEnforced contained "allApplications [600]" tag (AndroidKey)');
  }
  const statement = await MetadataService.getStatement(aaguid);
  if (statement) {
    try {
      await verifyAttestationWithMetadata({
        statement,
        credentialPublicKey,
        x5c,
        attestationStatementAlg: alg
      });
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (AndroidKey)`);
    }
  } else {
    try {
      await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
    } catch (err) {
      const _err = err;
      throw new Error(`${_err.message} (AndroidKey)`);
    }
  }
  const signatureBase = isoUint8Array_exports.concat([authData, clientDataHash]);
  return verifySignature({
    signature: sig,
    data: signatureBase,
    x509Certificate: x5c[0],
    hashAlgorithm: alg
  });
}
var init_verifyAttestationAndroidKey = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidKey.js"() {
    init_deps();
    init_convertCertBufferToPEM();
    init_validateCertificatePath();
    init_verifySignature();
    init_convertCOSEtoPKCS();
    init_cose();
    init_iso();
    init_metadataService();
    init_verifyAttestationWithMetadata();
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationApple.js
async function verifyAttestationApple(options3) {
  const { attStmt, authData, clientDataHash, credentialPublicKey, rootCertificates } = options3;
  const x5c = attStmt.get("x5c");
  if (!x5c) {
    throw new Error("No attestation certificate provided in attestation statement (Apple)");
  }
  try {
    await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);
  } catch (err) {
    const _err = err;
    throw new Error(`${_err.message} (Apple)`);
  }
  const parsedCredCert = AsnParser.parse(x5c[0], Certificate);
  const { extensions, subjectPublicKeyInfo } = parsedCredCert.tbsCertificate;
  if (!extensions) {
    throw new Error("credCert missing extensions (Apple)");
  }
  const extCertNonce = extensions.find((ext) => ext.extnID === "1.2.840.113635.100.8.2");
  if (!extCertNonce) {
    throw new Error('credCert missing "1.2.840.113635.100.8.2" extension (Apple)');
  }
  const nonceToHash = isoUint8Array_exports.concat([authData, clientDataHash]);
  const nonce = await toHash(nonceToHash);
  const extNonce = new Uint8Array(extCertNonce.extnValue.buffer).slice(6);
  if (!isoUint8Array_exports.areEqual(nonce, extNonce)) {
    throw new Error(`credCert nonce was not expected value (Apple)`);
  }
  const credPubKeyPKCS = convertCOSEtoPKCS(credentialPublicKey);
  const credCertSubjectPublicKey = new Uint8Array(subjectPublicKeyInfo.subjectPublicKey);
  if (!isoUint8Array_exports.areEqual(credPubKeyPKCS, credCertSubjectPublicKey)) {
    throw new Error("Credential public key does not equal credCert public key (Apple)");
  }
  return true;
}
var init_verifyAttestationApple = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifications/verifyAttestationApple.js"() {
    init_deps();
    init_validateCertificatePath();
    init_convertCertBufferToPEM();
    init_toHash();
    init_convertCOSEtoPKCS();
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/registration/verifyRegistrationResponse.js
async function verifyRegistrationResponse(options3) {
  const { response, expectedChallenge, expectedOrigin, expectedRPID, expectedType, requireUserVerification = true, supportedAlgorithmIDs = supportedCOSEAlgorithmIdentifiers } = options3;
  const { id, rawId, type: credentialType, response: attestationResponse } = response;
  if (!id) {
    throw new Error("Missing credential ID");
  }
  if (id !== rawId) {
    throw new Error("Credential ID was not base64url-encoded");
  }
  if (credentialType !== "public-key") {
    throw new Error(`Unexpected credential type ${credentialType}, expected "public-key"`);
  }
  const clientDataJSON = decodeClientDataJSON(attestationResponse.clientDataJSON);
  const { type, origin: origin2, challenge, tokenBinding } = clientDataJSON;
  if (Array.isArray(expectedType)) {
    if (!expectedType.includes(type)) {
      const joinedExpectedType = expectedType.join(", ");
      throw new Error(`Unexpected registration response type "${type}", expected one of: ${joinedExpectedType}`);
    }
  } else if (expectedType) {
    if (type !== expectedType) {
      throw new Error(`Unexpected registration response type "${type}", expected "${expectedType}"`);
    }
  } else if (type !== "webauthn.create") {
    throw new Error(`Unexpected registration response type: ${type}`);
  }
  if (typeof expectedChallenge === "function") {
    if (!await expectedChallenge(challenge)) {
      throw new Error(`Custom challenge verifier returned false for registration response challenge "${challenge}"`);
    }
  } else if (challenge !== expectedChallenge) {
    throw new Error(`Unexpected registration response challenge "${challenge}", expected "${expectedChallenge}"`);
  }
  if (Array.isArray(expectedOrigin)) {
    if (!expectedOrigin.includes(origin2)) {
      throw new Error(`Unexpected registration response origin "${origin2}", expected one of: ${expectedOrigin.join(", ")}`);
    }
  } else {
    if (origin2 !== expectedOrigin) {
      throw new Error(`Unexpected registration response origin "${origin2}", expected "${expectedOrigin}"`);
    }
  }
  if (tokenBinding) {
    if (typeof tokenBinding !== "object") {
      throw new Error(`Unexpected value for TokenBinding "${tokenBinding}"`);
    }
    if (["present", "supported", "not-supported"].indexOf(tokenBinding.status) < 0) {
      throw new Error(`Unexpected tokenBinding.status value of "${tokenBinding.status}"`);
    }
  }
  const attestationObject = isoBase64URL_exports.toBuffer(attestationResponse.attestationObject);
  const decodedAttestationObject = decodeAttestationObject(attestationObject);
  const fmt = decodedAttestationObject.get("fmt");
  const authData = decodedAttestationObject.get("authData");
  const attStmt = decodedAttestationObject.get("attStmt");
  const parsedAuthData = parseAuthenticatorData(authData);
  const { aaguid, rpIdHash, flags, credentialID, counter, credentialPublicKey, extensionsData } = parsedAuthData;
  let matchedRPID;
  if (expectedRPID) {
    let expectedRPIDs = [];
    if (typeof expectedRPID === "string") {
      expectedRPIDs = [expectedRPID];
    } else {
      expectedRPIDs = expectedRPID;
    }
    matchedRPID = await matchExpectedRPID(rpIdHash, expectedRPIDs);
  }
  if (!flags.up) {
    throw new Error("User not present during registration");
  }
  if (requireUserVerification && !flags.uv) {
    throw new Error("User verification required, but user could not be verified");
  }
  if (!credentialID) {
    throw new Error("No credential ID was provided by authenticator");
  }
  if (!credentialPublicKey) {
    throw new Error("No public key was provided by authenticator");
  }
  if (!aaguid) {
    throw new Error("No AAGUID was present during registration");
  }
  const decodedPublicKey = decodeCredentialPublicKey(credentialPublicKey);
  const alg = decodedPublicKey.get(COSEKEYS.alg);
  if (typeof alg !== "number") {
    throw new Error("Credential public key was missing numeric alg");
  }
  if (!supportedAlgorithmIDs.includes(alg)) {
    const supported = supportedAlgorithmIDs.join(", ");
    throw new Error(`Unexpected public key alg "${alg}", expected one of "${supported}"`);
  }
  const clientDataHash = await toHash(isoBase64URL_exports.toBuffer(attestationResponse.clientDataJSON));
  const rootCertificates = SettingsService.getRootCertificates({
    identifier: fmt
  });
  const verifierOpts = {
    aaguid,
    attStmt,
    authData,
    clientDataHash,
    credentialID,
    credentialPublicKey,
    rootCertificates,
    rpIdHash
  };
  let verified = false;
  if (fmt === "fido-u2f") {
    verified = await verifyAttestationFIDOU2F(verifierOpts);
  } else if (fmt === "packed") {
    verified = await verifyAttestationPacked(verifierOpts);
  } else if (fmt === "android-safetynet") {
    verified = await verifyAttestationAndroidSafetyNet(verifierOpts);
  } else if (fmt === "android-key") {
    verified = await verifyAttestationAndroidKey(verifierOpts);
  } else if (fmt === "tpm") {
    verified = await verifyAttestationTPM(verifierOpts);
  } else if (fmt === "apple") {
    verified = await verifyAttestationApple(verifierOpts);
  } else if (fmt === "none") {
    if (attStmt.size > 0) {
      throw new Error("None attestation had unexpected attestation statement");
    }
    verified = true;
  } else {
    throw new Error(`Unsupported Attestation Format: ${fmt}`);
  }
  const toReturn = {
    verified
  };
  if (toReturn.verified) {
    const { credentialDeviceType, credentialBackedUp } = parseBackupFlags(flags);
    toReturn.registrationInfo = {
      fmt,
      counter,
      aaguid: convertAAGUIDToString(aaguid),
      credentialID,
      credentialPublicKey,
      credentialType,
      attestationObject,
      userVerified: flags.uv,
      credentialDeviceType,
      credentialBackedUp,
      origin: clientDataJSON.origin,
      rpID: matchedRPID,
      authenticatorExtensionResults: extensionsData
    };
  }
  return toReturn;
}
var init_verifyRegistrationResponse = __esm({
  "node_modules/@simplewebauthn/server/esm/registration/verifyRegistrationResponse.js"() {
    init_decodeAttestationObject();
    init_decodeClientDataJSON();
    init_parseAuthenticatorData();
    init_toHash();
    init_decodeCredentialPublicKey();
    init_cose();
    init_convertAAGUIDToString();
    init_parseBackupFlags();
    init_matchExpectedRPID();
    init_iso();
    init_settingsService();
    init_generateRegistrationOptions();
    init_verifyAttestationFIDOU2F();
    init_verifyAttestationPacked();
    init_verifyAttestationAndroidSafetyNet();
    init_verifyAttestationTPM();
    init_verifyAttestationAndroidKey();
    init_verifyAttestationApple();
  }
});

// node_modules/@simplewebauthn/server/esm/authentication/generateAuthenticationOptions.js
var init_generateAuthenticationOptions = __esm({
  "node_modules/@simplewebauthn/server/esm/authentication/generateAuthenticationOptions.js"() {
    init_iso();
    init_generateChallenge();
  }
});

// node_modules/@simplewebauthn/server/esm/authentication/verifyAuthenticationResponse.js
var init_verifyAuthenticationResponse = __esm({
  "node_modules/@simplewebauthn/server/esm/authentication/verifyAuthenticationResponse.js"() {
    init_decodeClientDataJSON();
    init_toHash();
    init_verifySignature();
    init_parseAuthenticatorData();
    init_parseBackupFlags();
    init_matchExpectedRPID();
    init_iso();
  }
});

// node_modules/@simplewebauthn/server/esm/index.js
var init_esm2 = __esm({
  "node_modules/@simplewebauthn/server/esm/index.js"() {
    init_generateRegistrationOptions();
    init_verifyRegistrationResponse();
    init_generateAuthenticationOptions();
    init_verifyAuthenticationResponse();
    init_metadataService();
    init_settingsService();
  }
});

// .svelte-kit/output/server/entries/endpoints/(api)/api/localAuth/register/_server.ts.js
var server_ts_exports4 = {};
__export(server_ts_exports4, {
  GET: () => GET3
});
var rpName, rpID, getUserFromDB, getUserAuthenticators, GET3;
var init_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/endpoints/(api)/api/localAuth/register/_server.ts.js"() {
    init_chunks();
    init_esm2();
    rpName = "SimpleWebAuthn Example";
    rpID = "localhost";
    getUserFromDB = (userId) => {
      return { id: `id:${userId}`, username: `user:${userId}`, idk: "test" };
    };
    getUserAuthenticators = (user) => {
      return [];
    };
    GET3 = async ({ url }) => {
      const user = getUserFromDB(url.searchParams.get("userid"));
      const userAuthenticators = getUserAuthenticators();
      const options3 = await generateRegistrationOptions({
        rpName,
        rpID,
        userID: user.id,
        userName: user.username,
        // Don't prompt users for additional information about the authenticator
        // (Recommended for smoother UX)
        attestationType: "none",
        // Prevent users from re-registering existing authenticators
        excludeCredentials: userAuthenticators.map((authenticator) => ({
          id: authenticator.credentialID,
          type: "public-key",
          // Optional
          transports: authenticator.transports
        })),
        // See "Guiding use of authenticators via authenticatorSelection" below
        authenticatorSelection: {
          // Defaults
          residentKey: "preferred",
          userVerification: "preferred",
          // Optional
          authenticatorAttachment: "platform"
        }
      });
      return json(options3);
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/(api)/api/localAuth/verify/_server.ts.js
var server_ts_exports5 = {};
__export(server_ts_exports5, {
  POST: () => POST2
});
var rpID2, origin, getUserCurrentChallenge, POST2;
var init_server_ts5 = __esm({
  ".svelte-kit/output/server/entries/endpoints/(api)/api/localAuth/verify/_server.ts.js"() {
    init_chunks();
    init_esm2();
    rpID2 = "localhost";
    origin = `https://${rpID2}`;
    getUserCurrentChallenge = (user) => {
      return user;
    };
    POST2 = async ({ request }) => {
      let body2 = {};
      const expectedChallenge = getUserCurrentChallenge("test");
      let verification;
      try {
        verification = await verifyRegistrationResponse({
          response: body2,
          expectedChallenge,
          expectedOrigin: origin,
          expectedRPID: rpID2
        });
      } catch (error2) {
        console.error(error2);
        return new Response("Failed to verify registration response");
      }
      const { verified } = verification;
      return json(verified);
    };
  }
});

// .svelte-kit/output/server/index.js
init_prod_ssr();

// .svelte-kit/output/server/chunks/internal.js
init_index3();
init_main_client();
init_shared_server();
var assets;
var base;
var options;
var set_building;
var set_manifest;
var set_prerendering;
var get_hooks;
var set_read_implementation;
var override;
var prerendering;
var reset;
var set_assets;
var __tla = (async () => {
  base = "";
  assets = base;
  const initial = {
    base,
    assets
  };
  override = function(paths) {
    base = paths.base;
    assets = paths.assets;
  };
  reset = function() {
    base = initial.base;
    assets = initial.assets;
  };
  set_assets = function(path2) {
    assets = initial.assets = path2;
  };
  const STATE_SYMBOL = Symbol("$state");
  function proxy(value, immutable2 = true) {
    if (typeof value === "object" && value != null && !is_frozen(value)) {
      if (STATE_SYMBOL in value) {
        const metadata = value[STATE_SYMBOL];
        if (metadata.t === value || metadata.p === value)
          return metadata.p;
      }
      const prototype = get_prototype_of(value);
      if (prototype === object_prototype || prototype === array_prototype) {
        const proxy2 = new Proxy(value, state_proxy_handler);
        define_property(value, STATE_SYMBOL, {
          value: {
            s: /* @__PURE__ */ new Map(),
            v: source(0),
            a: is_array(value),
            i: immutable2,
            p: proxy2,
            t: value
          },
          writable: true,
          enumerable: false
        });
        return proxy2;
      }
    }
    return value;
  }
  const state_proxy_handler = {
    defineProperty(target, prop, descriptor) {
      if (descriptor.value) {
        const metadata = target[STATE_SYMBOL];
        const s9 = metadata.s.get(prop);
        if (s9 !== void 0)
          set(s9, proxy(descriptor.value, metadata.i));
      }
      return Reflect.defineProperty(target, prop, descriptor);
    },
    deleteProperty(target, prop) {
      const metadata = target[STATE_SYMBOL];
      const s9 = metadata.s.get(prop);
      const is_array2 = metadata.a;
      const boolean = delete target[prop];
      if (is_array2 && boolean) {
        const ls = metadata.s.get("length");
        const length = target.length - 1;
        if (ls !== void 0 && ls.v !== length) {
          set(ls, length);
        }
      }
      if (s9 !== void 0)
        set(s9, UNINITIALIZED);
      if (prop in target)
        update(metadata.v);
      return boolean;
    },
    get(target, prop, receiver) {
      if (prop === STATE_SYMBOL) {
        return Reflect.get(target, STATE_SYMBOL);
      }
      const metadata = target[STATE_SYMBOL];
      let s9 = metadata.s.get(prop);
      if (s9 === void 0 && (effect_active() || updating_derived) && (!(prop in target) || get_descriptor(target, prop)?.writable)) {
        s9 = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i));
        metadata.s.set(prop, s9);
      }
      if (s9 !== void 0) {
        const value = get(s9);
        return value === UNINITIALIZED ? void 0 : value;
      }
      return Reflect.get(target, prop, receiver);
    },
    getOwnPropertyDescriptor(target, prop) {
      const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
      if (descriptor && "value" in descriptor) {
        const metadata = target[STATE_SYMBOL];
        const s9 = metadata.s.get(prop);
        if (s9) {
          descriptor.value = get(s9);
        }
      }
      return descriptor;
    },
    has(target, prop) {
      if (prop === STATE_SYMBOL) {
        return true;
      }
      const metadata = target[STATE_SYMBOL];
      const has2 = Reflect.has(target, prop);
      let s9 = metadata.s.get(prop);
      if (s9 !== void 0 || effect_active() && (!has2 || get_descriptor(target, prop)?.writable)) {
        if (s9 === void 0) {
          s9 = (metadata.i ? source : mutable_source)(has2 ? proxy(target[prop], metadata.i) : UNINITIALIZED);
          metadata.s.set(prop, s9);
        }
        const value = get(s9);
        if (value === UNINITIALIZED) {
          return false;
        }
      }
      return has2;
    },
    set(target, prop, value) {
      const metadata = target[STATE_SYMBOL];
      const s9 = metadata.s.get(prop);
      if (s9 !== void 0)
        set(s9, proxy(value, metadata.i));
      const is_array2 = metadata.a;
      const not_has = !(prop in target);
      if (is_array2 && prop === "length") {
        for (let i9 = value; i9 < target.length; i9 += 1) {
          const s22 = metadata.s.get(i9 + "");
          if (s22 !== void 0)
            set(s22, UNINITIALIZED);
        }
      }
      target[prop] = value;
      if (not_has) {
        if (is_array2) {
          const ls = metadata.s.get("length");
          const length = target.length;
          if (ls !== void 0 && ls.v !== length) {
            set(ls, length);
          }
        }
        update(metadata.v);
      }
      return true;
    },
    ownKeys(target) {
      const metadata = target[STATE_SYMBOL];
      get(metadata.v);
      return Reflect.ownKeys(target);
    }
  };
  var node_prototype;
  var element_prototype;
  var text_prototype;
  var map_prototype;
  function init_operations() {
    if (node_prototype !== void 0) {
      return;
    }
    node_prototype = Node.prototype;
    element_prototype = Element.prototype;
    text_prototype = Text.prototype;
    map_prototype = Map.prototype;
    node_prototype.appendChild;
    node_prototype.cloneNode;
    map_prototype.set;
    map_prototype.get;
    map_prototype.delete;
    element_prototype.__click = void 0;
    text_prototype.__nodeValue = " ";
    element_prototype.__className = "";
    get_descriptor(node_prototype, "firstChild").get;
    get_descriptor(node_prototype, "nextSibling").get;
    get_descriptor(node_prototype, "textContent").set;
    get_descriptor(element_prototype, "className").set;
  }
  function empty() {
    return document.createTextNode("");
  }
  function set_current_hydration_fragment(fragment) {
  }
  function get_hydration_fragment(node, insert_text = false) {
    const fragment = [];
    let current_node = node;
    let target_depth = null;
    while (current_node !== null) {
      const node_type = current_node.nodeType;
      const next_sibling = current_node.nextSibling;
      if (node_type === 8) {
        const data = current_node.data;
        if (data.startsWith("ssr:")) {
          const depth = data.slice(4);
          if (target_depth === null) {
            target_depth = depth;
          } else if (depth === target_depth) {
            if (insert_text && fragment.length === 0) {
              const text2 = empty();
              fragment.push(text2);
              current_node.parentNode.insertBefore(text2, current_node);
            }
            return fragment;
          } else {
            fragment.push(current_node);
          }
          current_node = next_sibling;
          continue;
        }
      }
      if (target_depth !== null) {
        fragment.push(current_node);
      }
      current_node = next_sibling;
    }
    return null;
  }
  function remove3(current) {
    var first_node = current;
    if (is_array(current)) {
      var i9 = 0;
      var node;
      for (; i9 < current.length; i9++) {
        node = current[i9];
        if (i9 === 0) {
          first_node = node;
        }
        if (node.isConnected) {
          node.remove();
        }
      }
    } else if (current.isConnected) {
      current.remove();
    }
    return first_node;
  }
  const all_registerd_events = /* @__PURE__ */ new Set();
  const root_event_handles = /* @__PURE__ */ new Set();
  function handle_event_propagation(handler_element, event) {
    const event_name = event.type;
    const path2 = event.composedPath?.() || [];
    let current_target = path2[0] || event.target;
    if (event.target !== current_target) {
      define_property(event, "target", {
        configurable: true,
        value: current_target
      });
    }
    let path_idx = 0;
    const handled_at = event.__root;
    if (handled_at) {
      const at_idx = path2.indexOf(handled_at);
      if (at_idx !== -1 && handler_element === document) {
        event.__root = document;
        return;
      }
      const handler_idx = path2.indexOf(handler_element);
      if (handler_idx === -1) {
        return;
      }
      if (at_idx <= handler_idx) {
        path_idx = at_idx + 1;
      }
    }
    current_target = path2[path_idx] || event.target;
    define_property(event, "currentTarget", {
      configurable: true,
      get() {
        return current_target || document;
      }
    });
    while (current_target !== null) {
      const parent_element = current_target.parentNode || current_target.host || null;
      const internal_prop_name = "__" + event_name;
      const delegated = current_target[internal_prop_name];
      if (delegated !== void 0 && !current_target.disabled) {
        if (is_array(delegated)) {
          const [fn, ...data] = delegated;
          fn.apply(current_target, [
            event,
            ...data
          ]);
        } else {
          delegated.call(current_target, event);
        }
      }
      if (event.cancelBubble || parent_element === handler_element || current_target === handler_element) {
        break;
      }
      current_target = parent_element;
    }
    event.__root = handler_element;
    current_target = handler_element;
  }
  function createRoot(component7, options22) {
    const props = proxy(options22.props || {}, false);
    let [accessors, $destroy] = mount(component7, {
      ...options22,
      props
    });
    const result = {
      $set: (next2) => {
        object_assign(props, next2);
      },
      $destroy
    };
    for (const key3 of object_keys(accessors || {})) {
      define_property(result, key3, {
        get() {
          return accessors[key3];
        },
        set(value) {
          flushSync(() => accessors[key3] = value);
        },
        enumerable: true
      });
    }
    return result;
  }
  function mount(component7, options22) {
    init_operations();
    const registered_events = /* @__PURE__ */ new Set();
    const container = options22.target;
    const block2 = create_root_block(options22.intro || false);
    const first_child = container.firstChild;
    const hydration_fragment = get_hydration_fragment(first_child, true);
    let accessors = void 0;
    try {
      let anchor = null;
      if (hydration_fragment === null) {
        anchor = empty();
        container.appendChild(anchor);
      }
      set_current_hydration_fragment(hydration_fragment);
      const effect2 = render_effect(() => {
        if (options22.context) {
          push$1({});
          current_component_context.c = options22.context;
        }
        accessors = component7(anchor, options22.props || {});
        if (options22.context) {
          pop$1();
        }
      }, block2, true);
      block2.e = effect2;
    } catch (error2) {
      if (options22.recover !== false && hydration_fragment !== null) {
        console.error("ERR_SVELTE_HYDRATION_MISMATCH", error2);
        remove3(hydration_fragment);
        first_child.remove();
        hydration_fragment.at(-1)?.nextSibling?.remove();
        return mount(component7, options22);
      } else {
        throw error2;
      }
    } finally {
    }
    const bound_event_listener = handle_event_propagation.bind(null, container);
    const bound_document_event_listener = handle_event_propagation.bind(null, document);
    const event_handle = (events) => {
      for (let i9 = 0; i9 < events.length; i9++) {
        const event_name = events[i9];
        if (!registered_events.has(event_name)) {
          registered_events.add(event_name);
          container.addEventListener(event_name, bound_event_listener, PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0);
          document.addEventListener(event_name, bound_document_event_listener, PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0);
        }
      }
    };
    event_handle(array_from(all_registerd_events));
    root_event_handles.add(event_handle);
    return [
      accessors,
      () => {
        for (const event_name of registered_events) {
          container.removeEventListener(event_name, bound_event_listener);
        }
        root_event_handles.delete(event_handle);
        const dom = block2.d;
        if (dom !== null) {
          remove3(dom);
        }
        if (hydration_fragment !== null) {
          remove3(hydration_fragment);
        }
        destroy_signal(block2.e);
      }
    ];
  }
  function asClassComponent$1(component7) {
    return class extends Svelte4Component {
      constructor(options22) {
        super({
          component: component7,
          ...options22
        });
      }
    };
  }
  class Svelte4Component {
    #events = {};
    #instance;
    constructor(options22) {
      this.#instance = createRoot(options22.component, {
        target: options22.target,
        props: {
          ...options22.props,
          $$events: this.#events
        },
        context: options22.context,
        intro: options22.intro,
        recover: options22.recover
      });
      for (const key3 of Object.keys(this.#instance)) {
        if (key3 === "$set" || key3 === "$destroy")
          continue;
        define_property(this, key3, {
          get() {
            return this.#instance[key3];
          },
          set(value) {
            this.#instance[key3] = value;
          },
          enumerable: true
        });
      }
    }
    $set(props) {
      this.#instance.$set(props);
    }
    $on(event, callback) {
      this.#events[event] = this.#events[event] || [];
      const cb = (...args) => callback.call(this, ...args);
      this.#events[event].push(cb);
      return () => {
        this.#events[event] = this.#events[event].filter((fn) => fn !== cb);
      };
    }
    $destroy() {
      this.#instance.$destroy();
    }
  }
  function asClassComponent(component7) {
    const component_constructor = asClassComponent$1(component7);
    const _render = (props, { context } = {}) => {
      const result = render(component7, {
        props,
        context
      });
      return {
        css: {
          code: "",
          map: null
        },
        head: result.head,
        html: result.html
      };
    };
    component_constructor.render = _render;
    return component_constructor;
  }
  prerendering = false;
  set_building = function() {
  };
  set_prerendering = function() {
    prerendering = true;
  };
  function Root2($$payload, $$props) {
    push(true);
    let { stores, page: page2, constructors, components = [], form, data_0 = null, data_1 = null, data_2 = null } = $$props;
    {
      setContext("__svelte__", stores);
    }
    {
      stores.page.set(page2);
    }
    let $$settled = true;
    let $$inner_payload;
    function $$render_inner($$payload2) {
      const anchor = create_anchor($$payload2);
      const anchor_7 = create_anchor($$payload2);
      $$payload2.out += `${anchor}`;
      if (constructors[1]) {
        $$payload2.out += "<!--ssr:if:true-->";
        const anchor_1 = create_anchor($$payload2);
        $$payload2.out += `${anchor_1}`;
        constructors[0]?.($$payload2, {
          get this() {
            return components[0];
          },
          set this($$value) {
            components[0] = $$value;
            $$settled = false;
          },
          data: data_0,
          children: ($$payload3, $$slotProps) => {
            const anchor_2 = create_anchor($$payload3);
            $$payload3.out += `${anchor_2}`;
            if (constructors[2]) {
              $$payload3.out += "<!--ssr:if:true-->";
              const anchor_3 = create_anchor($$payload3);
              $$payload3.out += `${anchor_3}`;
              constructors[1]?.($$payload3, {
                get this() {
                  return components[1];
                },
                set this($$value) {
                  components[1] = $$value;
                  $$settled = false;
                },
                data: data_1,
                children: ($$payload4, $$slotProps2) => {
                  const anchor_4 = create_anchor($$payload4);
                  $$payload4.out += `${anchor_4}`;
                  constructors[2]?.($$payload4, {
                    get this() {
                      return components[2];
                    },
                    set this($$value) {
                      components[2] = $$value;
                      $$settled = false;
                    },
                    data: data_2,
                    form
                  });
                  $$payload4.out += `${anchor_4}`;
                }
              });
              $$payload3.out += `${anchor_3}`;
            } else {
              $$payload3.out += "<!--ssr:if:false-->";
              const anchor_5 = create_anchor($$payload3);
              $$payload3.out += `${anchor_5}`;
              constructors[1]?.($$payload3, {
                get this() {
                  return components[1];
                },
                set this($$value) {
                  components[1] = $$value;
                  $$settled = false;
                },
                data: data_1,
                form
              });
              $$payload3.out += `${anchor_5}`;
            }
            $$payload3.out += `${anchor_2}`;
          }
        });
        $$payload2.out += `${anchor_1}`;
      } else {
        $$payload2.out += "<!--ssr:if:false-->";
        const anchor_6 = create_anchor($$payload2);
        $$payload2.out += `${anchor_6}`;
        constructors[0]?.($$payload2, {
          get this() {
            return components[0];
          },
          set this($$value) {
            components[0] = $$value;
            $$settled = false;
          },
          data: data_0,
          form
        });
        $$payload2.out += `${anchor_6}`;
      }
      $$payload2.out += `${anchor} ${anchor_7}`;
      {
        $$payload2.out += "<!--ssr:if:false-->";
      }
      $$payload2.out += `${anchor_7}`;
    }
    do {
      $$settled = true;
      $$inner_payload = copy_payload($$payload);
      $$render_inner($$inner_payload);
    } while (!$$settled);
    assign_payload($$payload, $$inner_payload);
    bind_props($$props, {
      stores,
      page: page2,
      constructors,
      components,
      form,
      data_0,
      data_1,
      data_2
    });
    pop();
  }
  const root2 = asClassComponent(Root2);
  set_read_implementation = function(fn) {
  };
  set_manifest = function(_4) {
  };
  options = {
    app_dir: "_app",
    app_template_contains_nonce: false,
    csp: {
      "mode": "auto",
      "directives": {
        "upgrade-insecure-requests": false,
        "block-all-mixed-content": false
      },
      "reportOnly": {
        "upgrade-insecure-requests": false,
        "block-all-mixed-content": false
      }
    },
    csrf_check_origin: true,
    embedded: false,
    env_public_prefix: "PUBLIC_",
    env_private_prefix: "",
    hooks: null,
    preload_strategy: "modulepreload",
    root: root2,
    service_worker: false,
    templates: {
      app: ({ head: head2, body: body2, assets: assets2, nonce, env }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head2 + '\n	</head>\n	<body data-sveltekit-preload-data="hover">\n		<div style="display: contents">' + body2 + "</div>\n	</body>\n</html>\n",
      error: ({ status, message: message2 }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message2 + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message2 + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n"
    },
    version_hash: "1p3jfjs"
  };
  get_hooks = async function() {
    return {
      ...await Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports))
    };
  };
})();

// .svelte-kit/output/server/index.js
init_chunks();
init_exports();
init_devalue();
init_index4();
init_shared_server();
var import_cookie = __toESM(require_cookie(), 1);
var set_cookie_parser = __toESM(require_set_cookie(), 1);
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types2) {
  const parts = [];
  accept.split(",").forEach((str2, i9) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str2);
    if (match) {
      const [, type, subtype, q4 = "1"] = match;
      parts.push({ type, subtype, q: +q4, i: i9 });
    }
  });
  parts.sort((a7, b5) => {
    if (a7.q !== b5.q) {
      return b5.q - a7.q;
    }
    if (a7.subtype === "*" !== (b5.subtype === "*")) {
      return a7.subtype === "*" ? 1 : -1;
    }
    if (a7.type === "*" !== (b5.type === "*")) {
      return a7.type === "*" ? 1 : -1;
    }
    return a7.i - b5.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types2) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function is_content_type(request, ...types2) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types2.includes(type.toLowerCase());
}
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
function normalize_error(error2) {
  return (
    /** @type {import('../runtime/control.js').Redirect | HttpError | SvelteKitError | Error} */
    error2
  );
}
function get_status(error2) {
  return error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : 500;
}
function get_message(error2) {
  return error2 instanceof SvelteKitError ? error2.text : "Internal Error";
}
function method_not_allowed(mod, method) {
  return text(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod || "HEAD" in mod)
    allowed.push("HEAD");
  return allowed;
}
function static_error_page(options22, status, message2) {
  let page2 = options22.templates.error({ status, message: message2 });
  return text(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
async function handle_fatal_error(event, options22, error2) {
  error2 = error2 instanceof HttpError ? error2 : coalesce_to_error(error2);
  const status = get_status(error2);
  const body2 = await handle_error_and_jsonify(event, options22, error2);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body2, {
      status
    });
  }
  return static_error_page(options22, status, body2.message);
}
async function handle_error_and_jsonify(event, options22, error2) {
  if (error2 instanceof HttpError) {
    return error2.body;
  }
  const status = get_status(error2);
  const message2 = get_message(error2);
  return await options22.hooks.handleError({ error: error2, event, status, message: message2 }) ?? { message: message2 };
}
function redirect_response(status, location) {
  const response = new Response(void 0, {
    status,
    headers: { location }
  });
  return response;
}
function clarify_devalue_error(event, error2) {
  if (error2.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error2.message} (data${error2.path})`;
  }
  if (error2.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error2.message;
}
function stringify_uses(node) {
  const uses = [];
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.push(`"dependencies":${JSON.stringify(Array.from(node.uses.dependencies))}`);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.push(`"search_params":${JSON.stringify(Array.from(node.uses.search_params))}`);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.push(`"params":${JSON.stringify(Array.from(node.uses.params))}`);
  }
  if (node.uses?.parent)
    uses.push('"parent":1');
  if (node.uses?.route)
    uses.push('"route":1');
  if (node.uses?.url)
    uses.push('"url":1');
  return `"uses":{${uses.join(",")}}`;
}
async function render_endpoint(event, mod, state) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && mod.GET && !mod.HEAD) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state.prerendering && !prerender) {
    if (state.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  try {
    let response = await handler(
      /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
      event
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state.prerendering) {
      response = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      response.headers.set("x-sveltekit-prerender", String(prerender));
    }
    return response;
  } catch (e5) {
    if (e5 instanceof Redirect) {
      return new Response(void 0, {
        status: e5.status,
        headers: { location: e5.location }
      });
    }
    throw e5;
  }
}
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true")
    return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
function compact(arr2) {
  return arr2.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
async function handle_action_json_request(event, options22, server2) {
  const actions = server2?.actions;
  if (!actions) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      "POST method not allowed. No actions exist for this page"
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options22, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, actions);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id
        )
      });
    }
  } catch (e5) {
    const err = normalize_error(e5);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options22, check_incorrect_fail_use(err))
      },
      {
        status: get_status(err)
      }
    );
  }
}
function check_incorrect_fail_use(error2) {
  return error2 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error2;
}
function action_json_redirect(redirect) {
  return action_json({
    type: "redirect",
    status: redirect.status,
    location: redirect.location
  });
}
function action_json(data, init22) {
  return json(data, init22);
}
function is_action_request(event) {
  return event.request.method === "POST";
}
async function handle_action_request(event, server2) {
  const actions = server2?.actions;
  if (!actions) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        "POST method not allowed. No actions exist for this page"
      )
    };
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, actions);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e5) {
    const err = normalize_error(e5);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
function check_named_default_separate(actions) {
  if (actions.default && Object.keys(actions).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://kit.svelte.dev/docs/form-actions#named-actions"
    );
  }
}
async function call_action(event, actions) {
  const url = new URL(event.request.url);
  let name2 = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name2 = param[0].slice(1);
      if (name2 === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions[name2];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name2}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return action(event);
}
function uneval_action_response(data, route_id) {
  return try_deserialize(data, uneval, route_id);
}
function stringify_action_response(data, route_id) {
  return try_deserialize(data, stringify2, route_id);
}
function try_deserialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e5) {
    const error2 = (
      /** @type {any} */
      e5
    );
    if ("path" in error2) {
      let message2 = `Data returned from action inside ${route_id} is not serializable: ${error2.message}`;
      if (error2.path !== "")
        message2 += ` (data.${error2.path})`;
      throw new Error(message2);
    }
    throw error2;
  }
}
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function b64_encode(buffer) {
  if (globalThis.Buffer) {
    return Buffer.from(buffer).toString("base64");
  }
  const little_endian = new Uint8Array(new Uint16Array([1]).buffer)[0] > 0;
  return btoa(
    new TextDecoder(little_endian ? "utf-16le" : "utf-16be").decode(
      new Uint16Array(new Uint8Array(buffer))
    )
  );
}
async function load_server_data({ event, state, node, parent }) {
  if (!node?.server)
    return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state.prerendering) {
    disable_search(url);
  }
  const result = await node.server.load?.call(null, {
    ...event,
    fetch: (info, init22) => {
      new URL(info instanceof Request ? info.url : info, event.url);
      return event.fetch(info, init22);
    },
    /** @param {string[]} deps */
    depends: (...deps) => {
      for (const dep of deps) {
        const { href } = new URL(dep, event.url);
        uses.dependencies.add(href);
      }
    },
    params: new Proxy(event.params, {
      get: (target, key22) => {
        if (is_tracking) {
          uses.params.add(key22);
        }
        return target[
          /** @type {string} */
          key22
        ];
      }
    }),
    parent: async () => {
      if (is_tracking) {
        uses.parent = true;
      }
      return parent();
    },
    route: new Proxy(event.route, {
      get: (target, key22) => {
        if (is_tracking) {
          uses.route = true;
        }
        return target[
          /** @type {'id'} */
          key22
        ];
      }
    }),
    url,
    untrack(fn) {
      is_tracking = false;
      try {
        return fn();
      } finally {
        is_tracking = true;
      }
    }
  });
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash: node.server.trailingSlash
  };
}
async function load_data({
  event,
  fetched,
  node,
  parent,
  server_data_promise,
  state,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  if (!node?.universal?.load) {
    return server_data_node?.data ?? null;
  }
  const result = await node.universal.load.call(null, {
    url: event.url,
    params: event.params,
    data: server_data_node?.data ?? null,
    route: event.route,
    fetch: create_universal_fetch(event, state, fetched, csr, resolve_opts),
    setHeaders: event.setHeaders,
    depends: () => {
    },
    parent,
    untrack: (fn) => fn()
  });
  return result ?? null;
}
function create_universal_fetch(event, state, fetched, csr, resolve_opts) {
  const universal_fetch = async (input, init22) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init22?.headers;
    let response = await event.fetch(input, init22);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state.prerendering) {
        dependency = { response, body: null };
        state.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else {
      const mode = input instanceof Request ? input.mode : init22?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    const proxy = new Proxy(response, {
      get(response2, key22, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init22?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        if (key22 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            if (dependency) {
              dependency.body = new Uint8Array(buffer);
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(b64_encode(buffer), true);
            }
            return buffer;
          };
        }
        async function text2() {
          const body2 = await response2.text();
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        if (key22 === "text") {
          return text2;
        }
        if (key22 === "json") {
          return async () => {
            return JSON.parse(await text2());
          };
        }
        return Reflect.get(response2, key22, response2);
      }
    });
    if (csr) {
      const get4 = response.headers.get;
      response.headers.get = (key22) => {
        const lower = key22.toLowerCase();
        const value = get4.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy;
  };
  return (input, init22) => {
    const response = universal_fetch(input, init22);
    response.catch(() => {
    });
    return response;
  };
}
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  const decoder2 = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += decoder2.decode(value);
  }
  return result;
}
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i9 = value.length;
      while (i9)
        hash2 = hash2 * 33 ^ value.charCodeAt(--i9);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i9 = buffer.length;
      while (i9)
        hash2 = hash2 * 33 ^ buffer[--i9];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(
  // special characters
  `[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`,
  "g"
);
function escape_html_attr(str2) {
  const escaped_str = str2.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var replacements = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering2 = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key22, value] of fetched.response.headers) {
    if (filter(key22, value)) {
      headers2[key22] = value;
    }
    if (key22 === "cache-control")
      cache_control = value;
    else if (key22 === "age")
      age = value;
    else if (key22 === "vary" && value.trim() === "*")
      varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url=${escape_html_attr(fetched.url)}`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering2 && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
var s = JSON.stringify;
var encoder$2 = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array2 = encode(data);
  for (let i9 = 0; i9 < array2.length; i9 += 16) {
    const w6 = array2.subarray(i9, i9 + 16);
    let tmp;
    let a7;
    let b5;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w6[i22];
      } else {
        a7 = w6[i22 + 1 & 15];
        b5 = w6[i22 + 14 & 15];
        tmp = w6[i22 & 15] = (a7 >>> 7 ^ a7 >>> 18 ^ a7 >>> 3 ^ a7 << 25 ^ a7 << 14) + (b5 >>> 17 ^ b5 >>> 19 ^ b5 >>> 10 ^ b5 << 15 ^ b5 << 13) + w6[i22 & 15] + w6[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x4) {
    return (x4 - Math.floor(x4)) * 4294967296;
  }
  let prime = 2;
  for (let i9 = 0; i9 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i9 < 8) {
        init[i9] = frac(prime ** (1 / 2));
      }
      key[i9] = frac(prime ** (1 / 3));
      i9++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i9 = 0; i9 < bytes.length; i9 += 4) {
    const a7 = bytes[i9 + 0];
    const b5 = bytes[i9 + 1];
    const c8 = bytes[i9 + 2];
    const d6 = bytes[i9 + 3];
    bytes[i9 + 0] = d6;
    bytes[i9 + 1] = c8;
    bytes[i9 + 2] = b5;
    bytes[i9 + 3] = a7;
  }
}
function encode(str2) {
  const encoded = encoder$2.encode(str2);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l7 = bytes.length;
  let result = "";
  let i9;
  for (i9 = 2; i9 < l7; i9 += 3) {
    result += chars2[bytes[i9 - 2] >> 2];
    result += chars2[(bytes[i9 - 2] & 3) << 4 | bytes[i9 - 1] >> 4];
    result += chars2[(bytes[i9 - 1] & 15) << 2 | bytes[i9] >> 6];
    result += chars2[bytes[i9] & 63];
  }
  if (i9 === l7 + 1) {
    result += chars2[bytes[i9 - 2] >> 2];
    result += chars2[(bytes[i9 - 2] & 3) << 4];
    result += "==";
  }
  if (i9 === l7) {
    result += chars2[bytes[i9 - 2] >> 2];
    result += chars2[(bytes[i9 - 2] & 3) << 4 | bytes[i9 - 1] >> 4];
    result += chars2[(bytes[i9 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return base64(array);
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d6 = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d6["script-src"] || d6["default-src"];
    const script_src_elem = d6["script-src-elem"];
    const effective_style_src = d6["style-src"] || d6["default-src"];
    const style_src_attr = d6["style-src-attr"];
    const style_src_elem = d6["style-src-elem"];
    this.#script_needs_csp = !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0 || !!script_src_elem && script_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.#style_needs_csp = !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_attr && style_src_attr.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_elem && style_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (this.#script_needs_csp) {
      const d6 = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha256(content);
        this.#script_src.push(`sha256-${hash2}`);
        if (d6["script-src-elem"]?.length) {
          this.#script_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#script_src.length === 0) {
          this.#script_src.push(`nonce-${this.#nonce}`);
        }
        if (d6["script-src-elem"]?.length) {
          this.#script_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (this.#style_needs_csp) {
      const empty_comment_hash = "9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d6 = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha256(content);
        this.#style_src.push(`sha256-${hash2}`);
        if (d6["style-src-attr"]?.length) {
          this.#style_src_attr.push(`sha256-${hash2}`);
        }
        if (d6["style-src-elem"]?.length) {
          if (hash2 !== empty_comment_hash && !d6["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#style_src.length === 0 && !d6["style-src"]?.includes("unsafe-inline")) {
          this.#style_src.push(`nonce-${this.#nonce}`);
        }
        if (d6["style-src-attr"]?.length) {
          this.#style_src_attr.push(`nonce-${this.#nonce}`);
        }
        if (d6["style-src-elem"]?.length) {
          if (!d6["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key22 in directives) {
      if (is_meta && (key22 === "frame-ancestors" || key22 === "report-uri" || key22 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key22]
      );
      if (!value)
        continue;
      const directive = [key22];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content=${escape_html_attr(content)}>`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v5) => !!v5).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function defer() {
  let fulfil;
  let reject;
  const promise = new Promise((f5, r8) => {
    fulfil = f5;
    reject = r8;
  });
  return { promise, fulfil, reject };
}
function create_async_iterator() {
  const deferred = [defer()];
  return {
    iterator: {
      [Symbol.asyncIterator]() {
        return {
          next: async () => {
            const next2 = await deferred[0].promise;
            if (!next2.done)
              deferred.shift();
            return next2;
          }
        };
      }
    },
    push: (value) => {
      deferred[deferred.length - 1].fulfil({
        value,
        done: false
      });
      deferred.push(defer());
    },
    done: () => {
      deferred[deferred.length - 1].fulfil({ done: true });
    }
  };
}
var updated = {
  ...readable(false),
  check: () => false
};
var encoder$1 = new TextEncoder();
async function render_response({
  branch,
  fetched,
  options: options22,
  manifest: manifest2,
  state,
  page_config,
  status,
  error: error2 = null,
  event,
  resolve_opts,
  action_result
}) {
  if (state.prerendering) {
    if (options22.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options22.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets7 = new Set(client.stylesheets);
  const fonts7 = new Set(client.fonts);
  const link_header_preloads = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  if (!state.prerendering?.fallback) {
    const segments = event.url.pathname.slice(base.length).split("/").slice(2);
    base$1 = segments.map(() => "..").join("/") || ".";
    base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
    if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
      assets$1 = base$1;
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(branch.map(({ node }) => node.component())),
      form: form_value
    };
    let data2 = {};
    for (let i9 = 0; i9 < branch.length; i9 += 1) {
      data2 = { ...data2, ...branch[i9].data };
      props[`data_${i9}`] = data2;
    }
    props.page = {
      error: error2,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value,
      state: {}
    };
    override({ base: base$1, assets: assets$1 });
    {
      try {
        rendered = options22.root.render(props);
      } finally {
        reset();
      }
    }
    for (const { node } of branch) {
      for (const url of node.imports)
        modulepreloads.add(url);
      for (const url of node.stylesheets)
        stylesheets7.add(url);
      for (const url of node.fonts)
        fonts7.add(url);
      if (node.inline_styles) {
        Object.entries(await node.inline_styles()).forEach(([k4, v5]) => inline_styles.set(k4, v5));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head2 = "";
  let body2 = rendered.html;
  const csp = new Csp(options22.csp, {
    prerender: !!state.prerendering
  });
  const prefixed = (path2) => {
    if (path2.startsWith("/")) {
      return base + path2;
    }
    return `${assets$1}/${path2}`;
  };
  if (inline_styles.size > 0) {
    const content = Array.from(inline_styles.values()).join("\n");
    const attributes = [];
    if (csp.style_needs_nonce)
      attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(content);
    head2 += `
	<style${attributes.join("")}>${content}</style>`;
  }
  for (const dep of stylesheets7) {
    const path2 = prefixed(dep);
    const attributes = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path: path2 })) {
        const preload_atts = ['rel="preload"', 'as="style"'];
        link_header_preloads.add(`<${encodeURI(path2)}>; ${preload_atts.join(";")}; nopush`);
      }
    }
    head2 += `
		<link href="${path2}" ${attributes.join(" ")}>`;
  }
  for (const dep of fonts7) {
    const path2 = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path: path2 })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      const attributes = [
        'rel="preload"',
        'as="font"',
        `type="font/${ext}"`,
        `href="${path2}"`,
        "crossorigin"
      ];
      head2 += `
		<link ${attributes.join(" ")}>`;
    }
  }
  const global2 = `__sveltekit_${options22.version_hash}`;
  const { data, chunks } = get_data(
    event,
    options22,
    branch.map((b5) => b5.server_data),
    global2
  );
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    if (client.uses_env_dynamic_public && state.prerendering) {
      modulepreloads.add(`${options22.app_dir}/env.js`);
    }
    const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
      (path2) => resolve_opts.preload({ type: "js", path: path2 })
    );
    for (const path2 of included_modulepreloads) {
      link_header_preloads.add(`<${encodeURI(path2)}>; rel="modulepreload"; nopush`);
      if (options22.preload_strategy !== "modulepreload") {
        head2 += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path2}">`;
      } else if (state.prerendering) {
        head2 += `
		<link rel="modulepreload" href="${path2}">`;
      }
    }
    const blocks = [];
    const load_env_eagerly = client.uses_env_dynamic_public && state.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      properties.push(`resolve: ({ id, data, error }) => {
							const { fulfil, reject } = deferred.get(id);
							deferred.delete(id);

							if (error) reject(error);
							else fulfil(data);
						}`);
    }
    blocks.push(`${global2} = {
						${properties.join(",\n						")}
					};`);
    const args = ["app", "element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      blocks.push(`const data = ${data};`);
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id
        );
      }
      if (error2) {
        serialized.error = uneval(error2);
      }
      const hydrate = [
        `node_ids: [${branch.map(({ node }) => node.index).join(", ")}]`,
        "data",
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate.push(`status: ${status}`);
      }
      if (options22.embedded) {
        hydrate.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate.join(`,
${indent}	`)}
${indent}}`);
    }
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${options22.app_dir}/env.js`)}).then(({ env }) => {
						${global2}.env = env;

						Promise.all([
							import(${s(prefixed(client.start))}),
							import(${s(prefixed(client.app))})
						]).then(([kit, app]) => {
							kit.start(${args.join(", ")});
						});
					});`);
    } else {
      blocks.push(`Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						kit.start(${args.join(", ")});
					});`);
    }
    if (options22.service_worker) {
      const opts = "";
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head2 = http_equiv.join("\n") + head2;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_header_preloads.size) {
      headers2.set("link", Array.from(link_header_preloads).join(", "));
    }
  }
  head2 += rendered.head;
  const html = options22.templates.app({
    head: head2,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: safe_public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller) {
        controller.enqueue(encoder$1.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller.enqueue(encoder$1.encode(chunk));
        }
        controller.close();
      },
      type: "bytes"
    }),
    {
      headers: {
        "content-type": "text/html"
      }
    }
  );
}
function get_data(event, options22, nodes, global2) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push: push2, done } = create_async_iterator();
  function replacer(thing) {
    if (typeof thing?.then === "function") {
      const id = promise_id++;
      count += 1;
      thing.then(
        /** @param {any} data */
        (data) => ({ data })
      ).catch(
        /** @param {any} error */
        async (error2) => ({
          error: await handle_error_and_jsonify(event, options22, error2)
        })
      ).then(
        /**
         * @param {{data: any; error: any}} result
         */
        async ({ data, error: error2 }) => {
          count -= 1;
          let str2;
          try {
            str2 = uneval({ id, data, error: error2 }, replacer);
          } catch (e5) {
            error2 = await handle_error_and_jsonify(
              event,
              options22,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            data = void 0;
            str2 = uneval({ id, data, error: error2 }, replacer);
          }
          push2(`<script>${global2}.resolve(${str2})<\/script>
`);
          if (count === 0)
            done();
        }
      );
      return `${global2}.defer(${id})`;
    }
  }
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      return `{"type":"data","data":${uneval(node.data, replacer)},${stringify_uses(node)}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `[${strings.join(",")}]`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e5) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e5
    ));
  }
}
function get_option(nodes, option) {
  return nodes.reduce(
    (value, node) => {
      return (
        /** @type {Value} TypeScript's too dumb to understand this */
        node?.universal?.[option] ?? node?.server?.[option] ?? value
      );
    },
    /** @type {Value | undefined} */
    void 0
  );
}
async function respond_with_error({
  event,
  options: options22,
  manifest: manifest2,
  state,
  status,
  error: error2,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options22,
      status,
      /** @type {Error} */
      error2.message
    );
  }
  const fetched = [];
  try {
    const branch = [];
    const default_layout = await manifest2._.nodes[0]();
    const ssr4 = get_option([default_layout], "ssr") ?? true;
    const csr = get_option([default_layout], "csr") ?? true;
    if (ssr4) {
      state.error = true;
      const server_data_promise = load_server_data({
        event,
        state,
        node: default_layout,
        parent: async () => ({})
      });
      const server_data = await server_data_promise;
      const data = await load_data({
        event,
        fetched,
        node: default_layout,
        parent: async () => ({}),
        resolve_opts,
        server_data_promise,
        state,
        csr
      });
      branch.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options22,
      manifest: manifest2,
      state,
      page_config: {
        ssr: ssr4,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, options22, error2),
      branch,
      fetched,
      event,
      resolve_opts
    });
  } catch (e5) {
    if (e5 instanceof Redirect) {
      return redirect_response(e5.status, e5.location);
    }
    return static_error_page(
      options22,
      get_status(e5),
      (await handle_error_and_jsonify(event, options22, e5)).message
    );
  }
}
function once(fn) {
  let done = false;
  let result;
  return () => {
    if (done)
      return result;
    done = true;
    return result = fn();
  };
}
var encoder2 = new TextEncoder();
async function render_data(event, route, options22, manifest2, state, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n7, i9) => {
      return once(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n7 == void 0 ? n7 : await manifest2._.nodes[n7]();
          return load_server_data({
            event: new_event,
            state,
            node,
            parent: async () => {
              const data2 = {};
              for (let j4 = 0; j4 < i9; j4 += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j4]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            }
          });
        } catch (e5) {
          aborted = true;
          throw e5;
        }
      });
    });
    const promises = functions.map(async (fn, i9) => {
      if (!invalidated[i9]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p5, i9) => p5.catch(async (error2) => {
          if (error2 instanceof Redirect) {
            throw error2;
          }
          length = Math.min(length, i9 + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, options22, error2),
              status: error2 instanceof HttpError || error2 instanceof SvelteKitError ? error2.status : void 0
            }
          );
        })
      )
    );
    const { data, chunks } = get_data_json(event, options22, nodes);
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller) {
          controller.enqueue(encoder2.encode(data));
          for await (const chunk of chunks) {
            controller.enqueue(encoder2.encode(chunk));
          }
          controller.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e5) {
    const error2 = normalize_error(e5);
    if (error2 instanceof Redirect) {
      return redirect_json_response(error2);
    } else {
      return json_response(await handle_error_and_jsonify(event, options22, error2), 500);
    }
  }
}
function json_response(json2, status = 200) {
  return text(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
function redirect_json_response(redirect) {
  return json_response({
    type: "redirect",
    location: redirect.location
  });
}
function get_data_json(event, options22, nodes) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push: push2, done } = create_async_iterator();
  const reducers = {
    /** @param {any} thing */
    Promise: (thing) => {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        count += 1;
        let key22 = "data";
        thing.catch(
          /** @param {any} e */
          async (e5) => {
            key22 = "error";
            return handle_error_and_jsonify(
              event,
              options22,
              /** @type {any} */
              e5
            );
          }
        ).then(
          /** @param {any} value */
          async (value) => {
            let str2;
            try {
              str2 = stringify2(value, reducers);
            } catch (e5) {
              const error2 = await handle_error_and_jsonify(
                event,
                options22,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              key22 = "error";
              str2 = stringify2(error2, reducers);
            }
            count -= 1;
            push2(`{"type":"chunk","id":${id},"${key22}":${str2}}
`);
            if (count === 0)
              done();
          }
        );
        return id;
      }
    }
  };
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      if (node.type === "error" || node.type === "skip") {
        return JSON.stringify(node);
      }
      return `{"type":"data","data":${stringify2(node.data, reducers)},${stringify_uses(
        node
      )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e5) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e5
    ));
  }
}
function load_page_nodes(page2, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page2.layouts.map((n7) => n7 == void 0 ? n7 : manifest2._.nodes[n7]()),
    manifest2._.nodes[page2.leaf]()
  ]);
}
var MAX_DEPTH = 10;
async function render_page(event, page2, options22, manifest2, state, resolve_opts) {
  if (state.depth > MAX_DEPTH) {
    return text(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, options22, node?.server);
  }
  try {
    const nodes = await load_page_nodes(page2, manifest2);
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.at(-1)
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      action_result = await handle_action_request(event, leaf_node.server);
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender_data = nodes.some((node) => node?.server?.load);
    const data_pathname = add_data_suffix(event.url.pathname);
    const should_prerender = get_option(nodes, "prerender") ?? false;
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state.prerender_default = should_prerender;
    const fetched = [];
    if (get_option(nodes, "ssr") === false && !(state.prerendering && should_prerender_data)) {
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr: get_option(nodes, "csr") ?? true
        },
        status,
        error: null,
        event,
        options: options22,
        manifest: manifest2,
        state,
        resolve_opts
      });
    }
    const branch = [];
    let load_error = null;
    const server_promises = nodes.map((node, i9) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          return await load_server_data({
            event,
            state,
            node,
            parent: async () => {
              const data = {};
              for (let j4 = 0; j4 < i9; j4 += 1) {
                const parent = await server_promises[j4];
                if (parent)
                  Object.assign(data, await parent.data);
              }
              return data;
            }
          });
        } catch (e5) {
          load_error = /** @type {Error} */
          e5;
          throw load_error;
        }
      });
    });
    const csr = get_option(nodes, "csr") ?? true;
    const load_promises = nodes.map((node, i9) => {
      if (load_error)
        throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            fetched,
            node,
            parent: async () => {
              const data = {};
              for (let j4 = 0; j4 < i9; j4 += 1) {
                Object.assign(data, await load_promises[j4]);
              }
              return data;
            },
            resolve_opts,
            server_data_promise: server_promises[i9],
            state,
            csr
          });
        } catch (e5) {
          load_error = /** @type {Error} */
          e5;
          throw load_error;
        }
      });
    });
    for (const p5 of server_promises)
      p5.catch(() => {
      });
    for (const p5 of load_promises)
      p5.catch(() => {
      });
    for (let i9 = 0; i9 < nodes.length; i9 += 1) {
      const node = nodes[i9];
      if (node) {
        try {
          const server_data = await server_promises[i9];
          const data = await load_promises[i9];
          branch.push({ node, server_data, data });
        } catch (e5) {
          const err = normalize_error(e5);
          if (err instanceof Redirect) {
            if (state.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state.prerendering.dependencies.set(data_pathname, {
                response: text(body2),
                body: body2
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = get_status(err);
          const error2 = await handle_error_and_jsonify(event, options22, err);
          while (i9--) {
            if (page2.errors[i9]) {
              const index7 = (
                /** @type {number} */
                page2.errors[i9]
              );
              const node2 = await manifest2._.nodes[index7]();
              let j4 = i9;
              while (!branch[j4])
                j4 -= 1;
              return await render_response({
                event,
                options: options22,
                manifest: manifest2,
                state,
                resolve_opts,
                page_config: { ssr: true, csr: true },
                status: status2,
                error: error2,
                branch: compact(branch.slice(0, j4 + 1)).concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched
              });
            }
          }
          return static_error_page(options22, status2, error2.message);
        }
      } else {
        branch.push(null);
      }
    }
    if (state.prerendering && should_prerender_data) {
      let { data, chunks } = get_data_json(
        event,
        options22,
        branch.map((node) => node?.server_data)
      );
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state.prerendering.dependencies.set(data_pathname, {
        response: text(data),
        body: data
      });
    }
    const ssr4 = get_option(nodes, "ssr") ?? true;
    return await render_response({
      event,
      options: options22,
      manifest: manifest2,
      state,
      resolve_opts,
      page_config: {
        csr: get_option(nodes, "csr") ?? true,
        ssr: ssr4
      },
      status,
      error: null,
      branch: ssr4 === false ? [] : compact(branch),
      action_result,
      fetched
    });
  } catch (e5) {
    return await respond_with_error({
      event,
      options: options22,
      manifest: manifest2,
      state,
      status: 500,
      error: e5,
      resolve_opts
    });
  }
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i9 = 0; i9 < params.length; i9 += 1) {
    const param = params[i9];
    let value = values[i9 - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i9 - buffered, i9 + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i9 + 1];
      const next_value = values[i9 + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function validate_options(options22) {
  if (options22?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
function get_cookies(request, url, trailing_slash) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = (0, import_cookie.parse)(header, { decode: (value) => value });
  const normalized_url = normalize_path(url.pathname, trailing_slash);
  const new_cookies = {};
  const defaults4 = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} opts
     */
    get(name2, opts) {
      const c8 = new_cookies[name2];
      if (c8 && domain_matches(url.hostname, c8.options.domain) && path_matches(url.pathname, c8.options.path)) {
        return c8.value;
      }
      const decoder2 = opts?.decode || decodeURIComponent;
      const req_cookies = (0, import_cookie.parse)(header, { decode: decoder2 });
      const cookie2 = req_cookies[name2];
      return cookie2;
    },
    /**
     * @param {import('cookie').CookieParseOptions} opts
     */
    getAll(opts) {
      const decoder2 = opts?.decode || decodeURIComponent;
      const cookies2 = (0, import_cookie.parse)(header, { decode: decoder2 });
      for (const c8 of Object.values(new_cookies)) {
        if (domain_matches(url.hostname, c8.options.domain) && path_matches(url.pathname, c8.options.path)) {
          cookies2[c8.name] = c8.value;
        }
      }
      return Object.entries(cookies2).map(([name2, value]) => ({ name: name2, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name2, value, options22) {
      validate_options(options22);
      set_internal(name2, value, { ...defaults4, ...options22 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name2, options22) {
      validate_options(options22);
      cookies.set(name2, "", { ...options22, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name2, value, options22) {
      validate_options(options22);
      let path2 = options22.path;
      if (!options22.domain || options22.domain === url.hostname) {
        path2 = resolve(normalized_url, path2);
      }
      return (0, import_cookie.serialize)(name2, value, { ...defaults4, ...options22, path: path2 });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const key22 in new_cookies) {
      const cookie2 = new_cookies[key22];
      if (!domain_matches(destination.hostname, cookie2.options.domain))
        continue;
      if (!path_matches(destination.pathname, cookie2.options.path))
        continue;
      const encoder22 = cookie2.options.encode || encodeURIComponent;
      combined_cookies[cookie2.name] = encoder22(cookie2.value);
    }
    if (header2) {
      const parsed = (0, import_cookie.parse)(header2, { decode: (value) => value });
      for (const name2 in parsed) {
        combined_cookies[name2] = parsed[name2];
      }
    }
    return Object.entries(combined_cookies).map(([name2, value]) => `${name2}=${value}`).join("; ");
  }
  function set_internal(name2, value, options22) {
    let path2 = options22.path;
    if (!options22.domain || options22.domain === url.hostname) {
      path2 = resolve(normalized_url, path2);
    }
    new_cookies[name2] = { name: name2, value, options: { ...options22, path: path2 } };
  }
  return { cookies, new_cookies, get_cookie_header, set_internal };
}
function domain_matches(hostname, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized)
    return true;
  return hostname.endsWith("." + normalized);
}
function path_matches(path2, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path2 === normalized)
    return true;
  return path2.startsWith(normalized + "/");
}
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name: name2, value, options: options22 } = new_cookie;
    headers2.append("set-cookie", (0, import_cookie.serialize)(name2, value, options22));
    if (options22.path.endsWith(".html")) {
      const path2 = add_data_suffix(options22.path);
      headers2.append("set-cookie", (0, import_cookie.serialize)(name2, value, { ...options22, path: path2 }));
    }
  }
}
function create_fetch({ event, options: options22, manifest: manifest2, state, get_cookie_header, set_internal }) {
  const server_fetch = async (info, init22) => {
    const original_request = normalize_fetch_input(info, init22, event.url);
    let mode = (info instanceof Request ? info.mode : init22?.mode) ?? "cors";
    let credentials = (info instanceof Request ? info.credentials : init22?.credentials) ?? "same-origin";
    return options22.hooks.handleFetch({
      event,
      request: original_request,
      fetch: async (info2, init3) => {
        const request = normalize_fetch_input(info2, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info2 !== original_request) {
          mode = (info2 instanceof Request ? info2.mode : init3?.mode) ?? "cors";
          credentials = (info2 instanceof Request ? info2.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie2 = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie2)
              request.headers.set("cookie", cookie2);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename);
        const is_asset_html = manifest2.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          }
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie2 = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie2) {
            request.headers.set("cookie", cookie2);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await respond(request, options22, manifest2, {
          ...state,
          depth: state.depth + 1
        });
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str2 of set_cookie_parser.splitCookiesString(set_cookie)) {
            const { name: name2, value, ...options3 } = set_cookie_parser.parseString(str2);
            const path2 = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name2, value, {
              path: path2,
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }
    });
  };
  return (input, init22) => {
    const response = server_fetch(input, init22);
    response.catch(() => {
    });
    return response;
  };
}
function normalize_fetch_input(info, init22, url) {
  if (info instanceof Request) {
    return info;
  }
  return new Request(typeof info === "string" ? new URL(info, url) : info, init22);
}
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
function get_page_config(nodes) {
  let current = {};
  for (const node of nodes) {
    if (!node?.universal?.config && !node?.server?.config)
      continue;
    current = {
      ...current,
      ...node?.universal?.config,
      ...node?.server?.config
    };
  }
  return Object.keys(current).length ? current : void 0;
}
var default_transform = ({ html }) => html;
var default_filter = () => false;
var default_preload = ({ type }) => type === "js" || type === "css";
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
async function respond(request, options22, manifest2, state) {
  const url = new URL(request.url);
  if (options22.csrf_check_origin) {
    const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url.origin;
    if (forbidden) {
      const csrf_error = new HttpError(
        403,
        `Cross-site ${request.method} form submissions are forbidden`
      );
      if (request.headers.get("accept") === "application/json") {
        return json(csrf_error.body, { status: csrf_error.status });
      }
      return text(csrf_error.body.message, { status: csrf_error.status });
    }
  }
  let rerouted_path;
  try {
    rerouted_path = options22.hooks.reroute({ url: new URL(url) }) ?? url.pathname;
  } catch (e5) {
    return text("Internal Server Error", {
      status: 500
    });
  }
  let decoded;
  try {
    decoded = decode_pathname(rerouted_path);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  let route = null;
  let params = {};
  if (base && !state.prerendering?.fallback) {
    if (!decoded.startsWith(base)) {
      return text("Not found", { status: 404 });
    }
    decoded = decoded.slice(base.length) || "/";
  }
  if (decoded === `/${options22.app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (decoded.startsWith(`/${options22.app_dir}`)) {
    return text("Not found", { status: 404 });
  }
  const is_data_request = has_data_suffix(decoded);
  let invalidated_data_nodes;
  if (is_data_request) {
    decoded = strip_data_suffix(decoded) || "/";
    url.pathname = strip_data_suffix(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  }
  if (!state.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  let trailing_slash = void 0;
  const headers2 = {};
  let cookies_to_add = {};
  const event = {
    // @ts-expect-error `cookies` and `fetch` need to be created after the `event` itself
    cookies: null,
    // @ts-expect-error
    fetch: null,
    getClientAddress: state.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params,
    platform: state.platform,
    request,
    route: { id: route?.id ?? null },
    setHeaders: (new_headers) => {
      for (const key22 in new_headers) {
        const lower = key22.toLowerCase();
        const value = new_headers[key22];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key22}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state.prerendering && lower === "cache-control") {
            state.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    },
    url,
    isDataRequest: is_data_request,
    isSubRequest: state.depth > 0
  };
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  try {
    if (route) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (route.page) {
        const nodes = await load_page_nodes(route.page, manifest2);
        if (DEV)
          ;
        trailing_slash = get_option(nodes, "trailingSlash");
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash;
        if (DEV)
          ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash ?? "never");
        if (normalized !== url.pathname && !state.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state.before_handle || state.emulator?.platform) {
        let config = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config = node.config ?? config;
          prerender = node.prerender ?? prerender;
        } else if (route.page) {
          const nodes = await load_page_nodes(route.page, manifest2);
          config = get_page_config(nodes) ?? config;
          prerender = get_option(nodes, "prerender") ?? false;
        }
        if (state.before_handle) {
          state.before_handle(event, config, prerender);
        }
        if (state.emulator?.platform) {
          event.platform = await state.emulator.platform({ config, prerender });
        }
      }
    }
    const { cookies, new_cookies, get_cookie_header, set_internal } = get_cookies(
      request,
      url,
      trailing_slash ?? "never"
    );
    cookies_to_add = new_cookies;
    event.cookies = cookies;
    event.fetch = create_fetch({
      event,
      options: options22,
      manifest: manifest2,
      state,
      get_cookie_header,
      set_internal
    });
    if (state.prerendering && !state.prerendering.fallback)
      disable_search(url);
    const response = await options22.hooks.handle({
      event,
      resolve: (event2, opts) => resolve2(event2, opts).then((response2) => {
        for (const key22 in headers2) {
          const value = headers2[key22];
          response2.headers.set(
            key22,
            /** @type {string} */
            value
          );
        }
        add_cookies_to_headers(response2.headers, Object.values(cookies_to_add));
        if (state.prerendering && event2.route.id !== null) {
          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
        }
        return response2;
      })
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key22 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key22);
          if (value)
            headers22.set(key22, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location = response.headers.get("location");
      if (location) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location
        ));
      }
    }
    return response;
  } catch (e5) {
    if (e5 instanceof Redirect) {
      const response = is_data_request ? redirect_json_response(e5) : route?.page && is_action_json_request(event) ? action_json_redirect(e5) : redirect_response(e5.status, e5.location);
      add_cookies_to_headers(response.headers, Object.values(cookies_to_add));
      return response;
    }
    return await handle_fatal_error(event, options22, e5);
  }
  async function resolve2(event2, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (state.prerendering?.fallback) {
        return await render_response({
          event: event2,
          options: options22,
          manifest: manifest2,
          state,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts
        });
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response;
        if (is_data_request) {
          response = await render_data(
            event2,
            route,
            options22,
            manifest2,
            state,
            invalidated_data_nodes,
            trailing_slash ?? "never"
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response = await render_endpoint(event2, await route.endpoint(), state);
        } else if (route.page) {
          if (page_methods.has(method)) {
            response = await render_page(event2, route.page, options22, manifest2, state, resolve_opts);
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response.headers.get("vary")?.split(",")?.map((v5) => v5.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response = new Response(response.body, {
              status: response.status,
              statusText: response.statusText,
              headers: new Headers(response.headers)
            });
            response.headers.append("Vary", "Accept");
          }
        }
        return response;
      }
      if (state.error && event2.isSubRequest) {
        return await fetch(request, {
          headers: {
            "x-sveltekit-error": "true"
          }
        });
      }
      if (state.error) {
        return text("Internal Server Error", {
          status: 500
        });
      }
      if (state.depth === 0) {
        return await respond_with_error({
          event: event2,
          options: options22,
          manifest: manifest2,
          state,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state.prerendering) {
        return text("not found", { status: 404 });
      }
      return await fetch(request);
    } catch (e5) {
      return await handle_fatal_error(event2, options22, e5);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function filter_private_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k4]) => k4.startsWith(private_prefix) && (public_prefix === "" || !k4.startsWith(public_prefix))
    )
  );
}
function filter_public_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k4]) => k4.startsWith(public_prefix) && (private_prefix === "" || !k4.startsWith(private_prefix))
    )
  );
}
var prerender_env_handler = {
  get({ type }, prop) {
    throw new Error(
      `Cannot read values from $env/dynamic/${type} while prerendering (attempted to read env.${prop.toString()}). Use $env/static/${type} instead`
    );
  }
};
var Server = class {
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
  }
  /**
   * @param {{
   *   env: Record<string, string>;
   *   read?: (file: string) => ReadableStream;
   * }} opts
   */
  async init({ env, read: read2 }) {
    const prefixes = {
      public_prefix: this.#options.env_public_prefix,
      private_prefix: this.#options.env_private_prefix
    };
    const private_env2 = filter_private_env(env, prefixes);
    const public_env2 = filter_public_env(env, prefixes);
    set_private_env(
      prerendering ? new Proxy({ type: "private" }, prerender_env_handler) : private_env2
    );
    set_public_env(
      prerendering ? new Proxy({ type: "public" }, prerender_env_handler) : public_env2
    );
    set_safe_public_env(public_env2);
    if (!this.#options.hooks) {
      try {
        const module2 = await get_hooks();
        this.#options.hooks = {
          handle: module2.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module2.handleError || (({ error: error2 }) => console.error(error2)),
          handleFetch: module2.handleFetch || (({ request, fetch: fetch22 }) => fetch22(request)),
          reroute: module2.reroute || (() => {
          })
        };
      } catch (error2) {
        {
          throw error2;
        }
      }
    }
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options22) {
    return respond(request, this.#options, this.#manifest, {
      ...options22,
      error: false,
      depth: 0
    });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.png", "placeholder.svg"]),
    mimeTypes: { ".png": "image/png", ".svg": "image/svg+xml" },
    _: {
      client: { "start": "_app/immutable/entry/start.Z-Qtyrst.js", "app": "_app/immutable/entry/app.4XAKCv6e.js", "imports": ["_app/immutable/entry/start.Z-Qtyrst.js", "_app/immutable/chunks/entry.DT7XnUlp.js", "_app/immutable/chunks/runtime.PSreMutw.js", "_app/immutable/chunks/index.ChcU8woL.js", "_app/immutable/entry/app.4XAKCv6e.js", "_app/immutable/chunks/index.CncxOQDq.js", "_app/immutable/chunks/index.ChcU8woL.js", "_app/immutable/chunks/runtime.PSreMutw.js", "_app/immutable/chunks/render.CzD__4ML.js", "_app/immutable/chunks/disclose-version.BDr9Qe-U.js", "_app/immutable/chunks/main-client.PbirmUuu.js"], "stylesheets": [], "fonts": [], "uses_env_dynamic_public": false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6)))
      ],
      routes: [
        {
          id: "/(main)",
          pattern: /^\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 3 },
          endpoint: null
        },
        {
          id: "/(api)/api/bookmarks/create",
          pattern: /^\/api\/bookmarks\/create\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts(), server_ts_exports)))
        },
        {
          id: "/(api)/api/bookmarks/get_url",
          pattern: /^\/api\/bookmarks\/get_url\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts2(), server_ts_exports2)))
        },
        {
          id: "/(api)/api/localAuth/auth",
          pattern: /^\/api\/localAuth\/auth\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts3(), server_ts_exports3)))
        },
        {
          id: "/(api)/api/localAuth/register",
          pattern: /^\/api\/localAuth\/register\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts4(), server_ts_exports4)))
        },
        {
          id: "/(api)/api/localAuth/verify",
          pattern: /^\/api\/localAuth\/verify\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts5(), server_ts_exports5)))
        },
        {
          id: "/(main)/b",
          pattern: /^\/b\/?$/,
          params: [],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 4 },
          endpoint: null
        },
        {
          id: "/(main)/b/[id]",
          pattern: /^\/b\/([^/]+?)\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, ,], leaf: 5 },
          endpoint: null
        }
      ],
      matchers: async () => {
        return {};
      },
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var app_path = "_app";

// .svelte-kit/cloudflare-tmp/_worker.js
async function e4(e32, t22) {
  let n22 = "string" != typeof t22 && "HEAD" === t22.method;
  n22 && (t22 = new Request(t22, { method: "GET" }));
  let r32 = await e32.match(t22);
  return n22 && r32 && (r32 = new Response(null, r32)), r32;
}
function t7(e32, t22, n22, o22) {
  return ("string" == typeof t22 || "GET" === t22.method) && r7(n22) && (n22.headers.has("Set-Cookie") && (n22 = new Response(n22.body, n22)).headers.append("Cache-Control", "private=Set-Cookie"), o22.waitUntil(e32.put(t22, n22.clone()))), n22;
}
var n6 = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r7(e32) {
  if (!n6.has(e32.status))
    return false;
  if (~(e32.headers.get("Vary") || "").indexOf("*"))
    return false;
  let t22 = e32.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t22);
}
function o6(n22) {
  return async function(r32, o22) {
    let a7 = await e4(n22, r32);
    if (a7)
      return a7;
    o22.defer((e32) => {
      t7(n22, r32, e32, o22);
    });
  };
}
var s8 = caches.default;
var c7 = t7.bind(0, s8);
var r22 = e4.bind(0, s8);
var e22 = o6.bind(0, s8);
var server = new Server(manifest);
var immutable = `/${app_path}/immutable/`;
var version_file = `/${app_path}/version.json`;
var worker = {
  async fetch(req, env, context) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res)
      return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.substring(1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html");
    }
    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env.ASSETS.fetch(req);
    } else if (location && prerendered.has(location)) {
      if (search)
        location += search;
      res = new Response("", {
        status: 308,
        headers: {
          location
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c7(req, res, context) : res;
  }
};
var worker_default = worker;
export {
  worker_default as default
};
/**
 * @license lucide-svelte v0.323.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

@corbado/webcomponent/pkg/package.js:
  (*! For license information please see package.js.LICENSE.txt *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)

pvtsutils/build/index.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2022 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)
*/
//# sourceMappingURL=_worker.js.map
